var Ext = Ext || {};
Ext._startTime = new Date().getTime();
(function() {
    var k = this,
        a = Object.prototype,
        l = a.toString,
        c = true,
        j = {
            toString: 1
        },
        g = function() {},
        e = function() {
            var i = e.caller.caller;
            return i.$owner.prototype[i.$name].apply(this, arguments)
        },
        d;
    Ext.global = k;
    for (d in j) {
        c = null
    }
    if (c) {
        c = ["hasOwnProperty", "valueOf", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "constructor"]
    }
    Ext.enumerables = c;
    Ext.apply = function(p, o, r) {
        if (r) {
            Ext.apply(p, r)
        }
        if (p && o && typeof o === "object") {
            var q, n, m;
            for (q in o) {
                p[q] = o[q]
            }
            if (c) {
                for (n = c.length; n--;) {
                    m = c[n];
                    if (o.hasOwnProperty(m)) {
                        p[m] = o[m]
                    }
                }
            }
        }
        return p
    };
    Ext.buildSettings = Ext.apply({
        baseCSSPrefix: "x-",
        scopeResetCSS: false
    }, Ext.buildSettings || {});
    Ext.apply(Ext, {
        name: Ext.sandboxName || "Ext",
        emptyFn: g,
        emptyString: new String(),
        baseCSSPrefix: Ext.buildSettings.baseCSSPrefix,
        applyIf: function(m, i) {
            var n;
            if (m) {
                for (n in i) {
                    if (m[n] === undefined) {
                        m[n] = i[n]
                    }
                }
            }
            return m
        },
        iterate: function(i, n, m) {
            if (Ext.isEmpty(i)) {
                return
            }
            if (m === undefined) {
                m = i
            }
            if (Ext.isIterable(i)) {
                Ext.Array.each.call(Ext.Array, i, n, m)
            } else {
                Ext.Object.each.call(Ext.Object, i, n, m)
            }
        }
    });
    Ext.apply(Ext, {
        extend: (function() {
            var i = a.constructor,
                m = function(p) {
                    for (var n in p) {
                        if (!p.hasOwnProperty(n)) {
                            continue
                        }
                        this[n] = p[n]
                    }
                };
            return function(n, s, q) {
                if (Ext.isObject(s)) {
                    q = s;
                    s = n;
                    n = q.constructor !== i ? q.constructor : function() {
                        s.apply(this, arguments)
                    }
                }
                var p = function() {},
                    o, r = s.prototype;
                p.prototype = r;
                o = n.prototype = new p();
                o.constructor = n;
                n.superclass = r;
                if (r.constructor === i) {
                    r.constructor = s
                }
                n.override = function(t) {
                    Ext.override(n, t)
                };
                o.override = m;
                o.proto = o;
                n.override(q);
                n.extend = function(t) {
                    return Ext.extend(n, t)
                };
                return n
            }
        }()),
        override: function(o, p) {
            if (o.$isClass) {
                o.override(p)
            } else {
                if (typeof o == "function") {
                    Ext.apply(o.prototype, p)
                } else {
                    var i = o.self,
                        m, n;
                    if (i && i.$isClass) {
                        for (m in p) {
                            if (p.hasOwnProperty(m)) {
                                n = p[m];
                                if (typeof n == "function") {
                                    n.$name = m;
                                    n.$owner = i;
                                    n.$previous = o.hasOwnProperty(m) ? o[m] : e
                                }
                                o[m] = n
                            }
                        }
                    } else {
                        Ext.apply(o, p)
                    }
                }
            }
            return o
        }
    });
    Ext.apply(Ext, {
        valueFrom: function(n, i, m) {
            return Ext.isEmpty(n, m) ? i : n
        },
        typeOf: function(m) {
            var i, n;
            if (m === null) {
                return "null"
            }
            i = typeof m;
            if (i === "undefined" || i === "string" || i === "number" || i === "boolean") {
                return i
            }
            n = l.call(m);
            switch (n) {
                case "[object Array]":
                    return "array";
                case "[object Date]":
                    return "date";
                case "[object Boolean]":
                    return "boolean";
                case "[object Number]":
                    return "number";
                case "[object RegExp]":
                    return "regexp"
            }
            if (i === "function") {
                return "function"
            }
            if (i === "object") {
                if (m.nodeType !== undefined) {
                    if (m.nodeType === 3) {
                        return (/\S/).test(m.nodeValue) ? "textnode" : "whitespace"
                    } else {
                        return "element"
                    }
                }
                return "object"
            }
        },
        isEmpty: function(i, m) {
            return (i === null) || (i === undefined) || (!m ? i === "" : false) || (Ext.isArray(i) && i.length === 0)
        },
        isArray: ("isArray" in Array) ? Array.isArray : function(i) {
            return l.call(i) === "[object Array]"
        },
        isDate: function(i) {
            return l.call(i) === "[object Date]"
        },
        isObject: (l.call(null) === "[object Object]") ? function(i) {
            return i !== null && i !== undefined && l.call(i) === "[object Object]" && i.ownerDocument === undefined
        } : function(i) {
            return l.call(i) === "[object Object]"
        },
        isSimpleObject: function(i) {
            return i instanceof Object && i.constructor === Object
        },
        isPrimitive: function(m) {
            var i = typeof m;
            return i === "string" || i === "number" || i === "boolean"
        },
        isFunction: (typeof document !== "undefined" && typeof document.getElementsByTagName("body") === "function") ? function(i) {
            return l.call(i) === "[object Function]"
        } : function(i) {
            return typeof i === "function"
        },
        isNumber: function(i) {
            return typeof i === "number" && isFinite(i)
        },
        isNumeric: function(i) {
            return !isNaN(parseFloat(i)) && isFinite(i)
        },
        isString: function(i) {
            return typeof i === "string"
        },
        isBoolean: function(i) {
            return typeof i === "boolean"
        },
        isElement: function(i) {
            return i ? i.nodeType === 1 : false
        },
        isTextNode: function(i) {
            return i ? i.nodeName === "#text" : false
        },
        isDefined: function(i) {
            return typeof i !== "undefined"
        },
        isIterable: function(m) {
            var i = typeof m,
                n = false;
            if (m && i != "string") {
                if (i == "function") {
                    if (Ext.isSafari) {
                        n = m instanceof NodeList || m instanceof HTMLCollection
                    }
                } else {
                    n = true
                }
            }
            return n ? m.length !== undefined : false
        }
    });
    Ext.apply(Ext, {
        clone: function(r) {
            var q, p, n, m, s, o;
            if (r === null || r === undefined) {
                return r
            }
            if (r.nodeType && r.cloneNode) {
                return r.cloneNode(true)
            }
            q = l.call(r);
            if (q === "[object Date]") {
                return new Date(r.getTime())
            }
            if (q === "[object Array]") {
                p = r.length;
                s = [];
                while (p--) {
                    s[p] = Ext.clone(r[p])
                }
            } else {
                if (q === "[object Object]" && r.constructor === Object) {
                    s = {};
                    for (o in r) {
                        s[o] = Ext.clone(r[o])
                    }
                    if (c) {
                        for (n = c.length; n--;) {
                            m = c[n];
                            s[m] = r[m]
                        }
                    }
                }
            }
            return s || r
        },
        getUniqueGlobalNamespace: function() {
            var n = this.uniqueGlobalNamespace,
                m;
            if (n === undefined) {
                m = 0;
                do {
                    n = "ExtBox" + (++m)
                } while (Ext.global[n] !== undefined);
                Ext.global[n] = Ext;
                this.uniqueGlobalNamespace = n
            }
            return n
        },
        functionFactoryCache: {},
        cacheableFunctionFactory: function() {
            var q = this,
                n = Array.prototype.slice.call(arguments),
                m = q.functionFactoryCache,
                i, o, p;
            if (Ext.isSandboxed) {
                p = n.length;
                if (p > 0) {
                    p--;
                    n[p] = "var Ext=window." + Ext.name + ";" + n[p]
                }
            }
            i = n.join("");
            o = m[i];
            if (!o) {
                o = Function.prototype.constructor.apply(Function.prototype, n);
                m[i] = o
            }
            return o
        },
        functionFactory: function() {
            var n = this,
                i = Array.prototype.slice.call(arguments),
                m;
            if (Ext.isSandboxed) {
                m = i.length;
                if (m > 0) {
                    m--;
                    i[m] = "var Ext=window." + Ext.name + ";" + i[m]
                }
            }
            return Function.prototype.constructor.apply(Function.prototype, i)
        },
        Logger: {
            verbose: g,
            log: g,
            info: g,
            warn: g,
            error: function(i) {
                throw new Error(i)
            },
            deprecate: g
        }
    });
    Ext.type = Ext.typeOf
}());
Ext.globalEval = Ext.global.execScript ? function(a) {
    execScript(a)
} : function($$code) {
    (function() {
        eval($$code)
    }())
};
(function() {
    var a = "4.1.1.1",
        c;
    Ext.Version = c = Ext.extend(Object, {
        constructor: function(d) {
            var g, e;
            if (d instanceof c) {
                return d
            }
            this.version = this.shortVersion = String(d).toLowerCase().replace(/_/g, ".").replace(/[\-+]/g, "");
            e = this.version.search(/([^\d\.])/);
            if (e !== -1) {
                this.release = this.version.substr(e, d.length);
                this.shortVersion = this.version.substr(0, e)
            }
            this.shortVersion = this.shortVersion.replace(/[^\d]/g, "");
            g = this.version.split(".");
            this.major = parseInt(g.shift() || 0, 10);
            this.minor = parseInt(g.shift() || 0, 10);
            this.patch = parseInt(g.shift() || 0, 10);
            this.build = parseInt(g.shift() || 0, 10);
            return this
        },
        toString: function() {
            return this.version
        },
        valueOf: function() {
            return this.version
        },
        getMajor: function() {
            return this.major || 0
        },
        getMinor: function() {
            return this.minor || 0
        },
        getPatch: function() {
            return this.patch || 0
        },
        getBuild: function() {
            return this.build || 0
        },
        getRelease: function() {
            return this.release || ""
        },
        isGreaterThan: function(d) {
            return c.compare(this.version, d) === 1
        },
        isGreaterThanOrEqual: function(d) {
            return c.compare(this.version, d) >= 0
        },
        isLessThan: function(d) {
            return c.compare(this.version, d) === -1
        },
        isLessThanOrEqual: function(d) {
            return c.compare(this.version, d) <= 0
        },
        equals: function(d) {
            return c.compare(this.version, d) === 0
        },
        match: function(d) {
            d = String(d);
            return this.version.substr(0, d.length) === d
        },
        toArray: function() {
            return [this.getMajor(), this.getMinor(), this.getPatch(), this.getBuild(), this.getRelease()]
        },
        getShortVersion: function() {
            return this.shortVersion
        },
        gt: function() {
            return this.isGreaterThan.apply(this, arguments)
        },
        lt: function() {
            return this.isLessThan.apply(this, arguments)
        },
        gtEq: function() {
            return this.isGreaterThanOrEqual.apply(this, arguments)
        },
        ltEq: function() {
            return this.isLessThanOrEqual.apply(this, arguments)
        }
    });
    Ext.apply(c, {
        releaseValueMap: {
            dev: -6,
            alpha: -5,
            a: -5,
            beta: -4,
            b: -4,
            rc: -3,
            "#": -2,
            p: -1,
            pl: -1
        },
        getComponentValue: function(d) {
            return !d ? 0 : (isNaN(d) ? this.releaseValueMap[d] || d : parseInt(d, 10))
        },
        compare: function(k, j) {
            var e, g, d;
            k = new c(k).toArray();
            j = new c(j).toArray();
            for (d = 0; d < Math.max(k.length, j.length); d++) {
                e = this.getComponentValue(k[d]);
                g = this.getComponentValue(j[d]);
                if (e < g) {
                    return -1
                } else {
                    if (e > g) {
                        return 1
                    }
                }
            }
            return 0
        }
    });
    Ext.apply(Ext, {
        versions: {},
        lastRegisteredVersion: null,
        setVersion: function(e, d) {
            Ext.versions[e] = new c(d);
            Ext.lastRegisteredVersion = Ext.versions[e];
            return this
        },
        getVersion: function(d) {
            if (d === undefined) {
                return Ext.lastRegisteredVersion
            }
            return Ext.versions[d]
        },
        deprecate: function(d, g, i, e) {
            if (c.compare(Ext.getVersion(d), g) < 1) {
                i.call(e)
            }
        }
    });
    Ext.setVersion("core", a)
}());
Ext.String = (function() {
    var k = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g,
        o = /('|\\)/g,
        j = /\{(\d+)\}/g,
        c = /([-.*+?\^${}()|\[\]\/\\])/g,
        p = /^\s+|\s+$/g,
        l = /\s+/,
        n = /(^[^a-z]*|[^\w])/gi,
        e, a, i, d, g = function(r, q) {
            return e[q]
        },
        m = function(r, q) {
            return (q in a) ? a[q] : String.fromCharCode(parseInt(q.substr(2), 10))
        };
    return {
        createVarName: function(q) {
            return q.replace(n, "")
        },
        htmlEncode: function(q) {
            return (!q) ? q : String(q).replace(i, g)
        },
        htmlDecode: function(q) {
            return (!q) ? q : String(q).replace(d, m)
        },
        addCharacterEntities: function(r) {
            var q = [],
                u = [],
                s, t;
            for (s in r) {
                t = r[s];
                a[s] = t;
                e[t] = s;
                q.push(t);
                u.push(s)
            }
            i = new RegExp("(" + q.join("|") + ")", "g");
            d = new RegExp("(" + u.join("|") + "|&#[0-9]{1,5};)", "g")
        },
        resetCharacterEntities: function() {
            e = {};
            a = {};
            this.addCharacterEntities({
                "&amp;": "&",
                "&gt;": ">",
                "&lt;": "<",
                "&quot;": '"',
                "&#39;": "'"
            })
        },
        urlAppend: function(r, q) {
            if (!Ext.isEmpty(q)) {
                return r + (r.indexOf("?") === -1 ? "?" : "&") + q
            }
            return r
        },
        trim: function(q) {
            return q.replace(k, "")
        },
        capitalize: function(q) {
            return q.charAt(0).toUpperCase() + q.substr(1)
        },
        uncapitalize: function(q) {
            return q.charAt(0).toLowerCase() + q.substr(1)
        },
        ellipsis: function(s, q, t) {
            if (s && s.length > q) {
                if (t) {
                    var u = s.substr(0, q - 2),
                        r = Math.max(u.lastIndexOf(" "), u.lastIndexOf("."), u.lastIndexOf("!"), u.lastIndexOf("?"));
                    if (r !== -1 && r >= (q - 15)) {
                        return u.substr(0, r) + "..."
                    }
                }
                return s.substr(0, q - 3) + "..."
            }
            return s
        },
        escapeRegex: function(q) {
            return q.replace(c, "\\$1")
        },
        escape: function(q) {
            return q.replace(o, "\\$1")
        },
        toggle: function(r, s, q) {
            return r === s ? q : s
        },
        leftPad: function(r, s, t) {
            var q = String(r);
            t = t || " ";
            while (q.length < s) {
                q = t + q
            }
            return q
        },
        format: function(r) {
            var q = Ext.Array.toArray(arguments, 1);
            return r.replace(j, function(s, t) {
                return q[t]
            })
        },
        repeat: function(u, t, r) {
            for (var q = [], s = t; s--;) {
                q.push(u)
            }
            return q.join(r || "")
        },
        splitWords: function(q) {
            if (q && typeof q == "string") {
                return q.replace(p, "").split(l)
            }
            return q || []
        }
    }
}());
Ext.String.resetCharacterEntities();
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;
Ext.Number = new function() {
    var c = this,
        d = (0.9).toFixed() !== "1",
        a = Math;
    Ext.apply(this, {
        constrain: function(j, i, g) {
            var e = parseFloat(j);
            return (e < i) ? i : ((e > g) ? g : e)
        },
        snap: function(j, g, i, k) {
            var e;
            if (j === undefined || j < i) {
                return i || 0
            }
            if (g) {
                e = j % g;
                if (e !== 0) {
                    j -= e;
                    if (e * 2 >= g) {
                        j += g
                    } else {
                        if (e * 2 < -g) {
                            j -= g
                        }
                    }
                }
            }
            return c.constrain(j, i, k)
        },
        snapInRange: function(j, e, i, k) {
            var g;
            i = (i || 0);
            if (j === undefined || j < i) {
                return i
            }
            if (e && (g = ((j - i) % e))) {
                j -= g;
                g *= 2;
                if (g >= e) {
                    j += e
                }
            }
            if (k !== undefined) {
                if (j > (k = c.snapInRange(k, e, i))) {
                    j = k
                }
            }
            return j
        },
        toFixed: d ? function(i, e) {
            e = e || 0;
            var g = a.pow(10, e);
            return (a.round(i * g) / g).toFixed(e)
        } : function(g, e) {
            return g.toFixed(e)
        },
        from: function(g, e) {
            if (isFinite(g)) {
                g = parseFloat(g)
            }
            return !isNaN(g) ? g : e
        },
        randomInt: function(g, e) {
            return a.floor(a.random() * (e - g + 1) + g)
        }
    });
    Ext.num = function() {
        return c.from.apply(this, arguments)
    }
};
(function() {
    var i = Array.prototype,
        q = i.slice,
        s = (function() {
            var D = [],
                e, C = 20;
            if (!D.splice) {
                return false
            }
            while (C--) {
                D.push("A")
            }
            D.splice(15, 0, "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F");
            e = D.length;
            D.splice(13, 0, "XXX");
            if (e + 1 != D.length) {
                return false
            }
            return true
        }()),
        l = "forEach" in i,
        x = "map" in i,
        r = "indexOf" in i,
        B = "every" in i,
        d = "some" in i,
        g = "filter" in i,
        p = (function() {
            var e = [1, 2, 3, 4, 5].sort(function() {
                return 0
            });
            return e[0] === 1 && e[1] === 2 && e[2] === 3 && e[3] === 4 && e[4] === 5
        }()),
        m = true,
        a, z, v, y;
    try {
        if (typeof document !== "undefined") {
            q.call(document.getElementsByTagName("body"))
        }
    } catch (u) {
        m = false
    }

    function o(C, e) {
        return (e < 0) ? Math.max(0, C.length + e) : Math.min(C.length, e)
    }

    function A(J, I, C, M) {
        var N = M ? M.length : 0,
            E = J.length,
            K = o(J, I),
            H, L, D, e, F, G;
        if (K === E) {
            if (N) {
                J.push.apply(J, M)
            }
        } else {
            H = Math.min(C, E - K);
            L = K + H;
            D = L + N - H;
            e = E - L;
            F = E - H;
            if (D < L) {
                for (G = 0; G < e; ++G) {
                    J[D + G] = J[L + G]
                }
            } else {
                if (D > L) {
                    for (G = e; G--;) {
                        J[D + G] = J[L + G]
                    }
                }
            }
            if (N && K === F) {
                J.length = F;
                J.push.apply(J, M)
            } else {
                J.length = F + N;
                for (G = 0; G < N; ++G) {
                    J[K + G] = M[G]
                }
            }
        }
        return J
    }

    function k(E, e, D, C) {
        if (C && C.length) {
            if (e < E.length) {
                E.splice.apply(E, [e, D].concat(C))
            } else {
                E.push.apply(E, C)
            }
        } else {
            E.splice(e, D)
        }
        return E
    }

    function c(D, e, C) {
        return A(D, e, C)
    }

    function t(D, e, C) {
        D.splice(e, C);
        return D
    }

    function n(F, e, D) {
        var E = o(F, e),
            C = F.slice(e, o(F, E + D));
        if (arguments.length < 4) {
            A(F, E, D)
        } else {
            A(F, E, D, q.call(arguments, 3))
        }
        return C
    }

    function j(e) {
        return e.splice.apply(e, q.call(arguments, 1))
    }
    z = s ? t : c;
    v = s ? k : A;
    y = s ? j : n;
    a = Ext.Array = {
        each: function(G, E, D, e) {
            G = a.from(G);
            var C, F = G.length;
            if (e !== true) {
                for (C = 0; C < F; C++) {
                    if (E.call(D || G[C], G[C], C, G) === false) {
                        return C
                    }
                }
            } else {
                for (C = F - 1; C > -1; C--) {
                    if (E.call(D || G[C], G[C], C, G) === false) {
                        return C
                    }
                }
            }
            return true
        },
        forEach: l ? function(D, C, e) {
            return D.forEach(C, e)
        } : function(F, D, C) {
            var e = 0,
                E = F.length;
            for (; e < E; e++) {
                D.call(C, F[e], e, F)
            }
        },
        indexOf: r ? function(D, e, C) {
            return D.indexOf(e, C)
        } : function(F, D, E) {
            var e, C = F.length;
            for (e = (E < 0) ? Math.max(0, C + E) : E || 0; e < C; e++) {
                if (F[e] === D) {
                    return e
                }
            }
            return -1
        },
        contains: r ? function(C, e) {
            return C.indexOf(e) !== -1
        } : function(E, D) {
            var e, C;
            for (e = 0, C = E.length; e < C; e++) {
                if (E[e] === D) {
                    return true
                }
            }
            return false
        },
        toArray: function(D, F, e) {
            if (!D || !D.length) {
                return []
            }
            if (typeof D === "string") {
                D = D.split("")
            }
            if (m) {
                return q.call(D, F || 0, e || D.length)
            }
            var E = [],
                C;
            F = F || 0;
            e = e ? ((e < 0) ? D.length + e : e) : D.length;
            for (C = F; C < e; C++) {
                E.push(D[C])
            }
            return E
        },
        pluck: function(G, e) {
            var C = [],
                D, F, E;
            for (D = 0, F = G.length; D < F; D++) {
                E = G[D];
                C.push(E[e])
            }
            return C
        },
        map: x ? function(D, C, e) {
            return D.map(C, e)
        } : function(G, F, E) {
            var D = [],
                C = 0,
                e = G.length;
            for (; C < e; C++) {
                D[C] = F.call(E, G[C], C, G)
            }
            return D
        },
        every: B ? function(D, C, e) {
            return D.every(C, e)
        } : function(F, D, C) {
            var e = 0,
                E = F.length;
            for (; e < E; ++e) {
                if (!D.call(C, F[e], e, F)) {
                    return false
                }
            }
            return true
        },
        some: d ? function(D, C, e) {
            return D.some(C, e)
        } : function(F, D, C) {
            var e = 0,
                E = F.length;
            for (; e < E; ++e) {
                if (D.call(C, F[e], e, F)) {
                    return true
                }
            }
            return false
        },
        clean: function(F) {
            var C = [],
                e = 0,
                E = F.length,
                D;
            for (; e < E; e++) {
                D = F[e];
                if (!Ext.isEmpty(D)) {
                    C.push(D)
                }
            }
            return C
        },
        unique: function(F) {
            var E = [],
                e = 0,
                D = F.length,
                C;
            for (; e < D; e++) {
                C = F[e];
                if (a.indexOf(E, C) === -1) {
                    E.push(C)
                }
            }
            return E
        },
        filter: g ? function(D, C, e) {
            return D.filter(C, e)
        } : function(G, E, D) {
            var C = [],
                e = 0,
                F = G.length;
            for (; e < F; e++) {
                if (E.call(D, G[e], e, G)) {
                    C.push(G[e])
                }
            }
            return C
        },
        from: function(D, C) {
            if (D === undefined || D === null) {
                return []
            }
            if (Ext.isArray(D)) {
                return (C) ? q.call(D) : D
            }
            var e = typeof D;
            if (D && D.length !== undefined && e !== "string" && (e !== "function" || !D.apply)) {
                return a.toArray(D)
            }
            return [D]
        },
        remove: function(D, C) {
            var e = a.indexOf(D, C);
            if (e !== -1) {
                z(D, e, 1)
            }
            return D
        },
        include: function(C, e) {
            if (!a.contains(C, e)) {
                C.push(e)
            }
        },
        clone: function(e) {
            return q.call(e)
        },
        merge: function() {
            var e = q.call(arguments),
                E = [],
                C, D;
            for (C = 0, D = e.length; C < D; C++) {
                E = E.concat(e[C])
            }
            return a.unique(E)
        },
        intersect: function() {
            var e = [],
                D = q.call(arguments),
                O, M, I, L, P, E, C, K, N, F, J, H, G;
            if (!D.length) {
                return e
            }
            O = D.length;
            for (J = P = 0; J < O; J++) {
                E = D[J];
                if (!L || E.length < L.length) {
                    L = E;
                    P = J
                }
            }
            L = a.unique(L);
            z(D, P, 1);
            C = L.length;
            O = D.length;
            for (J = 0; J < C; J++) {
                K = L[J];
                F = 0;
                for (H = 0; H < O; H++) {
                    M = D[H];
                    I = M.length;
                    for (G = 0; G < I; G++) {
                        N = M[G];
                        if (K === N) {
                            F++;
                            break
                        }
                    }
                }
                if (F === O) {
                    e.push(K)
                }
            }
            return e
        },
        difference: function(C, e) {
            var H = q.call(C),
                F = H.length,
                E, D, G;
            for (E = 0, G = e.length; E < G; E++) {
                for (D = 0; D < F; D++) {
                    if (H[D] === e[E]) {
                        z(H, D, 1);
                        D--;
                        F--
                    }
                }
            }
            return H
        },
        slice: ([1, 2].slice(1, undefined).length ? function(D, C, e) {
            return q.call(D, C, e)
        } : function(D, C, e) {
            if (typeof C === "undefined") {
                return q.call(D)
            }
            if (typeof e === "undefined") {
                return q.call(D, C)
            }
            return q.call(D, C, e)
        }),
        sort: p ? function(C, e) {
            if (e) {
                return C.sort(e)
            } else {
                return C.sort()
            }
        } : function(I, H) {
            var F = I.length,
                E = 0,
                G, e, D, C;
            for (; E < F; E++) {
                D = E;
                for (e = E + 1; e < F; e++) {
                    if (H) {
                        G = H(I[e], I[D]);
                        if (G < 0) {
                            D = e
                        }
                    } else {
                        if (I[e] < I[D]) {
                            D = e
                        }
                    }
                }
                if (D !== E) {
                    C = I[E];
                    I[E] = I[D];
                    I[D] = C
                }
            }
            return I
        },
        flatten: function(D) {
            var C = [];

            function e(E) {
                var G, H, F;
                for (G = 0, H = E.length; G < H; G++) {
                    F = E[G];
                    if (Ext.isArray(F)) {
                        e(F)
                    } else {
                        C.push(F)
                    }
                }
                return C
            }
            return e(D)
        },
        min: function(G, F) {
            var C = G[0],
                e, E, D;
            for (e = 0, E = G.length; e < E; e++) {
                D = G[e];
                if (F) {
                    if (F(C, D) === 1) {
                        C = D
                    }
                } else {
                    if (D < C) {
                        C = D
                    }
                }
            }
            return C
        },
        max: function(G, F) {
            var e = G[0],
                C, E, D;
            for (C = 0, E = G.length; C < E; C++) {
                D = G[C];
                if (F) {
                    if (F(e, D) === -1) {
                        e = D
                    }
                } else {
                    if (D > e) {
                        e = D
                    }
                }
            }
            return e
        },
        mean: function(e) {
            return e.length > 0 ? a.sum(e) / e.length : undefined
        },
        sum: function(F) {
            var C = 0,
                e, E, D;
            for (e = 0, E = F.length; e < E; e++) {
                D = F[e];
                C += D
            }
            return C
        },
        toMap: function(F, e, D) {
            var E = {},
                C = F.length;
            if (!e) {
                while (C--) {
                    E[F[C]] = C + 1
                }
            } else {
                if (typeof e == "string") {
                    while (C--) {
                        E[F[C][e]] = C + 1
                    }
                } else {
                    while (C--) {
                        E[e.call(D, F[C])] = C + 1
                    }
                }
            }
            return E
        },
        erase: z,
        insert: function(D, C, e) {
            return v(D, C, 0, e)
        },
        replace: v,
        splice: y,
        push: function(E) {
            var e = arguments.length,
                D = 1,
                C;
            if (E === undefined) {
                E = []
            } else {
                if (!Ext.isArray(E)) {
                    E = [E]
                }
            }
            for (; D < e; D++) {
                C = arguments[D];
                Array.prototype.push[Ext.isArray(C) ? "apply" : "call"](E, C)
            }
            return E
        }
    };
    Ext.each = a.each;
    a.union = a.merge;
    Ext.min = a.min;
    Ext.max = a.max;
    Ext.sum = a.sum;
    Ext.mean = a.mean;
    Ext.flatten = a.flatten;
    Ext.clean = a.clean;
    Ext.unique = a.unique;
    Ext.pluck = a.pluck;
    Ext.toArray = function() {
        return a.toArray.apply(a, arguments)
    }
}());
Ext.Function = {
    flexSetter: function(a) {
        return function(d, c) {
            var e, g;
            if (d === null) {
                return this
            }
            if (typeof d !== "string") {
                for (e in d) {
                    if (d.hasOwnProperty(e)) {
                        a.call(this, e, d[e])
                    }
                }
                if (Ext.enumerables) {
                    for (g = Ext.enumerables.length; g--;) {
                        e = Ext.enumerables[g];
                        if (d.hasOwnProperty(e)) {
                            a.call(this, e, d[e])
                        }
                    }
                }
            } else {
                a.call(this, d, c)
            }
            return this
        }
    },
    bind: function(e, d, c, a) {
        if (arguments.length === 2) {
            return function() {
                return e.apply(d, arguments)
            }
        }
        var i = e,
            g = Array.prototype.slice;
        return function() {
            var j = c || arguments;
            if (a === true) {
                j = g.call(arguments, 0);
                j = j.concat(c)
            } else {
                if (typeof a == "number") {
                    j = g.call(arguments, 0);
                    Ext.Array.insert(j, a, c)
                }
            }
            return i.apply(d || Ext.global, j)
        }
    },
    pass: function(d, a, c) {
        if (!Ext.isArray(a)) {
            if (Ext.isIterable(a)) {
                a = Ext.Array.clone(a)
            } else {
                a = a !== undefined ? [a] : []
            }
        }
        return function() {
            var e = [].concat(a);
            e.push.apply(e, arguments);
            return d.apply(c || this, e)
        }
    },
    alias: function(c, a) {
        return function() {
            return c[a].apply(c, arguments)
        }
    },
    clone: function(a) {
        return function() {
            return a.apply(this, arguments)
        }
    },
    createInterceptor: function(e, d, c, a) {
        var g = e;
        if (!Ext.isFunction(d)) {
            return e
        } else {
            return function() {
                var j = this,
                    i = arguments;
                d.target = j;
                d.method = e;
                return (d.apply(c || j || Ext.global, i) !== false) ? e.apply(j || Ext.global, i) : a || null
            }
        }
    },
    createDelayed: function(g, d, e, c, a) {
        if (e || c) {
            g = Ext.Function.bind(g, e, c, a)
        }
        return function() {
            var j = this,
                i = Array.prototype.slice.call(arguments);
            setTimeout(function() {
                g.apply(j, i)
            }, d)
        }
    },
    defer: function(g, d, e, c, a) {
        g = Ext.Function.bind(g, e, c, a);
        if (d > 0) {
            return setTimeout(Ext.supports.TimeoutActualLateness ? function() {
                g()
            } : g, d)
        }
        g();
        return 0
    },
    createSequence: function(c, d, a) {
        if (!d) {
            return c
        } else {
            return function() {
                var e = c.apply(this, arguments);
                d.apply(a || this, arguments);
                return e
            }
        }
    },
    createBuffered: function(g, c, e, d) {
        var a;
        return function() {
            var j = d || Array.prototype.slice.call(arguments, 0),
                i = e || this;
            if (a) {
                clearTimeout(a)
            }
            a = setTimeout(function() {
                g.apply(i, j)
            }, c)
        }
    },
    createThrottled: function(g, c, e) {
        var i, a, d, k, j = function() {
            g.apply(e || this, d);
            i = new Date().getTime()
        };
        return function() {
            a = new Date().getTime() - i;
            d = arguments;
            clearTimeout(k);
            if (!i || (a >= c)) {
                j()
            } else {
                k = setTimeout(j, c - a)
            }
        }
    },
    interceptBefore: function(c, a, e, d) {
        var g = c[a] || Ext.emptyFn;
        return (c[a] = function() {
            var i = e.apply(d || this, arguments);
            g.apply(this, arguments);
            return i
        })
    },
    interceptAfter: function(c, a, e, d) {
        var g = c[a] || Ext.emptyFn;
        return (c[a] = function() {
            g.apply(this, arguments);
            return e.apply(d || this, arguments)
        })
    }
};
Ext.defer = Ext.Function.alias(Ext.Function, "defer");
Ext.pass = Ext.Function.alias(Ext.Function, "pass");
Ext.bind = Ext.Function.alias(Ext.Function, "bind");
(function() {
    var a = function() {},
        c = Ext.Object = {
            chain: function(e) {
                a.prototype = e;
                var d = new a();
                a.prototype = null;
                return d
            },
            toQueryObjects: function(g, m, e) {
                var d = c.toQueryObjects,
                    l = [],
                    j, k;
                if (Ext.isArray(m)) {
                    for (j = 0, k = m.length; j < k; j++) {
                        if (e) {
                            l = l.concat(d(g + "[" + j + "]", m[j], true))
                        } else {
                            l.push({
                                name: g,
                                value: m[j]
                            })
                        }
                    }
                } else {
                    if (Ext.isObject(m)) {
                        for (j in m) {
                            if (m.hasOwnProperty(j)) {
                                if (e) {
                                    l = l.concat(d(g + "[" + j + "]", m[j], true))
                                } else {
                                    l.push({
                                        name: g,
                                        value: m[j]
                                    })
                                }
                            }
                        }
                    } else {
                        l.push({
                            name: g,
                            value: m
                        })
                    }
                }
                return l
            },
            toQueryString: function(k, e) {
                var l = [],
                    g = [],
                    n, m, o, d, p;
                for (n in k) {
                    if (k.hasOwnProperty(n)) {
                        l = l.concat(c.toQueryObjects(n, k[n], e))
                    }
                }
                for (m = 0, o = l.length; m < o; m++) {
                    d = l[m];
                    p = d.value;
                    if (Ext.isEmpty(p)) {
                        p = ""
                    } else {
                        if (Ext.isDate(p)) {
                            p = Ext.Date.toString(p)
                        }
                    }
                    g.push(encodeURIComponent(d.name) + "=" + encodeURIComponent(String(p)))
                }
                return g.join("&")
            },
            fromQueryString: function(e, t) {
                var o = e.replace(/^\?/, "").split("&"),
                    x = {},
                    u, m, z, p, s, k, q, r, d, l, v, n, y, g;
                for (s = 0, k = o.length; s < k; s++) {
                    q = o[s];
                    if (q.length > 0) {
                        m = q.split("=");
                        z = decodeURIComponent(m[0]);
                        p = (m[1] !== undefined) ? decodeURIComponent(m[1]) : "";
                        if (!t) {
                            if (x.hasOwnProperty(z)) {
                                if (!Ext.isArray(x[z])) {
                                    x[z] = [x[z]]
                                }
                                x[z].push(p)
                            } else {
                                x[z] = p
                            }
                        } else {
                            l = z.match(/(\[):?([^\]]*)\]/g);
                            v = z.match(/^([^\[]+)/);
                            z = v[0];
                            n = [];
                            if (l === null) {
                                x[z] = p;
                                continue
                            }
                            for (r = 0, d = l.length; r < d; r++) {
                                y = l[r];
                                y = (y.length === 2) ? "" : y.substring(1, y.length - 1);
                                n.push(y)
                            }
                            n.unshift(z);
                            u = x;
                            for (r = 0, d = n.length; r < d; r++) {
                                y = n[r];
                                if (r === d - 1) {
                                    if (Ext.isArray(u) && y === "") {
                                        u.push(p)
                                    } else {
                                        u[y] = p
                                    }
                                } else {
                                    if (u[y] === undefined || typeof u[y] === "string") {
                                        g = n[r + 1];
                                        u[y] = (Ext.isNumeric(g) || g === "") ? [] : {}
                                    }
                                    u = u[y]
                                }
                            }
                        }
                    }
                }
                return x
            },
            each: function(d, g, e) {
                for (var i in d) {
                    if (d.hasOwnProperty(i)) {
                        if (g.call(e || d, i, d[i], d) === false) {
                            return
                        }
                    }
                }
            },
            merge: function(m) {
                var k = 1,
                    l = arguments.length,
                    d = c.merge,
                    g = Ext.clone,
                    j, o, n, e;
                for (; k < l; k++) {
                    j = arguments[k];
                    for (o in j) {
                        n = j[o];
                        if (n && n.constructor === Object) {
                            e = m[o];
                            if (e && e.constructor === Object) {
                                d(e, n)
                            } else {
                                m[o] = g(n)
                            }
                        } else {
                            m[o] = n
                        }
                    }
                }
                return m
            },
            mergeIf: function(d) {
                var k = 1,
                    l = arguments.length,
                    g = Ext.clone,
                    e, j, m;
                for (; k < l; k++) {
                    e = arguments[k];
                    for (j in e) {
                        if (!(j in d)) {
                            m = e[j];
                            if (m && m.constructor === Object) {
                                d[j] = g(m)
                            } else {
                                d[j] = m
                            }
                        }
                    }
                }
                return d
            },
            getKey: function(d, g) {
                for (var e in d) {
                    if (d.hasOwnProperty(e) && d[e] === g) {
                        return e
                    }
                }
                return null
            },
            getValues: function(e) {
                var d = [],
                    g;
                for (g in e) {
                    if (e.hasOwnProperty(g)) {
                        d.push(e[g])
                    }
                }
                return d
            },
            getKeys: (typeof Object.keys == "function") ? function(d) {
                if (!d) {
                    return []
                }
                return Object.keys(d)
            } : function(d) {
                var e = [],
                    g;
                for (g in d) {
                    if (d.hasOwnProperty(g)) {
                        e.push(g)
                    }
                }
                return e
            },
            getSize: function(d) {
                var e = 0,
                    g;
                for (g in d) {
                    if (d.hasOwnProperty(g)) {
                        e++
                    }
                }
                return e
            },
            classify: function(i) {
                var g = i,
                    k = [],
                    e = {},
                    d = function() {
                        var m = 0,
                            n = k.length,
                            o;
                        for (; m < n; m++) {
                            o = k[m];
                            this[o] = new e[o]()
                        }
                    },
                    j, l;
                for (j in i) {
                    if (i.hasOwnProperty(j)) {
                        l = i[j];
                        if (l && l.constructor === Object) {
                            k.push(j);
                            e[j] = c.classify(l)
                        }
                    }
                }
                d.prototype = g;
                return d
            }
        };
    Ext.merge = Ext.Object.merge;
    Ext.mergeIf = Ext.Object.mergeIf;
    Ext.urlEncode = function() {
        var d = Ext.Array.from(arguments),
            e = "";
        if ((typeof d[1] === "string")) {
            e = d[1] + "&";
            d[1] = false
        }
        return e + c.toQueryString.apply(c, d)
    };
    Ext.urlDecode = function() {
        return c.fromQueryString.apply(c, arguments)
    }
}());
(function() {
    function c(e) {
        var d = Array.prototype.slice.call(arguments, 1);
        return e.replace(/\{(\d+)\}/g, function(g, j) {
            return d[j]
        })
    }
    Ext.Date = {
        now: Date.now || function() {
            return +new Date()
        },
        toString: function(d) {
            var e = Ext.String.leftPad;
            return d.getFullYear() + "-" + e(d.getMonth() + 1, 2, "0") + "-" + e(d.getDate(), 2, "0") + "T" + e(d.getHours(), 2, "0") + ":" + e(d.getMinutes(), 2, "0") + ":" + e(d.getSeconds(), 2, "0")
        },
        getElapsed: function(e, d) {
            return Math.abs(e - (d || new Date()))
        },
        useStrict: false,
        formatCodeToRegex: function(e, d) {
            var g = a.parseCodes[e];
            if (g) {
                g = typeof g == "function" ? g() : g;
                a.parseCodes[e] = g
            }
            return g ? Ext.applyIf({
                c: g.c ? c(g.c, d || "{0}") : g.c
            }, g) : {
                g: 0,
                c: null,
                s: Ext.String.escapeRegex(e)
            }
        },
        parseFunctions: {
            MS: function(e, d) {
                var g = new RegExp("\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/"),
                    i = (e || "").match(g);
                return i ? new Date(((i[1] || "") + i[2]) * 1) : null
            }
        },
        parseRegexes: [],
        formatFunctions: {
            MS: function() {
                return "\\/Date(" + this.getTime() + ")\\/"
            }
        },
        y2kYear: 50,
        MILLI: "ms",
        SECOND: "s",
        MINUTE: "mi",
        HOUR: "h",
        DAY: "d",
        MONTH: "mo",
        YEAR: "y",
        defaults: {},
        dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthNumbers: {
            January: 0,
            Jan: 0,
            February: 1,
            Feb: 1,
            March: 2,
            Mar: 2,
            April: 3,
            Apr: 3,
            May: 4,
            June: 5,
            Jun: 5,
            July: 6,
            Jul: 6,
            August: 7,
            Aug: 7,
            September: 8,
            Sep: 8,
            October: 9,
            Oct: 9,
            November: 10,
            Nov: 10,
            December: 11,
            Dec: 11
        },
        defaultFormat: "m/d/Y",
        getShortMonthName: function(d) {
            return Ext.Date.monthNames[d].substring(0, 3)
        },
        getShortDayName: function(d) {
            return Ext.Date.dayNames[d].substring(0, 3)
        },
        getMonthNumber: function(d) {
            return Ext.Date.monthNumbers[d.substring(0, 1).toUpperCase() + d.substring(1, 3).toLowerCase()]
        },
        formatContainsHourInfo: (function() {
            var e = /(\\.)/g,
                d = /([gGhHisucUOPZ]|MS)/;
            return function(g) {
                return d.test(g.replace(e, ""))
            }
        }()),
        formatContainsDateInfo: (function() {
            var e = /(\\.)/g,
                d = /([djzmnYycU]|MS)/;
            return function(g) {
                return d.test(g.replace(e, ""))
            }
        }()),
        unescapeFormat: (function() {
            var d = /\\/gi;
            return function(e) {
                return e.replace(d, "")
            }
        }()),
        formatCodes: {
            d: "Ext.String.leftPad(this.getDate(), 2, '0')",
            D: "Ext.Date.getShortDayName(this.getDay())",
            j: "this.getDate()",
            l: "Ext.Date.dayNames[this.getDay()]",
            N: "(this.getDay() ? this.getDay() : 7)",
            S: "Ext.Date.getSuffix(this)",
            w: "this.getDay()",
            z: "Ext.Date.getDayOfYear(this)",
            W: "Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')",
            F: "Ext.Date.monthNames[this.getMonth()]",
            m: "Ext.String.leftPad(this.getMonth() + 1, 2, '0')",
            M: "Ext.Date.getShortMonthName(this.getMonth())",
            n: "(this.getMonth() + 1)",
            t: "Ext.Date.getDaysInMonth(this)",
            L: "(Ext.Date.isLeapYear(this) ? 1 : 0)",
            o: "(this.getFullYear() + (Ext.Date.getWeekOfYear(this) == 1 && this.getMonth() > 0 ? +1 : (Ext.Date.getWeekOfYear(this) >= 52 && this.getMonth() < 11 ? -1 : 0)))",
            Y: "Ext.String.leftPad(this.getFullYear(), 4, '0')",
            y: "('' + this.getFullYear()).substring(2, 4)",
            a: "(this.getHours() < 12 ? 'am' : 'pm')",
            A: "(this.getHours() < 12 ? 'AM' : 'PM')",
            g: "((this.getHours() % 12) ? this.getHours() % 12 : 12)",
            G: "this.getHours()",
            h: "Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')",
            H: "Ext.String.leftPad(this.getHours(), 2, '0')",
            i: "Ext.String.leftPad(this.getMinutes(), 2, '0')",
            s: "Ext.String.leftPad(this.getSeconds(), 2, '0')",
            u: "Ext.String.leftPad(this.getMilliseconds(), 3, '0')",
            O: "Ext.Date.getGMTOffset(this)",
            P: "Ext.Date.getGMTOffset(this, true)",
            T: "Ext.Date.getTimezone(this)",
            Z: "(this.getTimezoneOffset() * -60)",
            c: function() {
                var m, j, g, d, k;
                for (m = "Y-m-dTH:i:sP", j = [], g = 0, d = m.length; g < d; ++g) {
                    k = m.charAt(g);
                    j.push(k == "T" ? "'T'" : a.getFormatCode(k))
                }
                return j.join(" + ")
            },
            U: "Math.round(this.getTime() / 1000)"
        },
        isValid: function(p, e, o, l, j, k, g) {
            l = l || 0;
            j = j || 0;
            k = k || 0;
            g = g || 0;
            var n = a.add(new Date(p < 100 ? 100 : p, e - 1, o, l, j, k, g), a.YEAR, p < 100 ? p - 100 : 0);
            return p == n.getFullYear() && e == n.getMonth() + 1 && o == n.getDate() && l == n.getHours() && j == n.getMinutes() && k == n.getSeconds() && g == n.getMilliseconds()
        },
        parse: function(e, i, d) {
            var g = a.parseFunctions;
            if (g[i] == null) {
                a.createParser(i)
            }
            return g[i](e, Ext.isDefined(d) ? d : a.useStrict)
        },
        parseDate: function(e, g, d) {
            return a.parse(e, g, d)
        },
        getFormatCode: function(e) {
            var d = a.formatCodes[e];
            if (d) {
                d = typeof d == "function" ? d() : d;
                a.formatCodes[e] = d
            }
            return d || ("'" + Ext.String.escape(e) + "'")
        },
        createFormat: function(k) {
            var j = [],
                d = false,
                g = "",
                e;
            for (e = 0; e < k.length; ++e) {
                g = k.charAt(e);
                if (!d && g == "\\") {
                    d = true
                } else {
                    if (d) {
                        d = false;
                        j.push("'" + Ext.String.escape(g) + "'")
                    } else {
                        j.push(a.getFormatCode(g))
                    }
                }
            }
            a.formatFunctions[k] = Ext.functionFactory("return " + j.join("+"))
        },
        createParser: (function() {
            var d = ["var dt, y, m, d, h, i, s, ms, o, z, zz, u, v,", "def = Ext.Date.defaults,", "results = String(input).match(Ext.Date.parseRegexes[{0}]);", "if(results){", "{1}", "if(u != null){", "v = new Date(u * 1000);", "}else{", "dt = Ext.Date.clearTime(new Date);", "y = Ext.Number.from(y, Ext.Number.from(def.y, dt.getFullYear()));", "m = Ext.Number.from(m, Ext.Number.from(def.m - 1, dt.getMonth()));", "d = Ext.Number.from(d, Ext.Number.from(def.d, dt.getDate()));", "h  = Ext.Number.from(h, Ext.Number.from(def.h, dt.getHours()));", "i  = Ext.Number.from(i, Ext.Number.from(def.i, dt.getMinutes()));", "s  = Ext.Number.from(s, Ext.Number.from(def.s, dt.getSeconds()));", "ms = Ext.Number.from(ms, Ext.Number.from(def.ms, dt.getMilliseconds()));", "if(z >= 0 && y >= 0){", "v = Ext.Date.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);", "v = !strict? v : (strict === true && (z <= 364 || (Ext.Date.isLeapYear(v) && z <= 365))? Ext.Date.add(v, Ext.Date.DAY, z) : null);", "}else if(strict === true && !Ext.Date.isValid(y, m + 1, d, h, i, s, ms)){", "v = null;", "}else{", "v = Ext.Date.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);", "}", "}", "}", "if(v){", "if(zz != null){", "v = Ext.Date.add(v, Ext.Date.SECOND, -v.getTimezoneOffset() * 60 - zz);", "}else if(o){", "v = Ext.Date.add(v, Ext.Date.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));", "}", "}", "return v;"].join("\n");
            return function(q) {
                var g = a.parseRegexes.length,
                    r = 1,
                    j = [],
                    p = [],
                    n = false,
                    e = "",
                    l = 0,
                    m = q.length,
                    o = [],
                    k;
                for (; l < m; ++l) {
                    e = q.charAt(l);
                    if (!n && e == "\\") {
                        n = true
                    } else {
                        if (n) {
                            n = false;
                            p.push(Ext.String.escape(e))
                        } else {
                            k = a.formatCodeToRegex(e, r);
                            r += k.g;
                            p.push(k.s);
                            if (k.g && k.c) {
                                if (k.calcAtEnd) {
                                    o.push(k.c)
                                } else {
                                    j.push(k.c)
                                }
                            }
                        }
                    }
                }
                j = j.concat(o);
                a.parseRegexes[g] = new RegExp("^" + p.join("") + "$", "i");
                a.parseFunctions[q] = Ext.functionFactory("input", "strict", c(d, g, j.join("")))
            }
        }()),
        parseCodes: {
            d: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(3[0-1]|[1-2][0-9]|0[1-9])"
            },
            j: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(3[0-1]|[1-2][0-9]|[1-9])"
            },
            D: function() {
                for (var d = [], e = 0; e < 7; d.push(a.getShortDayName(e)), ++e) {}
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + d.join("|") + ")"
                }
            },
            l: function() {
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + a.dayNames.join("|") + ")"
                }
            },
            N: {
                g: 0,
                c: null,
                s: "[1-7]"
            },
            S: {
                g: 0,
                c: null,
                s: "(?:st|nd|rd|th)"
            },
            w: {
                g: 0,
                c: null,
                s: "[0-6]"
            },
            z: {
                g: 1,
                c: "z = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,3})"
            },
            W: {
                g: 0,
                c: null,
                s: "(?:\\d{2})"
            },
            F: function() {
                return {
                    g: 1,
                    c: "m = parseInt(Ext.Date.getMonthNumber(results[{0}]), 10);\n",
                    s: "(" + a.monthNames.join("|") + ")"
                }
            },
            M: function() {
                for (var d = [], e = 0; e < 12; d.push(a.getShortMonthName(e)), ++e) {}
                return Ext.applyIf({
                    s: "(" + d.join("|") + ")"
                }, a.formatCodeToRegex("F"))
            },
            m: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(1[0-2]|0[1-9])"
            },
            n: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(1[0-2]|[1-9])"
            },
            t: {
                g: 0,
                c: null,
                s: "(?:\\d{2})"
            },
            L: {
                g: 0,
                c: null,
                s: "(?:1|0)"
            },
            o: function() {
                return a.formatCodeToRegex("Y")
            },
            Y: {
                g: 1,
                c: "y = parseInt(results[{0}], 10);\n",
                s: "(\\d{4})"
            },
            y: {
                g: 1,
                c: "var ty = parseInt(results[{0}], 10);\ny = ty > Ext.Date.y2kYear ? 1900 + ty : 2000 + ty;\n",
                s: "(\\d{1,2})"
            },
            a: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\nif (!h || h == 12) { h = 0; }\n} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(am|pm|AM|PM)",
                calcAtEnd: true
            },
            A: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\nif (!h || h == 12) { h = 0; }\n} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(AM|PM|am|pm)",
                calcAtEnd: true
            },
            g: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(1[0-2]|[0-9])"
            },
            G: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(2[0-3]|1[0-9]|[0-9])"
            },
            h: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(1[0-2]|0[1-9])"
            },
            H: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(2[0-3]|[0-1][0-9])"
            },
            i: {
                g: 1,
                c: "i = parseInt(results[{0}], 10);\n",
                s: "([0-5][0-9])"
            },
            s: {
                g: 1,
                c: "s = parseInt(results[{0}], 10);\n",
                s: "([0-5][0-9])"
            },
            u: {
                g: 1,
                c: "ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n",
                s: "(\\d+)"
            },
            O: {
                g: 1,
                c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", "mn = o.substring(3,5) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"),
                s: "([+-]\\d{4})"
            },
            P: {
                g: 1,
                c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", "mn = o.substring(4,6) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"),
                s: "([+-]\\d{2}:\\d{2})"
            },
            T: {
                g: 0,
                c: null,
                s: "[A-Z]{1,4}"
            },
            Z: {
                g: 1,
                c: "zz = results[{0}] * 1;\nzz = (-43200 <= zz && zz <= 50400)? zz : null;\n",
                s: "([+-]?\\d{1,5})"
            },
            c: function() {
                var g = [],
                    d = [a.formatCodeToRegex("Y", 1), a.formatCodeToRegex("m", 2), a.formatCodeToRegex("d", 3), a.formatCodeToRegex("H", 4), a.formatCodeToRegex("i", 5), a.formatCodeToRegex("s", 6), {
                        c: "ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"
                    }, {
                        c: ["if(results[8]) {", "if(results[8] == 'Z'){", "zz = 0;", "}else if (results[8].indexOf(':') > -1){", a.formatCodeToRegex("P", 8).c, "}else{", a.formatCodeToRegex("O", 8).c, "}", "}"].join("\n")
                    }],
                    j, e;
                for (j = 0, e = d.length; j < e; ++j) {
                    g.push(d[j].c)
                }
                return {
                    g: 1,
                    c: g.join(""),
                    s: [d[0].s, "(?:", "-", d[1].s, "(?:", "-", d[2].s, "(?:", "(?:T| )?", d[3].s, ":", d[4].s, "(?::", d[5].s, ")?", "(?:(?:\\.|,)(\\d+))?", "(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", ")?", ")?", ")?"].join("")
                }
            },
            U: {
                g: 1,
                c: "u = parseInt(results[{0}], 10);\n",
                s: "(-?\\d+)"
            }
        },
        dateFormat: function(d, e) {
            return a.format(d, e)
        },
        isEqual: function(e, d) {
            if (e && d) {
                return (e.getTime() === d.getTime())
            }
            return !(e || d)
        },
        format: function(e, g) {
            var d = a.formatFunctions;
            if (!Ext.isDate(e)) {
                return ""
            }
            if (d[g] == null) {
                a.createFormat(g)
            }
            return d[g].call(e) + ""
        },
        getTimezone: function(d) {
            return d.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,4})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, "$1$2").replace(/[^A-Z]/g, "")
        },
        getGMTOffset: function(d, e) {
            var g = d.getTimezoneOffset();
            return (g > 0 ? "-" : "+") + Ext.String.leftPad(Math.floor(Math.abs(g) / 60), 2, "0") + (e ? ":" : "") + Ext.String.leftPad(Math.abs(g % 60), 2, "0")
        },
        getDayOfYear: function(j) {
            var g = 0,
                l = Ext.Date.clone(j),
                e = j.getMonth(),
                k;
            for (k = 0, l.setDate(1), l.setMonth(0); k < e; l.setMonth(++k)) {
                g += a.getDaysInMonth(l)
            }
            return g + j.getDate() - 1
        },
        getWeekOfYear: (function() {
            var d = 86400000,
                e = 7 * d;
            return function(i) {
                var j = Date.UTC(i.getFullYear(), i.getMonth(), i.getDate() + 3) / d,
                    g = Math.floor(j / 7),
                    k = new Date(g * e).getUTCFullYear();
                return g - Math.floor(Date.UTC(k, 0, 7) / e) + 1
            }
        }()),
        isLeapYear: function(d) {
            var e = d.getFullYear();
            return !!((e & 3) == 0 && (e % 100 || (e % 400 == 0 && e)))
        },
        getFirstDayOfMonth: function(e) {
            var d = (e.getDay() - (e.getDate() - 1)) % 7;
            return (d < 0) ? (d + 7) : d
        },
        getLastDayOfMonth: function(d) {
            return a.getLastDateOfMonth(d).getDay()
        },
        getFirstDateOfMonth: function(d) {
            return new Date(d.getFullYear(), d.getMonth(), 1)
        },
        getLastDateOfMonth: function(d) {
            return new Date(d.getFullYear(), d.getMonth(), a.getDaysInMonth(d))
        },
        getDaysInMonth: (function() {
            var d = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            return function(g) {
                var e = g.getMonth();
                return e == 1 && a.isLeapYear(g) ? 29 : d[e]
            }
        }()),
        getSuffix: function(d) {
            switch (d.getDate()) {
                case 1:
                case 21:
                case 31:
                    return "st";
                case 2:
                case 22:
                    return "nd";
                case 3:
                case 23:
                    return "rd";
                default:
                    return "th"
            }
        },
        clone: function(d) {
            return new Date(d.getTime())
        },
        isDST: function(d) {
            return new Date(d.getFullYear(), 0, 1).getTimezoneOffset() != d.getTimezoneOffset()
        },
        clearTime: function(e, k) {
            if (k) {
                return Ext.Date.clearTime(Ext.Date.clone(e))
            }
            var i = e.getDate(),
                g, j;
            e.setHours(0);
            e.setMinutes(0);
            e.setSeconds(0);
            e.setMilliseconds(0);
            if (e.getDate() != i) {
                for (g = 1, j = a.add(e, Ext.Date.HOUR, g); j.getDate() != i; g++, j = a.add(e, Ext.Date.HOUR, g)) {}
                e.setDate(i);
                e.setHours(j.getHours())
            }
            return e
        },
        add: function(j, i, k) {
            var l = Ext.Date.clone(j),
                e = Ext.Date,
                g;
            if (!i || k === 0) {
                return l
            }
            switch (i.toLowerCase()) {
                case Ext.Date.MILLI:
                    l.setMilliseconds(l.getMilliseconds() + k);
                    break;
                case Ext.Date.SECOND:
                    l.setSeconds(l.getSeconds() + k);
                    break;
                case Ext.Date.MINUTE:
                    l.setMinutes(l.getMinutes() + k);
                    break;
                case Ext.Date.HOUR:
                    l.setHours(l.getHours() + k);
                    break;
                case Ext.Date.DAY:
                    l.setDate(l.getDate() + k);
                    break;
                case Ext.Date.MONTH:
                    g = j.getDate();
                    if (g > 28) {
                        g = Math.min(g, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(j), Ext.Date.MONTH, k)).getDate())
                    }
                    l.setDate(g);
                    l.setMonth(j.getMonth() + k);
                    break;
                case Ext.Date.YEAR:
                    g = j.getDate();
                    if (g > 28) {
                        g = Math.min(g, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(j), Ext.Date.YEAR, k)).getDate())
                    }
                    l.setDate(g);
                    l.setFullYear(j.getFullYear() + k);
                    break
            }
            return l
        },
        between: function(e, i, d) {
            var g = e.getTime();
            return i.getTime() <= g && g <= d.getTime()
        },
        compat: function() {
            var e = window.Date,
                d, n, l = ["useStrict", "formatCodeToRegex", "parseFunctions", "parseRegexes", "formatFunctions", "y2kYear", "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "MONTH", "YEAR", "defaults", "dayNames", "monthNames", "monthNumbers", "getShortMonthName", "getShortDayName", "getMonthNumber", "formatCodes", "isValid", "parseDate", "getFormatCode", "createFormat", "createParser", "parseCodes"],
                j = ["dateFormat", "format", "getTimezone", "getGMTOffset", "getDayOfYear", "getWeekOfYear", "isLeapYear", "getFirstDayOfMonth", "getLastDayOfMonth", "getDaysInMonth", "getSuffix", "clone", "isDST", "clearTime", "add", "between"],
                k = l.length,
                g = j.length,
                i, m, o;
            for (o = 0; o < k; o++) {
                i = l[o];
                e[i] = a[i]
            }
            for (d = 0; d < g; d++) {
                m = j[d];
                e.prototype[m] = function() {
                    var p = Array.prototype.slice.call(arguments);
                    p.unshift(this);
                    return a[m].apply(a, p)
                }
            }
        }
    };
    var a = Ext.Date
}());
(function(a) {
    var d = [],
        c = function() {};
    Ext.apply(c, {
        $className: "Ext.Base",
        $isClass: true,
        create: function() {
            return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)))
        },
        extend: function(l) {
            var e = l.prototype,
                o, j, k, m, g, n;
            j = this.prototype = Ext.Object.chain(e);
            j.self = this;
            this.superclass = j.superclass = e;
            if (!l.$isClass) {
                o = Ext.Base.prototype;
                for (k in o) {
                    if (k in j) {
                        j[k] = o[k]
                    }
                }
            }
            n = e.$inheritableStatics;
            if (n) {
                for (k = 0, m = n.length; k < m; k++) {
                    g = n[k];
                    if (!this.hasOwnProperty(g)) {
                        this[g] = l[g]
                    }
                }
            }
            if (l.$onExtended) {
                this.$onExtended = l.$onExtended.slice()
            }
            j.config = new j.configClass();
            j.initConfigList = j.initConfigList.slice();
            j.initConfigMap = Ext.clone(j.initConfigMap);
            j.configMap = Ext.Object.chain(j.configMap)
        },
        $onExtended: [],
        triggerExtended: function() {
            var j = this.$onExtended,
                g = j.length,
                e, k;
            if (g > 0) {
                for (e = 0; e < g; e++) {
                    k = j[e];
                    k.fn.apply(k.scope || this, arguments)
                }
            }
        },
        onExtended: function(g, e) {
            this.$onExtended.push({
                fn: g,
                scope: e
            });
            return this
        },
        addConfig: function(j, n) {
            var p = this.prototype,
                o = Ext.Class.configNameCache,
                k = p.configMap,
                l = p.initConfigList,
                i = p.initConfigMap,
                m = p.config,
                e, g, q;
            for (g in j) {
                if (j.hasOwnProperty(g)) {
                    if (!k[g]) {
                        k[g] = true
                    }
                    q = j[g];
                    e = o[g].initialized;
                    if (!i[g] && q !== null && !p[e]) {
                        i[g] = true;
                        l.push(g)
                    }
                }
            }
            if (n) {
                Ext.merge(m, j)
            } else {
                Ext.mergeIf(m, j)
            }
            p.configClass = Ext.Object.classify(m)
        },
        addStatics: function(e) {
            var i, g;
            for (g in e) {
                if (e.hasOwnProperty(g)) {
                    i = e[g];
                    if (typeof i == "function" && !i.$isClass && i !== Ext.emptyFn && i !== Ext.identityFn) {
                        i.$owner = this;
                        i.$name = g
                    }
                    this[g] = i
                }
            }
            return this
        },
        addInheritableStatics: function(g) {
            var k, e, j = this.prototype,
                i, l;
            k = j.$inheritableStatics;
            e = j.$hasInheritableStatics;
            if (!k) {
                k = j.$inheritableStatics = [];
                e = j.$hasInheritableStatics = {}
            }
            for (i in g) {
                if (g.hasOwnProperty(i)) {
                    l = g[i];
                    this[i] = l;
                    if (!e[i]) {
                        e[i] = true;
                        k.push(i)
                    }
                }
            }
            return this
        },
        addMembers: function(g) {
            var k = this.prototype,
                e = Ext.enumerables,
                n = [],
                l, m, j, o;
            for (j in g) {
                n.push(j)
            }
            if (e) {
                n.push.apply(n, e)
            }
            for (l = 0, m = n.length; l < m; l++) {
                j = n[l];
                if (g.hasOwnProperty(j)) {
                    o = g[j];
                    if (typeof o == "function" && !o.$isClass && o !== Ext.emptyFn) {
                        o.$owner = this;
                        o.$name = j
                    }
                    k[j] = o
                }
            }
            return this
        },
        addMember: function(e, g) {
            if (typeof g == "function" && !g.$isClass && g !== Ext.emptyFn) {
                g.$owner = this;
                g.$name = e
            }
            this.prototype[e] = g;
            return this
        },
        implement: function() {
            this.addMembers.apply(this, arguments)
        },
        borrow: function(l, j) {
            var p = this.prototype,
                o = l.prototype,
                k, m, g, n, e;
            j = Ext.Array.from(j);
            for (k = 0, m = j.length; k < m; k++) {
                g = j[k];
                e = o[g];
                if (typeof e == "function") {
                    n = Ext.Function.clone(e);
                    n.$owner = this;
                    n.$name = g;
                    p[g] = n
                } else {
                    p[g] = e
                }
            }
            return this
        },
        override: function(g) {
            var o = this,
                q = Ext.enumerables,
                m = o.prototype,
                j = Ext.Function.clone,
                e, l, i, p, n, k;
            if (arguments.length === 2) {
                e = g;
                g = {};
                g[e] = arguments[1];
                q = null
            }
            do {
                n = [];
                p = null;
                for (e in g) {
                    if (e == "statics") {
                        p = g[e]
                    } else {
                        if (e == "config") {
                            o.addConfig(g[e], true)
                        } else {
                            n.push(e)
                        }
                    }
                }
                if (q) {
                    n.push.apply(n, q)
                }
                for (l = n.length; l--;) {
                    e = n[l];
                    if (g.hasOwnProperty(e)) {
                        i = g[e];
                        if (typeof i == "function" && !i.$className && i !== Ext.emptyFn) {
                            if (typeof i.$owner != "undefined") {
                                i = j(i)
                            }
                            i.$owner = o;
                            i.$name = e;
                            k = m[e];
                            if (k) {
                                i.$previous = k
                            }
                        }
                        m[e] = i
                    }
                }
                m = o;
                g = p
            } while (g);
            return this
        },
        callParent: function(e) {
            var g;
            return (g = this.callParent.caller) && (g.$previous || ((g = g.$owner ? g : g.caller) && g.$owner.superclass.self[g.$name])).apply(this, e || d)
        },
        callSuper: function(e) {
            var g;
            return (g = this.callSuper.caller) && ((g = g.$owner ? g : g.caller) && g.$owner.superclass.self[g.$name]).apply(this, e || d)
        },
        mixin: function(i, k) {
            var e = k.prototype,
                g = this.prototype,
                j;
            if (typeof e.onClassMixedIn != "undefined") {
                e.onClassMixedIn.call(k, this)
            }
            if (!g.hasOwnProperty("mixins")) {
                if ("mixins" in g) {
                    g.mixins = Ext.Object.chain(g.mixins)
                } else {
                    g.mixins = {}
                }
            }
            for (j in e) {
                if (j === "mixins") {
                    Ext.merge(g.mixins, e[j])
                } else {
                    if (typeof g[j] == "undefined" && j != "mixinId" && j != "config") {
                        g[j] = e[j]
                    }
                }
            }
            if ("config" in e) {
                this.addConfig(e.config, false)
            }
            g.mixins[i] = e
        },
        getName: function() {
            return Ext.getClassName(this)
        },
        createAlias: a(function(g, e) {
            this.override(g, function() {
                return this[e].apply(this, arguments)
            })
        }),
        addXtype: function(k) {
            var g = this.prototype,
                j = g.xtypesMap,
                i = g.xtypes,
                e = g.xtypesChain;
            if (!g.hasOwnProperty("xtypesMap")) {
                j = g.xtypesMap = Ext.merge({}, g.xtypesMap || {});
                i = g.xtypes = g.xtypes ? [].concat(g.xtypes) : [];
                e = g.xtypesChain = g.xtypesChain ? [].concat(g.xtypesChain) : [];
                g.xtype = k
            }
            if (!j[k]) {
                j[k] = true;
                i.push(k);
                e.push(k);
                Ext.ClassManager.setAlias(this, "widget." + k)
            }
            return this
        }
    });
    c.implement({
        isInstance: true,
        $className: "Ext.Base",
        configClass: Ext.emptyFn,
        initConfigList: [],
        configMap: {},
        initConfigMap: {},
        statics: function() {
            var g = this.statics.caller,
                e = this.self;
            if (!g) {
                return e
            }
            return g.$owner
        },
        callParent: function(g) {
            var i, e = (i = this.callParent.caller) && (i.$previous || ((i = i.$owner ? i : i.caller) && i.$owner.superclass[i.$name]));
            return e.apply(this, g || d)
        },
        callSuper: function(g) {
            var i, e = (i = this.callSuper.caller) && ((i = i.$owner ? i : i.caller) && i.$owner.superclass[i.$name]);
            return e.apply(this, g || d)
        },
        self: c,
        constructor: function() {
            return this
        },
        initConfig: function(j) {
            var o = j,
                n = Ext.Class.configNameCache,
                l = new this.configClass(),
                r = this.initConfigList,
                k = this.configMap,
                q, m, p, g, e;
            this.initConfig = Ext.emptyFn;
            this.initialConfig = o || {};
            this.config = j = (o) ? Ext.merge(l, j) : l;
            if (o) {
                r = r.slice();
                for (g in o) {
                    if (k[g]) {
                        if (o[g] !== null) {
                            r.push(g);
                            this[n[g].initialized] = false
                        }
                    }
                }
            }
            for (m = 0, p = r.length; m < p; m++) {
                g = r[m];
                q = n[g];
                e = q.initialized;
                if (!this[e]) {
                    this[e] = true;
                    this[q.set].call(this, j[g])
                }
            }
            return this
        },
        hasConfig: function(e) {
            return Boolean(this.configMap[e])
        },
        setConfig: function(j, n) {
            if (!j) {
                return this
            }
            var i = Ext.Class.configNameCache,
                e = this.config,
                m = this.configMap,
                l = this.initialConfig,
                g, k;
            n = Boolean(n);
            for (g in j) {
                if (n && l.hasOwnProperty(g)) {
                    continue
                }
                k = j[g];
                e[g] = k;
                if (m[g]) {
                    this[i[g].set](k)
                }
            }
            return this
        },
        getConfig: function(g) {
            var e = Ext.Class.configNameCache;
            return this[e[g].get]()
        },
        getInitialConfig: function(g) {
            var e = this.config;
            if (!g) {
                return e
            } else {
                return e[g]
            }
        },
        onConfigUpdate: function(m, o, p) {
            var q = this.self,
                j, l, e, k, n, g;
            m = Ext.Array.from(m);
            p = p || this;
            for (j = 0, l = m.length; j < l; j++) {
                e = m[j];
                k = "update" + Ext.String.capitalize(e);
                n = this[k] || Ext.emptyFn;
                g = function() {
                    n.apply(this, arguments);
                    p[o].apply(p, arguments)
                };
                g.$name = k;
                g.$owner = q;
                this[k] = g
            }
        },
        destroy: function() {
            this.destroy = Ext.emptyFn
        }
    });
    c.prototype.callOverridden = c.prototype.callParent;
    Ext.Base = c
}(Ext.Function.flexSetter));
(function() {
    var d, c = Ext.Base,
        i = [],
        g, e;
    for (g in c) {
        if (c.hasOwnProperty(g)) {
            i.push(g)
        }
    }
    e = i.length;

    function a(k) {
        function j() {
            return this.constructor.apply(this, arguments) || null
        }
        return j
    }
    Ext.Class = d = function(k, l, j) {
        if (typeof k != "function") {
            j = l;
            l = k;
            k = null
        }
        if (!l) {
            l = {}
        }
        k = d.create(k, l);
        d.process(k, l, j);
        return k
    };
    Ext.apply(d, {
        onBeforeCreated: function(k, l, j) {
            k.addMembers(l);
            j.onCreated.call(k, k)
        },
        create: function(j, m) {
            var k, l;
            if (!j) {
                j = a()
            }
            for (l = 0; l < e; l++) {
                k = i[l];
                j[k] = c[k]
            }
            return j
        },
        process: function(k, r, n) {
            var m = r.preprocessors || d.defaultPreprocessors,
                u = this.preprocessors,
                y = {
                    onBeforeCreated: this.onBeforeCreated
                },
                x = [],
                z, q, p, v, o, t, s, l;
            delete r.preprocessors;
            for (p = 0, v = m.length; p < v; p++) {
                z = m[p];
                if (typeof z == "string") {
                    z = u[z];
                    q = z.properties;
                    if (q === true) {
                        x.push(z.fn)
                    } else {
                        if (q) {
                            for (o = 0, t = q.length; o < t; o++) {
                                s = q[o];
                                if (r.hasOwnProperty(s)) {
                                    x.push(z.fn);
                                    break
                                }
                            }
                        }
                    }
                } else {
                    x.push(z)
                }
            }
            y.onCreated = n ? n : Ext.emptyFn;
            y.preprocessors = x;
            this.doProcess(k, r, y)
        },
        doProcess: function(k, n, j) {
            var m = this,
                l = j.preprocessors.shift();
            if (!l) {
                j.onBeforeCreated.apply(m, arguments);
                return
            }
            if (l.call(m, k, n, j, m.doProcess) !== false) {
                m.doProcess(k, n, j)
            }
        },
        preprocessors: {},
        registerPreprocessor: function(k, n, l, j, m) {
            if (!j) {
                j = "last"
            }
            if (!l) {
                l = [k]
            }
            this.preprocessors[k] = {
                name: k,
                properties: l || false,
                fn: n
            };
            this.setDefaultPreprocessorPosition(k, j, m);
            return this
        },
        getPreprocessor: function(j) {
            return this.preprocessors[j]
        },
        getPreprocessors: function() {
            return this.preprocessors
        },
        defaultPreprocessors: [],
        getDefaultPreprocessors: function() {
            return this.defaultPreprocessors
        },
        setDefaultPreprocessors: function(j) {
            this.defaultPreprocessors = Ext.Array.from(j);
            return this
        },
        setDefaultPreprocessorPosition: function(l, n, m) {
            var j = this.defaultPreprocessors,
                k;
            if (typeof n == "string") {
                if (n === "first") {
                    j.unshift(l);
                    return this
                } else {
                    if (n === "last") {
                        j.push(l);
                        return this
                    }
                }
                n = (n === "after") ? 1 : -1
            }
            k = Ext.Array.indexOf(j, m);
            if (k !== -1) {
                Ext.Array.splice(j, Math.max(0, k + n), 0, l)
            }
            return this
        },
        configNameCache: {},
        getConfigNameMap: function(l) {
            var k = this.configNameCache,
                m = k[l],
                j;
            if (!m) {
                j = l.charAt(0).toUpperCase() + l.substr(1);
                m = k[l] = {
                    internal: l,
                    initialized: "_is" + j + "Initialized",
                    apply: "apply" + j,
                    update: "update" + j,
                    set: "set" + j,
                    get: "get" + j,
                    doSet: "doSet" + j,
                    changeEvent: l.toLowerCase() + "change"
                }
            }
            return m
        }
    });
    d.registerPreprocessor("extend", function(k, o) {
        var n = Ext.Base,
            p = n.prototype,
            q = o.extend,
            m, j, l;
        delete o.extend;
        if (q && q !== Object) {
            m = q
        } else {
            m = n
        }
        j = m.prototype;
        if (!m.$isClass) {
            for (l in p) {
                if (!j[l]) {
                    j[l] = p[l]
                }
            }
        }
        k.extend(m);
        k.triggerExtended.apply(k, arguments);
        if (o.onClassExtended) {
            k.onExtended(o.onClassExtended, k);
            delete o.onClassExtended
        }
    }, true);
    d.registerPreprocessor("statics", function(j, k) {
        j.addStatics(k.statics);
        delete k.statics
    });
    d.registerPreprocessor("inheritableStatics", function(j, k) {
        j.addInheritableStatics(k.inheritableStatics);
        delete k.inheritableStatics
    });
    d.registerPreprocessor("config", function(j, m) {
        var l = m.config,
            k = j.prototype;
        delete m.config;
        Ext.Object.each(l, function(p, z) {
            var x = d.getConfigNameMap(p),
                s = x.internal,
                n = x.initialized,
                y = x.apply,
                q = x.update,
                v = x.set,
                o = x.get,
                B = (v in k) || m.hasOwnProperty(v),
                r = (y in k) || m.hasOwnProperty(y),
                t = (q in k) || m.hasOwnProperty(q),
                A, u;
            if (z === null || (!B && !r && !t)) {
                k[s] = z;
                k[n] = true
            } else {
                k[n] = false
            }
            if (!B) {
                m[v] = function(E) {
                    var D = this[s],
                        C = this[y],
                        F = this[q];
                    if (!this[n]) {
                        this[n] = true
                    }
                    if (C) {
                        E = C.call(this, E, D)
                    }
                    if (typeof E != "undefined") {
                        this[s] = E;
                        if (F && E !== D) {
                            F.call(this, E, D)
                        }
                    }
                    return this
                }
            }
            if (!(o in k) || m.hasOwnProperty(o)) {
                u = m[o] || false;
                if (u) {
                    A = function() {
                        return u.apply(this, arguments)
                    }
                } else {
                    A = function() {
                        return this[s]
                    }
                }
                m[o] = function() {
                    var C;
                    if (!this[n]) {
                        this[n] = true;
                        this[v](this.config[p])
                    }
                    C = this[o];
                    if ("$previous" in C) {
                        C.$previous = A
                    } else {
                        this[o] = A
                    }
                    return A.apply(this, arguments)
                }
            }
        });
        j.addConfig(l, true)
    });
    d.registerPreprocessor("mixins", function(m, q, j) {
        var k = q.mixins,
            n, l, o, p;
        delete q.mixins;
        Ext.Function.interceptBefore(j, "onCreated", function() {
            if (k instanceof Array) {
                for (o = 0, p = k.length; o < p; o++) {
                    l = k[o];
                    n = l.prototype.mixinId || l.$className;
                    m.mixin(n, l)
                }
            } else {
                for (var r in k) {
                    if (k.hasOwnProperty(r)) {
                        m.mixin(r, k[r])
                    }
                }
            }
        })
    });
    Ext.extend = function(l, m, k) {
        if (arguments.length === 2 && Ext.isObject(m)) {
            k = m;
            m = l;
            l = null
        }
        var j;
        if (!m) {
            throw new Error("[Ext.extend] Attempting to extend from a class which has not been loaded on the page.")
        }
        k.extend = m;
        k.preprocessors = ["extend", "statics", "inheritableStatics", "mixins", "config"];
        if (l) {
            j = new d(l, k);
            j.prototype.constructor = l
        } else {
            j = new d(k)
        }
        j.prototype.override = function(p) {
            for (var n in p) {
                if (p.hasOwnProperty(n)) {
                    this[n] = p[n]
                }
            }
        };
        return j
    }
}());
(function(d, g, j, e, i) {
    function a() {
        function k() {
            return this.constructor.apply(this, arguments) || null
        }
        return k
    }
    var c = Ext.ClassManager = {
        classes: {},
        existCache: {},
        namespaceRewrites: [{
            from: "Ext.",
            to: Ext
        }],
        maps: {
            alternateToName: {},
            aliasToName: {},
            nameToAliases: {},
            nameToAlternates: {}
        },
        enableNamespaceParseCache: true,
        namespaceParseCache: {},
        instantiators: [],
        isCreated: function(o) {
            var n = this.existCache,
                m, p, l, k, q;
            if (this.classes[o] || n[o]) {
                return true
            }
            k = i;
            q = this.parseNamespace(o);
            for (m = 0, p = q.length; m < p; m++) {
                l = q[m];
                if (typeof l != "string") {
                    k = l
                } else {
                    if (!k || !k[l]) {
                        return false
                    }
                    k = k[l]
                }
            }
            n[o] = true;
            this.triggerCreated(o);
            return true
        },
        createdListeners: [],
        nameCreatedListeners: {},
        triggerCreated: function(s) {
            var u = this.createdListeners,
                m = this.nameCreatedListeners,
                n = this.maps.nameToAlternates[s],
                t = [s],
                p, r, o, q, l, k;
            for (p = 0, r = u.length; p < r; p++) {
                l = u[p];
                l.fn.call(l.scope, s)
            }
            if (n) {
                t.push.apply(t, n)
            }
            for (p = 0, r = t.length; p < r; p++) {
                k = t[p];
                u = m[k];
                if (u) {
                    for (o = 0, q = u.length; o < q; o++) {
                        l = u[o];
                        l.fn.call(l.scope, k)
                    }
                    delete m[k]
                }
            }
        },
        onCreated: function(o, n, m) {
            var l = this.createdListeners,
                k = this.nameCreatedListeners,
                p = {
                    fn: o,
                    scope: n
                };
            if (m) {
                if (this.isCreated(m)) {
                    o.call(n, m);
                    return
                }
                if (!k[m]) {
                    k[m] = []
                }
                k[m].push(p)
            } else {
                l.push(p)
            }
        },
        parseNamespace: function(m) {
            var k = this.namespaceParseCache,
                n, p, r, l, u, t, s, o, q;
            if (this.enableNamespaceParseCache) {
                if (k.hasOwnProperty(m)) {
                    return k[m]
                }
            }
            n = [];
            p = this.namespaceRewrites;
            r = i;
            l = m;
            for (o = 0, q = p.length; o < q; o++) {
                u = p[o];
                t = u.from;
                s = u.to;
                if (l === t || l.substring(0, t.length) === t) {
                    l = l.substring(t.length);
                    if (typeof s != "string") {
                        r = s
                    } else {
                        n = n.concat(s.split("."))
                    }
                    break
                }
            }
            n.push(r);
            n = n.concat(l.split("."));
            if (this.enableNamespaceParseCache) {
                k[m] = n
            }
            return n
        },
        setNamespace: function(n, q) {
            var l = i,
                r = this.parseNamespace(n),
                p = r.length - 1,
                k = r[p],
                o, m;
            for (o = 0; o < p; o++) {
                m = r[o];
                if (typeof m != "string") {
                    l = m
                } else {
                    if (!l[m]) {
                        l[m] = {}
                    }
                    l = l[m]
                }
            }
            l[k] = q;
            return l[k]
        },
        createNamespaces: function() {
            var k = i,
                p, m, n, l, o, q;
            for (n = 0, o = arguments.length; n < o; n++) {
                p = this.parseNamespace(arguments[n]);
                for (l = 0, q = p.length; l < q; l++) {
                    m = p[l];
                    if (typeof m != "string") {
                        k = m
                    } else {
                        if (!k[m]) {
                            k[m] = {}
                        }
                        k = k[m]
                    }
                }
            }
            return k
        },
        set: function(k, o) {
            var n = this,
                q = n.maps,
                p = q.nameToAlternates,
                m = n.getName(o),
                l;
            n.classes[k] = n.setNamespace(k, o);
            if (m && m !== k) {
                q.alternateToName[k] = m;
                l = p[m] || (p[m] = []);
                l.push(k)
            }
            return this
        },
        get: function(m) {
            var o = this.classes,
                k, q, l, n, p;
            if (o[m]) {
                return o[m]
            }
            k = i;
            q = this.parseNamespace(m);
            for (n = 0, p = q.length; n < p; n++) {
                l = q[n];
                if (typeof l != "string") {
                    k = l
                } else {
                    if (!k || !k[l]) {
                        return null
                    }
                    k = k[l]
                }
            }
            return k
        },
        setAlias: function(k, l) {
            var n = this.maps.aliasToName,
                o = this.maps.nameToAliases,
                m;
            if (typeof k == "string") {
                m = k
            } else {
                m = this.getName(k)
            }
            if (l && n[l] !== m) {
                n[l] = m
            }
            if (!o[m]) {
                o[m] = []
            }
            if (l) {
                Ext.Array.include(o[m], l)
            }
            return this
        },
        addNameAliasMappings: function(k) {
            var p = this.maps.aliasToName,
                q = this.maps.nameToAliases,
                n, o, m, l;
            for (n in k) {
                o = q[n] || (q[n] = []);
                for (l = 0; l < k[n].length; l++) {
                    m = k[n][l];
                    if (!p[m]) {
                        p[m] = n;
                        o.push(m)
                    }
                }
            }
            return this
        },
        addNameAlternateMappings: function(n) {
            var k = this.maps.alternateToName,
                q = this.maps.nameToAlternates,
                m, o, p, l;
            for (m in n) {
                o = q[m] || (q[m] = []);
                for (l = 0; l < n[m].length; l++) {
                    p = n[m];
                    if (!k[p]) {
                        k[p] = m;
                        o.push(p)
                    }
                }
            }
            return this
        },
        getByAlias: function(k) {
            return this.get(this.getNameByAlias(k))
        },
        getNameByAlias: function(k) {
            return this.maps.aliasToName[k] || ""
        },
        getNameByAlternate: function(k) {
            return this.maps.alternateToName[k] || ""
        },
        getAliasesByName: function(k) {
            return this.maps.nameToAliases[k] || []
        },
        getName: function(k) {
            return k && k.$className || ""
        },
        getClass: function(k) {
            return k && k.self || null
        },
        create: function(l, n, k) {
            var m = a();
            if (typeof n == "function") {
                n = n(m)
            }
            n.$className = l;
            return new d(m, n, function() {
                var o = n.postprocessors || c.defaultPostprocessors,
                    v = c.postprocessors,
                    x = [],
                    u, q, t, p, s, r, y;
                delete n.postprocessors;
                for (q = 0, t = o.length; q < t; q++) {
                    u = o[q];
                    if (typeof u == "string") {
                        u = v[u];
                        r = u.properties;
                        if (r === true) {
                            x.push(u.fn)
                        } else {
                            if (r) {
                                for (p = 0, s = r.length; p < s; p++) {
                                    y = r[p];
                                    if (n.hasOwnProperty(y)) {
                                        x.push(u.fn);
                                        break
                                    }
                                }
                            }
                        }
                    } else {
                        x.push(u)
                    }
                }
                n.postprocessors = x;
                n.createdFn = k;
                c.processCreate(l, this, n)
            })
        },
        processCreate: function(n, l, p) {
            var o = this,
                k = p.postprocessors.shift(),
                m = p.createdFn;
            if (!k) {
                if (n) {
                    o.set(n, l)
                }
                if (m) {
                    m.call(l, l)
                }
                if (n) {
                    o.triggerCreated(n)
                }
                return
            }
            if (k.call(o, n, l, p, o.processCreate) !== false) {
                o.processCreate(n, l, p)
            }
        },
        createOverride: function(n, r, l) {
            var q = this,
                p = r.override,
                m = r.requires,
                k = r.uses,
                o = function() {
                    var s, t;
                    if (m) {
                        t = m;
                        m = null;
                        Ext.Loader.require(t, o)
                    } else {
                        s = q.get(p);
                        delete r.override;
                        delete r.requires;
                        delete r.uses;
                        Ext.override(s, r);
                        q.triggerCreated(n);
                        if (k) {
                            Ext.Loader.addUsedClasses(k)
                        }
                        if (l) {
                            l.call(s)
                        }
                    }
                };
            q.existCache[n] = true;
            q.onCreated(o, q, p);
            return q
        },
        instantiateByAlias: function() {
            var l = arguments[0],
                k = j.call(arguments),
                m = this.getNameByAlias(l);
            if (!m) {
                m = this.maps.aliasToName[l];
                Ext.syncRequire(m)
            }
            k[0] = m;
            return this.instantiate.apply(this, k)
        },
        instantiate: function() {
            var m = arguments[0],
                o = typeof m,
                l = j.call(arguments, 1),
                n = m,
                p, k;
            if (o != "function") {
                if (o != "string" && l.length === 0) {
                    l = [m];
                    m = m.xclass
                }
                k = this.get(m)
            } else {
                k = m
            }
            if (!k) {
                p = this.getNameByAlias(m);
                if (p) {
                    m = p;
                    k = this.get(m)
                }
            }
            if (!k) {
                p = this.getNameByAlternate(m);
                if (p) {
                    m = p;
                    k = this.get(m)
                }
            }
            if (!k) {
                Ext.syncRequire(m);
                k = this.get(m)
            }
            return this.getInstantiator(l.length)(k, l)
        },
        dynInstantiate: function(l, k) {
            k = e(k, true);
            k.unshift(l);
            return this.instantiate.apply(this, k)
        },
        getInstantiator: function(n) {
            var m = this.instantiators,
                o, l, k;
            o = m[n];
            if (!o) {
                l = n;
                k = [];
                for (l = 0; l < n; l++) {
                    k.push("a[" + l + "]")
                }
                o = m[n] = new Function("c", "a", "return new c(" + k.join(",") + ")")
            }
            return o
        },
        postprocessors: {},
        defaultPostprocessors: [],
        registerPostprocessor: function(l, o, m, k, n) {
            if (!k) {
                k = "last"
            }
            if (!m) {
                m = [l]
            }
            this.postprocessors[l] = {
                name: l,
                properties: m || false,
                fn: o
            };
            this.setDefaultPostprocessorPosition(l, k, n);
            return this
        },
        setDefaultPostprocessors: function(k) {
            this.defaultPostprocessors = e(k);
            return this
        },
        setDefaultPostprocessorPosition: function(l, o, n) {
            var m = this.defaultPostprocessors,
                k;
            if (typeof o == "string") {
                if (o === "first") {
                    m.unshift(l);
                    return this
                } else {
                    if (o === "last") {
                        m.push(l);
                        return this
                    }
                }
                o = (o === "after") ? 1 : -1
            }
            k = Ext.Array.indexOf(m, n);
            if (k !== -1) {
                Ext.Array.splice(m, Math.max(0, k + o), 0, l)
            }
            return this
        },
        getNamesByExpression: function(r) {
            var p = this.maps.nameToAliases,
                s = [],
                k, o, m, l, t, n, q;
            if (r.indexOf("*") !== -1) {
                r = r.replace(/\*/g, "(.*?)");
                t = new RegExp("^" + r + "$");
                for (k in p) {
                    if (p.hasOwnProperty(k)) {
                        m = p[k];
                        if (k.search(t) !== -1) {
                            s.push(k)
                        } else {
                            for (n = 0, q = m.length; n < q; n++) {
                                o = m[n];
                                if (o.search(t) !== -1) {
                                    s.push(k);
                                    break
                                }
                            }
                        }
                    }
                }
            } else {
                l = this.getNameByAlias(r);
                if (l) {
                    s.push(l)
                } else {
                    l = this.getNameByAlternate(r);
                    if (l) {
                        s.push(l)
                    } else {
                        s.push(r)
                    }
                }
            }
            return s
        }
    };
    c.registerPostprocessor("alias", function(m, l, p) {
        var k = p.alias,
            n, o;
        for (n = 0, o = k.length; n < o; n++) {
            g = k[n];
            this.setAlias(l, g)
        }
    }, ["xtype", "alias"]);
    c.registerPostprocessor("singleton", function(l, k, n, m) {
        m.call(this, l, new k(), n);
        return false
    });
    c.registerPostprocessor("alternateClassName", function(l, k, p) {
        var n = p.alternateClassName,
            m, o, q;
        if (!(n instanceof Array)) {
            n = [n]
        }
        for (m = 0, o = n.length; m < o; m++) {
            q = n[m];
            this.set(q, k)
        }
    });
    Ext.apply(Ext, {
        create: g(c, "instantiate"),
        widget: function(m, l) {
            var q = m,
                n, o, k, p;
            if (typeof q != "string") {
                l = m;
                q = l.xtype
            } else {
                l = l || {}
            }
            if (l.isComponent) {
                return l
            }
            n = "widget." + q;
            o = c.getNameByAlias(n);
            if (!o) {
                p = true
            }
            k = c.get(o);
            if (p || !k) {
                return c.instantiateByAlias(n, l)
            }
            return new k(l)
        },
        createByAlias: g(c, "instantiateByAlias"),
        define: function(l, m, k) {
            if (m.override) {
                return c.createOverride.apply(c, arguments)
            }
            return c.create.apply(c, arguments)
        },
        getClassName: g(c, "getName"),
        getDisplayName: function(k) {
            if (k) {
                if (k.displayName) {
                    return k.displayName
                }
                if (k.$name && k.$class) {
                    return Ext.getClassName(k.$class) + "#" + k.$name
                }
                if (k.$className) {
                    return k.$className
                }
            }
            return "Anonymous"
        },
        getClass: g(c, "getClass"),
        namespace: g(c, "createNamespaces")
    });
    Ext.createWidget = Ext.widget;
    Ext.ns = Ext.namespace;
    d.registerPreprocessor("className", function(k, l) {
        if (l.$className) {
            k.$className = l.$className
        }
    }, true, "first");
    d.registerPreprocessor("alias", function(v, p) {
        var t = v.prototype,
            m = e(p.xtype),
            k = e(p.alias),
            x = "widget.",
            u = x.length,
            q = Array.prototype.slice.call(t.xtypesChain || []),
            n = Ext.merge({}, t.xtypesMap || {}),
            o, s, r, l;
        for (o = 0, s = k.length; o < s; o++) {
            r = k[o];
            if (r.substring(0, u) === x) {
                l = r.substring(u);
                Ext.Array.include(m, l)
            }
        }
        v.xtype = p.xtype = m[0];
        p.xtypes = m;
        for (o = 0, s = m.length; o < s; o++) {
            l = m[o];
            if (!n[l]) {
                n[l] = true;
                q.push(l)
            }
        }
        p.xtypesChain = q;
        p.xtypesMap = n;
        Ext.Function.interceptAfter(p, "onClassCreated", function() {
            var y = t.mixins,
                A, z;
            for (A in y) {
                if (y.hasOwnProperty(A)) {
                    z = y[A];
                    m = z.xtypes;
                    if (m) {
                        for (o = 0, s = m.length; o < s; o++) {
                            l = m[o];
                            if (!n[l]) {
                                n[l] = true;
                                q.push(l)
                            }
                        }
                    }
                }
            }
        });
        for (o = 0, s = m.length; o < s; o++) {
            l = m[o];
            Ext.Array.include(k, x + l)
        }
        p.alias = k
    }, ["xtype", "alias"])
}(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global));
Ext.Loader = new function() {
    var l = this,
        c = Ext.ClassManager,
        t = Ext.Class,
        g = Ext.Function.flexSetter,
        o = Ext.Function.alias,
        a = Ext.Function.pass,
        e = Ext.Function.defer,
        j = Ext.Array.erase,
        n = ["extend", "mixins", "requires"],
        v = {},
        m = [],
        d = /\/\.\//g,
        i = /\./g;
    Ext.apply(l, {
        isInHistory: v,
        history: m,
        config: {
            enabled: false,
            scriptChainDelay: false,
            disableCaching: true,
            disableCachingParam: "_dc",
            garbageCollect: false,
            paths: {
                Ext: "."
            },
            preserveScripts: true,
            scriptCharset: undefined
        },
        setConfig: function(z, A) {
            if (Ext.isObject(z) && arguments.length === 1) {
                Ext.merge(l.config, z)
            } else {
                l.config[z] = (Ext.isObject(A)) ? Ext.merge(l.config[z], A) : A
            }
            return l
        },
        getConfig: function(z) {
            if (z) {
                return l.config[z]
            }
            return l.config
        },
        setPath: g(function(z, A) {
            l.config.paths[z] = A;
            return l
        }),
        addClassPathMappings: function(A) {
            var z;
            for (z in A) {
                l.config.paths[z] = A[z]
            }
            return l
        },
        getPath: function(z) {
            var B = "",
                C = l.config.paths,
                A = l.getPrefix(z);
            if (A.length > 0) {
                if (A === z) {
                    return C[A]
                }
                B = C[A];
                z = z.substring(A.length + 1)
            }
            if (B.length > 0) {
                B += "/"
            }
            return B.replace(d, "/") + z.replace(i, "/") + ".js"
        },
        getPrefix: function(A) {
            var C = l.config.paths,
                B, z = "";
            if (C.hasOwnProperty(A)) {
                return A
            }
            for (B in C) {
                if (C.hasOwnProperty(B) && B + "." === A.substring(0, B.length + 1)) {
                    if (B.length > z.length) {
                        z = B
                    }
                }
            }
            return z
        },
        isAClassNameWithAKnownPrefix: function(z) {
            var A = l.getPrefix(z);
            return A !== "" && A !== z
        },
        require: function(B, A, z, C) {
            if (A) {
                A.call(z)
            }
        },
        syncRequire: function() {},
        exclude: function(z) {
            return {
                require: function(C, B, A) {
                    return l.require(C, B, A, z)
                },
                syncRequire: function(C, B, A) {
                    return l.syncRequire(C, B, A, z)
                }
            }
        },
        onReady: function(C, B, D, z) {
            var A;
            if (D !== false && Ext.onDocumentReady) {
                A = C;
                C = function() {
                    Ext.onDocumentReady(A, B, z)
                }
            }
            C.call(B)
        }
    });
    var q = [],
        r = {},
        u = {},
        s = {},
        p = {},
        x = [],
        y = [],
        k = {};
    Ext.apply(l, {
        documentHead: typeof document != "undefined" && (document.head || document.getElementsByTagName("head")[0]),
        isLoading: false,
        queue: q,
        isClassFileLoaded: r,
        isFileLoaded: u,
        readyListeners: x,
        optionalRequires: y,
        requiresMap: k,
        numPendingFiles: 0,
        numLoadedFiles: 0,
        hasFileLoadError: false,
        classNameToFilePathMap: s,
        scriptsLoading: 0,
        syncModeEnabled: false,
        scriptElements: p,
        refreshQueue: function() {
            var D = q.length,
                A, C, z, B;
            if (!D && !l.scriptsLoading) {
                return l.triggerReady()
            }
            for (A = 0; A < D; A++) {
                C = q[A];
                if (C) {
                    B = C.requires;
                    if (B.length > l.numLoadedFiles) {
                        continue
                    }
                    for (z = 0; z < B.length;) {
                        if (c.isCreated(B[z])) {
                            j(B, z, 1)
                        } else {
                            z++
                        }
                    }
                    if (C.requires.length === 0) {
                        j(q, A, 1);
                        C.callback.call(C.scope);
                        l.refreshQueue();
                        break
                    }
                }
            }
            return l
        },
        injectScriptElement: function(z, G, D, I, B) {
            var H = document.createElement("script"),
                E = false,
                A = l.config,
                F = function() {
                    if (!E) {
                        E = true;
                        H.onload = H.onreadystatechange = H.onerror = null;
                        if (typeof A.scriptChainDelay == "number") {
                            e(G, A.scriptChainDelay, I)
                        } else {
                            G.call(I)
                        }
                        l.cleanupScriptElement(H, A.preserveScripts === false, A.garbageCollect)
                    }
                },
                C = function(J) {
                    e(D, 1, I);
                    l.cleanupScriptElement(H, A.preserveScripts === false, A.garbageCollect)
                };
            H.type = "text/javascript";
            H.onerror = C;
            B = B || A.scriptCharset;
            if (B) {
                H.charset = B
            }
            if ("addEventListener" in H) {
                H.onload = F
            } else {
                if ("readyState" in H) {
                    H.onreadystatechange = function() {
                        if (this.readyState == "loaded" || this.readyState == "complete") {
                            F()
                        }
                    }
                } else {
                    H.onload = F
                }
            }
            H.src = z;
            (l.documentHead || document.getElementsByTagName("head")[0]).appendChild(H);
            return H
        },
        removeScriptElement: function(z) {
            if (p[z]) {
                l.cleanupScriptElement(p[z], true, !!l.getConfig("garbageCollect"));
                delete p[z]
            }
            return l
        },
        cleanupScriptElement: function(B, A, C) {
            var D;
            B.onload = B.onreadystatechange = B.onerror = null;
            if (A) {
                Ext.removeNode(B);
                if (C) {
                    for (D in B) {
                        try {
                            B[D] = null;
                            delete B[D]
                        } catch (z) {}
                    }
                }
            }
            return l
        },
        loadScript: function(I) {
            var C = l.getConfig(),
                B = typeof I == "string",
                A = B ? I : I.url,
                E = !B && I.onError,
                F = !B && I.onLoad,
                H = !B && I.scope,
                G = function() {
                    l.numPendingFiles--;
                    l.scriptsLoading--;
                    if (E) {
                        E.call(H, "Failed loading '" + A + "', please verify that the file exists")
                    }
                    if (l.numPendingFiles + l.scriptsLoading === 0) {
                        l.refreshQueue()
                    }
                },
                D = function() {
                    l.numPendingFiles--;
                    l.scriptsLoading--;
                    if (F) {
                        F.call(H)
                    }
                    if (l.numPendingFiles + l.scriptsLoading === 0) {
                        l.refreshQueue()
                    }
                },
                z;
            l.isLoading = true;
            l.numPendingFiles++;
            l.scriptsLoading++;
            z = C.disableCaching ? (A + "?" + C.disableCachingParam + "=" + Ext.Date.now()) : A;
            p[A] = l.injectScriptElement(z, D, G)
        },
        loadScriptFile: function(A, H, F, K, z) {
            if (u[A]) {
                return l
            }
            var C = l.getConfig(),
                L = A + (C.disableCaching ? ("?" + C.disableCachingParam + "=" + Ext.Date.now()) : ""),
                B = false,
                J, D, I, E = "";
            K = K || l;
            l.isLoading = true;
            if (!z) {
                I = function() {};
                p[A] = l.injectScriptElement(L, H, I, K)
            } else {
                if (typeof XMLHttpRequest != "undefined") {
                    J = new XMLHttpRequest()
                } else {
                    J = new ActiveXObject("Microsoft.XMLHTTP")
                }
                try {
                    J.open("GET", L, false);
                    J.send(null)
                } catch (G) {
                    B = true
                }
                D = (J.status === 1223) ? 204 : (J.status === 0 && (self.location || {}).protocol == "file:") ? 200 : J.status;
                B = B || (D === 0);
                if (B) {} else {
                    if ((D >= 200 && D < 300) || (D === 304)) {
                        if (!Ext.isIE) {
                            E = "\n//@ sourceURL=" + A
                        }
                        Ext.globalEval(J.responseText + E);
                        H.call(K)
                    } else {}
                }
                J = null
            }
        },
        syncRequire: function() {
            var z = l.syncModeEnabled;
            if (!z) {
                l.syncModeEnabled = true
            }
            l.require.apply(l, arguments);
            if (!z) {
                l.syncModeEnabled = false
            }
            l.refreshQueue()
        },
        require: function(R, I, C, E) {
            var K = {},
                B = {},
                H = [],
                T = [],
                Q = [],
                A = [],
                G, S, M, L, z, F, P, O, N, J, D;
            if (E) {
                E = (typeof E === "string") ? [E] : E;
                for (O = 0, J = E.length; O < J; O++) {
                    z = E[O];
                    if (typeof z == "string" && z.length > 0) {
                        H = c.getNamesByExpression(z);
                        for (N = 0, D = H.length; N < D; N++) {
                            K[H[N]] = true
                        }
                    }
                }
            }
            R = (typeof R === "string") ? [R] : (R ? R : []);
            if (I) {
                if (I.length > 0) {
                    G = function() {
                        var V = [],
                            U, W;
                        for (U = 0, W = A.length; U < W; U++) {
                            V.push(c.get(A[U]))
                        }
                        return I.apply(this, V)
                    }
                } else {
                    G = I
                }
            } else {
                G = Ext.emptyFn
            }
            C = C || Ext.global;
            for (O = 0, J = R.length; O < J; O++) {
                L = R[O];
                if (typeof L == "string" && L.length > 0) {
                    T = c.getNamesByExpression(L);
                    D = T.length;
                    for (N = 0; N < D; N++) {
                        P = T[N];
                        if (K[P] !== true) {
                            A.push(P);
                            if (!c.isCreated(P) && !B[P]) {
                                B[P] = true;
                                Q.push(P)
                            }
                        }
                    }
                }
            }
            if (Q.length > 0) {
                if (!l.config.enabled) {
                    throw new Error("Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. Missing required class" + ((Q.length > 1) ? "es" : "") + ": " + Q.join(", "))
                }
            } else {
                G.call(C);
                return l
            }
            S = l.syncModeEnabled;
            if (!S) {
                q.push({
                    requires: Q.slice(),
                    callback: G,
                    scope: C
                })
            }
            J = Q.length;
            for (O = 0; O < J; O++) {
                F = Q[O];
                M = l.getPath(F);
                if (S && r.hasOwnProperty(F)) {
                    l.numPendingFiles--;
                    l.removeScriptElement(M);
                    delete r[F]
                }
                if (!r.hasOwnProperty(F)) {
                    r[F] = false;
                    s[F] = M;
                    l.numPendingFiles++;
                    l.loadScriptFile(M, a(l.onFileLoaded, [F, M], l), a(l.onFileLoadError, [F, M], l), l, S)
                }
            }
            if (S) {
                G.call(C);
                if (J === 1) {
                    return c.get(F)
                }
            }
            return l
        },
        onFileLoaded: function(A, z) {
            l.numLoadedFiles++;
            r[A] = true;
            u[z] = true;
            l.numPendingFiles--;
            if (l.numPendingFiles === 0) {
                l.refreshQueue()
            }
        },
        onFileLoadError: function(B, A, z, C) {
            l.numPendingFiles--;
            l.hasFileLoadError = true
        },
        addUsedClasses: function(B) {
            var z, A, C;
            if (B) {
                B = (typeof B == "string") ? [B] : B;
                for (A = 0, C = B.length; A < C; A++) {
                    z = B[A];
                    if (typeof z == "string" && !Ext.Array.contains(y, z)) {
                        y.push(z)
                    }
                }
            }
            return l
        },
        triggerReady: function() {
            var A, z, B = y;
            if (l.isLoading) {
                l.isLoading = false;
                if (B.length !== 0) {
                    B = B.slice();
                    y.length = 0;
                    l.require(B, l.triggerReady, l);
                    return l
                }
            }
            while (x.length && !l.isLoading) {
                A = x.shift();
                A.fn.call(A.scope)
            }
            return l
        },
        onReady: function(C, B, D, z) {
            var A;
            if (D !== false && Ext.onDocumentReady) {
                A = C;
                C = function() {
                    Ext.onDocumentReady(A, B, z)
                }
            }
            if (!l.isLoading) {
                C.call(B)
            } else {
                x.push({
                    fn: C,
                    scope: B
                })
            }
        },
        historyPush: function(z) {
            if (z && r.hasOwnProperty(z) && !v[z]) {
                v[z] = true;
                m.push(z)
            }
            return l
        }
    });
    Ext.disableCacheBuster = function(A, B) {
        var z = new Date();
        z.setTime(z.getTime() + (A ? 10 * 365 : -1) * 24 * 60 * 60 * 1000);
        z = z.toGMTString();
        document.cookie = "ext-cache=1; expires=" + z + "; path=" + (B || "/")
    };
    Ext.require = o(l, "require");
    Ext.syncRequire = o(l, "syncRequire");
    Ext.exclude = o(l, "exclude");
    Ext.onReady = function(B, A, z) {
        l.onReady(B, A, true, z)
    };
    t.registerPreprocessor("loader", function(P, D, O, N) {
        var K = this,
            I = [],
            z, J = c.getName(P),
            C, B, H, G, M, F, A, L, E;
        for (C = 0, H = n.length; C < H; C++) {
            F = n[C];
            if (D.hasOwnProperty(F)) {
                A = D[F];
                if (typeof A == "string") {
                    I.push(A)
                } else {
                    if (A instanceof Array) {
                        for (B = 0, G = A.length; B < G; B++) {
                            M = A[B];
                            if (typeof M == "string") {
                                I.push(M)
                            }
                        }
                    } else {
                        if (typeof A != "function") {
                            for (B in A) {
                                if (A.hasOwnProperty(B)) {
                                    M = A[B];
                                    if (typeof M == "string") {
                                        I.push(M)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (I.length === 0) {
            return
        }
        l.require(I, function() {
            for (C = 0, H = n.length; C < H; C++) {
                F = n[C];
                if (D.hasOwnProperty(F)) {
                    A = D[F];
                    if (typeof A == "string") {
                        D[F] = c.get(A)
                    } else {
                        if (A instanceof Array) {
                            for (B = 0, G = A.length; B < G; B++) {
                                M = A[B];
                                if (typeof M == "string") {
                                    D[F][B] = c.get(M)
                                }
                            }
                        } else {
                            if (typeof A != "function") {
                                for (var Q in A) {
                                    if (A.hasOwnProperty(Q)) {
                                        M = A[Q];
                                        if (typeof M == "string") {
                                            D[F][Q] = c.get(M)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            N.call(K, P, D, O)
        });
        return false
    }, true, "after", "className");
    c.registerPostprocessor("uses", function(B, A, C) {
        var z = C.uses;
        if (z) {
            l.addUsedClasses(z)
        }
    });
    c.onCreated(l.historyPush)
};
if (Ext._classPathMetadata) {
    Ext.Loader.addClassPathMappings(Ext._classPathMetadata);
    Ext._classPathMetadata = null
}(function() {
    var a = document.getElementsByTagName("script"),
        c = a[a.length - 1],
        e = c.src,
        d = e.substring(0, e.lastIndexOf("/") + 1),
        g = Ext.Loader;
    g.setConfig({
        enabled: true,
        disableCaching: true,
        paths: {
            Ext: d + "src"
        }
    })
})();
Ext._endTime = new Date().getTime();
if (Ext._beforereadyhandler) {
    Ext._beforereadyhandler()
}
Ext.Error = Ext.extend(Error, {
    statics: {
        ignore: false,
        raise: function(a) {
            a = a || {};
            if (Ext.isString(a)) {
                a = {
                    msg: a
                }
            }
            var d = this.raise.caller,
                c;
            if (d) {
                if (d.$name) {
                    a.sourceMethod = d.$name
                }
                if (d.$owner) {
                    a.sourceClass = d.$owner.$className
                }
            }
            if (Ext.Error.handle(a) !== true) {
                c = Ext.Error.prototype.toString.call(a);
                Ext.log({
                    msg: c,
                    level: "error",
                    dump: a,
                    stack: true
                });
                throw new Ext.Error(a)
            }
        },
        handle: function() {
            return Ext.Error.ignore
        }
    },
    name: "Ext.Error",
    constructor: function(a) {
        if (Ext.isString(a)) {
            a = {
                msg: a
            }
        }
        var c = this;
        Ext.apply(c, a);
        c.message = c.message || c.msg
    },
    toString: function() {
        var d = this,
            c = d.sourceClass ? d.sourceClass : "",
            a = d.sourceMethod ? "." + d.sourceMethod + "(): " : "",
            e = d.msg || "(No description provided)";
        return c + a + e
    }
});
Ext.deprecated = function(a) {
    return Ext.emptyFn
};
Ext.JSON = (new(function() {
    var me = this,
        encodingFunction, decodingFunction, useNative = null,
        useHasOwn = !!{}.hasOwnProperty,
        isNative = function() {
            if (useNative === null) {
                useNative = Ext.USE_NATIVE_JSON && window.JSON && JSON.toString() == "[object JSON]"
            }
            return useNative
        },
        pad = function(n) {
            return n < 10 ? "0" + n : n
        },
        doDecode = function(json) {
            return eval("(" + json + ")")
        },
        doEncode = function(o, newline) {
            if (o === null || o === undefined) {
                return "null"
            } else {
                if (Ext.isDate(o)) {
                    return Ext.JSON.encodeDate(o)
                } else {
                    if (Ext.isString(o)) {
                        return Ext.JSON.encodeString(o)
                    } else {
                        if (typeof o == "number") {
                            return isFinite(o) ? String(o) : "null"
                        } else {
                            if (Ext.isBoolean(o)) {
                                return String(o)
                            } else {
                                if (o.toJSON) {
                                    return o.toJSON()
                                } else {
                                    if (Ext.isArray(o)) {
                                        return encodeArray(o, newline)
                                    } else {
                                        if (Ext.isObject(o)) {
                                            return encodeObject(o, newline)
                                        } else {
                                            if (typeof o === "function") {
                                                return "null"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return "undefined"
        },
        m = {
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            '"': '\\"',
            "\\": "\\\\",
            "\x0b": "\\u000b"
        },
        charToReplace = /[\\\"\x00-\x1f\x7f-\uffff]/g,
        encodeString = function(s) {
            return '"' + s.replace(charToReplace, function(a) {
                var c = m[a];
                return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
            }) + '"'
        },
        encodeArray = function(o, newline) {
            var a = ["[", ""],
                len = o.length,
                i;
            for (i = 0; i < len; i += 1) {
                a.push(Ext.JSON.encodeValue(o[i]), ",")
            }
            a[a.length - 1] = "]";
            return a.join("")
        },
        encodeObject = function(o, newline) {
            var a = ["{", ""],
                i;
            for (i in o) {
                if (!useHasOwn || o.hasOwnProperty(i)) {
                    a.push(Ext.JSON.encodeValue(i), ":", Ext.JSON.encodeValue(o[i]), ",")
                }
            }
            a[a.length - 1] = "}";
            return a.join("")
        };
    me.encodeString = encodeString;
    me.encodeValue = doEncode;
    me.encodeDate = function(o) {
        return '"' + o.getFullYear() + "-" + pad(o.getMonth() + 1) + "-" + pad(o.getDate()) + "T" + pad(o.getHours()) + ":" + pad(o.getMinutes()) + ":" + pad(o.getSeconds()) + '"'
    };
    me.encode = function(o) {
        if (!encodingFunction) {
            encodingFunction = isNative() ? JSON.stringify : me.encodeValue
        }
        return encodingFunction(o)
    };
    me.decode = function(json, safe) {
        if (!decodingFunction) {
            decodingFunction = isNative() ? JSON.parse : doDecode
        }
        try {
            return decodingFunction(json)
        } catch (e) {
            if (safe === true) {
                return null
            }
            Ext.Error.raise({
                sourceClass: "Ext.JSON",
                sourceMethod: "decode",
                msg: "You're trying to decode an invalid JSON String: " + json
            })
        }
    }
})());
Ext.encode = Ext.JSON.encode;
Ext.decode = Ext.JSON.decode;
Ext.apply(Ext, {
    userAgent: navigator.userAgent.toLowerCase(),
    cache: {},
    idSeed: 1000,
    windowId: "ext-window",
    documentId: "ext-document",
    isReady: false,
    enableGarbageCollector: true,
    enableListenerCollection: true,
    addCacheEntry: function(g, c, e) {
        e = e || c.dom;
        var a = g || (c && c.id) || e.id,
            d = Ext.cache[a] || (Ext.cache[a] = {
                data: {},
                events: {},
                dom: e,
                skipGarbageCollection: !!(e.getElementById || e.navigator)
            });
        if (c) {
            c.$cache = d;
            d.el = c
        }
        return d
    },
    updateCacheEntry: function(a, c) {
        a.dom = c;
        if (a.el) {
            a.el.dom = c
        }
        return a
    },
    id: function(a, d) {
        var c = this,
            e = "";
        a = Ext.getDom(a, true) || {};
        if (a === document) {
            a.id = c.documentId
        } else {
            if (a === window) {
                a.id = c.windowId
            }
        }
        if (!a.id) {
            if (c.isSandboxed) {
                e = Ext.sandboxName.toLowerCase() + "-"
            }
            a.id = e + (d || "ext-gen") + (++Ext.idSeed)
        }
        return a.id
    },
    escapeId: (function() {
        var d = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i,
            e = /([\W]{1})/g,
            c = /^(\d)/g,
            a = function(j, i) {
                return "\\" + i
            },
            g = function(j, i) {
                return "\\00" + i.charCodeAt(0).toString(16) + " "
            };
        return function(i) {
            return d.test(i) ? i : i.replace(e, a).replace(c, g)
        }
    }()),
    getBody: (function() {
        var a;
        return function() {
            return a || (a = Ext.get(document.body))
        }
    }()),
    getHead: (function() {
        var a;
        return function() {
            return a || (a = Ext.get(document.getElementsByTagName("head")[0]))
        }
    }()),
    getDoc: (function() {
        var a;
        return function() {
            return a || (a = Ext.get(document))
        }
    }()),
    getCmp: function(a) {
        return Ext.ComponentManager.get(a)
    },
    getOrientation: function() {
        return window.innerHeight > window.innerWidth ? "portrait" : "landscape"
    },
    destroy: function() {
        var d = arguments.length,
            c, a;
        for (c = 0; c < d; c++) {
            a = arguments[c];
            if (a) {
                if (Ext.isArray(a)) {
                    this.destroy.apply(this, a)
                } else {
                    if (Ext.isFunction(a.destroy)) {
                        a.destroy()
                    } else {
                        if (a.dom) {
                            a.remove()
                        }
                    }
                }
            }
        }
    },
    callback: function(e, d, c, a) {
        if (Ext.isFunction(e)) {
            c = c || [];
            d = d || window;
            if (a) {
                Ext.defer(e, a, d, c)
            } else {
                e.apply(d, c)
            }
        }
    },
    htmlEncode: function(a) {
        return Ext.String.htmlEncode(a)
    },
    htmlDecode: function(a) {
        return Ext.String.htmlDecode(a)
    },
    urlAppend: function(a, c) {
        return Ext.String.urlAppend(a, c)
    }
});
Ext.ns = Ext.namespace;
window.undefined = window.undefined;
(function() {
    var q = function(e) {
            return e.test(Ext.userAgent)
        },
        v = document.compatMode == "CSS1Compat",
        I = function(U, T) {
            var e;
            return (U && (e = T.exec(Ext.userAgent))) ? parseFloat(e[1]) : 0
        },
        r = document.documentMode,
        a = q(/opera/),
        y = a && q(/version\/10\.5/),
        N = q(/\bchrome\b/),
        C = q(/webkit/),
        d = !N && q(/safari/),
        L = d && q(/applewebkit\/4/),
        J = d && q(/version\/3/),
        G = d && q(/version\/4/),
        l = d && q(/version\/5\.0/),
        F = d && q(/version\/5/),
        k = !a && q(/msie/),
        M = k && ((q(/msie 7/) && r != 8 && r != 9) || r == 7),
        K = k && ((q(/msie 8/) && r != 7 && r != 9) || r == 8),
        H = k && ((q(/msie 9/) && r != 7 && r != 8) || r == 9),
        P = k && q(/msie 6/),
        c = !C && q(/gecko/),
        S = c && q(/rv:1\.9/),
        R = c && q(/rv:2\.0/),
        Q = c && q(/rv:5\./),
        t = c && q(/rv:10\./),
        B = S && q(/rv:1\.9\.0/),
        z = S && q(/rv:1\.9\.1/),
        x = S && q(/rv:1\.9\.2/),
        i = q(/windows|win32/),
        E = q(/macintosh|mac os x/),
        A = q(/linux/),
        n = null,
        o = I(true, /\bchrome\/(\d+\.\d+)/),
        j = I(true, /\bfirefox\/(\d+\.\d+)/),
        p = I(k, /msie (\d+\.\d+)/),
        u = I(a, /version\/(\d+\.\d+)/),
        g = I(d, /version\/(\d+\.\d+)/),
        D = I(C, /webkit\/(\d+\.\d+)/),
        s = /^https/i.test(window.location.protocol),
        m;
    try {
        document.execCommand("BackgroundImageCache", false, true)
    } catch (O) {}
    m = function() {};
    m.info = m.warn = m.error = Ext.emptyFn;
    Ext.setVersion("extjs", "4.1.1.1");
    Ext.apply(Ext, {
        SSL_SECURE_URL: s && k ? "javascript:''" : "about:blank",
        scopeResetCSS: Ext.buildSettings.scopeResetCSS,
        resetCls: Ext.buildSettings.baseCSSPrefix + "reset",
        enableNestedListenerRemoval: false,
        USE_NATIVE_JSON: false,
        getDom: function(U, T) {
            if (!U || !document) {
                return null
            }
            if (U.dom) {
                return U.dom
            } else {
                if (typeof U == "string") {
                    var V = Ext.getElementById(U);
                    if (V && k && T) {
                        if (U == V.getAttribute("id")) {
                            return V
                        } else {
                            return null
                        }
                    }
                    return V
                } else {
                    return U
                }
            }
        },
        removeNode: P || M || K ? (function() {
            var e;
            return function(V) {
                if (V && V.tagName.toUpperCase() != "BODY") {
                    (Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(V): Ext.EventManager.removeAll(V);
                    var T = Ext.cache,
                        U = V.id;
                    if (T[U]) {
                        delete T[U].dom;
                        delete T[U]
                    }
                    if (K && V.parentNode) {
                        V.parentNode.removeChild(V)
                    }
                    e = e || document.createElement("div");
                    e.appendChild(V);
                    e.innerHTML = ""
                }
            }
        }()) : function(U) {
            if (U && U.parentNode && U.tagName.toUpperCase() != "BODY") {
                (Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(U): Ext.EventManager.removeAll(U);
                var e = Ext.cache,
                    T = U.id;
                if (e[T]) {
                    delete e[T].dom;
                    delete e[T]
                }
                U.parentNode.removeChild(U)
            }
        },
        isStrict: v,
        isIEQuirks: k && !v,
        isOpera: a,
        isOpera10_5: y,
        isWebKit: C,
        isChrome: N,
        isSafari: d,
        isSafari3: J,
        isSafari4: G,
        isSafari5: F,
        isSafari5_0: l,
        isSafari2: L,
        isIE: k,
        isIE6: P,
        isIE7: M,
        isIE8: K,
        isIE9: H,
        isGecko: c,
        isGecko3: S,
        isGecko4: R,
        isGecko5: Q,
        isGecko10: t,
        isFF3_0: B,
        isFF3_5: z,
        isFF3_6: x,
        isFF4: 4 <= j && j < 5,
        isFF5: 5 <= j && j < 6,
        isFF10: 10 <= j && j < 11,
        isLinux: A,
        isWindows: i,
        isMac: E,
        chromeVersion: o,
        firefoxVersion: j,
        ieVersion: p,
        operaVersion: u,
        safariVersion: g,
        webKitVersion: D,
        isSecure: s,
        BLANK_IMAGE_URL: (P || M) ? "//www.sencha.com/s.gif" : "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==",
        value: function(U, e, T) {
            return Ext.isEmpty(U, T) ? e : U
        },
        escapeRe: function(e) {
            return e.replace(/([-.*+?\^${}()|\[\]\/\\])/g, "\\$1")
        },
        addBehaviors: function(W) {
            if (!Ext.isReady) {
                Ext.onReady(function() {
                    Ext.addBehaviors(W)
                })
            } else {
                var T = {},
                    V, e, U;
                for (e in W) {
                    if ((V = e.split("@"))[1]) {
                        U = V[0];
                        if (!T[U]) {
                            T[U] = Ext.select(U)
                        }
                        T[U].on(V[1], W[e])
                    }
                }
                T = null
            }
        },
        getScrollbarSize: function(T) {
            if (!Ext.isReady) {
                return {}
            }
            if (T || !n) {
                var e = document.body,
                    U = document.createElement("div");
                U.style.width = U.style.height = "100px";
                U.style.overflow = "scroll";
                U.style.position = "absolute";
                e.appendChild(U);
                n = {
                    width: U.offsetWidth - U.clientWidth,
                    height: U.offsetHeight - U.clientHeight
                };
                e.removeChild(U)
            }
            return n
        },
        getScrollBarWidth: function(T) {
            var e = Ext.getScrollbarSize(T);
            return e.width + 2
        },
        copyTo: function(T, V, X, W) {
            if (typeof X == "string") {
                X = X.split(/[,;\s]/)
            }
            var Y, U = X.length,
                e;
            for (Y = 0; Y < U; Y++) {
                e = X[Y];
                if (W || V.hasOwnProperty(e)) {
                    T[e] = V[e]
                }
            }
            return T
        },
        destroyMembers: function(V) {
            for (var U = 1, T = arguments, e = T.length; U < e; U++) {
                Ext.destroy(V[T[U]]);
                delete V[T[U]]
            }
        },
        log: m,
        partition: function(e, W) {
            var X = [
                    [],
                    []
                ],
                T, V, U = e.length;
            for (T = 0; T < U; T++) {
                V = e[T];
                X[(W && W(V, T, e)) || (!W && V) ? 0 : 1].push(V)
            }
            return X
        },
        invoke: function(e, W) {
            var Y = [],
                X = Array.prototype.slice.call(arguments, 2),
                T, V, U = e.length;
            for (T = 0; T < U; T++) {
                V = e[T];
                if (V && typeof V[W] == "function") {
                    Y.push(V[W].apply(V, X))
                } else {
                    Y.push(undefined)
                }
            }
            return Y
        },
        zip: function() {
            var Z = Ext.partition(arguments, function(aa) {
                    return typeof aa != "function"
                }),
                W = Z[0],
                Y = Z[1][0],
                e = Ext.max(Ext.pluck(W, "length")),
                V = [],
                X, U, T;
            for (X = 0; X < e; X++) {
                V[X] = [];
                if (Y) {
                    V[X] = Y.apply(Y, Ext.pluck(W, X))
                } else {
                    for (U = 0, T = W.length; U < T; U++) {
                        V[X].push(W[U][X])
                    }
                }
            }
            return V
        },
        toSentence: function(T, e) {
            var W = T.length,
                V, U;
            if (W <= 1) {
                return T[0]
            } else {
                V = T.slice(0, W - 1);
                U = T[W - 1];
                return Ext.util.Format.format("{0} {1} {2}", V.join(", "), e || "and", U)
            }
        },
        useShims: P
    })
}());
Ext.application = function(a) {
    Ext.require("Ext.app.Application");
    Ext.onReady(function() {
        new Ext.app.Application(a)
    })
};
(function() {
    Ext.ns("Ext.util");
    Ext.util.Format = {};
    var i = Ext.util.Format,
        g = /<\/?[^>]+>/gi,
        d = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig,
        c = /\r?\n/g,
        e = /[^\d\.]/g,
        a;
    Ext.apply(i, {
        thousandSeparator: ",",
        decimalSeparator: ".",
        currencyPrecision: 2,
        currencySign: "$",
        currencyAtEnd: false,
        undef: function(j) {
            return j !== undefined ? j : ""
        },
        defaultValue: function(k, j) {
            return k !== undefined && k !== "" ? k : j
        },
        substr: "ab".substr(-1) != "b" ? function(k, m, j) {
            var l = String(k);
            return (m < 0) ? l.substr(Math.max(l.length + m, 0), j) : l.substr(m, j)
        } : function(k, l, j) {
            return String(k).substr(l, j)
        },
        lowercase: function(j) {
            return String(j).toLowerCase()
        },
        uppercase: function(j) {
            return String(j).toUpperCase()
        },
        usMoney: function(j) {
            return i.currency(j, "$", 2)
        },
        currency: function(l, n, k, j) {
            var p = "",
                o = ",0",
                m = 0;
            l = l - 0;
            if (l < 0) {
                l = -l;
                p = "-"
            }
            k = Ext.isDefined(k) ? k : i.currencyPrecision;
            o += o + (k > 0 ? "." : "");
            for (; m < k; m++) {
                o += "0"
            }
            l = i.number(l, o);
            if ((j || i.currencyAtEnd) === true) {
                return Ext.String.format("{0}{1}{2}", p, l, n || i.currencySign)
            } else {
                return Ext.String.format("{0}{1}{2}", p, n || i.currencySign, l)
            }
        },
        date: function(j, k) {
            if (!j) {
                return ""
            }
            if (!Ext.isDate(j)) {
                j = new Date(Date.parse(j))
            }
            return Ext.Date.dateFormat(j, k || Ext.Date.defaultFormat)
        },
        dateRenderer: function(j) {
            return function(k) {
                return i.date(k, j)
            }
        },
        stripTags: function(j) {
            return !j ? j : String(j).replace(g, "")
        },
        stripScripts: function(j) {
            return !j ? j : String(j).replace(d, "")
        },
        fileSize: function(j) {
            if (j < 1024) {
                return j + " bytes"
            } else {
                if (j < 1048576) {
                    return (Math.round(((j * 10) / 1024)) / 10) + " KB"
                } else {
                    return (Math.round(((j * 10) / 1048576)) / 10) + " MB"
                }
            }
        },
        math: (function() {
            var j = {};
            return function(l, k) {
                if (!j[k]) {
                    j[k] = Ext.functionFactory("v", "return v " + k + ";")
                }
                return j[k](l)
            }
        }()),
        round: function(l, k) {
            var j = Number(l);
            if (typeof k == "number") {
                k = Math.pow(10, k);
                j = Math.round(l * k) / k
            }
            return j
        },
        number: function(A, t) {
            if (!t) {
                return A
            }
            A = Ext.Number.from(A, NaN);
            if (isNaN(A)) {
                return ""
            }
            var C = i.thousandSeparator,
                r = i.decimalSeparator,
                B = false,
                s = A < 0,
                l, k, z, y, q, u, p, o, x;
            A = Math.abs(A);
            if (t.substr(t.length - 2) == "/i") {
                if (!a) {
                    a = new RegExp("[^\\d\\" + i.decimalSeparator + "]", "g")
                }
                t = t.substr(0, t.length - 2);
                B = true;
                l = t.indexOf(C) != -1;
                k = t.replace(a, "").split(r)
            } else {
                l = t.indexOf(",") != -1;
                k = t.replace(e, "").split(".")
            }
            if (k.length > 2) {} else {
                if (k.length > 1) {
                    A = Ext.Number.toFixed(A, k[1].length)
                } else {
                    A = Ext.Number.toFixed(A, 0)
                }
            }
            z = A.toString();
            k = z.split(".");
            if (l) {
                y = k[0];
                q = [];
                u = y.length;
                p = Math.floor(u / 3);
                o = y.length % 3 || 3;
                for (x = 0; x < u; x += o) {
                    if (x !== 0) {
                        o = 3
                    }
                    q[q.length] = y.substr(x, o);
                    p -= 1
                }
                z = q.join(C);
                if (k[1]) {
                    z += r + k[1]
                }
            } else {
                if (k[1]) {
                    z = k[0] + r + k[1]
                }
            }
            if (s) {
                s = z.replace(/[^1-9]/g, "") !== ""
            }
            return (s ? "-" : "") + t.replace(/[\d,?\.?]+/, z)
        },
        numberRenderer: function(j) {
            return function(k) {
                return i.number(k, j)
            }
        },
        plural: function(j, k, l) {
            return j + " " + (j == 1 ? k : (l ? l : k + "s"))
        },
        nl2br: function(j) {
            return Ext.isEmpty(j) ? "" : j.replace(c, "<br/>")
        },
        capitalize: Ext.String.capitalize,
        ellipsis: Ext.String.ellipsis,
        format: Ext.String.format,
        htmlDecode: Ext.String.htmlDecode,
        htmlEncode: Ext.String.htmlEncode,
        leftPad: Ext.String.leftPad,
        trim: Ext.String.trim,
        parseBox: function(k) {
            k = Ext.isEmpty(k) ? "" : k;
            if (Ext.isNumber(k)) {
                k = k.toString()
            }
            var l = k.split(" "),
                j = l.length;
            if (j == 1) {
                l[1] = l[2] = l[3] = l[0]
            } else {
                if (j == 2) {
                    l[2] = l[0];
                    l[3] = l[1]
                } else {
                    if (j == 3) {
                        l[3] = l[1]
                    }
                }
            }
            return {
                top: parseInt(l[0], 10) || 0,
                right: parseInt(l[1], 10) || 0,
                bottom: parseInt(l[2], 10) || 0,
                left: parseInt(l[3], 10) || 0
            }
        },
        escapeRegex: function(j) {
            return j.replace(/([\-.*+?\^${}()|\[\]\/\\])/g, "\\$1")
        }
    })
}());
Ext.define("Ext.util.TaskRunner", {
    interval: 10,
    timerId: null,
    constructor: function(a) {
        var c = this;
        if (typeof a == "number") {
            c.interval = a
        } else {
            if (a) {
                Ext.apply(c, a)
            }
        }
        c.tasks = [];
        c.timerFn = Ext.Function.bind(c.onTick, c)
    },
    newTask: function(c) {
        var a = new Ext.util.TaskRunner.Task(c);
        a.manager = this;
        return a
    },
    start: function(a) {
        var d = this,
            c = new Date().getTime();
        if (!a.pending) {
            d.tasks.push(a);
            a.pending = true
        }
        a.stopped = false;
        a.taskStartTime = c;
        a.taskRunTime = a.fireOnStart !== false ? 0 : a.taskStartTime;
        a.taskRunCount = 0;
        if (!d.firing) {
            if (a.fireOnStart !== false) {
                d.startTimer(0, c)
            } else {
                d.startTimer(a.interval, c)
            }
        }
        return a
    },
    stop: function(a) {
        if (!a.stopped) {
            a.stopped = true;
            if (a.onStop) {
                a.onStop.call(a.scope || a, a)
            }
        }
        return a
    },
    stopAll: function() {
        Ext.each(this.tasks, this.stop, this)
    },
    firing: false,
    nextExpires: 1e+99,
    onTick: function() {
        var o = this,
            g = o.tasks,
            a = new Date().getTime(),
            p = 1e+99,
            m = g.length,
            d, q, k, c, e, j;
        o.timerId = null;
        o.firing = true;
        for (k = 0; k < m || k < (m = g.length); ++k) {
            c = g[k];
            if (!(j = c.stopped)) {
                d = c.taskRunTime + c.interval;
                if (d <= a) {
                    e = 1;
                    try {
                        e = c.run.apply(c.scope || c, c.args || [++c.taskRunCount])
                    } catch (l) {
                        try {
                            if (c.onError) {
                                e = c.onError.call(c.scope || c, c, l)
                            }
                        } catch (n) {}
                    }
                    c.taskRunTime = a;
                    if (e === false || c.taskRunCount === c.repeat) {
                        o.stop(c);
                        j = true
                    } else {
                        j = c.stopped;
                        d = a + c.interval
                    }
                }
                if (!j && c.duration && c.duration <= (a - c.taskStartTime)) {
                    o.stop(c);
                    j = true
                }
            }
            if (j) {
                c.pending = false;
                if (!q) {
                    q = g.slice(0, k)
                }
            } else {
                if (q) {
                    q.push(c)
                }
                if (p > d) {
                    p = d
                }
            }
        }
        if (q) {
            o.tasks = q
        }
        o.firing = false;
        if (o.tasks.length) {
            o.startTimer(p - a, new Date().getTime())
        }
    },
    startTimer: function(g, d) {
        var e = this,
            c = d + g,
            a = e.timerId;
        if (a && e.nextExpires - c > e.interval) {
            clearTimeout(a);
            a = null
        }
        if (!a) {
            if (g < e.interval) {
                g = e.interval
            }
            e.timerId = setTimeout(e.timerFn, g);
            e.nextExpires = c
        }
    }
}, function() {
    var c = this,
        a = c.prototype;
    a.destroy = a.stopAll;
    Ext.util.TaskManager = Ext.TaskManager = new c();
    c.Task = new Ext.Class({
        isTask: true,
        stopped: true,
        fireOnStart: false,
        constructor: function(d) {
            Ext.apply(this, d)
        },
        restart: function(d) {
            if (d !== undefined) {
                this.interval = d
            }
            this.manager.start(this)
        },
        start: function(d) {
            if (this.stopped) {
                this.restart(d)
            }
        },
        stop: function() {
            this.manager.stop(this)
        }
    });
    a = c.Task.prototype;
    a.destroy = a.stop
});
Ext.define("Ext.perf.Accumulator", (function() {
    var d = null,
        j = Ext.global.chrome,
        e, c = function() {
            c = function() {
                return new Date().getTime()
            };
            var n, o;
            if (Ext.isChrome && j && j.Interval) {
                n = new j.Interval();
                n.start();
                c = function() {
                    return n.microseconds() / 1000
                }
            } else {
                if (window.ActiveXObject) {
                    try {
                        o = new ActiveXObject("SenchaToolbox.Toolbox");
                        Ext.senchaToolbox = o;
                        c = function() {
                            return o.milliseconds
                        }
                    } catch (p) {}
                } else {
                    if (Date.now) {
                        c = Date.now
                    }
                }
            }
            Ext.perf.getTimestamp = Ext.perf.Accumulator.getTimestamp = c;
            return c()
        };

    function k(o, n) {
        o.sum += n;
        o.min = Math.min(o.min, n);
        o.max = Math.max(o.max, n)
    }

    function g(q) {
        var o = q ? q : (c() - this.time),
            p = this,
            n = p.accum;
        ++n.count;
        if (!--n.depth) {
            k(n.total, o)
        }
        k(n.pure, o - p.childTime);
        d = p.parent;
        if (d) {
            ++d.accum.childCount;
            d.childTime += o
        }
    }

    function a() {
        return {
            min: Number.MAX_VALUE,
            max: 0,
            sum: 0
        }
    }

    function l(o, n) {
        return function() {
            var q = o.enter(),
                p = n.apply(this, arguments);
            q.leave();
            return p
        }
    }

    function m(n) {
        return Math.round(n * 100) / 100
    }

    function i(p, o, n, r) {
        var q = {
            avg: 0,
            min: r.min,
            max: r.max,
            sum: 0
        };
        if (p) {
            n = n || 0;
            q.sum = r.sum - o * n;
            q.avg = q.sum / p
        }
        return q
    }
    return {
        constructor: function(n) {
            var o = this;
            o.count = o.childCount = o.depth = o.maxDepth = 0;
            o.pure = a();
            o.total = a();
            o.name = n
        },
        statics: {
            getTimestamp: c
        },
        format: function(n) {
            if (!e) {
                e = new Ext.XTemplate(["{name} - {count} call(s)", '<tpl if="count">', '<tpl if="childCount">', " ({childCount} children)", "</tpl>", '<tpl if="depth - 1">', " ({depth} deep)", "</tpl>", '<tpl for="times">', ", {type}: {[this.time(values.sum)]} msec (", "avg={[this.time(values.sum / parent.count)]}", ")", "</tpl>", "</tpl>"].join(""), {
                    time: function(p) {
                        return Math.round(p * 100) / 100
                    }
                })
            }
            var o = this.getData(n);
            o.name = this.name;
            o.pure.type = "Pure";
            o.total.type = "Total";
            o.times = [o.pure, o.total];
            return e.apply(o)
        },
        getData: function(n) {
            var o = this;
            return {
                count: o.count,
                childCount: o.childCount,
                depth: o.maxDepth,
                pure: i(o.count, o.childCount, n, o.pure),
                total: i(o.count, o.childCount, n, o.total)
            }
        },
        enter: function() {
            var n = this,
                o = {
                    accum: n,
                    leave: g,
                    childTime: 0,
                    parent: d
                };
            ++n.depth;
            if (n.maxDepth < n.depth) {
                n.maxDepth = n.depth
            }
            d = o;
            o.time = c();
            return o
        },
        monitor: function(p, o, n) {
            var q = this.enter();
            if (n) {
                p.apply(o, n)
            } else {
                p.call(o)
            }
            q.leave()
        },
        report: function() {
            Ext.log(this.format())
        },
        tap: function(v, y) {
            var x = this,
                q = typeof y == "string" ? [y] : y,
                u, z, s, r, p, o, n, t;
            t = function() {
                if (typeof v == "string") {
                    u = Ext.global;
                    r = v.split(".");
                    for (s = 0, p = r.length; s < p; ++s) {
                        u = u[r[s]]
                    }
                } else {
                    u = v
                }
                for (s = 0, p = q.length; s < p; ++s) {
                    o = q[s];
                    z = o.charAt(0) == "!";
                    if (z) {
                        o = o.substring(1)
                    } else {
                        z = !(o in u.prototype)
                    }
                    n = z ? u : u.prototype;
                    n[o] = l(x, n[o])
                }
            };
            Ext.ClassManager.onCreated(t, x, v);
            return x
        }
    }
}()), function() {
    Ext.perf.getTimestamp = this.getTimestamp
});
Ext.define("Ext.perf.Monitor", {
    singleton: true,
    alternateClassName: "Ext.Perf",
    requires: ["Ext.perf.Accumulator"],
    constructor: function() {
        this.accumulators = [];
        this.accumulatorsByName = {}
    },
    calibrate: function() {
        var c = new Ext.perf.Accumulator("$"),
            i = c.total,
            d = Ext.perf.Accumulator.getTimestamp,
            g = 0,
            j, a, e;
        e = d();
        do {
            j = c.enter();
            j.leave();
            ++g
        } while (i.sum < 100);
        a = d();
        return (a - e) / g
    },
    get: function(c) {
        var d = this,
            a = d.accumulatorsByName[c];
        if (!a) {
            d.accumulatorsByName[c] = a = new Ext.perf.Accumulator(c);
            d.accumulators.push(a)
        }
        return a
    },
    enter: function(a) {
        return this.get(a).enter()
    },
    monitor: function(a, d, c) {
        this.get(a).monitor(d, c)
    },
    report: function() {
        var d = this,
            c = d.accumulators,
            a = d.calibrate();
        c.sort(function(g, e) {
            return (g.name < e.name) ? -1 : ((e.name < g.name) ? 1 : 0)
        });
        d.updateGC();
        Ext.log("Calibration: " + Math.round(a * 100) / 100 + " msec/sample");
        Ext.each(c, function(e) {
            Ext.log(e.format(a))
        })
    },
    getData: function(d) {
        var c = {},
            a = this.accumulators;
        Ext.each(a, function(e) {
            if (d || e.count) {
                c[e.name] = e.getData()
            }
        });
        return c
    },
    reset: function() {
        Ext.each(this.accumulators, function(a) {
            var c = a;
            c.count = c.childCount = c.depth = c.maxDepth = 0;
            c.pure = {
                min: Number.MAX_VALUE,
                max: 0,
                sum: 0
            };
            c.total = {
                min: Number.MAX_VALUE,
                max: 0,
                sum: 0
            }
        })
    },
    updateGC: function() {
        var a = this.accumulatorsByName.GC,
            c = Ext.senchaToolbox,
            d;
        if (a) {
            a.count = c.garbageCollectionCounter || 0;
            if (a.count) {
                d = a.pure;
                a.total.sum = d.sum = c.garbageCollectionMilliseconds;
                d.min = d.max = d.sum / a.count;
                d = a.total;
                d.min = d.max = d.sum / a.count
            }
        }
    },
    watchGC: function() {
        Ext.perf.getTimestamp();
        var a = Ext.senchaToolbox;
        if (a) {
            this.get("GC");
            a.watchGarbageCollector(false)
        }
    },
    setup: function(d) {
        if (!d) {
            d = {
                render: {
                    "Ext.AbstractComponent": "render"
                },
                layout: {
                    "Ext.layout.Context": "run"
                }
            }
        }
        this.currentConfig = d;
        var e, i, c, g, a;
        for (e in d) {
            if (d.hasOwnProperty(e)) {
                i = d[e];
                c = Ext.Perf.get(e);
                for (g in i) {
                    if (i.hasOwnProperty(g)) {
                        a = i[g];
                        c.tap(g, a)
                    }
                }
            }
        }
        this.watchGC()
    }
});
Ext.is = {
    init: function(c) {
        var d = this.platforms,
            g = d.length,
            e, a;
        c = c || window.navigator;
        for (e = 0; e < g; e++) {
            a = d[e];
            this[a.identity] = a.regex.test(c[a.property])
        }
        this.Desktop = this.Mac || this.Windows || (this.Linux && !this.Android);
        this.Tablet = this.iPad;
        this.Phone = !this.Desktop && !this.Tablet;
        this.iOS = this.iPhone || this.iPad || this.iPod;
        this.Standalone = !!window.navigator.standalone
    },
    platforms: [{
        property: "platform",
        regex: /iPhone/i,
        identity: "iPhone"
    }, {
        property: "platform",
        regex: /iPod/i,
        identity: "iPod"
    }, {
        property: "userAgent",
        regex: /iPad/i,
        identity: "iPad"
    }, {
        property: "userAgent",
        regex: /Blackberry/i,
        identity: "Blackberry"
    }, {
        property: "userAgent",
        regex: /Android/i,
        identity: "Android"
    }, {
        property: "platform",
        regex: /Mac/i,
        identity: "Mac"
    }, {
        property: "platform",
        regex: /Win/i,
        identity: "Windows"
    }, {
        property: "platform",
        regex: /Linux/i,
        identity: "Linux"
    }]
};
Ext.is.init();
(function() {
    var a = function(e, d) {
        var c = e.ownerDocument.defaultView,
            g = (c ? c.getComputedStyle(e, null) : e.currentStyle) || e.style;
        return g[d]
    };
    Ext.supports = {
        init: function() {
            var e = this,
                g = document,
                d = e.tests,
                k = d.length,
                j = k && Ext.isReady && g.createElement("div"),
                i, c = [];
            if (j) {
                j.innerHTML = ['<div style="height:30px;width:50px;">', '<div style="height:20px;width:20px;"></div>', "</div>", '<div style="width: 200px; height: 200px; position: relative; padding: 5px;">', '<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>', "</div>", '<div style="position: absolute; left: 10%; top: 10%;"></div>', '<div style="float:left; background-color:transparent;"></div>'].join("");
                g.body.appendChild(j)
            }
            while (k--) {
                i = d[k];
                if (j || i.early) {
                    e[i.identity] = i.fn.call(e, g, j)
                } else {
                    c.push(i)
                }
            }
            if (j) {
                g.body.removeChild(j)
            }
            e.tests = c
        },
        PointerEvents: "pointerEvents" in document.documentElement.style,
        CSS3BoxShadow: "boxShadow" in document.documentElement.style || "WebkitBoxShadow" in document.documentElement.style || "MozBoxShadow" in document.documentElement.style,
        ClassList: !!document.documentElement.classList,
        OrientationChange: ((typeof window.orientation != "undefined") && ("onorientationchange" in window)),
        DeviceMotion: ("ondevicemotion" in window),
        Touch: ("ontouchstart" in window) && (!Ext.is.Desktop),
        TimeoutActualLateness: (function() {
            setTimeout(function() {
                Ext.supports.TimeoutActualLateness = arguments.length !== 0
            }, 0)
        }()),
        tests: [{
            identity: "Transitions",
            fn: function(k, m) {
                var j = ["webkit", "Moz", "o", "ms", "khtml"],
                    l = "TransitionEnd",
                    c = [j[0] + l, "transitionend", j[2] + l, j[3] + l, j[4] + l],
                    g = j.length,
                    e = 0,
                    d = false;
                for (; e < g; e++) {
                    if (a(m, j[e] + "TransitionProperty")) {
                        Ext.supports.CSS3Prefix = j[e];
                        Ext.supports.CSS3TransitionEnd = c[e];
                        d = true;
                        break
                    }
                }
                return d
            }
        }, {
            identity: "RightMargin",
            fn: function(d, e) {
                var c = d.defaultView;
                return !(c && c.getComputedStyle(e.firstChild.firstChild, null).marginRight != "0px")
            }
        }, {
            identity: "DisplayChangeInputSelectionBug",
            early: true,
            fn: function() {
                var c = Ext.webKitVersion;
                return 0 < c && c < 533
            }
        }, {
            identity: "DisplayChangeTextAreaSelectionBug",
            early: true,
            fn: function() {
                var c = Ext.webKitVersion;
                return 0 < c && c < 534.24
            }
        }, {
            identity: "TransparentColor",
            fn: function(d, e, c) {
                c = d.defaultView;
                return !(c && c.getComputedStyle(e.lastChild, null).backgroundColor != "transparent")
            }
        }, {
            identity: "ComputedStyle",
            fn: function(d, e, c) {
                c = d.defaultView;
                return c && c.getComputedStyle
            }
        }, {
            identity: "Svg",
            fn: function(c) {
                return !!c.createElementNS && !!c.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect
            }
        }, {
            identity: "Canvas",
            fn: function(c) {
                return !!c.createElement("canvas").getContext
            }
        }, {
            identity: "Vml",
            fn: function(c) {
                var e = c.createElement("div");
                e.innerHTML = "<!--[if vml]><br/><br/><![endif]-->";
                return (e.childNodes.length == 2)
            }
        }, {
            identity: "Float",
            fn: function(c, d) {
                return !!d.lastChild.style.cssFloat
            }
        }, {
            identity: "AudioTag",
            fn: function(c) {
                return !!c.createElement("audio").canPlayType
            }
        }, {
            identity: "History",
            fn: function() {
                var c = window.history;
                return !!(c && c.pushState)
            }
        }, {
            identity: "CSS3DTransform",
            fn: function() {
                return (typeof WebKitCSSMatrix != "undefined" && new WebKitCSSMatrix().hasOwnProperty("m41"))
            }
        }, {
            identity: "CSS3LinearGradient",
            fn: function(j, l) {
                var i = "background-image:",
                    e = "-webkit-gradient(linear, left top, right bottom, from(black), to(white))",
                    k = "linear-gradient(left top, black, white)",
                    g = "-moz-" + k,
                    c = "-o-" + k,
                    d = [i + e, i + k, i + g, i + c];
                l.style.cssText = d.join(";");
                return ("" + l.style.backgroundImage).indexOf("gradient") !== -1
            }
        }, {
            identity: "CSS3BorderRadius",
            fn: function(g, j) {
                var d = ["borderRadius", "BorderRadius", "MozBorderRadius", "WebkitBorderRadius", "OBorderRadius", "KhtmlBorderRadius"],
                    e = false,
                    c;
                for (c = 0; c < d.length; c++) {
                    if (document.body.style[d[c]] !== undefined) {
                        return true
                    }
                }
                return e
            }
        }, {
            identity: "GeoLocation",
            fn: function() {
                return (typeof navigator != "undefined" && typeof navigator.geolocation != "undefined") || (typeof google != "undefined" && typeof google.gears != "undefined")
            }
        }, {
            identity: "MouseEnterLeave",
            fn: function(c, d) {
                return ("onmouseenter" in d && "onmouseleave" in d)
            }
        }, {
            identity: "MouseWheel",
            fn: function(c, d) {
                return ("onmousewheel" in d)
            }
        }, {
            identity: "Opacity",
            fn: function(c, d) {
                if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
                    return false
                }
                d.firstChild.style.cssText = "opacity:0.73";
                return d.firstChild.style.opacity == "0.73"
            }
        }, {
            identity: "Placeholder",
            fn: function(c) {
                return "placeholder" in c.createElement("input")
            }
        }, {
            identity: "Direct2DBug",
            fn: function() {
                return Ext.isString(document.body.style.msTransformOrigin)
            }
        }, {
            identity: "BoundingClientRect",
            fn: function(c, d) {
                return Ext.isFunction(d.getBoundingClientRect)
            }
        }, {
            identity: "IncludePaddingInWidthCalculation",
            fn: function(c, d) {
                return d.childNodes[1].firstChild.offsetWidth == 210
            }
        }, {
            identity: "IncludePaddingInHeightCalculation",
            fn: function(c, d) {
                return d.childNodes[1].firstChild.offsetHeight == 210
            }
        }, {
            identity: "ArraySort",
            fn: function() {
                var c = [1, 2, 3, 4, 5].sort(function() {
                    return 0
                });
                return c[0] === 1 && c[1] === 2 && c[2] === 3 && c[3] === 4 && c[4] === 5
            }
        }, {
            identity: "Range",
            fn: function() {
                return !!document.createRange
            }
        }, {
            identity: "CreateContextualFragment",
            fn: function() {
                var c = Ext.supports.Range ? document.createRange() : false;
                return c && !!c.createContextualFragment
            }
        }, {
            identity: "WindowOnError",
            fn: function() {
                return Ext.isIE || Ext.isGecko || Ext.webKitVersion >= 534.16
            }
        }, {
            identity: "TextAreaMaxLength",
            fn: function() {
                var c = document.createElement("textarea");
                return ("maxlength" in c)
            }
        }, {
            identity: "GetPositionPercentage",
            fn: function(c, d) {
                return a(d.childNodes[2], "left") == "10%"
            }
        }]
    }
}());
Ext.supports.init();
Ext.util.DelayedTask = function(e, d, a) {
    var g = this,
        i, c = function() {
            clearInterval(i);
            i = null;
            e.apply(d, a || [])
        };
    this.delay = function(k, m, l, j) {
        g.cancel();
        e = m || e;
        d = l || d;
        a = j || a;
        i = setInterval(c, k)
    };
    this.cancel = function() {
        if (i) {
            clearInterval(i);
            i = null
        }
    }
};
Ext.require("Ext.util.DelayedTask", function() {
    Ext.util.Event = Ext.extend(Object, (function() {
        var c = {};

        function e(j, k, l, i) {
            return function() {
                if (l.target === arguments[0]) {
                    j.apply(i, arguments)
                }
            }
        }

        function d(j, k, l, i) {
            k.task = new Ext.util.DelayedTask();
            return function() {
                k.task.delay(l.buffer, j, i, Ext.Array.toArray(arguments))
            }
        }

        function a(j, k, l, i) {
            return function() {
                var m = new Ext.util.DelayedTask();
                if (!k.tasks) {
                    k.tasks = []
                }
                k.tasks.push(m);
                m.delay(l.delay || 10, j, i, Ext.Array.toArray(arguments))
            }
        }

        function g(j, k, l, i) {
            return function() {
                var m = k.ev;
                if (m.removeListener(k.fn, i) && m.observable) {
                    m.observable.hasListeners[m.name] --
                }
                return j.apply(i, arguments)
            }
        }
        return {
            isEvent: true,
            constructor: function(j, i) {
                this.name = i;
                this.observable = j;
                this.listeners = []
            },
            addListener: function(k, j, i) {
                var l = this,
                    m;
                j = j || l.observable;
                if (!l.isListening(k, j)) {
                    m = l.createListener(k, j, i);
                    if (l.firing) {
                        l.listeners = l.listeners.slice(0)
                    }
                    l.listeners.push(m)
                }
            },
            createListener: function(l, k, i) {
                i = i || c;
                k = k || this.observable;
                var m = {
                        fn: l,
                        scope: k,
                        o: i,
                        ev: this
                    },
                    j = l;
                if (i.single) {
                    j = g(j, m, i, k)
                }
                if (i.target) {
                    j = e(j, m, i, k)
                }
                if (i.delay) {
                    j = a(j, m, i, k)
                }
                if (i.buffer) {
                    j = d(j, m, i, k)
                }
                m.fireFn = j;
                return m
            },
            findListener: function(n, m) {
                var l = this.listeners,
                    j = l.length,
                    o, k;
                while (j--) {
                    o = l[j];
                    if (o) {
                        k = o.scope;
                        if (o.fn == n && (k == (m || this.observable))) {
                            return j
                        }
                    }
                }
                return -1
            },
            isListening: function(j, i) {
                return this.findListener(j, i) !== -1
            },
            removeListener: function(m, l) {
                var n = this,
                    j, o, i;
                j = n.findListener(m, l);
                if (j != -1) {
                    o = n.listeners[j];
                    if (n.firing) {
                        n.listeners = n.listeners.slice(0)
                    }
                    if (o.task) {
                        o.task.cancel();
                        delete o.task
                    }
                    i = o.tasks && o.tasks.length;
                    if (i) {
                        while (i--) {
                            o.tasks[i].cancel()
                        }
                        delete o.tasks
                    }
                    Ext.Array.erase(n.listeners, j, 1);
                    return true
                }
                return false
            },
            clearListeners: function() {
                var k = this.listeners,
                    j = k.length;
                while (j--) {
                    this.removeListener(k[j].fn, k[j].scope)
                }
            },
            fire: function() {
                var n = this,
                    l = n.listeners,
                    m = l.length,
                    k, j, o;
                if (m > 0) {
                    n.firing = true;
                    for (k = 0; k < m; k++) {
                        o = l[k];
                        j = arguments.length ? Array.prototype.slice.call(arguments, 0) : [];
                        if (o.o) {
                            j.push(o.o)
                        }
                        if (o && o.fireFn.apply(o.scope || n.observable, j) === false) {
                            return (n.firing = false)
                        }
                    }
                }
                n.firing = false;
                return true
            }
        }
    }()))
});
Ext.EventManager = new function() {
    var a = this,
        e = document,
        d = window,
        c = function() {
            var m = e.body || e.getElementsByTagName("body")[0],
                k = Ext.baseCSSPrefix,
                q = [k + "body"],
                i = [],
                o = Ext.supports.CSS3LinearGradient,
                n = Ext.supports.CSS3BorderRadius,
                j = [],
                l, g;
            if (!m) {
                return false
            }
            l = m.parentNode;

            function p(r) {
                q.push(k + r)
            }
            if (Ext.isIE) {
                p("ie");
                if (Ext.isIE6) {
                    p("ie6")
                } else {
                    p("ie7p");
                    if (Ext.isIE7) {
                        p("ie7")
                    } else {
                        p("ie8p");
                        if (Ext.isIE8) {
                            p("ie8")
                        } else {
                            p("ie9p");
                            if (Ext.isIE9) {
                                p("ie9")
                            }
                        }
                    }
                }
                if (Ext.isIE6 || Ext.isIE7) {
                    p("ie7m")
                }
                if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
                    p("ie8m")
                }
                if (Ext.isIE7 || Ext.isIE8) {
                    p("ie78")
                }
            }
            if (Ext.isGecko) {
                p("gecko");
                if (Ext.isGecko3) {
                    p("gecko3")
                }
                if (Ext.isGecko4) {
                    p("gecko4")
                }
                if (Ext.isGecko5) {
                    p("gecko5")
                }
            }
            if (Ext.isOpera) {
                p("opera")
            }
            if (Ext.isWebKit) {
                p("webkit")
            }
            if (Ext.isSafari) {
                p("safari");
                if (Ext.isSafari2) {
                    p("safari2")
                }
                if (Ext.isSafari3) {
                    p("safari3")
                }
                if (Ext.isSafari4) {
                    p("safari4")
                }
                if (Ext.isSafari5) {
                    p("safari5")
                }
                if (Ext.isSafari5_0) {
                    p("safari5_0")
                }
            }
            if (Ext.isChrome) {
                p("chrome")
            }
            if (Ext.isMac) {
                p("mac")
            }
            if (Ext.isLinux) {
                p("linux")
            }
            if (!n) {
                p("nbr")
            }
            if (!o) {
                p("nlg")
            }
            if (Ext.scopeResetCSS) {
                g = Ext.resetElementSpec = {
                    cls: k + "reset"
                };
                if (!o) {
                    j.push(k + "nlg")
                }
                if (!n) {
                    j.push(k + "nbr")
                }
                if (j.length) {
                    g.cn = {
                        cls: j.join(" ")
                    }
                }
                Ext.resetElement = Ext.getBody().createChild(g);
                if (j.length) {
                    Ext.resetElement = Ext.get(Ext.resetElement.dom.firstChild)
                }
            } else {
                Ext.resetElement = Ext.getBody();
                p("reset")
            }
            if (l) {
                if (Ext.isStrict && (Ext.isIE6 || Ext.isIE7)) {
                    Ext.isBorderBox = false
                } else {
                    Ext.isBorderBox = true
                }
                if (Ext.isBorderBox) {
                    i.push(k + "border-box")
                }
                if (Ext.isStrict) {
                    i.push(k + "strict")
                } else {
                    i.push(k + "quirks")
                }
                Ext.fly(l, "_internal").addCls(i)
            }
            Ext.fly(m, "_internal").addCls(q);
            return true
        };
    Ext.apply(a, {
        hasBoundOnReady: false,
        hasFiredReady: false,
        deferReadyEvent: 1,
        onReadyChain: [],
        readyEvent: (function() {
            var g = new Ext.util.Event();
            g.fire = function() {
                Ext._beforeReadyTime = Ext._beforeReadyTime || new Date().getTime();
                g.self.prototype.fire.apply(g, arguments);
                Ext._afterReadytime = new Date().getTime()
            };
            return g
        }()),
        idleEvent: new Ext.util.Event(),
        isReadyPaused: function() {
            return (/[?&]ext-pauseReadyFire\b/i.test(location.search) && !Ext._continueFireReady)
        },
        bindReadyEvent: function() {
            if (a.hasBoundOnReady) {
                return
            }
            if (e.readyState == "complete") {
                a.onReadyEvent({
                    type: e.readyState || "body"
                })
            } else {
                document.addEventListener("DOMContentLoaded", a.onReadyEvent, false);
                window.addEventListener("load", a.onReadyEvent, false);
                a.hasBoundOnReady = true
            }
        },
        onReadyEvent: function(g) {
            if (g && g.type) {
                a.onReadyChain.push(g.type)
            }
            if (a.hasBoundOnReady) {
                document.removeEventListener("DOMContentLoaded", a.onReadyEvent, false);
                window.removeEventListener("load", a.onReadyEvent, false)
            }
            if (!Ext.isReady) {
                a.fireDocReady()
            }
        },
        fireDocReady: function() {
            if (!Ext.isReady) {
                Ext._readyTime = new Date().getTime();
                Ext.isReady = true;
                Ext.supports.init();
                a.onWindowUnload();
                a.readyEvent.onReadyChain = a.onReadyChain;
                if (Ext.isNumber(a.deferReadyEvent)) {
                    Ext.Function.defer(a.fireReadyEvent, a.deferReadyEvent);
                    a.hasDocReadyTimer = true
                } else {
                    a.fireReadyEvent()
                }
            }
        },
        fireReadyEvent: function() {
            var g = a.readyEvent;
            a.hasDocReadyTimer = false;
            a.isFiring = true;
            while (g.listeners.length && !a.isReadyPaused()) {
                g.fire()
            }
            a.isFiring = false;
            a.hasFiredReady = true
        },
        onDocumentReady: function(j, i, g) {
            g = g || {};
            g.single = true;
            a.readyEvent.addListener(j, i, g);
            if (!(a.isFiring || a.hasDocReadyTimer)) {
                if (Ext.isReady) {
                    a.fireReadyEvent()
                } else {
                    a.bindReadyEvent()
                }
            }
        },
        stoppedMouseDownEvent: new Ext.util.Event(),
        propRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|freezeEvent)$/,
        getId: function(g) {
            var i;
            g = Ext.getDom(g);
            if (g === e || g === d) {
                i = g === e ? Ext.documentId : Ext.windowId
            } else {
                i = Ext.id(g)
            }
            if (!Ext.cache[i]) {
                Ext.addCacheEntry(i, null, g)
            }
            return i
        },
        prepareListenerConfig: function(k, i, m) {
            var n = a.propRe,
                j, l, g;
            for (j in i) {
                if (i.hasOwnProperty(j)) {
                    if (!n.test(j)) {
                        l = i[j];
                        if (typeof l == "function") {
                            g = [k, j, l, i.scope, i]
                        } else {
                            g = [k, j, l.fn, l.scope, l]
                        }
                        if (m) {
                            a.removeListener.apply(a, g)
                        } else {
                            a.addListener.apply(a, g)
                        }
                    }
                }
            }
        },
        mouseEnterLeaveRe: /mouseenter|mouseleave/,
        normalizeEvent: function(g, i) {
            if (a.mouseEnterLeaveRe.test(g) && !Ext.supports.MouseEnterLeave) {
                if (i) {
                    i = Ext.Function.createInterceptor(i, a.contains)
                }
                g = g == "mouseenter" ? "mouseover" : "mouseout"
            } else {
                if (g == "mousewheel" && !Ext.supports.MouseWheel && !Ext.isOpera) {
                    g = "DOMMouseScroll"
                }
            }
            return {
                eventName: g,
                fn: i
            }
        },
        contains: function(i) {
            var g = i.browserEvent.currentTarget,
                j = a.getRelatedTarget(i);
            if (g && g.firstChild) {
                while (j) {
                    if (j === g) {
                        return false
                    }
                    j = j.parentNode;
                    if (j && (j.nodeType != 1)) {
                        j = null
                    }
                }
            }
            return true
        },
        addListener: function(j, g, m, l, i) {
            if (typeof g !== "string") {
                a.prepareListenerConfig(j, g);
                return
            }
            var n = j.dom || Ext.getDom(j),
                o, k;
            i = i || {};
            o = a.normalizeEvent(g, m);
            k = a.createListenerWrap(n, g, o.fn, l, i);
            if (n.attachEvent) {
                n.attachEvent("on" + o.eventName, k)
            } else {
                n.addEventListener(o.eventName, k, i.capture || false)
            }
            if (n == e && g == "mousedown") {
                a.stoppedMouseDownEvent.addListener(k)
            }
            a.getEventListenerCache(j.dom ? j : n, g).push({
                fn: m,
                wrap: k,
                scope: l
            })
        },
        removeListener: function(r, s, t, v) {
            if (typeof s !== "string") {
                a.prepareListenerConfig(r, s, true);
                return
            }
            var p = Ext.getDom(r),
                l = r.dom ? r : Ext.get(p),
                g = a.getEventListenerCache(l, s),
                u = a.normalizeEvent(s).eventName,
                q = g.length,
                o, m, k, n;
            while (q--) {
                m = g[q];
                if (m && (!t || m.fn == t) && (!v || m.scope === v)) {
                    k = m.wrap;
                    if (k.task) {
                        clearTimeout(k.task);
                        delete k.task
                    }
                    o = k.tasks && k.tasks.length;
                    if (o) {
                        while (o--) {
                            clearTimeout(k.tasks[o])
                        }
                        delete k.tasks
                    }
                    if (p.detachEvent) {
                        p.detachEvent("on" + u, k)
                    } else {
                        p.removeEventListener(u, k, false)
                    }
                    if (k && p == e && s == "mousedown") {
                        a.stoppedMouseDownEvent.removeListener(k)
                    }
                    Ext.Array.erase(g, q, 1)
                }
            }
        },
        removeAll: function(k) {
            var l = k.dom ? k : Ext.get(k),
                i, j, g;
            if (!l) {
                return
            }
            i = (l.$cache || l.getCache());
            j = i.events;
            for (g in j) {
                if (j.hasOwnProperty(g)) {
                    a.removeListener(l, g)
                }
            }
            i.events = {}
        },
        purgeElement: function(l, j) {
            var m = Ext.getDom(l),
                k = 0,
                g;
            if (j) {
                a.removeListener(l, j)
            } else {
                a.removeAll(l)
            }
            if (m && m.childNodes) {
                for (g = l.childNodes.length; k < g; k++) {
                    a.purgeElement(l.childNodes[k], j)
                }
            }
        },
        createListenerWrap: function(k, j, n, o, p) {
            p = p || {};
            var m, l, g = /\\/g,
                i = function(r, q) {
                    if (!l) {
                        m = ["if(!" + Ext.name + ") {return;}"];
                        if (p.buffer || p.delay || p.freezeEvent) {
                            m.push("e = new X.EventObjectImpl(e, " + (p.freezeEvent ? "true" : "false") + ");")
                        } else {
                            m.push("e = X.EventObject.setEvent(e);")
                        }
                        if (p.delegate) {
                            m.push('var result, t = e.getTarget("' + (p.delegate + "").replace(g, "\\\\") + '", this);');
                            m.push("if(!t) {return;}")
                        } else {
                            m.push("var t = e.target, result;")
                        }
                        if (p.target) {
                            m.push("if(e.target !== options.target) {return;}")
                        }
                        if (p.stopEvent) {
                            m.push("e.stopEvent();")
                        } else {
                            if (p.preventDefault) {
                                m.push("e.preventDefault();")
                            }
                            if (p.stopPropagation) {
                                m.push("e.stopPropagation();")
                            }
                        }
                        if (p.normalized === false) {
                            m.push("e = e.browserEvent;")
                        }
                        if (p.buffer) {
                            m.push("(wrap.task && clearTimeout(wrap.task));");
                            m.push("wrap.task = setTimeout(function() {")
                        }
                        if (p.delay) {
                            m.push("wrap.tasks = wrap.tasks || [];");
                            m.push("wrap.tasks.push(setTimeout(function() {")
                        }
                        m.push("result = fn.call(scope || dom, e, t, options);");
                        if (p.single) {
                            m.push("evtMgr.removeListener(dom, ename, fn, scope);")
                        }
                        if (j !== "mousemove") {
                            m.push("if (evtMgr.idleEvent.listeners.length) {");
                            m.push("evtMgr.idleEvent.fire();");
                            m.push("}")
                        }
                        if (p.delay) {
                            m.push("}, " + p.delay + "));")
                        }
                        if (p.buffer) {
                            m.push("}, " + p.buffer + ");")
                        }
                        m.push("return result;");
                        l = Ext.cacheableFunctionFactory("e", "options", "fn", "scope", "ename", "dom", "wrap", "args", "X", "evtMgr", m.join("\n"))
                    }
                    return l.call(k, r, p, n, o, j, k, i, q, Ext, a)
                };
            return i
        },
        getEventListenerCache: function(k, g) {
            var j, i;
            if (!k) {
                return []
            }
            if (k.$cache) {
                j = k.$cache
            } else {
                j = Ext.cache[a.getId(k)]
            }
            i = j.events || (j.events = {});
            return i[g] || (i[g] = [])
        },
        mouseLeaveRe: /(mouseout|mouseleave)/,
        mouseEnterRe: /(mouseover|mouseenter)/,
        stopEvent: function(g) {
            a.stopPropagation(g);
            a.preventDefault(g)
        },
        stopPropagation: function(g) {
            g = g.browserEvent || g;
            if (g.stopPropagation) {
                g.stopPropagation()
            } else {
                g.cancelBubble = true
            }
        },
        preventDefault: function(g) {
            g = g.browserEvent || g;
            if (g.preventDefault) {
                g.preventDefault()
            } else {
                g.returnValue = false;
                try {
                    if (g.ctrlKey || g.keyCode > 111 && g.keyCode < 124) {
                        g.keyCode = -1
                    }
                } catch (i) {}
            }
        },
        getRelatedTarget: function(g) {
            g = g.browserEvent || g;
            var i = g.relatedTarget;
            if (!i) {
                if (a.mouseLeaveRe.test(g.type)) {
                    i = g.toElement
                } else {
                    if (a.mouseEnterRe.test(g.type)) {
                        i = g.fromElement
                    }
                }
            }
            return a.resolveTextNode(i)
        },
        getPageX: function(g) {
            return a.getPageXY(g)[0]
        },
        getPageY: function(g) {
            return a.getPageXY(g)[1]
        },
        getPageXY: function(j) {
            j = j.browserEvent || j;
            var i = j.pageX,
                l = j.pageY,
                k = e.documentElement,
                g = e.body;
            if (!i && i !== 0) {
                i = j.clientX + (k && k.scrollLeft || g && g.scrollLeft || 0) - (k && k.clientLeft || g && g.clientLeft || 0);
                l = j.clientY + (k && k.scrollTop || g && g.scrollTop || 0) - (k && k.clientTop || g && g.clientTop || 0)
            }
            return [i, l]
        },
        getTarget: function(g) {
            g = g.browserEvent || g;
            return a.resolveTextNode(g.target || g.srcElement)
        },
        resolveTextNode: Ext.isGecko ? function(i) {
            if (!i) {
                return
            }
            var g = HTMLElement.prototype.toString.call(i);
            if (g == "[xpconnect wrapped native prototype]" || g == "[object XULElement]") {
                return
            }
            return i.nodeType == 3 ? i.parentNode : i
        } : function(g) {
            return g && g.nodeType == 3 ? g.parentNode : g
        },
        curWidth: 0,
        curHeight: 0,
        onWindowResize: function(k, j, i) {
            var g = a.resizeEvent;
            if (!g) {
                a.resizeEvent = g = new Ext.util.Event();
                a.on(d, "resize", a.fireResize, null, {
                    buffer: 100
                })
            }
            g.addListener(k, j, i)
        },
        fireResize: function() {
            var g = Ext.Element.getViewWidth(),
                i = Ext.Element.getViewHeight();
            if (a.curHeight != i || a.curWidth != g) {
                a.curHeight = i;
                a.curWidth = g;
                a.resizeEvent.fire(g, i)
            }
        },
        removeResizeListener: function(j, i) {
            var g = a.resizeEvent;
            if (g) {
                g.removeListener(j, i)
            }
        },
        onWindowUnload: function(k, j, i) {
            var g = a.unloadEvent;
            if (!g) {
                a.unloadEvent = g = new Ext.util.Event();
                a.addListener(d, "unload", a.fireUnload)
            }
            if (k) {
                g.addListener(k, j, i)
            }
        },
        fireUnload: function() {
            try {
                e = d = undefined;
                var n, j, l, k, g;
                a.unloadEvent.fire();
                if (Ext.isGecko3) {
                    n = Ext.ComponentQuery.query("gridview");
                    j = 0;
                    l = n.length;
                    for (; j < l; j++) {
                        n[j].scrollToTop()
                    }
                }
                g = Ext.cache;
                for (k in g) {
                    if (g.hasOwnProperty(k)) {
                        a.removeAll(k)
                    }
                }
            } catch (m) {}
        },
        removeUnloadListener: function(j, i) {
            var g = a.unloadEvent;
            if (g) {
                g.removeListener(j, i)
            }
        },
        useKeyDown: Ext.isWebKit ? parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 : !((Ext.isGecko && !Ext.isWindows) || Ext.isOpera),
        getKeyEvent: function() {
            return a.useKeyDown ? "keydown" : "keypress"
        }
    });
    if (!("addEventListener" in document) && document.attachEvent) {
        Ext.apply(a, {
            pollScroll: function() {
                var g = true;
                try {
                    document.documentElement.doScroll("left")
                } catch (i) {
                    g = false
                }
                if (g && document.body) {
                    a.onReadyEvent({
                        type: "doScroll"
                    })
                } else {
                    a.scrollTimeout = setTimeout(a.pollScroll, 20)
                }
                return g
            },
            scrollTimeout: null,
            readyStatesRe: /complete/i,
            checkReadyState: function() {
                var g = document.readyState;
                if (a.readyStatesRe.test(g)) {
                    a.onReadyEvent({
                        type: g
                    })
                }
            },
            bindReadyEvent: function() {
                var g = true;
                if (a.hasBoundOnReady) {
                    return
                }
                try {
                    g = window.frameElement === undefined
                } catch (i) {
                    g = false
                }
                if (!g || !e.documentElement.doScroll) {
                    a.pollScroll = Ext.emptyFn
                }
                if (a.pollScroll() === true) {
                    return
                }
                if (e.readyState == "complete") {
                    a.onReadyEvent({
                        type: "already " + (e.readyState || "body")
                    })
                } else {
                    e.attachEvent("onreadystatechange", a.checkReadyState);
                    window.attachEvent("onload", a.onReadyEvent);
                    a.hasBoundOnReady = true
                }
            },
            onReadyEvent: function(g) {
                if (g && g.type) {
                    a.onReadyChain.push(g.type)
                }
                if (a.hasBoundOnReady) {
                    document.detachEvent("onreadystatechange", a.checkReadyState);
                    window.detachEvent("onload", a.onReadyEvent)
                }
                if (Ext.isNumber(a.scrollTimeout)) {
                    clearTimeout(a.scrollTimeout);
                    delete a.scrollTimeout
                }
                if (!Ext.isReady) {
                    a.fireDocReady()
                }
            },
            onReadyChain: []
        })
    }
    Ext.onReady = function(j, i, g) {
        Ext.Loader.onReady(j, i, true, g)
    };
    Ext.onDocumentReady = a.onDocumentReady;
    a.on = a.addListener;
    a.un = a.removeListener;
    Ext.onReady(c)
};
Ext.define("Ext.EventObjectImpl", {
    uses: ["Ext.util.Point"],
    BACKSPACE: 8,
    TAB: 9,
    NUM_CENTER: 12,
    ENTER: 13,
    RETURN: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    CONTEXT_MENU: 93,
    NUM_ZERO: 96,
    NUM_ONE: 97,
    NUM_TWO: 98,
    NUM_THREE: 99,
    NUM_FOUR: 100,
    NUM_FIVE: 101,
    NUM_SIX: 102,
    NUM_SEVEN: 103,
    NUM_EIGHT: 104,
    NUM_NINE: 105,
    NUM_MULTIPLY: 106,
    NUM_PLUS: 107,
    NUM_MINUS: 109,
    NUM_PERIOD: 110,
    NUM_DIVISION: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    WHEEL_SCALE: (function() {
        var a;
        if (Ext.isGecko) {
            a = 3
        } else {
            if (Ext.isMac) {
                if (Ext.isSafari && Ext.webKitVersion >= 532) {
                    a = 120
                } else {
                    a = 12
                }
                a *= 3
            } else {
                a = 120
            }
        }
        return a
    }()),
    clickRe: /(dbl)?click/,
    safariKeys: {
        3: 13,
        63234: 37,
        63235: 39,
        63232: 38,
        63233: 40,
        63276: 33,
        63277: 34,
        63272: 46,
        63273: 36,
        63275: 35
    },
    btnMap: Ext.isIE ? {
        1: 0,
        4: 1,
        2: 2
    } : {
        0: 0,
        1: 1,
        2: 2
    },
    constructor: function(a, c) {
        if (a) {
            this.setEvent(a.browserEvent || a, c)
        }
    },
    setEvent: function(e, g) {
        var d = this,
            c, a;
        if (e == d || (e && e.browserEvent)) {
            return e
        }
        d.browserEvent = e;
        if (e) {
            c = e.button ? d.btnMap[e.button] : (e.which ? e.which - 1 : -1);
            if (d.clickRe.test(e.type) && c == -1) {
                c = 0
            }
            a = {
                type: e.type,
                button: c,
                shiftKey: e.shiftKey,
                ctrlKey: e.ctrlKey || e.metaKey || false,
                altKey: e.altKey,
                keyCode: e.keyCode,
                charCode: e.charCode,
                target: Ext.EventManager.getTarget(e),
                relatedTarget: Ext.EventManager.getRelatedTarget(e),
                currentTarget: e.currentTarget,
                xy: (g ? d.getXY() : null)
            }
        } else {
            a = {
                button: -1,
                shiftKey: false,
                ctrlKey: false,
                altKey: false,
                keyCode: 0,
                charCode: 0,
                target: null,
                xy: [0, 0]
            }
        }
        Ext.apply(d, a);
        return d
    },
    stopEvent: function() {
        this.stopPropagation();
        this.preventDefault()
    },
    preventDefault: function() {
        if (this.browserEvent) {
            Ext.EventManager.preventDefault(this.browserEvent)
        }
    },
    stopPropagation: function() {
        var a = this.browserEvent;
        if (a) {
            if (a.type == "mousedown") {
                Ext.EventManager.stoppedMouseDownEvent.fire(this)
            }
            Ext.EventManager.stopPropagation(a)
        }
    },
    getCharCode: function() {
        return this.charCode || this.keyCode
    },
    getKey: function() {
        return this.normalizeKey(this.keyCode || this.charCode)
    },
    normalizeKey: function(a) {
        return Ext.isWebKit ? (this.safariKeys[a] || a) : a
    },
    getPageX: function() {
        return this.getX()
    },
    getPageY: function() {
        return this.getY()
    },
    getX: function() {
        return this.getXY()[0]
    },
    getY: function() {
        return this.getXY()[1]
    },
    getXY: function() {
        if (!this.xy) {
            this.xy = Ext.EventManager.getPageXY(this.browserEvent)
        }
        return this.xy
    },
    getTarget: function(c, d, a) {
        if (c) {
            return Ext.fly(this.target).findParent(c, d, a)
        }
        return a ? Ext.get(this.target) : this.target
    },
    getRelatedTarget: function(c, d, a) {
        if (c) {
            return Ext.fly(this.relatedTarget).findParent(c, d, a)
        }
        return a ? Ext.get(this.relatedTarget) : this.relatedTarget
    },
    correctWheelDelta: function(d) {
        var c = this.WHEEL_SCALE,
            a = Math.round(d / c);
        if (!a && d) {
            a = (d < 0) ? -1 : 1
        }
        return a
    },
    getWheelDeltas: function() {
        var e = this,
            d = e.browserEvent,
            c = 0,
            a = 0;
        if (Ext.isDefined(d.wheelDeltaX)) {
            c = d.wheelDeltaX;
            a = d.wheelDeltaY
        } else {
            if (d.wheelDelta) {
                a = d.wheelDelta
            } else {
                if (d.detail) {
                    a = -d.detail;
                    if (a > 100) {
                        a = 3
                    } else {
                        if (a < -100) {
                            a = -3
                        }
                    }
                    if (Ext.isDefined(d.axis) && d.axis === d.HORIZONTAL_AXIS) {
                        c = a;
                        a = 0
                    }
                }
            }
        }
        return {
            x: e.correctWheelDelta(c),
            y: e.correctWheelDelta(a)
        }
    },
    getWheelDelta: function() {
        var a = this.getWheelDeltas();
        return a.y
    },
    within: function(e, g, c) {
        if (e) {
            var d = g ? this.getRelatedTarget() : this.getTarget(),
                a;
            if (d) {
                a = Ext.fly(e).contains(d);
                if (!a && c) {
                    a = d == Ext.getDom(e)
                }
                return a
            }
        }
        return false
    },
    isNavKeyPress: function() {
        var c = this,
            a = this.normalizeKey(c.keyCode);
        return (a >= 33 && a <= 40) || a == c.RETURN || a == c.TAB || a == c.ESC
    },
    isSpecialKey: function() {
        var a = this.normalizeKey(this.keyCode);
        return (this.type == "keypress" && this.ctrlKey) || this.isNavKeyPress() || (a == this.BACKSPACE) || (a >= 16 && a <= 20) || (a >= 44 && a <= 46)
    },
    getPoint: function() {
        var a = this.getXY();
        return new Ext.util.Point(a[0], a[1])
    },
    hasModifier: function() {
        return this.ctrlKey || this.altKey || this.shiftKey || this.metaKey
    },
    injectEvent: (function() {
        var e, g = {},
            d;
        if (!Ext.isIE && document.createEvent) {
            e = {
                createHtmlEvent: function(m, k, j, i) {
                    var l = m.createEvent("HTMLEvents");
                    l.initEvent(k, j, i);
                    return l
                },
                createMouseEvent: function(x, u, o, n, q, m, k, l, i, t, s, p, r) {
                    var j = x.createEvent("MouseEvents"),
                        v = x.defaultView || window;
                    if (j.initMouseEvent) {
                        j.initMouseEvent(u, o, n, v, q, m, k, m, k, l, i, t, s, p, r)
                    } else {
                        j = x.createEvent("UIEvents");
                        j.initEvent(u, o, n);
                        j.view = v;
                        j.detail = q;
                        j.screenX = m;
                        j.screenY = k;
                        j.clientX = m;
                        j.clientY = k;
                        j.ctrlKey = l;
                        j.altKey = i;
                        j.metaKey = s;
                        j.shiftKey = t;
                        j.button = p;
                        j.relatedTarget = r
                    }
                    return j
                },
                createUIEvent: function(o, m, k, j, l) {
                    var n = o.createEvent("UIEvents"),
                        i = o.defaultView || window;
                    n.initUIEvent(m, k, j, i, l);
                    return n
                },
                fireEvent: function(k, i, j) {
                    k.dispatchEvent(j)
                },
                fixTarget: function(i) {
                    if (i == window && !i.dispatchEvent) {
                        return document
                    }
                    return i
                }
            }
        } else {
            if (document.createEventObject) {
                d = {
                    0: 1,
                    1: 4,
                    2: 2
                };
                e = {
                    createHtmlEvent: function(m, k, j, i) {
                        var l = m.createEventObject();
                        l.bubbles = j;
                        l.cancelable = i;
                        return l
                    },
                    createMouseEvent: function(v, u, o, n, q, m, k, l, i, t, s, p, r) {
                        var j = v.createEventObject();
                        j.bubbles = o;
                        j.cancelable = n;
                        j.detail = q;
                        j.screenX = m;
                        j.screenY = k;
                        j.clientX = m;
                        j.clientY = k;
                        j.ctrlKey = l;
                        j.altKey = i;
                        j.shiftKey = t;
                        j.metaKey = s;
                        j.button = d[p] || p;
                        j.relatedTarget = r;
                        return j
                    },
                    createUIEvent: function(n, l, j, i, k) {
                        var m = n.createEventObject();
                        m.bubbles = j;
                        m.cancelable = i;
                        return m
                    },
                    fireEvent: function(k, i, j) {
                        k.fireEvent("on" + i, j)
                    },
                    fixTarget: function(i) {
                        if (i == document) {
                            return document.documentElement
                        }
                        return i
                    }
                }
            }
        }
        Ext.Object.each({
            load: [false, false],
            unload: [false, false],
            select: [true, false],
            change: [true, false],
            submit: [true, true],
            reset: [true, false],
            resize: [true, false],
            scroll: [true, false]
        }, function(k, l) {
            var j = l[0],
                i = l[1];
            g[k] = function(o, m) {
                var n = e.createHtmlEvent(k, j, i);
                e.fireEvent(o, k, n)
            }
        });

        function c(k, j) {
            var i = (k != "mousemove");
            return function(o, l) {
                var n = l.getXY(),
                    m = e.createMouseEvent(o.ownerDocument, k, true, i, j, n[0], n[1], l.ctrlKey, l.altKey, l.shiftKey, l.metaKey, l.button, l.relatedTarget);
                e.fireEvent(o, k, m)
            }
        }
        Ext.each(["click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout"], function(i) {
            g[i] = c(i, 1)
        });
        Ext.Object.each({
            focusin: [true, false],
            focusout: [true, false],
            activate: [true, true],
            focus: [false, false],
            blur: [false, false]
        }, function(k, l) {
            var j = l[0],
                i = l[1];
            g[k] = function(o, m) {
                var n = e.createUIEvent(o.ownerDocument, k, j, i, 1);
                e.fireEvent(o, k, n)
            }
        });
        if (!e) {
            g = {};
            e = {
                fixTarget: function(i) {
                    return i
                }
            }
        }

        function a(j, i) {}
        return function(l) {
            var k = this,
                j = g[k.type] || a,
                i = l ? (l.dom || l) : k.getTarget();
            i = e.fixTarget(i);
            j(i, k)
        }
    }())
}, function() {
    Ext.EventObject = new Ext.EventObjectImpl()
});
Ext.define("Ext.dom.AbstractQuery", {
    select: function(m, c) {
        var l = [],
            e, k, g, d, a;
        c = c || document;
        if (typeof c == "string") {
            c = document.getElementById(c)
        }
        m = m.split(",");
        for (k = 0, d = m.length; k < d; k++) {
            if (typeof m[k] == "string") {
                if (typeof m[k][0] == "@") {
                    e = c.getAttributeNode(m[k].substring(1));
                    l.push(e)
                } else {
                    e = c.querySelectorAll(m[k]);
                    for (g = 0, a = e.length; g < a; g++) {
                        l.push(e[g])
                    }
                }
            }
        }
        return l
    },
    selectNode: function(c, a) {
        return this.select(c, a)[0]
    },
    is: function(a, c) {
        if (typeof a == "string") {
            a = document.getElementById(a)
        }
        return this.select(c).indexOf(a) !== -1
    }
});
Ext.define("Ext.dom.AbstractHelper", {
    emptyTags: /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i,
    confRe: /(?:tag|children|cn|html|tpl|tplData)$/i,
    endRe: /end/i,
    attributeTransform: {
        cls: "class",
        htmlFor: "for"
    },
    closeTags: {},
    decamelizeName: (function() {
        var d = /([a-z])([A-Z])/g,
            c = {};

        function a(e, i, g) {
            return i + "-" + g.toLowerCase()
        }
        return function(e) {
            return c[e] || (c[e] = e.replace(d, a))
        }
    }()),
    generateMarkup: function(e, d) {
        var k = this,
            c, l, a, g, j;
        if (typeof e == "string") {
            d.push(e)
        } else {
            if (Ext.isArray(e)) {
                for (g = 0; g < e.length; g++) {
                    if (e[g]) {
                        k.generateMarkup(e[g], d)
                    }
                }
            } else {
                a = e.tag || "div";
                d.push("<", a);
                for (c in e) {
                    if (e.hasOwnProperty(c)) {
                        l = e[c];
                        if (!k.confRe.test(c)) {
                            if (typeof l == "object") {
                                d.push(" ", c, '="');
                                k.generateStyles(l, d).push('"')
                            } else {
                                d.push(" ", k.attributeTransform[c] || c, '="', l, '"')
                            }
                        }
                    }
                }
                if (k.emptyTags.test(a)) {
                    d.push("/>")
                } else {
                    d.push(">");
                    if ((l = e.tpl)) {
                        l.applyOut(e.tplData, d)
                    }
                    if ((l = e.html)) {
                        d.push(l)
                    }
                    if ((l = e.cn || e.children)) {
                        k.generateMarkup(l, d)
                    }
                    j = k.closeTags;
                    d.push(j[a] || (j[a] = "</" + a + ">"))
                }
            }
        }
        return d
    },
    generateStyles: function(g, d) {
        var c = d || [],
            e;
        for (e in g) {
            if (g.hasOwnProperty(e)) {
                c.push(this.decamelizeName(e), ":", g[e], ";")
            }
        }
        return d || c.join("")
    },
    markup: function(a) {
        if (typeof a == "string") {
            return a
        }
        var c = this.generateMarkup(a, []);
        return c.join("")
    },
    applyStyles: function(e, g) {
        if (g) {
            var c = 0,
                a, d;
            e = Ext.fly(e);
            if (typeof g == "function") {
                g = g.call()
            }
            if (typeof g == "string") {
                g = Ext.util.Format.trim(g).split(/\s*(?::|;)\s*/);
                for (a = g.length; c < a;) {
                    e.setStyle(g[c++], g[c++])
                }
            } else {
                if (Ext.isObject(g)) {
                    e.setStyle(g)
                }
            }
        }
    },
    insertHtml: function(i, a, j) {
        var g = {},
            d, l, k, m, e, c;
        i = i.toLowerCase();
        g.beforebegin = ["BeforeBegin", "previousSibling"];
        g.afterend = ["AfterEnd", "nextSibling"];
        k = a.ownerDocument.createRange();
        l = "setStart" + (this.endRe.test(i) ? "After" : "Before");
        if (g[i]) {
            k[l](a);
            m = k.createContextualFragment(j);
            a.parentNode.insertBefore(m, i == "beforebegin" ? a : a.nextSibling);
            return a[(i == "beforebegin" ? "previous" : "next") + "Sibling"]
        } else {
            e = (i == "afterbegin" ? "first" : "last") + "Child";
            if (a.firstChild) {
                k[l](a[e]);
                m = k.createContextualFragment(j);
                if (i == "afterbegin") {
                    a.insertBefore(m, a.firstChild)
                } else {
                    a.appendChild(m)
                }
            } else {
                a.innerHTML = j
            }
            return a[e]
        }
        throw 'Illegal insertion point -> "' + i + '"'
    },
    insertBefore: function(a, d, c) {
        return this.doInsert(a, d, c, "beforebegin")
    },
    insertAfter: function(a, d, c) {
        return this.doInsert(a, d, c, "afterend", "nextSibling")
    },
    insertFirst: function(a, d, c) {
        return this.doInsert(a, d, c, "afterbegin", "firstChild")
    },
    append: function(a, d, c) {
        return this.doInsert(a, d, c, "beforeend", "", true)
    },
    overwrite: function(a, d, c) {
        a = Ext.getDom(a);
        a.innerHTML = this.markup(d);
        return c ? Ext.get(a.firstChild) : a.firstChild
    },
    doInsert: function(e, i, g, j, d, a) {
        var c = this.insertHtml(j, Ext.getDom(e), this.markup(i));
        return g ? Ext.get(c, true) : c
    }
});
(function() {
    var a = window.document,
        c = /^\s+|\s+$/g,
        d = /\s/;
    if (!Ext.cache) {
        Ext.cache = {}
    }
    Ext.define("Ext.dom.AbstractElement", {
        inheritableStatics: {
            get: function(g) {
                var i = this,
                    j = Ext.dom.Element,
                    e, l, k, m;
                if (!g) {
                    return null
                }
                if (typeof g == "string") {
                    if (g == Ext.windowId) {
                        return j.get(window)
                    } else {
                        if (g == Ext.documentId) {
                            return j.get(a)
                        }
                    }
                    e = Ext.cache[g];
                    if (e && e.skipGarbageCollection) {
                        l = e.el;
                        return l
                    }
                    if (!(k = a.getElementById(g))) {
                        return null
                    }
                    if (e && e.el) {
                        l = Ext.updateCacheEntry(e, k).el
                    } else {
                        l = new j(k, !!e)
                    }
                    return l
                } else {
                    if (g.tagName) {
                        if (!(m = g.id)) {
                            m = Ext.id(g)
                        }
                        e = Ext.cache[m];
                        if (e && e.el) {
                            l = Ext.updateCacheEntry(e, g).el
                        } else {
                            l = new j(g, !!e)
                        }
                        return l
                    } else {
                        if (g instanceof i) {
                            if (g != i.docEl && g != i.winEl) {
                                m = g.id;
                                e = Ext.cache[m];
                                if (e) {
                                    Ext.updateCacheEntry(e, a.getElementById(m) || g.dom)
                                }
                            }
                            return g
                        } else {
                            if (g.isComposite) {
                                return g
                            } else {
                                if (Ext.isArray(g)) {
                                    return i.select(g)
                                } else {
                                    if (g === a) {
                                        if (!i.docEl) {
                                            i.docEl = Ext.Object.chain(j.prototype);
                                            i.docEl.dom = a;
                                            i.docEl.id = Ext.id(a);
                                            i.addToCache(i.docEl)
                                        }
                                        return i.docEl
                                    } else {
                                        if (g === window) {
                                            if (!i.winEl) {
                                                i.winEl = Ext.Object.chain(j.prototype);
                                                i.winEl.dom = window;
                                                i.winEl.id = Ext.id(window);
                                                i.addToCache(i.winEl)
                                            }
                                            return i.winEl
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return null
            },
            addToCache: function(e, g) {
                if (e) {
                    Ext.addCacheEntry(g, e)
                }
                return e
            },
            addMethods: function() {
                this.override.apply(this, arguments)
            },
            mergeClsList: function() {
                var p, o = {},
                    m, e, k, n, g, q = [],
                    l = false;
                for (m = 0, e = arguments.length; m < e; m++) {
                    p = arguments[m];
                    if (Ext.isString(p)) {
                        p = p.replace(c, "").split(d)
                    }
                    if (p) {
                        for (k = 0, n = p.length; k < n; k++) {
                            g = p[k];
                            if (!o[g]) {
                                if (m) {
                                    l = true
                                }
                                o[g] = true
                            }
                        }
                    }
                }
                for (g in o) {
                    q.push(g)
                }
                q.changed = l;
                return q
            },
            removeCls: function(j, n) {
                var g = {},
                    k, m, l, e = [],
                    o = false;
                if (j) {
                    if (Ext.isString(j)) {
                        j = j.replace(c, "").split(d)
                    }
                    for (k = 0, m = j.length; k < m; k++) {
                        g[j[k]] = true
                    }
                }
                if (n) {
                    if (Ext.isString(n)) {
                        n = n.split(d)
                    }
                    for (k = 0, m = n.length; k < m; k++) {
                        l = n[k];
                        if (g[l]) {
                            o = true;
                            delete g[l]
                        }
                    }
                }
                for (l in g) {
                    e.push(l)
                }
                e.changed = o;
                return e
            },
            VISIBILITY: 1,
            DISPLAY: 2,
            OFFSETS: 3,
            ASCLASS: 4
        },
        constructor: function(e, g) {
            var i = this,
                j = typeof e == "string" ? a.getElementById(e) : e,
                k;
            if (!j) {
                return null
            }
            k = j.id;
            if (!g && k && Ext.cache[k]) {
                return Ext.cache[k].el
            }
            i.dom = j;
            i.id = k || Ext.id(j);
            i.self.addToCache(i)
        },
        set: function(k, g) {
            var i = this.dom,
                e, j;
            for (e in k) {
                if (k.hasOwnProperty(e)) {
                    j = k[e];
                    if (e == "style") {
                        this.applyStyles(j)
                    } else {
                        if (e == "cls") {
                            i.className = j
                        } else {
                            if (g !== false) {
                                if (j === undefined) {
                                    i.removeAttribute(e)
                                } else {
                                    i.setAttribute(e, j)
                                }
                            } else {
                                i[e] = j
                            }
                        }
                    }
                }
            }
            return this
        },
        defaultUnit: "px",
        is: function(e) {
            return Ext.DomQuery.is(this.dom, e)
        },
        getValue: function(e) {
            var g = this.dom.value;
            return e ? parseInt(g, 10) : g
        },
        remove: function() {
            var e = this,
                g = e.dom;
            if (g) {
                Ext.removeNode(g);
                delete e.dom
            }
        },
        contains: function(e) {
            if (!e) {
                return false
            }
            var g = this,
                i = e.dom || e;
            return (i === g.dom) || Ext.dom.AbstractElement.isAncestor(g.dom, i)
        },
        getAttribute: function(e, g) {
            var i = this.dom;
            return i.getAttributeNS(g, e) || i.getAttribute(g + ":" + e) || i.getAttribute(e) || i[e]
        },
        update: function(e) {
            if (this.dom) {
                this.dom.innerHTML = e
            }
            return this
        },
        setHTML: function(e) {
            if (this.dom) {
                this.dom.innerHTML = e
            }
            return this
        },
        getHTML: function() {
            return this.dom ? this.dom.innerHTML : ""
        },
        hide: function() {
            this.setVisible(false);
            return this
        },
        show: function() {
            this.setVisible(true);
            return this
        },
        setVisible: function(l, e) {
            var g = this,
                k = g.self,
                j = g.getVisibilityMode(),
                i = Ext.baseCSSPrefix;
            switch (j) {
                case k.VISIBILITY:
                    g.removeCls([i + "hidden-display", i + "hidden-offsets"]);
                    g[l ? "removeCls" : "addCls"](i + "hidden-visibility");
                    break;
                case k.DISPLAY:
                    g.removeCls([i + "hidden-visibility", i + "hidden-offsets"]);
                    g[l ? "removeCls" : "addCls"](i + "hidden-display");
                    break;
                case k.OFFSETS:
                    g.removeCls([i + "hidden-visibility", i + "hidden-display"]);
                    g[l ? "removeCls" : "addCls"](i + "hidden-offsets");
                    break
            }
            return g
        },
        getVisibilityMode: function() {
            var g = (this.$cache || this.getCache()).data,
                e = g.visibilityMode;
            if (e === undefined) {
                g.visibilityMode = e = this.self.DISPLAY
            }
            return e
        },
        setVisibilityMode: function(e) {
            (this.$cache || this.getCache()).data.visibilityMode = e;
            return this
        },
        getCache: function() {
            var e = this,
                g = e.dom.id || Ext.id(e.dom);
            e.$cache = Ext.cache[g] || Ext.addCacheEntry(g, null, e.dom);
            return e.$cache
        }
    }, function() {
        var e = this;
        Ext.getDetachedBody = function() {
            var g = e.detachedBodyEl;
            if (!g) {
                g = a.createElement("div");
                e.detachedBodyEl = g = new e.Fly(g);
                g.isDetachedBody = true
            }
            return g
        };
        Ext.getElementById = function(j) {
            var i = a.getElementById(j),
                g;
            if (!i && (g = e.detachedBodyEl)) {
                i = g.dom.querySelector("#" + Ext.escapeId(j))
            }
            return i
        };
        Ext.get = function(g) {
            return Ext.dom.Element.get(g)
        };
        this.addStatics({
            Fly: new Ext.Class({
                extend: e,
                isFly: true,
                constructor: function(g) {
                    this.dom = g
                },
                attach: function(g) {
                    this.dom = g;
                    this.$cache = g.id ? Ext.cache[g.id] : null;
                    return this
                }
            }),
            _flyweights: {},
            fly: function(k, i) {
                var j = null,
                    g = e._flyweights;
                i = i || "_global";
                k = Ext.getDom(k);
                if (k) {
                    j = g[i] || (g[i] = new e.Fly());
                    j.dom = k;
                    j.$cache = k.id ? Ext.cache[k.id] : null
                }
                return j
            }
        });
        Ext.fly = function() {
            return e.fly.apply(e, arguments)
        };
        (function(g) {
            g.destroy = g.remove;
            if (a.querySelector) {
                g.getById = function(k, i) {
                    var j = a.getElementById(k) || this.dom.querySelector("#" + Ext.escapeId(k));
                    return i ? j : (j ? Ext.get(j) : null)
                }
            } else {
                g.getById = function(k, i) {
                    var j = a.getElementById(k);
                    return i ? j : (j ? Ext.get(j) : null)
                }
            }
        }(this.prototype))
    })
}());
Ext.dom.AbstractElement.addInheritableStatics({
    unitRe: /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i,
    camelRe: /(-[a-z])/gi,
    cssRe: /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*);?/gi,
    opacityRe: /alpha\(opacity=(.*)\)/i,
    propertyCache: {},
    defaultUnit: "px",
    borders: {
        l: "border-left-width",
        r: "border-right-width",
        t: "border-top-width",
        b: "border-bottom-width"
    },
    paddings: {
        l: "padding-left",
        r: "padding-right",
        t: "padding-top",
        b: "padding-bottom"
    },
    margins: {
        l: "margin-left",
        r: "margin-right",
        t: "margin-top",
        b: "margin-bottom"
    },
    addUnits: function(c, a) {
        if (typeof c == "number") {
            return c + (a || this.defaultUnit || "px")
        }
        if (c === "" || c == "auto" || c === undefined || c === null) {
            return c || ""
        }
        if (!this.unitRe.test(c)) {
            return c || ""
        }
        return c
    },
    isAncestor: function(d, e) {
        var a = false;
        d = Ext.getDom(d);
        e = Ext.getDom(e);
        if (d && e) {
            if (d.contains) {
                return d.contains(e)
            } else {
                if (d.compareDocumentPosition) {
                    return !!(d.compareDocumentPosition(e) & 16)
                } else {
                    while ((e = e.parentNode)) {
                        a = e == d || a
                    }
                }
            }
        }
        return a
    },
    parseBox: function(c) {
        if (typeof c != "string") {
            c = c.toString()
        }
        var d = c.split(" "),
            a = d.length;
        if (a == 1) {
            d[1] = d[2] = d[3] = d[0]
        } else {
            if (a == 2) {
                d[2] = d[0];
                d[3] = d[1]
            } else {
                if (a == 3) {
                    d[3] = d[1]
                }
            }
        }
        return {
            top: parseFloat(d[0]) || 0,
            right: parseFloat(d[1]) || 0,
            bottom: parseFloat(d[2]) || 0,
            left: parseFloat(d[3]) || 0
        }
    },
    unitizeBox: function(g, e) {
        var d = this.addUnits,
            c = this.parseBox(g);
        return d(c.top, e) + " " + d(c.right, e) + " " + d(c.bottom, e) + " " + d(c.left, e)
    },
    camelReplaceFn: function(c, d) {
        return d.charAt(1).toUpperCase()
    },
    normalize: function(a) {
        if (a == "float") {
            a = Ext.supports.Float ? "cssFloat" : "styleFloat"
        }
        return this.propertyCache[a] || (this.propertyCache[a] = a.replace(this.camelRe, this.camelReplaceFn))
    },
    getDocumentHeight: function() {
        return Math.max(!Ext.isStrict ? document.body.scrollHeight : document.documentElement.scrollHeight, this.getViewportHeight())
    },
    getDocumentWidth: function() {
        return Math.max(!Ext.isStrict ? document.body.scrollWidth : document.documentElement.scrollWidth, this.getViewportWidth())
    },
    getViewportHeight: function() {
        return window.innerHeight
    },
    getViewportWidth: function() {
        return window.innerWidth
    },
    getViewSize: function() {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        }
    },
    getOrientation: function() {
        if (Ext.supports.OrientationChange) {
            return (window.orientation == 0) ? "portrait" : "landscape"
        }
        return (window.innerHeight > window.innerWidth) ? "portrait" : "landscape"
    },
    fromPoint: function(a, c) {
        return Ext.get(document.elementFromPoint(a, c))
    },
    parseStyles: function(d) {
        var a = {},
            c = this.cssRe,
            e;
        if (d) {
            c.lastIndex = 0;
            while ((e = c.exec(d))) {
                a[e[1]] = e[2]
            }
        }
        return a
    }
});
(function() {
    var i = document,
        a = Ext.dom.AbstractElement,
        g = null,
        e = i.compatMode == "CSS1Compat",
        d, c = function(k) {
            if (!d) {
                d = new a.Fly()
            }
            d.attach(k);
            return d
        };
    if (!("activeElement" in i) && i.addEventListener) {
        i.addEventListener("focus", function(k) {
            if (k && k.target) {
                g = (k.target == i) ? null : k.target
            }
        }, true)
    }

    function j(l, m, k) {
        return function() {
            l.selectionStart = m;
            l.selectionEnd = k
        }
    }
    a.addInheritableStatics({
        getActiveElement: function() {
            return i.activeElement || g
        },
        getRightMarginFixCleaner: function(p) {
            var m = Ext.supports,
                n = m.DisplayChangeInputSelectionBug,
                o = m.DisplayChangeTextAreaSelectionBug,
                q, k, r, l;
            if (n || o) {
                q = i.activeElement || g;
                k = q && q.tagName;
                if ((o && k == "TEXTAREA") || (n && k == "INPUT" && q.type == "text")) {
                    if (Ext.dom.Element.isAncestor(p, q)) {
                        r = q.selectionStart;
                        l = q.selectionEnd;
                        if (Ext.isNumber(r) && Ext.isNumber(l)) {
                            return j(q, r, l)
                        }
                    }
                }
            }
            return Ext.emptyFn
        },
        getViewWidth: function(k) {
            return k ? Ext.dom.Element.getDocumentWidth() : Ext.dom.Element.getViewportWidth()
        },
        getViewHeight: function(k) {
            return k ? Ext.dom.Element.getDocumentHeight() : Ext.dom.Element.getViewportHeight()
        },
        getDocumentHeight: function() {
            return Math.max(!e ? i.body.scrollHeight : i.documentElement.scrollHeight, Ext.dom.Element.getViewportHeight())
        },
        getDocumentWidth: function() {
            return Math.max(!e ? i.body.scrollWidth : i.documentElement.scrollWidth, Ext.dom.Element.getViewportWidth())
        },
        getViewportHeight: function() {
            return Ext.isIE ? (Ext.isStrict ? i.documentElement.clientHeight : i.body.clientHeight) : self.innerHeight
        },
        getViewportWidth: function() {
            return (!Ext.isStrict && !Ext.isOpera) ? i.body.clientWidth : Ext.isIE ? i.documentElement.clientWidth : self.innerWidth
        },
        getY: function(k) {
            return Ext.dom.Element.getXY(k)[1]
        },
        getX: function(k) {
            return Ext.dom.Element.getXY(k)[0]
        },
        getXY: function(m) {
            var p = i.body,
                l = i.documentElement,
                k = 0,
                n = 0,
                q = [0, 0],
                t = Math.round,
                o, s;
            m = Ext.getDom(m);
            if (m != i && m != p) {
                if (Ext.isIE) {
                    try {
                        o = m.getBoundingClientRect();
                        n = l.clientTop || p.clientTop;
                        k = l.clientLeft || p.clientLeft
                    } catch (r) {
                        o = {
                            left: 0,
                            top: 0
                        }
                    }
                } else {
                    o = m.getBoundingClientRect()
                }
                s = c(document).getScroll();
                q = [t(o.left + s.left - k), t(o.top + s.top - n)]
            }
            return q
        },
        setXY: function(l, m) {
            (l = Ext.fly(l, "_setXY")).position();
            var n = l.translatePoints(m),
                k = l.dom.style,
                o;
            for (o in n) {
                if (!isNaN(n[o])) {
                    k[o] = n[o] + "px"
                }
            }
        },
        setX: function(l, k) {
            Ext.dom.Element.setXY(l, [k, false])
        },
        setY: function(k, l) {
            Ext.dom.Element.setXY(k, [false, l])
        },
        serializeForm: function(m) {
            var n = m.elements || (document.forms[m] || Ext.getDom(m)).elements,
                y = false,
                x = encodeURIComponent,
                r = "",
                q = n.length,
                s, k, v, A, z, t, p, u, l;
            for (t = 0; t < q; t++) {
                s = n[t];
                k = s.name;
                v = s.type;
                A = s.options;
                if (!s.disabled && k) {
                    if (/select-(one|multiple)/i.test(v)) {
                        u = A.length;
                        for (p = 0; p < u; p++) {
                            l = A[p];
                            if (l.selected) {
                                z = l.hasAttribute ? l.hasAttribute("value") : l.getAttributeNode("value").specified;
                                r += Ext.String.format("{0}={1}&", x(k), x(z ? l.value : l.text))
                            }
                        }
                    } else {
                        if (!(/file|undefined|reset|button/i.test(v))) {
                            if (!(/radio|checkbox/i.test(v) && !s.checked) && !(v == "submit" && y)) {
                                r += x(k) + "=" + x(s.value) + "&";
                                y = /submit/i.test(v)
                            }
                        }
                    }
                }
            }
            return r.substr(0, r.length - 1)
        }
    })
}());
Ext.dom.AbstractElement.override({
    getAnchorXY: function(i, m, p) {
        i = (i || "tl").toLowerCase();
        p = p || {};
        var l = this,
            a = l.dom == document.body || l.dom == document,
            c = p.width || a ? window.innerWidth : l.getWidth(),
            n = p.height || a ? window.innerHeight : l.getHeight(),
            o, d = Math.round,
            e = l.getXY(),
            k = a ? 0 : !m ? e[0] : 0,
            j = a ? 0 : !m ? e[1] : 0,
            g = {
                c: [d(c * 0.5), d(n * 0.5)],
                t: [d(c * 0.5), 0],
                l: [0, d(n * 0.5)],
                r: [c, d(n * 0.5)],
                b: [d(c * 0.5), n],
                tl: [0, 0],
                bl: [0, n],
                br: [c, n],
                tr: [c, 0]
            };
        o = g[i];
        return [o[0] + k, o[1] + j]
    },
    alignToRe: /^([a-z]+)-([a-z]+)(\?)?$/,
    getAlignToXY: function(g, C, k, u) {
        u = !!u;
        g = Ext.get(g);
        k = k || [0, 0];
        if (!C || C == "?") {
            C = "tl-bl?"
        } else {
            if (!(/-/).test(C) && C !== "") {
                C = "tl-" + C
            }
        }
        C = C.toLowerCase();
        var A = this,
            e = C.match(this.alignToRe),
            p = window.innerWidth,
            z = window.innerHeight,
            d = "",
            c = "",
            D, B, o, n, s, q, i, a, m, l, t, r, j, v;
        if (!e) {
            throw "Element.alignTo with an invalid alignment " + C
        }
        d = e[1];
        c = e[2];
        v = !!e[3];
        D = A.getAnchorXY(d, true);
        B = g.getAnchorXY(c, u);
        o = B[0] - D[0] + k[0];
        n = B[1] - D[1] + k[1];
        if (v) {
            t = A.getWidth();
            r = A.getHeight();
            j = g.getPageBox();
            a = d.charAt(0);
            i = d.charAt(d.length - 1);
            l = c.charAt(0);
            m = c.charAt(c.length - 1);
            q = ((a == "t" && l == "b") || (a == "b" && l == "t"));
            s = ((i == "r" && m == "l") || (i == "l" && m == "r"));
            if (o + t > p) {
                o = s ? j.left - t : p - t
            }
            if (o < 0) {
                o = s ? j.right : 0
            }
            if (n + r > z) {
                n = q ? j.top - r : z - r
            }
            if (n < 0) {
                n = q ? j.bottom : 0
            }
        }
        return [o, n]
    },
    getAnchor: function() {
        var c = (this.$cache || this.getCache()).data,
            a;
        if (!this.dom) {
            return
        }
        a = c._anchor;
        if (!a) {
            a = c._anchor = {}
        }
        return a
    },
    adjustForConstraints: function(d, c) {
        var a = this.getConstrainVector(c, d);
        if (a) {
            d[0] += a[0];
            d[1] += a[1]
        }
        return d
    }
});
Ext.dom.AbstractElement.addMethods({
    appendChild: function(a) {
        return Ext.get(a).appendTo(this)
    },
    appendTo: function(a) {
        Ext.getDom(a).appendChild(this.dom);
        return this
    },
    insertBefore: function(a) {
        a = Ext.getDom(a);
        a.parentNode.insertBefore(this.dom, a);
        return this
    },
    insertAfter: function(a) {
        a = Ext.getDom(a);
        a.parentNode.insertBefore(this.dom, a.nextSibling);
        return this
    },
    insertFirst: function(c, a) {
        c = c || {};
        if (c.nodeType || c.dom || typeof c == "string") {
            c = Ext.getDom(c);
            this.dom.insertBefore(c, this.dom.firstChild);
            return !a ? Ext.get(c) : c
        } else {
            return this.createChild(c, this.dom.firstChild, a)
        }
    },
    insertSibling: function(c, i, l) {
        var k = this,
            m = (i || "before").toLowerCase() == "after",
            g, a, d, j;
        if (Ext.isArray(c)) {
            a = k;
            d = c.length;
            for (j = 0; j < d; j++) {
                g = Ext.fly(a, "_internal").insertSibling(c[j], i, l);
                if (m) {
                    a = g
                }
            }
            return g
        }
        c = c || {};
        if (c.nodeType || c.dom) {
            g = k.dom.parentNode.insertBefore(Ext.getDom(c), m ? k.dom.nextSibling : k.dom);
            if (!l) {
                g = Ext.get(g)
            }
        } else {
            if (m && !k.dom.nextSibling) {
                g = Ext.core.DomHelper.append(k.dom.parentNode, c, !l)
            } else {
                g = Ext.core.DomHelper[m ? "insertAfter" : "insertBefore"](k.dom, c, !l)
            }
        }
        return g
    },
    replace: function(a) {
        a = Ext.get(a);
        this.insertBefore(a);
        a.remove();
        return this
    },
    replaceWith: function(a) {
        var c = this;
        if (a.nodeType || a.dom || typeof a == "string") {
            a = Ext.get(a);
            c.dom.parentNode.insertBefore(a, c.dom)
        } else {
            a = Ext.core.DomHelper.insertBefore(c.dom, a)
        }
        delete Ext.cache[c.id];
        Ext.removeNode(c.dom);
        c.id = Ext.id(c.dom = a);
        Ext.dom.AbstractElement.addToCache(c.isFlyweight ? new Ext.dom.AbstractElement(c.dom) : c);
        return c
    },
    createChild: function(c, a, d) {
        c = c || {
            tag: "div"
        };
        if (a) {
            return Ext.core.DomHelper.insertBefore(a, c, d !== true)
        } else {
            return Ext.core.DomHelper[!this.dom.firstChild ? "insertFirst" : "append"](this.dom, c, d !== true)
        }
    },
    wrap: function(c, d, a) {
        var g = Ext.core.DomHelper.insertBefore(this.dom, c || {
                tag: "div"
            }, true),
            e = g;
        if (a) {
            e = Ext.DomQuery.selectNode(a, g.dom)
        }
        e.appendChild(this.dom);
        return d ? g.dom : g
    },
    insertHtml: function(c, d, a) {
        var e = Ext.core.DomHelper.insertHtml(c, this.dom, d);
        return a ? Ext.get(e) : e
    }
});
(function() {
    var a = Ext.dom.AbstractElement;
    a.override({
        getX: function(c) {
            return this.getXY(c)[0]
        },
        getY: function(c) {
            return this.getXY(c)[1]
        },
        getXY: function() {
            var c = window.webkitConvertPointFromNodeToPage(this.dom, new WebKitPoint(0, 0));
            return [c.x, c.y]
        },
        getOffsetsTo: function(c) {
            var g = this.getXY(),
                d = Ext.fly(c, "_internal").getXY();
            return [g[0] - d[0], g[1] - d[1]]
        },
        setX: function(c) {
            return this.setXY([c, this.getY()])
        },
        setY: function(c) {
            return this.setXY([this.getX(), c])
        },
        setLeft: function(c) {
            this.setStyle("left", a.addUnits(c));
            return this
        },
        setTop: function(c) {
            this.setStyle("top", a.addUnits(c));
            return this
        },
        setRight: function(c) {
            this.setStyle("right", a.addUnits(c));
            return this
        },
        setBottom: function(c) {
            this.setStyle("bottom", a.addUnits(c));
            return this
        },
        setXY: function(i) {
            var d = this,
                g, c, e;
            if (arguments.length > 1) {
                i = [i, arguments[1]]
            }
            g = d.translatePoints(i);
            c = d.dom.style;
            for (e in g) {
                if (!g.hasOwnProperty(e)) {
                    continue
                }
                if (!isNaN(g[e])) {
                    c[e] = g[e] + "px"
                }
            }
            return d
        },
        getLeft: function(c) {
            return parseInt(this.getStyle("left"), 10) || 0
        },
        getRight: function(c) {
            return parseInt(this.getStyle("right"), 10) || 0
        },
        getTop: function(c) {
            return parseInt(this.getStyle("top"), 10) || 0
        },
        getBottom: function(c) {
            return parseInt(this.getStyle("bottom"), 10) || 0
        },
        translatePoints: function(c, k) {
            k = isNaN(c[1]) ? k : c[1];
            c = isNaN(c[0]) ? c : c[0];
            var g = this,
                i = g.isStyle("position", "relative"),
                j = g.getXY(),
                d = parseInt(g.getStyle("left"), 10),
                e = parseInt(g.getStyle("top"), 10);
            d = !isNaN(d) ? d : (i ? 0 : g.dom.offsetLeft);
            e = !isNaN(e) ? e : (i ? 0 : g.dom.offsetTop);
            return {
                left: (c - j[0] + d),
                top: (k - j[1] + e)
            }
        },
        setBox: function(g) {
            var e = this,
                d = g.width,
                c = g.height,
                j = g.top,
                i = g.left;
            if (i !== undefined) {
                e.setLeft(i)
            }
            if (j !== undefined) {
                e.setTop(j)
            }
            if (d !== undefined) {
                e.setWidth(d)
            }
            if (c !== undefined) {
                e.setHeight(c)
            }
            return this
        },
        getBox: function(j, n) {
            var k = this,
                g = k.dom,
                d = g.offsetWidth,
                o = g.offsetHeight,
                q, i, e, c, p, m;
            if (!n) {
                q = k.getXY()
            } else {
                if (j) {
                    q = [0, 0]
                } else {
                    q = [parseInt(k.getStyle("left"), 10) || 0, parseInt(k.getStyle("top"), 10) || 0]
                }
            }
            if (!j) {
                i = {
                    x: q[0],
                    y: q[1],
                    0: q[0],
                    1: q[1],
                    width: d,
                    height: o
                }
            } else {
                e = k.getBorderWidth.call(k, "l") + k.getPadding.call(k, "l");
                c = k.getBorderWidth.call(k, "r") + k.getPadding.call(k, "r");
                p = k.getBorderWidth.call(k, "t") + k.getPadding.call(k, "t");
                m = k.getBorderWidth.call(k, "b") + k.getPadding.call(k, "b");
                i = {
                    x: q[0] + e,
                    y: q[1] + p,
                    0: q[0] + e,
                    1: q[1] + p,
                    width: d - (e + c),
                    height: o - (p + m)
                }
            }
            i.left = i.x;
            i.top = i.y;
            i.right = i.x + i.width;
            i.bottom = i.y + i.height;
            return i
        },
        getPageBox: function(g) {
            var j = this,
                d = j.dom,
                m = d.offsetWidth,
                i = d.offsetHeight,
                o = j.getXY(),
                n = o[1],
                c = o[0] + m,
                k = o[1] + i,
                e = o[0];
            if (!d) {
                return new Ext.util.Region()
            }
            if (g) {
                return new Ext.util.Region(n, c, k, e)
            } else {
                return {
                    left: e,
                    top: n,
                    width: m,
                    height: i,
                    right: c,
                    bottom: k
                }
            }
        }
    })
}());
(function() {
    var s = Ext.dom.AbstractElement,
        q = document.defaultView,
        p = Ext.Array,
        o = /^\s+|\s+$/g,
        c = /\w/g,
        r = /\s+/,
        v = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i,
        j = Ext.supports.ClassList,
        g = "padding",
        e = "margin",
        u = "border",
        m = "-left",
        t = "-right",
        n = "-top",
        d = "-bottom",
        k = "-width",
        l = {
            l: u + m + k,
            r: u + t + k,
            t: u + n + k,
            b: u + d + k
        },
        i = {
            l: g + m,
            r: g + t,
            t: g + n,
            b: g + d
        },
        a = {
            l: e + m,
            r: e + t,
            t: e + n,
            b: e + d
        };
    s.override({
        styleHooks: {},
        addStyles: function(E, D) {
            var z = 0,
                C = (E || "").match(c),
                B, x = C.length,
                A, y = [];
            if (x == 1) {
                z = Math.abs(parseFloat(this.getStyle(D[C[0]])) || 0)
            } else {
                if (x) {
                    for (B = 0; B < x; B++) {
                        A = C[B];
                        y.push(D[A])
                    }
                    y = this.getStyle(y);
                    for (B = 0; B < x; B++) {
                        A = C[B];
                        z += Math.abs(parseFloat(y[D[A]]) || 0)
                    }
                }
            }
            return z
        },
        addCls: j ? function(A) {
            var C = this,
                E = C.dom,
                D, B, z, x, y;
            if (typeof(A) == "string") {
                A = A.replace(o, "").split(r)
            }
            if (E && A && !!(x = A.length)) {
                if (!E.className) {
                    E.className = A.join(" ")
                } else {
                    D = E.classList;
                    for (z = 0; z < x; ++z) {
                        y = A[z];
                        if (y) {
                            if (!D.contains(y)) {
                                if (B) {
                                    B.push(y)
                                } else {
                                    B = E.className.replace(o, "");
                                    B = B ? [B, y] : [y]
                                }
                            }
                        }
                    }
                    if (B) {
                        E.className = B.join(" ")
                    }
                }
            }
            return C
        } : function(y) {
            var z = this,
                B = z.dom,
                A, x;
            if (B && y && y.length) {
                x = Ext.Element.mergeClsList(B.className, y);
                if (x.changed) {
                    B.className = x.join(" ")
                }
            }
            return z
        },
        removeCls: function(z) {
            var A = this,
                B = A.dom,
                x, y;
            if (typeof(z) == "string") {
                z = z.replace(o, "").split(r)
            }
            if (B && B.className && z && !!(x = z.length)) {
                if (x == 1 && j) {
                    if (z[0]) {
                        B.classList.remove(z[0])
                    }
                } else {
                    y = Ext.Element.removeCls(B.className, z);
                    if (y.changed) {
                        B.className = y.join(" ")
                    }
                }
            }
            return A
        },
        radioCls: function(A) {
            var B = this.dom.parentNode.childNodes,
                y, z, x;
            A = Ext.isArray(A) ? A : [A];
            for (z = 0, x = B.length; z < x; z++) {
                y = B[z];
                if (y && y.nodeType == 1) {
                    Ext.fly(y, "_internal").removeCls(A)
                }
            }
            return this.addCls(A)
        },
        toggleCls: j ? function(x) {
            var y = this,
                z = y.dom;
            if (z) {
                x = x.replace(o, "");
                if (x) {
                    z.classList.toggle(x)
                }
            }
            return y
        } : function(x) {
            var y = this;
            return y.hasCls(x) ? y.removeCls(x) : y.addCls(x)
        },
        hasCls: j ? function(x) {
            var y = this.dom;
            return (y && x) ? y.classList.contains(x) : false
        } : function(x) {
            var y = this.dom;
            return y ? x && (" " + y.className + " ").indexOf(" " + x + " ") != -1 : false
        },
        replaceCls: function(y, x) {
            return this.removeCls(y).addCls(x)
        },
        isStyle: function(x, y) {
            return this.getStyle(x) == y
        },
        getStyle: function(J, E) {
            var F = this,
                A = F.dom,
                M = typeof J != "string",
                K = F.styleHooks,
                y = J,
                G = y,
                D = 1,
                C, L, I, H, z, x, B;
            if (M) {
                I = {};
                y = G[0];
                B = 0;
                if (!(D = G.length)) {
                    return I
                }
            }
            if (!A || A.documentElement) {
                return I || ""
            }
            C = A.style;
            if (E) {
                x = C
            } else {
                x = A.ownerDocument.defaultView.getComputedStyle(A, null);
                if (!x) {
                    E = true;
                    x = C
                }
            }
            do {
                H = K[y];
                if (!H) {
                    K[y] = H = {
                        name: s.normalize(y)
                    }
                }
                if (H.get) {
                    z = H.get(A, F, E, x)
                } else {
                    L = H.name;
                    z = x[L]
                }
                if (!M) {
                    return z
                }
                I[y] = z;
                y = G[++B]
            } while (B < D);
            return I
        },
        getStyles: function() {
            var y = Ext.Array.slice(arguments),
                x = y.length,
                z;
            if (x && typeof y[x - 1] == "boolean") {
                z = y.pop()
            }
            return this.getStyle(y, z)
        },
        isTransparent: function(y) {
            var x = this.getStyle(y);
            return x ? v.test(x) : false
        },
        setStyle: function(E, C) {
            var A = this,
                D = A.dom,
                x = A.styleHooks,
                z = D.style,
                y = E,
                B;
            if (typeof y == "string") {
                B = x[y];
                if (!B) {
                    x[y] = B = {
                        name: s.normalize(y)
                    }
                }
                C = (C == null) ? "" : C;
                if (B.set) {
                    B.set(D, C, A)
                } else {
                    z[B.name] = C
                }
                if (B.afterSet) {
                    B.afterSet(D, C, A)
                }
            } else {
                for (y in E) {
                    if (E.hasOwnProperty(y)) {
                        B = x[y];
                        if (!B) {
                            x[y] = B = {
                                name: s.normalize(y)
                            }
                        }
                        C = E[y];
                        C = (C == null) ? "" : C;
                        if (B.set) {
                            B.set(D, C, A)
                        } else {
                            z[B.name] = C
                        }
                        if (B.afterSet) {
                            B.afterSet(D, C, A)
                        }
                    }
                }
            }
            return A
        },
        getHeight: function(y) {
            var z = this.dom,
                x = y ? (z.clientHeight - this.getPadding("tb")) : z.offsetHeight;
            return x > 0 ? x : 0
        },
        getWidth: function(x) {
            var z = this.dom,
                y = x ? (z.clientWidth - this.getPadding("lr")) : z.offsetWidth;
            return y > 0 ? y : 0
        },
        setWidth: function(x) {
            var y = this;
            y.dom.style.width = s.addUnits(x);
            return y
        },
        setHeight: function(x) {
            var y = this;
            y.dom.style.height = s.addUnits(x);
            return y
        },
        getBorderWidth: function(x) {
            return this.addStyles(x, l)
        },
        getPadding: function(x) {
            return this.addStyles(x, i)
        },
        margins: a,
        applyStyles: function(z) {
            if (z) {
                var y, x, A = this.dom;
                if (typeof z == "function") {
                    z = z.call()
                }
                if (typeof z == "string") {
                    z = Ext.util.Format.trim(z).split(/\s*(?::|;)\s*/);
                    for (y = 0, x = z.length; y < x;) {
                        A.style[s.normalize(z[y++])] = z[y++]
                    }
                } else {
                    if (typeof z == "object") {
                        this.setStyle(z)
                    }
                }
            }
        },
        setSize: function(z, x) {
            var A = this,
                y = A.dom.style;
            if (Ext.isObject(z)) {
                x = z.height;
                z = z.width
            }
            y.width = s.addUnits(z);
            y.height = s.addUnits(x);
            return A
        },
        getViewSize: function() {
            var x = document,
                y = this.dom;
            if (y == x || y == x.body) {
                return {
                    width: s.getViewportWidth(),
                    height: s.getViewportHeight()
                }
            } else {
                return {
                    width: y.clientWidth,
                    height: y.clientHeight
                }
            }
        },
        getSize: function(y) {
            var x = this.dom;
            return {
                width: Math.max(0, y ? (x.clientWidth - this.getPadding("lr")) : x.offsetWidth),
                height: Math.max(0, y ? (x.clientHeight - this.getPadding("tb")) : x.offsetHeight)
            }
        },
        repaint: function() {
            var x = this.dom;
            this.addCls(Ext.baseCSSPrefix + "repaint");
            setTimeout(function() {
                Ext.fly(x).removeCls(Ext.baseCSSPrefix + "repaint")
            }, 1);
            return this
        },
        getMargin: function(y) {
            var z = this,
                B = {
                    t: "top",
                    l: "left",
                    r: "right",
                    b: "bottom"
                },
                x, C, A;
            if (!y) {
                A = [];
                for (x in z.margins) {
                    if (z.margins.hasOwnProperty(x)) {
                        A.push(z.margins[x])
                    }
                }
                C = z.getStyle(A);
                if (C && typeof C == "object") {
                    for (x in z.margins) {
                        if (z.margins.hasOwnProperty(x)) {
                            C[B[x]] = parseFloat(C[z.margins[x]]) || 0
                        }
                    }
                }
                return C
            } else {
                return z.addStyles.call(z, y, z.margins)
            }
        },
        mask: function(y, C, G) {
            var D = this,
                z = D.dom,
                A = (D.$cache || D.getCache()).data,
                x = A.mask,
                H, F, E = "",
                B = Ext.baseCSSPrefix;
            D.addCls(B + "masked");
            if (D.getStyle("position") == "static") {
                D.addCls(B + "masked-relative")
            }
            if (x) {
                x.remove()
            }
            if (C && typeof C == "string") {
                E = " " + C
            } else {
                E = " " + B + "mask-gray"
            }
            H = D.createChild({
                cls: B + "mask" + ((G !== false) ? "" : (" " + B + "mask-gray")),
                html: y ? ('<div class="' + (C || (B + "mask-message")) + '">' + y + "</div>") : ""
            });
            F = D.getSize();
            A.mask = H;
            if (z === document.body) {
                F.height = window.innerHeight;
                if (D.orientationHandler) {
                    Ext.EventManager.unOrientationChange(D.orientationHandler, D)
                }
                D.orientationHandler = function() {
                    F = D.getSize();
                    F.height = window.innerHeight;
                    H.setSize(F)
                };
                Ext.EventManager.onOrientationChange(D.orientationHandler, D)
            }
            H.setSize(F);
            if (Ext.is.iPad) {
                Ext.repaint()
            }
        },
        unmask: function() {
            var y = this,
                A = (y.$cache || y.getCache()).data,
                x = A.mask,
                z = Ext.baseCSSPrefix;
            if (x) {
                x.remove();
                delete A.mask
            }
            y.removeCls([z + "masked", z + "masked-relative"]);
            if (y.dom === document.body) {
                Ext.EventManager.unOrientationChange(y.orientationHandler, y);
                delete y.orientationHandler
            }
        }
    });
    s.populateStyleMap = function(E, x) {
        var D = ["margin-", "padding-", "border-width-"],
            C = ["before", "after"],
            z, B, y, A;
        for (z = D.length; z--;) {
            for (A = 2; A--;) {
                B = D[z] + C[A];
                E[s.normalize(B)] = E[B] = {
                    name: s.normalize(D[z] + x[A])
                }
            }
        }
    };
    Ext.onReady(function() {
        var F = Ext.supports,
            x, D, B, y, E;

        function C(K, H, J, G) {
            var I = G[this.name] || "";
            return v.test(I) ? "transparent" : I
        }

        function A(M, J, L, I) {
            var G = I.marginRight,
                H, K;
            if (G != "0px") {
                H = M.style;
                K = H.display;
                H.display = "inline-block";
                G = (L ? I : M.ownerDocument.defaultView.getComputedStyle(M, null)).marginRight;
                H.display = K
            }
            return G
        }

        function z(N, K, M, J) {
            var G = J.marginRight,
                I, H, L;
            if (G != "0px") {
                I = N.style;
                H = s.getRightMarginFixCleaner(N);
                L = I.display;
                I.display = "inline-block";
                G = (M ? J : N.ownerDocument.defaultView.getComputedStyle(N, "")).marginRight;
                I.display = L;
                H()
            }
            return G
        }
        x = s.prototype.styleHooks;
        s.populateStyleMap(x, ["left", "right"]);
        if (F.init) {
            F.init()
        }
        if (!F.RightMargin) {
            x.marginRight = x["margin-right"] = {
                name: "marginRight",
                get: (F.DisplayChangeInputSelectionBug || F.DisplayChangeTextAreaSelectionBug) ? z : A
            }
        }
        if (!F.TransparentColor) {
            D = ["background-color", "border-color", "color", "outline-color"];
            for (B = D.length; B--;) {
                y = D[B];
                E = s.normalize(y);
                x[y] = x[E] = {
                    name: E,
                    get: C
                }
            }
        }
    })
}());
Ext.dom.AbstractElement.override({
    findParent: function(j, c, a) {
        var g = this.dom,
            d = document.documentElement,
            i = 0,
            e;
        c = c || 50;
        if (isNaN(c)) {
            e = Ext.getDom(c);
            c = Number.MAX_VALUE
        }
        while (g && g.nodeType == 1 && i < c && g != d && g != e) {
            if (Ext.DomQuery.is(g, j)) {
                return a ? Ext.get(g) : g
            }
            i++;
            g = g.parentNode
        }
        return null
    },
    findParentNode: function(e, c, a) {
        var d = Ext.fly(this.dom.parentNode, "_internal");
        return d ? d.findParent(e, c, a) : null
    },
    up: function(c, a) {
        return this.findParentNode(c, a, true)
    },
    select: function(a, c) {
        return Ext.dom.Element.select(a, this.dom, c)
    },
    query: function(a) {
        return Ext.DomQuery.select(a, this.dom)
    },
    down: function(a, c) {
        var d = Ext.DomQuery.selectNode(a, this.dom);
        return c ? d : Ext.get(d)
    },
    child: function(a, c) {
        var e, d = this,
            g;
        g = Ext.id(d.dom);
        g = Ext.escapeId(g);
        e = Ext.DomQuery.selectNode("#" + g + " > " + a, d.dom);
        return c ? e : Ext.get(e)
    },
    parent: function(a, c) {
        return this.matchNode("parentNode", "parentNode", a, c)
    },
    next: function(a, c) {
        return this.matchNode("nextSibling", "nextSibling", a, c)
    },
    prev: function(a, c) {
        return this.matchNode("previousSibling", "previousSibling", a, c)
    },
    first: function(a, c) {
        return this.matchNode("nextSibling", "firstChild", a, c)
    },
    last: function(a, c) {
        return this.matchNode("previousSibling", "lastChild", a, c)
    },
    matchNode: function(c, g, a, d) {
        if (!this.dom) {
            return null
        }
        var e = this.dom[g];
        while (e) {
            if (e.nodeType == 1 && (!a || Ext.DomQuery.is(e, a))) {
                return !d ? Ext.get(e) : e
            }
            e = e[c]
        }
        return null
    },
    isAncestor: function(a) {
        return this.self.isAncestor.call(this.self, this.dom, a)
    }
});
(function() {
    var c = "afterbegin",
        k = "afterend",
        a = "beforebegin",
        q = "beforeend",
        n = "<table>",
        j = "</table>",
        d = n + "<tbody>",
        p = "</tbody>" + j,
        m = d + "<tr>",
        g = "</tr>" + p,
        r = document.createElement("div"),
        o = ["BeforeBegin", "previousSibling"],
        l = ["AfterEnd", "nextSibling"],
        e = {
            beforebegin: o,
            afterend: l
        },
        i = {
            beforebegin: o,
            afterend: l,
            afterbegin: ["AfterBegin", "firstChild"],
            beforeend: ["BeforeEnd", "lastChild"]
        };
    Ext.define("Ext.dom.Helper", {
        extend: "Ext.dom.AbstractHelper",
        requires: ["Ext.dom.AbstractElement"],
        tableRe: /^table|tbody|tr|td$/i,
        tableElRe: /td|tr|tbody/i,
        useDom: false,
        createDom: function(s, z) {
            var t, C = document,
                x, A, u, B, y, v;
            if (Ext.isArray(s)) {
                t = C.createDocumentFragment();
                for (y = 0, v = s.length; y < v; y++) {
                    this.createDom(s[y], t)
                }
            } else {
                if (typeof s == "string") {
                    t = C.createTextNode(s)
                } else {
                    t = C.createElement(s.tag || "div");
                    x = !!t.setAttribute;
                    for (A in s) {
                        if (!this.confRe.test(A)) {
                            u = s[A];
                            if (A == "cls") {
                                t.className = u
                            } else {
                                if (x) {
                                    t.setAttribute(A, u)
                                } else {
                                    t[A] = u
                                }
                            }
                        }
                    }
                    Ext.DomHelper.applyStyles(t, s.style);
                    if ((B = s.children || s.cn)) {
                        this.createDom(B, t)
                    } else {
                        if (s.html) {
                            t.innerHTML = s.html
                        }
                    }
                }
            }
            if (z) {
                z.appendChild(t)
            }
            return t
        },
        ieTable: function(y, s, z, x) {
            r.innerHTML = [s, z, x].join("");
            var t = -1,
                v = r,
                u;
            while (++t < y) {
                v = v.firstChild
            }
            u = v.nextSibling;
            if (u) {
                v = document.createDocumentFragment();
                while (u) {
                    v.appendChild(u);
                    u = u.nextSibling
                }
            }
            return v
        },
        insertIntoTable: function(C, u, t, v) {
            var s, z, y = u == a,
                B = u == c,
                x = u == q,
                A = u == k;
            if (C == "td" && (B || x) || !this.tableElRe.test(C) && (y || A)) {
                return null
            }
            z = y ? t : A ? t.nextSibling : B ? t.firstChild : null;
            if (y || A) {
                t = t.parentNode
            }
            if (C == "td" || (C == "tr" && (x || B))) {
                s = this.ieTable(4, m, v, g)
            } else {
                if ((C == "tbody" && (x || B)) || (C == "tr" && (y || A))) {
                    s = this.ieTable(3, d, v, p)
                } else {
                    s = this.ieTable(2, n, v, j)
                }
            }
            t.insertBefore(s, z);
            return s
        },
        createContextualFragment: function(t) {
            var s = document.createDocumentFragment(),
                u, v;
            r.innerHTML = t;
            v = r.childNodes;
            u = v.length;
            while (u--) {
                s.appendChild(v[0])
            }
            return s
        },
        applyStyles: function(s, t) {
            if (t) {
                s = Ext.fly(s);
                if (typeof t == "function") {
                    t = t.call()
                }
                if (typeof t == "string") {
                    t = Ext.dom.Element.parseStyles(t)
                }
                if (typeof t == "object") {
                    s.setStyle(t)
                }
            }
        },
        createHtml: function(s) {
            return this.markup(s)
        },
        doInsert: function(v, y, x, z, u, s) {
            v = v.dom || Ext.getDom(v);
            var t;
            if (this.useDom) {
                t = this.createDom(y, null);
                if (s) {
                    v.appendChild(t)
                } else {
                    (u == "firstChild" ? v : v.parentNode).insertBefore(t, v[u] || v)
                }
            } else {
                t = this.insertHtml(z, v, this.markup(y))
            }
            return x ? Ext.get(t, true) : t
        },
        overwrite: function(u, t, v) {
            var s;
            u = Ext.getDom(u);
            t = this.markup(t);
            if (Ext.isIE && this.tableRe.test(u.tagName)) {
                while (u.firstChild) {
                    u.removeChild(u.firstChild)
                }
                if (t) {
                    s = this.insertHtml("afterbegin", u, t);
                    return v ? Ext.get(s) : s
                }
                return null
            }
            u.innerHTML = t;
            return v ? Ext.get(u.firstChild) : u.firstChild
        },
        insertHtml: function(u, y, v) {
            var A, t, x, s, z;
            u = u.toLowerCase();
            if (y.insertAdjacentHTML) {
                if (Ext.isIE && this.tableRe.test(y.tagName) && (z = this.insertIntoTable(y.tagName.toLowerCase(), u, y, v))) {
                    return z
                }
                if ((A = i[u])) {
                    y.insertAdjacentHTML(A[0], v);
                    return y[A[1]]
                }
            } else {
                if (y.nodeType === 3) {
                    u = u === "afterbegin" ? "beforebegin" : u;
                    u = u === "beforeend" ? "afterend" : u
                }
                t = Ext.supports.CreateContextualFragment ? y.ownerDocument.createRange() : undefined;
                s = "setStart" + (this.endRe.test(u) ? "After" : "Before");
                if (e[u]) {
                    if (t) {
                        t[s](y);
                        z = t.createContextualFragment(v)
                    } else {
                        z = this.createContextualFragment(v)
                    }
                    y.parentNode.insertBefore(z, u == a ? y : y.nextSibling);
                    return y[(u == a ? "previous" : "next") + "Sibling"]
                } else {
                    x = (u == c ? "first" : "last") + "Child";
                    if (y.firstChild) {
                        if (t) {
                            t[s](y[x]);
                            z = t.createContextualFragment(v)
                        } else {
                            z = this.createContextualFragment(v)
                        }
                        if (u == c) {
                            y.insertBefore(z, y.firstChild)
                        } else {
                            y.appendChild(z)
                        }
                    } else {
                        y.innerHTML = v
                    }
                    return y[x]
                }
            }
        },
        createTemplate: function(t) {
            var s = this.markup(t);
            return new Ext.Template(s)
        }
    }, function() {
        Ext.ns("Ext.core");
        Ext.DomHelper = Ext.core.DomHelper = new this
    })
}());
Ext.ns("Ext.core");
Ext.dom.Query = Ext.core.DomQuery = Ext.DomQuery = (function() {
    var cache = {},
        simpleCache = {},
        valueCache = {},
        nonSpace = /\S/,
        trimRe = /^\s+|\s+$/g,
        tplRe = /\{(\d+)\}/g,
        modeRe = /^(\s?[\/>+~]\s?|\s|$)/,
        tagTokenRe = /^(#)?([\w\-\*\\]+)/,
        nthRe = /(\d*)n\+?(\d*)/,
        nthRe2 = /\D/,
        startIdRe = /^\s*\#/,
        isIE = window.ActiveXObject ? true : false,
        key = 30803,
        longHex = /\\([0-9a-fA-F]{6})/g,
        shortHex = /\\([0-9a-fA-F]{1,6})\s{0,1}/g,
        nonHex = /\\([^0-9a-fA-F]{1})/g,
        escapes = /\\/g,
        num, hasEscapes, longHexToChar = function($0, $1) {
            return String.fromCharCode(parseInt($1, 16))
        },
        shortToLongHex = function($0, $1) {
            while ($1.length < 6) {
                $1 = "0" + $1
            }
            return "\\" + $1
        },
        charToLongHex = function($0, $1) {
            num = $1.charCodeAt(0).toString(16);
            if (num.length === 1) {
                num = "0" + num
            }
            return "\\0000" + num
        },
        unescapeCssSelector = function(selector) {
            return (hasEscapes) ? selector.replace(longHex, longHexToChar) : selector
        },
        setupEscapes = function(path) {
            hasEscapes = (path.indexOf("\\") > -1);
            if (hasEscapes) {
                path = path.replace(shortHex, shortToLongHex).replace(nonHex, charToLongHex).replace(escapes, "\\\\")
            }
            return path
        };
    eval("var batch = 30803;");

    function child(parent, index) {
        var i = 0,
            n = parent.firstChild;
        while (n) {
            if (n.nodeType == 1) {
                if (++i == index) {
                    return n
                }
            }
            n = n.nextSibling
        }
        return null
    }

    function next(n) {
        while ((n = n.nextSibling) && n.nodeType != 1) {}
        return n
    }

    function prev(n) {
        while ((n = n.previousSibling) && n.nodeType != 1) {}
        return n
    }

    function children(parent) {
        var n = parent.firstChild,
            nodeIndex = -1,
            nextNode;
        while (n) {
            nextNode = n.nextSibling;
            if (n.nodeType == 3 && !nonSpace.test(n.nodeValue)) {
                parent.removeChild(n)
            } else {
                n.nodeIndex = ++nodeIndex
            }
            n = nextNode
        }
        return this
    }

    function byClassName(nodeSet, cls) {
        cls = unescapeCssSelector(cls);
        if (!cls) {
            return nodeSet
        }
        var result = [],
            ri = -1,
            i, ci;
        for (i = 0, ci; ci = nodeSet[i]; i++) {
            if ((" " + ci.className + " ").indexOf(cls) != -1) {
                result[++ri] = ci
            }
        }
        return result
    }

    function attrValue(n, attr) {
        if (!n.tagName && typeof n.length != "undefined") {
            n = n[0]
        }
        if (!n) {
            return null
        }
        if (attr == "for") {
            return n.htmlFor
        }
        if (attr == "class" || attr == "className") {
            return n.className
        }
        return n.getAttribute(attr) || n[attr]
    }

    function getNodes(ns, mode, tagName) {
        var result = [],
            ri = -1,
            cs, i, ni, j, ci, cn, utag, n, cj;
        if (!ns) {
            return result
        }
        tagName = tagName || "*";
        if (typeof ns.getElementsByTagName != "undefined") {
            ns = [ns]
        }
        if (!mode) {
            for (i = 0, ni; ni = ns[i]; i++) {
                cs = ni.getElementsByTagName(tagName);
                for (j = 0, ci; ci = cs[j]; j++) {
                    result[++ri] = ci
                }
            }
        } else {
            if (mode == "/" || mode == ">") {
                utag = tagName.toUpperCase();
                for (i = 0, ni, cn; ni = ns[i]; i++) {
                    cn = ni.childNodes;
                    for (j = 0, cj; cj = cn[j]; j++) {
                        if (cj.nodeName == utag || cj.nodeName == tagName || tagName == "*") {
                            result[++ri] = cj
                        }
                    }
                }
            } else {
                if (mode == "+") {
                    utag = tagName.toUpperCase();
                    for (i = 0, n; n = ns[i]; i++) {
                        while ((n = n.nextSibling) && n.nodeType != 1) {}
                        if (n && (n.nodeName == utag || n.nodeName == tagName || tagName == "*")) {
                            result[++ri] = n
                        }
                    }
                } else {
                    if (mode == "~") {
                        utag = tagName.toUpperCase();
                        for (i = 0, n; n = ns[i]; i++) {
                            while ((n = n.nextSibling)) {
                                if (n.nodeName == utag || n.nodeName == tagName || tagName == "*") {
                                    result[++ri] = n
                                }
                            }
                        }
                    }
                }
            }
        }
        return result
    }

    function concat(a, b) {
        if (b.slice) {
            return a.concat(b)
        }
        for (var i = 0, l = b.length; i < l; i++) {
            a[a.length] = b[i]
        }
        return a
    }

    function byTag(cs, tagName) {
        if (cs.tagName || cs == document) {
            cs = [cs]
        }
        if (!tagName) {
            return cs
        }
        var result = [],
            ri = -1,
            i, ci;
        tagName = tagName.toLowerCase();
        for (i = 0, ci; ci = cs[i]; i++) {
            if (ci.nodeType == 1 && ci.tagName.toLowerCase() == tagName) {
                result[++ri] = ci
            }
        }
        return result
    }

    function byId(cs, id) {
        id = unescapeCssSelector(id);
        if (cs.tagName || cs == document) {
            cs = [cs]
        }
        if (!id) {
            return cs
        }
        var result = [],
            ri = -1,
            i, ci;
        for (i = 0, ci; ci = cs[i]; i++) {
            if (ci && ci.id == id) {
                result[++ri] = ci;
                return result
            }
        }
        return result
    }

    function byAttribute(cs, attr, value, op, custom) {
        var result = [],
            ri = -1,
            useGetStyle = custom == "{",
            fn = Ext.DomQuery.operators[op],
            a, xml, hasXml, i, ci;
        value = unescapeCssSelector(value);
        for (i = 0, ci; ci = cs[i]; i++) {
            if (ci.nodeType != 1) {
                continue
            }
            if (!hasXml) {
                xml = Ext.DomQuery.isXml(ci);
                hasXml = true
            }
            if (!xml) {
                if (useGetStyle) {
                    a = Ext.DomQuery.getStyle(ci, attr)
                } else {
                    if (attr == "class" || attr == "className") {
                        a = ci.className
                    } else {
                        if (attr == "for") {
                            a = ci.htmlFor
                        } else {
                            if (attr == "href") {
                                a = ci.getAttribute("href", 2)
                            } else {
                                a = ci.getAttribute(attr)
                            }
                        }
                    }
                }
            } else {
                a = ci.getAttribute(attr)
            }
            if ((fn && fn(a, value)) || (!fn && a)) {
                result[++ri] = ci
            }
        }
        return result
    }

    function byPseudo(cs, name, value) {
        value = unescapeCssSelector(value);
        return Ext.DomQuery.pseudos[name](cs, value)
    }

    function nodupIEXml(cs) {
        var d = ++key,
            r, i, len, c;
        cs[0].setAttribute("_nodup", d);
        r = [cs[0]];
        for (i = 1, len = cs.length; i < len; i++) {
            c = cs[i];
            if (!c.getAttribute("_nodup") != d) {
                c.setAttribute("_nodup", d);
                r[r.length] = c
            }
        }
        for (i = 0, len = cs.length; i < len; i++) {
            cs[i].removeAttribute("_nodup")
        }
        return r
    }

    function nodup(cs) {
        if (!cs) {
            return []
        }
        var len = cs.length,
            c, i, r = cs,
            cj, ri = -1,
            d, j;
        if (!len || typeof cs.nodeType != "undefined" || len == 1) {
            return cs
        }
        if (isIE && typeof cs[0].selectSingleNode != "undefined") {
            return nodupIEXml(cs)
        }
        d = ++key;
        cs[0]._nodup = d;
        for (i = 1; c = cs[i]; i++) {
            if (c._nodup != d) {
                c._nodup = d
            } else {
                r = [];
                for (j = 0; j < i; j++) {
                    r[++ri] = cs[j]
                }
                for (j = i + 1; cj = cs[j]; j++) {
                    if (cj._nodup != d) {
                        cj._nodup = d;
                        r[++ri] = cj
                    }
                }
                return r
            }
        }
        return r
    }

    function quickDiffIEXml(c1, c2) {
        var d = ++key,
            r = [],
            i, len;
        for (i = 0, len = c1.length; i < len; i++) {
            c1[i].setAttribute("_qdiff", d)
        }
        for (i = 0, len = c2.length; i < len; i++) {
            if (c2[i].getAttribute("_qdiff") != d) {
                r[r.length] = c2[i]
            }
        }
        for (i = 0, len = c1.length; i < len; i++) {
            c1[i].removeAttribute("_qdiff")
        }
        return r
    }

    function quickDiff(c1, c2) {
        var len1 = c1.length,
            d = ++key,
            r = [],
            i, len;
        if (!len1) {
            return c2
        }
        if (isIE && typeof c1[0].selectSingleNode != "undefined") {
            return quickDiffIEXml(c1, c2)
        }
        for (i = 0; i < len1; i++) {
            c1[i]._qdiff = d
        }
        for (i = 0, len = c2.length; i < len; i++) {
            if (c2[i]._qdiff != d) {
                r[r.length] = c2[i]
            }
        }
        return r
    }

    function quickId(ns, mode, root, id) {
        if (ns == root) {
            id = unescapeCssSelector(id);
            var d = root.ownerDocument || root;
            return d.getElementById(id)
        }
        ns = getNodes(ns, mode, "*");
        return byId(ns, id)
    }
    return {
        getStyle: function(el, name) {
            return Ext.fly(el).getStyle(name)
        },
        compile: function(path, type) {
            type = type || "select";
            var fn = ["var f = function(root){\n var mode; ++batch; var n = root || document;\n"],
                mode, lastPath, matchers = Ext.DomQuery.matchers,
                matchersLn = matchers.length,
                modeMatch, lmode = path.match(modeRe),
                tokenMatch, matched, j, t, m;
            path = setupEscapes(path);
            if (lmode && lmode[1]) {
                fn[fn.length] = 'mode="' + lmode[1].replace(trimRe, "") + '";';
                path = path.replace(lmode[1], "")
            }
            while (path.substr(0, 1) == "/") {
                path = path.substr(1)
            }
            while (path && lastPath != path) {
                lastPath = path;
                tokenMatch = path.match(tagTokenRe);
                if (type == "select") {
                    if (tokenMatch) {
                        if (tokenMatch[1] == "#") {
                            fn[fn.length] = 'n = quickId(n, mode, root, "' + tokenMatch[2] + '");'
                        } else {
                            fn[fn.length] = 'n = getNodes(n, mode, "' + tokenMatch[2] + '");'
                        }
                        path = path.replace(tokenMatch[0], "")
                    } else {
                        if (path.substr(0, 1) != "@") {
                            fn[fn.length] = 'n = getNodes(n, mode, "*");'
                        }
                    }
                } else {
                    if (tokenMatch) {
                        if (tokenMatch[1] == "#") {
                            fn[fn.length] = 'n = byId(n, "' + tokenMatch[2] + '");'
                        } else {
                            fn[fn.length] = 'n = byTag(n, "' + tokenMatch[2] + '");'
                        }
                        path = path.replace(tokenMatch[0], "")
                    }
                }
                while (!(modeMatch = path.match(modeRe))) {
                    matched = false;
                    for (j = 0; j < matchersLn; j++) {
                        t = matchers[j];
                        m = path.match(t.re);
                        if (m) {
                            fn[fn.length] = t.select.replace(tplRe, function(x, i) {
                                return m[i]
                            });
                            path = path.replace(m[0], "");
                            matched = true;
                            break
                        }
                    }
                    if (!matched) {
                        Ext.Error.raise({
                            sourceClass: "Ext.DomQuery",
                            sourceMethod: "compile",
                            msg: 'Error parsing selector. Parsing failed at "' + path + '"'
                        })
                    }
                }
                if (modeMatch[1]) {
                    fn[fn.length] = 'mode="' + modeMatch[1].replace(trimRe, "") + '";';
                    path = path.replace(modeMatch[1], "")
                }
            }
            fn[fn.length] = "return nodup(n);\n}";
            eval(fn.join(""));
            return f
        },
        jsSelect: function(path, root, type) {
            root = root || document;
            if (typeof root == "string") {
                root = document.getElementById(root)
            }
            var paths = path.split(","),
                results = [],
                i, len, subPath, result;
            for (i = 0, len = paths.length; i < len; i++) {
                subPath = paths[i].replace(trimRe, "");
                if (!cache[subPath]) {
                    cache[subPath] = Ext.DomQuery.compile(subPath, type);
                    if (!cache[subPath]) {
                        Ext.Error.raise({
                            sourceClass: "Ext.DomQuery",
                            sourceMethod: "jsSelect",
                            msg: subPath + " is not a valid selector"
                        })
                    }
                } else {
                    setupEscapes(subPath)
                }
                result = cache[subPath](root);
                if (result && result != document) {
                    results = results.concat(result)
                }
            }
            if (paths.length > 1) {
                return nodup(results)
            }
            return results
        },
        isXml: function(el) {
            var docEl = (el ? el.ownerDocument || el : 0).documentElement;
            return docEl ? docEl.nodeName !== "HTML" : false
        },
        select: document.querySelectorAll ? function(path, root, type) {
            root = root || document;
            if (!Ext.DomQuery.isXml(root)) {
                try {
                    if (root.parentNode && (root.nodeType !== 9) && path.indexOf(",") === -1 && !startIdRe.test(path)) {
                        path = "#" + Ext.escapeId(Ext.id(root)) + " " + path;
                        root = root.parentNode
                    }
                    return Ext.Array.toArray(root.querySelectorAll(path))
                } catch (e) {}
            }
            return Ext.DomQuery.jsSelect.call(this, path, root, type)
        } : function(path, root, type) {
            return Ext.DomQuery.jsSelect.call(this, path, root, type)
        },
        selectNode: function(path, root) {
            return Ext.DomQuery.select(path, root)[0]
        },
        selectValue: function(path, root, defaultValue) {
            path = path.replace(trimRe, "");
            if (!valueCache[path]) {
                valueCache[path] = Ext.DomQuery.compile(path, "select")
            } else {
                setupEscapes(path)
            }
            var n = valueCache[path](root),
                v;
            n = n[0] ? n[0] : n;
            if (typeof n.normalize == "function") {
                n.normalize()
            }
            v = (n && n.firstChild ? n.firstChild.nodeValue : null);
            return ((v === null || v === undefined || v === "") ? defaultValue : v)
        },
        selectNumber: function(path, root, defaultValue) {
            var v = Ext.DomQuery.selectValue(path, root, defaultValue || 0);
            return parseFloat(v)
        },
        is: function(el, ss) {
            if (typeof el == "string") {
                el = document.getElementById(el)
            }
            var isArray = Ext.isArray(el),
                result = Ext.DomQuery.filter(isArray ? el : [el], ss);
            return isArray ? (result.length == el.length) : (result.length > 0)
        },
        filter: function(els, ss, nonMatches) {
            ss = ss.replace(trimRe, "");
            if (!simpleCache[ss]) {
                simpleCache[ss] = Ext.DomQuery.compile(ss, "simple")
            } else {
                setupEscapes(ss)
            }
            var result = simpleCache[ss](els);
            return nonMatches ? quickDiff(result, els) : result
        },
        matchers: [{
            re: /^\.([\w\-\\]+)/,
            select: 'n = byClassName(n, " {1} ");'
        }, {
            re: /^\:([\w\-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/,
            select: 'n = byPseudo(n, "{1}", "{2}");'
        }, {
            re: /^(?:([\[\{])(?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/,
            select: 'n = byAttribute(n, "{2}", "{4}", "{3}", "{1}");'
        }, {
            re: /^#([\w\-\\]+)/,
            select: 'n = byId(n, "{1}");'
        }, {
            re: /^@([\w\-]+)/,
            select: 'return {firstChild:{nodeValue:attrValue(n, "{1}")}};'
        }],
        operators: {
            "=": function(a, v) {
                return a == v
            },
            "!=": function(a, v) {
                return a != v
            },
            "^=": function(a, v) {
                return a && a.substr(0, v.length) == v
            },
            "$=": function(a, v) {
                return a && a.substr(a.length - v.length) == v
            },
            "*=": function(a, v) {
                return a && a.indexOf(v) !== -1
            },
            "%=": function(a, v) {
                return (a % v) == 0
            },
            "|=": function(a, v) {
                return a && (a == v || a.substr(0, v.length + 1) == v + "-")
            },
            "~=": function(a, v) {
                return a && (" " + a + " ").indexOf(" " + v + " ") != -1
            }
        },
        pseudos: {
            "first-child": function(c) {
                var r = [],
                    ri = -1,
                    n, i, ci;
                for (i = 0;
                    (ci = n = c[i]); i++) {
                    while ((n = n.previousSibling) && n.nodeType != 1) {}
                    if (!n) {
                        r[++ri] = ci
                    }
                }
                return r
            },
            "last-child": function(c) {
                var r = [],
                    ri = -1,
                    n, i, ci;
                for (i = 0;
                    (ci = n = c[i]); i++) {
                    while ((n = n.nextSibling) && n.nodeType != 1) {}
                    if (!n) {
                        r[++ri] = ci
                    }
                }
                return r
            },
            "nth-child": function(c, a) {
                var r = [],
                    ri = -1,
                    m = nthRe.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !nthRe2.test(a) && "n+" + a || a),
                    f = (m[1] || 1) - 0,
                    l = m[2] - 0,
                    i, n, j, cn, pn;
                for (i = 0; n = c[i]; i++) {
                    pn = n.parentNode;
                    if (batch != pn._batch) {
                        j = 0;
                        for (cn = pn.firstChild; cn; cn = cn.nextSibling) {
                            if (cn.nodeType == 1) {
                                cn.nodeIndex = ++j
                            }
                        }
                        pn._batch = batch
                    }
                    if (f == 1) {
                        if (l == 0 || n.nodeIndex == l) {
                            r[++ri] = n
                        }
                    } else {
                        if ((n.nodeIndex + l) % f == 0) {
                            r[++ri] = n
                        }
                    }
                }
                return r
            },
            "only-child": function(c) {
                var r = [],
                    ri = -1,
                    i, ci;
                for (i = 0; ci = c[i]; i++) {
                    if (!prev(ci) && !next(ci)) {
                        r[++ri] = ci
                    }
                }
                return r
            },
            empty: function(c) {
                var r = [],
                    ri = -1,
                    i, ci, cns, j, cn, empty;
                for (i = 0, ci; ci = c[i]; i++) {
                    cns = ci.childNodes;
                    j = 0;
                    empty = true;
                    while (cn = cns[j]) {
                        ++j;
                        if (cn.nodeType == 1 || cn.nodeType == 3) {
                            empty = false;
                            break
                        }
                    }
                    if (empty) {
                        r[++ri] = ci
                    }
                }
                return r
            },
            contains: function(c, v) {
                var r = [],
                    ri = -1,
                    i, ci;
                for (i = 0; ci = c[i]; i++) {
                    if ((ci.textContent || ci.innerText || ci.text || "").indexOf(v) != -1) {
                        r[++ri] = ci
                    }
                }
                return r
            },
            nodeValue: function(c, v) {
                var r = [],
                    ri = -1,
                    i, ci;
                for (i = 0; ci = c[i]; i++) {
                    if (ci.firstChild && ci.firstChild.nodeValue == v) {
                        r[++ri] = ci
                    }
                }
                return r
            },
            checked: function(c) {
                var r = [],
                    ri = -1,
                    i, ci;
                for (i = 0; ci = c[i]; i++) {
                    if (ci.checked == true) {
                        r[++ri] = ci
                    }
                }
                return r
            },
            not: function(c, ss) {
                return Ext.DomQuery.filter(c, ss, true)
            },
            any: function(c, selectors) {
                var ss = selectors.split("|"),
                    r = [],
                    ri = -1,
                    s, i, ci, j;
                for (i = 0; ci = c[i]; i++) {
                    for (j = 0; s = ss[j]; j++) {
                        if (Ext.DomQuery.is(ci, s)) {
                            r[++ri] = ci;
                            break
                        }
                    }
                }
                return r
            },
            odd: function(c) {
                return this["nth-child"](c, "odd")
            },
            even: function(c) {
                return this["nth-child"](c, "even")
            },
            nth: function(c, a) {
                return c[a - 1] || []
            },
            first: function(c) {
                return c[0] || []
            },
            last: function(c) {
                return c[c.length - 1] || []
            },
            has: function(c, ss) {
                var s = Ext.DomQuery.select,
                    r = [],
                    ri = -1,
                    i, ci;
                for (i = 0; ci = c[i]; i++) {
                    if (s(ss, ci).length > 0) {
                        r[++ri] = ci
                    }
                }
                return r
            },
            next: function(c, ss) {
                var is = Ext.DomQuery.is,
                    r = [],
                    ri = -1,
                    i, ci, n;
                for (i = 0; ci = c[i]; i++) {
                    n = next(ci);
                    if (n && is(n, ss)) {
                        r[++ri] = ci
                    }
                }
                return r
            },
            prev: function(c, ss) {
                var is = Ext.DomQuery.is,
                    r = [],
                    ri = -1,
                    i, ci, n;
                for (i = 0; ci = c[i]; i++) {
                    n = prev(ci);
                    if (n && is(n, ss)) {
                        r[++ri] = ci
                    }
                }
                return r
            }
        }
    }
}());
Ext.query = Ext.DomQuery.select;
(function() {
    var HIDDEN = "hidden",
        DOC = document,
        VISIBILITY = "visibility",
        DISPLAY = "display",
        NONE = "none",
        XMASKED = Ext.baseCSSPrefix + "masked",
        XMASKEDRELATIVE = Ext.baseCSSPrefix + "masked-relative",
        EXTELMASKMSG = Ext.baseCSSPrefix + "mask-msg",
        bodyRe = /^body/i,
        visFly, noBoxAdjust = Ext.isStrict ? {
            select: 1
        } : {
            input: 1,
            select: 1,
            textarea: 1
        },
        isScrolled = function(c) {
            var r = [],
                ri = -1,
                i, ci;
            for (i = 0; ci = c[i]; i++) {
                if (ci.scrollTop > 0 || ci.scrollLeft > 0) {
                    r[++ri] = ci
                }
            }
            return r
        },
        Element = Ext.define("Ext.dom.Element", {
            extend: "Ext.dom.AbstractElement",
            alternateClassName: ["Ext.Element", "Ext.core.Element"],
            addUnits: function() {
                return this.self.addUnits.apply(this.self, arguments)
            },
            focus: function(defer, dom) {
                var me = this,
                    scrollTop, body;
                dom = dom || me.dom;
                body = (dom.ownerDocument || DOC).body || DOC.body;
                try {
                    if (Number(defer)) {
                        Ext.defer(me.focus, defer, me, [null, dom])
                    } else {
                        if (dom.offsetHeight > Element.getViewHeight()) {
                            scrollTop = body.scrollTop
                        }
                        dom.focus();
                        if (scrollTop !== undefined) {
                            body.scrollTop = scrollTop
                        }
                    }
                } catch (e) {}
                return me
            },
            blur: function() {
                try {
                    this.dom.blur()
                } catch (e) {}
                return this
            },
            isBorderBox: function() {
                var box = Ext.isBorderBox;
                if (box) {
                    box = !((this.dom.tagName || "").toLowerCase() in noBoxAdjust)
                }
                return box
            },
            hover: function(overFn, outFn, scope, options) {
                var me = this;
                me.on("mouseenter", overFn, scope || me.dom, options);
                me.on("mouseleave", outFn, scope || me.dom, options);
                return me
            },
            getAttributeNS: function(ns, name) {
                return this.getAttribute(name, ns)
            },
            getAttribute: (Ext.isIE && !(Ext.isIE9 && DOC.documentMode === 9)) ? function(name, ns) {
                var d = this.dom,
                    type;
                if (ns) {
                    type = typeof d[ns + ":" + name];
                    if (type != "undefined" && type != "unknown") {
                        return d[ns + ":" + name] || null
                    }
                    return null
                }
                if (name === "for") {
                    name = "htmlFor"
                }
                return d[name] || null
            } : function(name, ns) {
                var d = this.dom;
                if (ns) {
                    return d.getAttributeNS(ns, name) || d.getAttribute(ns + ":" + name)
                }
                return d.getAttribute(name) || d[name] || null
            },
            cacheScrollValues: function() {
                var me = this,
                    scrolledDescendants, el, i, scrollValues = [],
                    result = function() {
                        for (i = 0; i < scrolledDescendants.length; i++) {
                            el = scrolledDescendants[i];
                            el.scrollLeft = scrollValues[i][0];
                            el.scrollTop = scrollValues[i][1]
                        }
                    };
                if (!Ext.DomQuery.pseudos.isScrolled) {
                    Ext.DomQuery.pseudos.isScrolled = isScrolled
                }
                scrolledDescendants = me.query(":isScrolled");
                for (i = 0; i < scrolledDescendants.length; i++) {
                    el = scrolledDescendants[i];
                    scrollValues[i] = [el.scrollLeft, el.scrollTop]
                }
                return result
            },
            autoBoxAdjust: true,
            isVisible: function(deep) {
                var me = this,
                    dom = me.dom,
                    stopNode = dom.ownerDocument.documentElement;
                if (!visFly) {
                    visFly = new Element.Fly()
                }
                while (dom !== stopNode) {
                    if (!dom || dom.nodeType === 11 || (visFly.attach(dom)).isStyle(VISIBILITY, HIDDEN) || visFly.isStyle(DISPLAY, NONE)) {
                        return false
                    }
                    if (!deep) {
                        break
                    }
                    dom = dom.parentNode
                }
                return true
            },
            isDisplayed: function() {
                return !this.isStyle(DISPLAY, NONE)
            },
            enableDisplayMode: function(display) {
                var me = this;
                me.setVisibilityMode(Element.DISPLAY);
                if (!Ext.isEmpty(display)) {
                    (me.$cache || me.getCache()).data.originalDisplay = display
                }
                return me
            },
            mask: function(msg, msgCls, elHeight) {
                var me = this,
                    dom = me.dom,
                    setExpression = dom.style.setExpression,
                    data = (me.$cache || me.getCache()).data,
                    maskEl = data.maskEl,
                    maskMsg = data.maskMsg;
                if (!(bodyRe.test(dom.tagName) && me.getStyle("position") == "static")) {
                    me.addCls(XMASKEDRELATIVE)
                }
                if (maskEl) {
                    maskEl.remove()
                }
                if (maskMsg) {
                    maskMsg.remove()
                }
                Ext.DomHelper.append(dom, [{
                    cls: Ext.baseCSSPrefix + "mask"
                }, {
                    cls: msgCls ? EXTELMASKMSG + " " + msgCls : EXTELMASKMSG,
                    cn: {
                        tag: "div",
                        html: msg || ""
                    }
                }]);
                maskMsg = Ext.get(dom.lastChild);
                maskEl = Ext.get(maskMsg.dom.previousSibling);
                data.maskMsg = maskMsg;
                data.maskEl = maskEl;
                me.addCls(XMASKED);
                maskEl.setDisplayed(true);
                if (typeof msg == "string") {
                    maskMsg.setDisplayed(true);
                    maskMsg.center(me)
                } else {
                    maskMsg.setDisplayed(false)
                }
                if (!Ext.supports.IncludePaddingInWidthCalculation && setExpression) {
                    try {
                        maskEl.dom.style.setExpression("width", 'this.parentNode.clientWidth + "px"')
                    } catch (e) {}
                }
                if (!Ext.supports.IncludePaddingInHeightCalculation && setExpression) {
                    try {
                        maskEl.dom.style.setExpression("height", "this.parentNode." + (dom == DOC.body ? "scrollHeight" : "offsetHeight") + ' + "px"')
                    } catch (e) {}
                } else {
                    if (Ext.isIE && !(Ext.isIE7 && Ext.isStrict) && me.getStyle("height") == "auto") {
                        maskEl.setSize(undefined, elHeight || me.getHeight())
                    }
                }
                return maskEl
            },
            unmask: function() {
                var me = this,
                    data = (me.$cache || me.getCache()).data,
                    maskEl = data.maskEl,
                    maskMsg = data.maskMsg,
                    style;
                if (maskEl) {
                    style = maskEl.dom.style;
                    if (style.clearExpression) {
                        style.clearExpression("width");
                        style.clearExpression("height")
                    }
                    if (maskEl) {
                        maskEl.remove();
                        delete data.maskEl
                    }
                    if (maskMsg) {
                        maskMsg.remove();
                        delete data.maskMsg
                    }
                    me.removeCls([XMASKED, XMASKEDRELATIVE])
                }
            },
            isMasked: function() {
                var me = this,
                    data = (me.$cache || me.getCache()).data,
                    maskEl = data.maskEl,
                    maskMsg = data.maskMsg,
                    hasMask = false;
                if (maskEl && maskEl.isVisible()) {
                    if (maskMsg) {
                        maskMsg.center(me)
                    }
                    hasMask = true
                }
                return hasMask
            },
            createShim: function() {
                var el = DOC.createElement("iframe"),
                    shim;
                el.frameBorder = "0";
                el.className = Ext.baseCSSPrefix + "shim";
                el.src = Ext.SSL_SECURE_URL;
                shim = Ext.get(this.dom.parentNode.insertBefore(el, this.dom));
                shim.autoBoxAdjust = false;
                return shim
            },
            addKeyListener: function(key, fn, scope) {
                var config;
                if (typeof key != "object" || Ext.isArray(key)) {
                    config = {
                        target: this,
                        key: key,
                        fn: fn,
                        scope: scope
                    }
                } else {
                    config = {
                        target: this,
                        key: key.key,
                        shift: key.shift,
                        ctrl: key.ctrl,
                        alt: key.alt,
                        fn: fn,
                        scope: scope
                    }
                }
                return new Ext.util.KeyMap(config)
            },
            addKeyMap: function(config) {
                return new Ext.util.KeyMap(Ext.apply({
                    target: this
                }, config))
            },
            on: function(eventName, fn, scope, options) {
                Ext.EventManager.on(this, eventName, fn, scope || this, options);
                return this
            },
            un: function(eventName, fn, scope) {
                Ext.EventManager.un(this, eventName, fn, scope || this);
                return this
            },
            removeAllListeners: function() {
                Ext.EventManager.removeAll(this);
                return this
            },
            purgeAllListeners: function() {
                Ext.EventManager.purgeElement(this);
                return this
            }
        }, function() {
            var EC = Ext.cache,
                El = this,
                AbstractElement = Ext.dom.AbstractElement,
                focusRe = /a|button|embed|iframe|img|input|object|select|textarea/i,
                nonSpaceRe = /\S/,
                scriptTagRe = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/ig,
                replaceScriptTagRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig,
                srcRe = /\ssrc=([\'\"])(.*?)\1/i,
                typeRe = /\stype=([\'\"])(.*?)\1/i,
                useDocForId = !(Ext.isIE6 || Ext.isIE7 || Ext.isIE8);
            El.boxMarkup = '<div class="{0}-tl"><div class="{0}-tr"><div class="{0}-tc"></div></div></div><div class="{0}-ml"><div class="{0}-mr"><div class="{0}-mc"></div></div></div><div class="{0}-bl"><div class="{0}-br"><div class="{0}-bc"></div></div></div>';

            function garbageCollect() {
                if (!Ext.enableGarbageCollector) {
                    clearInterval(El.collectorThreadId)
                } else {
                    var eid, d, o, t;
                    for (eid in EC) {
                        if (!EC.hasOwnProperty(eid)) {
                            continue
                        }
                        o = EC[eid];
                        if (o.skipGarbageCollection) {
                            continue
                        }
                        d = o.dom;
                        if (!d.parentNode || (!d.offsetParent && !Ext.getElementById(eid))) {
                            if (d && Ext.enableListenerCollection) {
                                Ext.EventManager.removeAll(d)
                            }
                            delete EC[eid]
                        }
                    }
                    if (Ext.isIE) {
                        t = {};
                        for (eid in EC) {
                            if (!EC.hasOwnProperty(eid)) {
                                continue
                            }
                            t[eid] = EC[eid]
                        }
                        EC = Ext.cache = t
                    }
                }
            }
            El.collectorThreadId = setInterval(garbageCollect, 30000);
            El.addMethods({
                monitorMouseLeave: function(delay, handler, scope) {
                    var me = this,
                        timer, listeners = {
                            mouseleave: function(e) {
                                timer = setTimeout(Ext.Function.bind(handler, scope || me, [e]), delay)
                            },
                            mouseenter: function() {
                                clearTimeout(timer)
                            },
                            freezeEvent: true
                        };
                    me.on(listeners);
                    return listeners
                },
                swallowEvent: function(eventName, preventDefault) {
                    var me = this,
                        e, eLen;

                    function fn(e) {
                        e.stopPropagation();
                        if (preventDefault) {
                            e.preventDefault()
                        }
                    }
                    if (Ext.isArray(eventName)) {
                        eLen = eventName.length;
                        for (e = 0; e < eLen; e++) {
                            me.on(eventName[e], fn)
                        }
                        return me
                    }
                    me.on(eventName, fn);
                    return me
                },
                relayEvent: function(eventName, observable) {
                    this.on(eventName, function(e) {
                        observable.fireEvent(eventName, e)
                    })
                },
                clean: function(forceReclean) {
                    var me = this,
                        dom = me.dom,
                        data = (me.$cache || me.getCache()).data,
                        n = dom.firstChild,
                        ni = -1,
                        nx;
                    if (data.isCleaned && forceReclean !== true) {
                        return me
                    }
                    while (n) {
                        nx = n.nextSibling;
                        if (n.nodeType == 3) {
                            if (!(nonSpaceRe.test(n.nodeValue))) {
                                dom.removeChild(n)
                            } else {
                                if (nx && nx.nodeType == 3) {
                                    n.appendData(Ext.String.trim(nx.data));
                                    dom.removeChild(nx);
                                    nx = n.nextSibling;
                                    n.nodeIndex = ++ni
                                }
                            }
                        } else {
                            Ext.fly(n).clean();
                            n.nodeIndex = ++ni
                        }
                        n = nx
                    }
                    data.isCleaned = true;
                    return me
                },
                load: function(options) {
                    this.getLoader().load(options);
                    return this
                },
                getLoader: function() {
                    var me = this,
                        data = (me.$cache || me.getCache()).data,
                        loader = data.loader;
                    if (!loader) {
                        data.loader = loader = new Ext.ElementLoader({
                            target: me
                        })
                    }
                    return loader
                },
                syncContent: function(source) {
                    source = Ext.getDom(source);
                    var me = this,
                        sourceNodes = source.childNodes,
                        sourceLen = sourceNodes.length,
                        dest = me.dom,
                        destNodes = dest.childNodes,
                        destLen = destNodes.length,
                        i, destNode, sourceNode, nodeType;
                    dest.style.cssText = source.style.cssText;
                    dest.className = source.className;
                    if (sourceLen !== destLen) {
                        source.innerHTML = dest.innerHTML;
                        return
                    }
                    for (i = 0; i < sourceLen; i++) {
                        sourceNode = sourceNodes[i];
                        destNode = destNodes[i];
                        nodeType = sourceNode.nodeType;
                        if (nodeType !== destNode.nodeType || (nodeType === 1 && sourceNode.tagName !== destNode.tagName)) {
                            dest.innerHTML = source.innerHTML;
                            return
                        }
                        if (nodeType === 3) {
                            destNode.data = sourceNode.data
                        } else {
                            if (sourceNode.id && destNode.id !== sourceNode.id) {
                                destNode.id = sourceNode.id
                            }
                            destNode.style.cssText = sourceNode.style.cssText;
                            destNode.className = sourceNode.className;
                            Ext.fly(destNode).syncContent(sourceNode)
                        }
                    }
                },
                update: function(html, loadScripts, callback) {
                    var me = this,
                        id, dom, interval;
                    if (!me.dom) {
                        return me
                    }
                    html = html || "";
                    dom = me.dom;
                    if (loadScripts !== true) {
                        dom.innerHTML = html;
                        Ext.callback(callback, me);
                        return me
                    }
                    id = Ext.id();
                    html += '<span id="' + id + '"></span>';
                    interval = setInterval(function() {
                        var hd, match, attrs, srcMatch, typeMatch, el, s;
                        if (!(el = DOC.getElementById(id))) {
                            return false
                        }
                        clearInterval(interval);
                        Ext.removeNode(el);
                        hd = Ext.getHead().dom;
                        while ((match = scriptTagRe.exec(html))) {
                            attrs = match[1];
                            srcMatch = attrs ? attrs.match(srcRe) : false;
                            if (srcMatch && srcMatch[2]) {
                                s = DOC.createElement("script");
                                s.src = srcMatch[2];
                                typeMatch = attrs.match(typeRe);
                                if (typeMatch && typeMatch[2]) {
                                    s.type = typeMatch[2]
                                }
                                hd.appendChild(s)
                            } else {
                                if (match[2] && match[2].length > 0) {
                                    if (window.execScript) {
                                        window.execScript(match[2])
                                    } else {
                                        window.eval(match[2])
                                    }
                                }
                            }
                        }
                        Ext.callback(callback, me)
                    }, 20);
                    dom.innerHTML = html.replace(replaceScriptTagRe, "");
                    return me
                },
                removeAllListeners: function() {
                    this.removeAnchor();
                    Ext.EventManager.removeAll(this.dom);
                    return this
                },
                createProxy: function(config, renderTo, matchBox) {
                    config = (typeof config == "object") ? config : {
                        tag: "div",
                        cls: config
                    };
                    var me = this,
                        proxy = renderTo ? Ext.DomHelper.append(renderTo, config, true) : Ext.DomHelper.insertBefore(me.dom, config, true);
                    proxy.setVisibilityMode(Element.DISPLAY);
                    proxy.hide();
                    if (matchBox && me.setBox && me.getBox) {
                        proxy.setBox(me.getBox())
                    }
                    return proxy
                },
                getScopeParent: function() {
                    var parent = this.dom.parentNode;
                    if (Ext.scopeResetCSS) {
                        parent = parent.parentNode;
                        if (!Ext.supports.CSS3LinearGradient || !Ext.supports.CSS3BorderRadius) {
                            parent = parent.parentNode
                        }
                    }
                    return parent
                },
                needsTabIndex: function() {
                    if (this.dom) {
                        if ((this.dom.nodeName === "a") && (!this.dom.href)) {
                            return true
                        }
                        return !focusRe.test(this.dom.nodeName)
                    }
                },
                focusable: function() {
                    var dom = this.dom,
                        nodeName = dom.nodeName,
                        canFocus = false;
                    if (!dom.disabled) {
                        if (focusRe.test(nodeName)) {
                            if ((nodeName !== "a") || dom.href) {
                                canFocus = true
                            }
                        } else {
                            canFocus = !isNaN(dom.tabIndex)
                        }
                    }
                    return canFocus && this.isVisible(true)
                }
            });
            if (Ext.isIE) {
                El.prototype.getById = function(id, asDom) {
                    var dom = this.dom,
                        cacheItem, el, ret;
                    if (dom) {
                        el = (useDocForId && DOC.getElementById(id)) || dom.all[id];
                        if (el) {
                            if (asDom) {
                                ret = el
                            } else {
                                cacheItem = EC[id];
                                if (cacheItem && cacheItem.el) {
                                    ret = Ext.updateCacheEntry(cacheItem, el).el
                                } else {
                                    ret = new Element(el)
                                }
                            }
                            return ret
                        }
                    }
                    return asDom ? Ext.getDom(id) : El.get(id)
                }
            }
            El.createAlias({
                addListener: "on",
                removeListener: "un",
                clearListeners: "removeAllListeners"
            });
            El.Fly = AbstractElement.Fly = new Ext.Class({
                extend: El,
                constructor: function(dom) {
                    this.dom = dom
                },
                attach: AbstractElement.Fly.prototype.attach
            });
            if (Ext.isIE) {
                Ext.getElementById = function(id) {
                    var el = DOC.getElementById(id),
                        detachedBodyEl;
                    if (!el && (detachedBodyEl = AbstractElement.detachedBodyEl)) {
                        el = detachedBodyEl.dom.all[id]
                    }
                    return el
                }
            } else {
                if (!DOC.querySelector) {
                    Ext.getDetachedBody = Ext.getBody;
                    Ext.getElementById = function(id) {
                        return DOC.getElementById(id)
                    }
                }
            }
        })
}());
Ext.dom.Element.override((function() {
    var e = document,
        d = window,
        a = /^([a-z]+)-([a-z]+)(\?)?$/,
        c = Math.round;
    return {
        getAnchorXY: function(l, q, j) {
            l = (l || "tl").toLowerCase();
            j = j || {};
            var o = this,
                k = o.dom == e.body || o.dom == e,
                g = j.width || k ? Ext.dom.Element.getViewWidth() : o.getWidth(),
                i = j.height || k ? Ext.dom.Element.getViewHeight() : o.getHeight(),
                s, p = o.getXY(),
                r = o.getScroll(),
                n = k ? r.left : !q ? p[0] : 0,
                m = k ? r.top : !q ? p[1] : 0;
            switch (l) {
                case "tl":
                    s = [0, 0];
                    break;
                case "bl":
                    s = [0, i];
                    break;
                case "tr":
                    s = [g, 0];
                    break;
                case "c":
                    s = [c(g * 0.5), c(i * 0.5)];
                    break;
                case "t":
                    s = [c(g * 0.5), 0];
                    break;
                case "l":
                    s = [0, c(i * 0.5)];
                    break;
                case "r":
                    s = [g, c(i * 0.5)];
                    break;
                case "b":
                    s = [c(g * 0.5), i];
                    break;
                case "br":
                    s = [g, i]
            }
            return [s[0] + n, s[1] + m]
        },
        getAlignToXY: function(o, J, l) {
            o = Ext.get(o);
            if (!o || !o.dom) {}
            l = l || [0, 0];
            J = (!J || J == "?" ? "tl-bl?" : (!(/-/).test(J) && J !== "" ? "tl-" + J : J || "tl-bl")).toLowerCase();
            var K = this,
                n, B, s, q, m, C, D, H = Ext.dom.Element.getViewWidth() - 10,
                k = Ext.dom.Element.getViewHeight() - 10,
                i, j, p, r, z, A, I = e.documentElement,
                u = e.body,
                G = (I.scrollLeft || u.scrollLeft || 0),
                E = (I.scrollTop || u.scrollTop || 0),
                F, v, t, g = J.match(a);
            v = g[1];
            t = g[2];
            F = !!g[3];
            n = K.getAnchorXY(v, true);
            B = o.getAnchorXY(t, false);
            s = B[0] - n[0] + l[0];
            q = B[1] - n[1] + l[1];
            if (F) {
                m = K.getWidth();
                C = K.getHeight();
                D = o.getRegion();
                i = v.charAt(0);
                j = v.charAt(v.length - 1);
                p = t.charAt(0);
                r = t.charAt(t.length - 1);
                z = ((i == "t" && p == "b") || (i == "b" && p == "t"));
                A = ((j == "r" && r == "l") || (j == "l" && r == "r"));
                if (s + m > H + G) {
                    s = A ? D.left - m : H + G - m
                }
                if (s < G) {
                    s = A ? D.right : G
                }
                if (q + C > k + E) {
                    q = z ? D.top - C : k + E - C
                }
                if (q < E) {
                    q = z ? D.bottom : E
                }
            }
            return [s, q]
        },
        anchorTo: function(i, n, j, g, q, r) {
            var o = this,
                l = o.dom,
                p = !Ext.isEmpty(q),
                k = function() {
                    Ext.fly(l).alignTo(i, n, j, g);
                    Ext.callback(r, Ext.fly(l))
                },
                m = this.getAnchor();
            this.removeAnchor();
            Ext.apply(m, {
                fn: k,
                scroll: p
            });
            Ext.EventManager.onWindowResize(k, null);
            if (p) {
                Ext.EventManager.on(d, "scroll", k, null, {
                    buffer: !isNaN(q) ? q : 50
                })
            }
            k.call(o);
            return o
        },
        removeAnchor: function() {
            var i = this,
                g = this.getAnchor();
            if (g && g.fn) {
                Ext.EventManager.removeResizeListener(g.fn);
                if (g.scroll) {
                    Ext.EventManager.un(d, "scroll", g.fn)
                }
                delete g.fn
            }
            return i
        },
        getAlignVector: function(j, i, l) {
            var k = this,
                g = k.getXY(),
                m = k.getAlignToXY(j, i, l);
            j = Ext.get(j);
            m[0] -= g[0];
            m[1] -= g[1];
            return m
        },
        alignTo: function(j, g, l, i) {
            var k = this;
            return k.setXY(k.getAlignToXY(j, g, l), k.anim && !!i ? k.anim(i) : false)
        },
        getConstrainVector: function(k, i) {
            if (!(k instanceof Ext.util.Region)) {
                k = Ext.get(k).getViewRegion()
            }
            var m = this.getRegion(),
                g = [0, 0],
                l = (this.shadow && !this.shadowDisabled) ? this.shadow.getShadowSize() : undefined,
                j = false;
            if (i) {
                m.translateBy(i[0] - m.x, i[1] - m.y)
            }
            if (l) {
                k.adjust(l[0], -l[1], -l[2], l[3])
            }
            if (m.right > k.right) {
                j = true;
                g[0] = (k.right - m.right)
            }
            if (m.left + g[0] < k.left) {
                j = true;
                g[0] = (k.left - m.left)
            }
            if (m.bottom > k.bottom) {
                j = true;
                g[1] = (k.bottom - m.bottom)
            }
            if (m.top + g[1] < k.top) {
                j = true;
                g[1] = (k.top - m.top)
            }
            return j ? g : false
        },
        getCenterXY: function() {
            return this.getAlignToXY(e, "c-c")
        },
        center: function(g) {
            return this.alignTo(g || e, "c-c")
        }
    }
}()));
Ext.dom.Element.override({
    animate: function(c) {
        var e = this,
            d, g, a = e.dom.id || Ext.id(e.dom);
        if (!Ext.fx.Manager.hasFxBlock(a)) {
            if (c.listeners) {
                d = c.listeners;
                delete c.listeners
            }
            if (c.internalListeners) {
                c.listeners = c.internalListeners;
                delete c.internalListeners
            }
            g = new Ext.fx.Anim(e.anim(c));
            if (d) {
                g.on(d)
            }
            Ext.fx.Manager.queueFx(g)
        }
        return e
    },
    anim: function(a) {
        if (!Ext.isObject(a)) {
            return (a) ? {} : false
        }
        var c = this,
            d = a.duration || Ext.fx.Anim.prototype.duration,
            g = a.easing || "ease",
            e;
        if (a.stopAnimation) {
            c.stopAnimation()
        }
        Ext.applyIf(a, Ext.fx.Manager.getFxDefaults(c.id));
        Ext.fx.Manager.setFxDefaults(c.id, {
            delay: 0
        });
        e = {
            target: c.dom,
            remove: a.remove,
            alternate: a.alternate || false,
            duration: d,
            easing: g,
            callback: a.callback,
            listeners: a.listeners,
            iterations: a.iterations || 1,
            scope: a.scope,
            block: a.block,
            concurrent: a.concurrent,
            delay: a.delay || 0,
            paused: true,
            keyframes: a.keyframes,
            from: a.from || {},
            to: Ext.apply({}, a)
        };
        Ext.apply(e.to, a.to);
        delete e.to.to;
        delete e.to.from;
        delete e.to.remove;
        delete e.to.alternate;
        delete e.to.keyframes;
        delete e.to.iterations;
        delete e.to.listeners;
        delete e.to.target;
        delete e.to.paused;
        delete e.to.callback;
        delete e.to.scope;
        delete e.to.duration;
        delete e.to.easing;
        delete e.to.concurrent;
        delete e.to.block;
        delete e.to.stopAnimation;
        delete e.to.delay;
        return e
    },
    slideIn: function(d, c, e) {
        var i = this,
            l = i.dom.style,
            k, a, g, j;
        d = d || "t";
        c = c || {};
        k = function() {
            var p = this,
                o = c.listeners,
                q, m, r, n;
            if (!e) {
                i.fixDisplay()
            }
            q = i.getBox();
            if ((d == "t" || d == "b") && q.height === 0) {
                q.height = i.dom.scrollHeight
            } else {
                if ((d == "l" || d == "r") && q.width === 0) {
                    q.width = i.dom.scrollWidth
                }
            }
            m = i.getStyles("width", "height", "left", "right", "top", "bottom", "position", "z-index", true);
            i.setSize(q.width, q.height);
            if (c.preserveScroll) {
                g = i.cacheScrollValues()
            }
            n = i.wrap({
                id: Ext.id() + "-anim-wrap-for-" + i.id,
                style: {
                    visibility: e ? "visible" : "hidden"
                }
            });
            j = n.dom.parentNode;
            n.setPositioning(i.getPositioning());
            if (n.isStyle("position", "static")) {
                n.position("relative")
            }
            i.clearPositioning("auto");
            n.clip();
            if (g) {
                g()
            }
            i.setStyle({
                visibility: "",
                position: "absolute"
            });
            if (e) {
                n.setSize(q.width, q.height)
            }
            switch (d) {
                case "t":
                    r = {
                        from: {
                            width: q.width + "px",
                            height: "0px"
                        },
                        to: {
                            width: q.width + "px",
                            height: q.height + "px"
                        }
                    };
                    l.bottom = "0px";
                    break;
                case "l":
                    r = {
                        from: {
                            width: "0px",
                            height: q.height + "px"
                        },
                        to: {
                            width: q.width + "px",
                            height: q.height + "px"
                        }
                    };
                    l.right = "0px";
                    break;
                case "r":
                    r = {
                        from: {
                            x: q.x + q.width,
                            width: "0px",
                            height: q.height + "px"
                        },
                        to: {
                            x: q.x,
                            width: q.width + "px",
                            height: q.height + "px"
                        }
                    };
                    break;
                case "b":
                    r = {
                        from: {
                            y: q.y + q.height,
                            width: q.width + "px",
                            height: "0px"
                        },
                        to: {
                            y: q.y,
                            width: q.width + "px",
                            height: q.height + "px"
                        }
                    };
                    break;
                case "tl":
                    r = {
                        from: {
                            x: q.x,
                            y: q.y,
                            width: "0px",
                            height: "0px"
                        },
                        to: {
                            width: q.width + "px",
                            height: q.height + "px"
                        }
                    };
                    l.bottom = "0px";
                    l.right = "0px";
                    break;
                case "bl":
                    r = {
                        from: {
                            y: q.y + q.height,
                            width: "0px",
                            height: "0px"
                        },
                        to: {
                            y: q.y,
                            width: q.width + "px",
                            height: q.height + "px"
                        }
                    };
                    l.bottom = "0px";
                    break;
                case "br":
                    r = {
                        from: {
                            x: q.x + q.width,
                            y: q.y + q.height,
                            width: "0px",
                            height: "0px"
                        },
                        to: {
                            x: q.x,
                            y: q.y,
                            width: q.width + "px",
                            height: q.height + "px"
                        }
                    };
                    break;
                case "tr":
                    r = {
                        from: {
                            x: q.x + q.width,
                            width: "0px",
                            height: "0px"
                        },
                        to: {
                            x: q.x,
                            width: q.width + "px",
                            height: q.height + "px"
                        }
                    };
                    l.right = "0px";
                    break
            }
            n.show();
            a = Ext.apply({}, c);
            delete a.listeners;
            a = new Ext.fx.Anim(Ext.applyIf(a, {
                target: n,
                duration: 500,
                easing: "ease-out",
                from: e ? r.to : r.from,
                to: e ? r.from : r.to
            }));
            a.on("afteranimate", function() {
                i.setStyle(m);
                if (e) {
                    if (c.useDisplay) {
                        i.setDisplayed(false)
                    } else {
                        i.hide()
                    }
                }
                if (n.dom) {
                    if (n.dom.parentNode) {
                        n.dom.parentNode.insertBefore(i.dom, n.dom)
                    } else {
                        j.appendChild(i.dom)
                    }
                    n.remove()
                }
                if (g) {
                    g()
                }
                p.end()
            });
            if (o) {
                a.on(o)
            }
        };
        i.animate({
            duration: c.duration ? Math.max(c.duration, 500) * 2 : 1000,
            listeners: {
                beforeanimate: k
            }
        });
        return i
    },
    slideOut: function(a, c) {
        return this.slideIn(a, c, true)
    },
    puff: function(g) {
        var e = this,
            c, d = e.getBox(),
            a = e.getStyles("width", "height", "left", "right", "top", "bottom", "position", "z-index", "font-size", "opacity", true);
        g = Ext.applyIf(g || {}, {
            easing: "ease-out",
            duration: 500,
            useDisplay: false
        });
        c = function() {
            e.clearOpacity();
            e.show();
            this.to = {
                width: d.width * 2,
                height: d.height * 2,
                x: d.x - (d.width / 2),
                y: d.y - (d.height / 2),
                opacity: 0,
                fontSize: "200%"
            };
            this.on("afteranimate", function() {
                if (e.dom) {
                    if (g.useDisplay) {
                        e.setDisplayed(false)
                    } else {
                        e.hide()
                    }
                    e.setStyle(a);
                    g.callback.call(g.scope)
                }
            })
        };
        e.animate({
            duration: g.duration,
            easing: g.easing,
            listeners: {
                beforeanimate: {
                    fn: c
                }
            }
        });
        return e
    },
    switchOff: function(d) {
        var c = this,
            a;
        d = Ext.applyIf(d || {}, {
            easing: "ease-in",
            duration: 500,
            remove: false,
            useDisplay: false
        });
        a = function() {
            var j = this,
                i = c.getSize(),
                k = c.getXY(),
                g, e;
            c.clearOpacity();
            c.clip();
            e = c.getPositioning();
            g = new Ext.fx.Animator({
                target: c,
                duration: d.duration,
                easing: d.easing,
                keyframes: {
                    33: {
                        opacity: 0.3
                    },
                    66: {
                        height: 1,
                        y: k[1] + i.height / 2
                    },
                    100: {
                        width: 1,
                        x: k[0] + i.width / 2
                    }
                }
            });
            g.on("afteranimate", function() {
                if (d.useDisplay) {
                    c.setDisplayed(false)
                } else {
                    c.hide()
                }
                c.clearOpacity();
                c.setPositioning(e);
                c.setSize(i);
                j.end()
            })
        };
        c.animate({
            duration: (Math.max(d.duration, 500) * 2),
            listeners: {
                beforeanimate: {
                    fn: a
                }
            }
        });
        return c
    },
    frame: function(a, e, g) {
        var d = this,
            c;
        a = a || "#C3DAF9";
        e = e || 1;
        g = g || {};
        c = function() {
            d.show();
            var k = this,
                l = d.getBox(),
                j = Ext.getBody().createChild({
                    id: d.id + "-anim-proxy",
                    style: {
                        position: "absolute",
                        "pointer-events": "none",
                        "z-index": 35000,
                        border: "0px solid " + a
                    }
                }),
                i;
            i = new Ext.fx.Anim({
                target: j,
                duration: g.duration || 1000,
                iterations: e,
                from: {
                    top: l.y,
                    left: l.x,
                    borderWidth: 0,
                    opacity: 1,
                    height: l.height,
                    width: l.width
                },
                to: {
                    top: l.y - 20,
                    left: l.x - 20,
                    borderWidth: 10,
                    opacity: 0,
                    height: l.height + 40,
                    width: l.width + 40
                }
            });
            i.on("afteranimate", function() {
                j.remove();
                k.end()
            })
        };
        d.animate({
            duration: (Math.max(g.duration, 500) * 2) || 2000,
            listeners: {
                beforeanimate: {
                    fn: c
                }
            }
        });
        return d
    },
    ghost: function(a, e) {
        var d = this,
            c;
        a = a || "b";
        c = function() {
            var j = d.getWidth(),
                i = d.getHeight(),
                k = d.getXY(),
                g = d.getPositioning(),
                l = {
                    opacity: 0
                };
            switch (a) {
                case "t":
                    l.y = k[1] - i;
                    break;
                case "l":
                    l.x = k[0] - j;
                    break;
                case "r":
                    l.x = k[0] + j;
                    break;
                case "b":
                    l.y = k[1] + i;
                    break;
                case "tl":
                    l.x = k[0] - j;
                    l.y = k[1] - i;
                    break;
                case "bl":
                    l.x = k[0] - j;
                    l.y = k[1] + i;
                    break;
                case "br":
                    l.x = k[0] + j;
                    l.y = k[1] + i;
                    break;
                case "tr":
                    l.x = k[0] + j;
                    l.y = k[1] - i;
                    break
            }
            this.to = l;
            this.on("afteranimate", function() {
                if (d.dom) {
                    d.hide();
                    d.clearOpacity();
                    d.setPositioning(g)
                }
            })
        };
        d.animate(Ext.applyIf(e || {}, {
            duration: 500,
            easing: "ease-out",
            listeners: {
                beforeanimate: {
                    fn: c
                }
            }
        }));
        return d
    },
    highlight: function(e, c) {
        var k = this,
            g = k.dom,
            m = {},
            j, n, i, d, a, l;
        c = c || {};
        d = c.listeners || {};
        i = c.attr || "backgroundColor";
        m[i] = e || "ffff9c";
        if (!c.to) {
            n = {};
            n[i] = c.endColor || k.getColor(i, "ffffff", "")
        } else {
            n = c.to
        }
        c.listeners = Ext.apply(Ext.apply({}, d), {
            beforeanimate: function() {
                j = g.style[i];
                k.clearOpacity();
                k.show();
                a = d.beforeanimate;
                if (a) {
                    l = a.fn || a;
                    return l.apply(a.scope || d.scope || window, arguments)
                }
            },
            afteranimate: function() {
                if (g) {
                    g.style[i] = j
                }
                a = d.afteranimate;
                if (a) {
                    l = a.fn || a;
                    l.apply(a.scope || d.scope || window, arguments)
                }
            }
        });
        k.animate(Ext.apply({}, c, {
            duration: 1000,
            easing: "ease-in",
            from: m,
            to: n
        }));
        return k
    },
    pause: function(a) {
        var c = this;
        Ext.fx.Manager.setFxDefaults(c.id, {
            delay: a
        });
        return c
    },
    fadeIn: function(c) {
        var a = this;
        a.animate(Ext.apply({}, c, {
            opacity: 1,
            internalListeners: {
                beforeanimate: function(d) {
                    if (a.isStyle("display", "none")) {
                        a.setDisplayed("")
                    } else {
                        a.show()
                    }
                }
            }
        }));
        return this
    },
    fadeOut: function(c) {
        var a = this;
        c = Ext.apply({
            opacity: 0,
            internalListeners: {
                afteranimate: function(d) {
                    var e = a.dom;
                    if (e && d.to.opacity === 0) {
                        if (c.useDisplay) {
                            a.setDisplayed(false)
                        } else {
                            a.hide()
                        }
                    }
                }
            }
        }, c);
        a.animate(c);
        return a
    },
    scale: function(a, c, d) {
        this.animate(Ext.apply({}, d, {
            width: a,
            height: c
        }));
        return this
    },
    shift: function(a) {
        this.animate(a);
        return this
    }
});
Ext.dom.Element.override({
    initDD: function(d, c, e) {
        var a = new Ext.dd.DD(Ext.id(this.dom), d, c);
        return Ext.apply(a, e)
    },
    initDDProxy: function(d, c, e) {
        var a = new Ext.dd.DDProxy(Ext.id(this.dom), d, c);
        return Ext.apply(a, e)
    },
    initDDTarget: function(d, c, e) {
        var a = new Ext.dd.DDTarget(Ext.id(this.dom), d, c);
        return Ext.apply(a, e)
    }
});
(function() {
    var c = Ext.dom.Element,
        k = "visibility",
        i = "display",
        p = "none",
        g = "hidden",
        o = "visible",
        q = "offsets",
        l = "asclass",
        a = "nosize",
        d = "originalDisplay",
        e = "visibilityMode",
        j = "isVisible",
        n = Ext.baseCSSPrefix + "hide-offsets",
        m = function(s) {
            var t = (s.$cache || s.getCache()).data,
                u = t[d];
            if (u === undefined) {
                t[d] = u = ""
            }
            return u
        },
        r = function(t) {
            var u = (t.$cache || t.getCache()).data,
                s = u[e];
            if (s === undefined) {
                u[e] = s = c.VISIBILITY
            }
            return s
        };
    c.override({
        originalDisplay: "",
        visibilityMode: 1,
        setVisible: function(x, s) {
            var u = this,
                v = u.dom,
                t = r(u);
            if (typeof s == "string") {
                switch (s) {
                    case i:
                        t = c.DISPLAY;
                        break;
                    case k:
                        t = c.VISIBILITY;
                        break;
                    case q:
                        t = c.OFFSETS;
                        break;
                    case a:
                    case l:
                        t = c.ASCLASS;
                        break
                }
                u.setVisibilityMode(t);
                s = false
            }
            if (!s || !u.anim) {
                if (t == c.DISPLAY) {
                    return u.setDisplayed(x)
                } else {
                    if (t == c.OFFSETS) {
                        u[x ? "removeCls" : "addCls"](n)
                    } else {
                        if (t == c.VISIBILITY) {
                            u.fixDisplay();
                            v.style.visibility = x ? "" : g
                        } else {
                            if (t == c.ASCLASS) {
                                u[x ? "removeCls" : "addCls"](u.visibilityCls || c.visibilityCls)
                            }
                        }
                    }
                }
            } else {
                if (x) {
                    u.setOpacity(0.01);
                    u.setVisible(true)
                }
                if (!Ext.isObject(s)) {
                    s = {
                        duration: 350,
                        easing: "ease-in"
                    }
                }
                u.animate(Ext.applyIf({
                    callback: function() {
                        if (!x) {
                            u.setVisible(false).setOpacity(1)
                        }
                    },
                    to: {
                        opacity: (x) ? 1 : 0
                    }
                }, s))
            }(u.$cache || u.getCache()).data[j] = x;
            return u
        },
        hasMetrics: function() {
            var s = r(this);
            return this.isVisible() || (s == c.OFFSETS) || (s == c.VISIBILITY)
        },
        toggle: function(s) {
            var t = this;
            t.setVisible(!t.isVisible(), t.anim(s));
            return t
        },
        setDisplayed: function(s) {
            if (typeof s == "boolean") {
                s = s ? m(this) : p
            }
            this.setStyle(i, s);
            return this
        },
        fixDisplay: function() {
            var s = this;
            if (s.isStyle(i, p)) {
                s.setStyle(k, g);
                s.setStyle(i, m(s));
                if (s.isStyle(i, p)) {
                    s.setStyle(i, "block")
                }
            }
        },
        hide: function(s) {
            if (typeof s == "string") {
                this.setVisible(false, s);
                return this
            }
            this.setVisible(false, this.anim(s));
            return this
        },
        show: function(s) {
            if (typeof s == "string") {
                this.setVisible(true, s);
                return this
            }
            this.setVisible(true, this.anim(s));
            return this
        }
    })
}());
(function() {
    var t = Ext.dom.Element,
        p = "left",
        m = "right",
        s = "top",
        j = "bottom",
        q = "position",
        l = "static",
        A = "relative",
        r = "auto",
        y = "z-index",
        x = "BODY",
        d = "padding",
        v = "border",
        u = "-left",
        o = "-right",
        a = "-top",
        n = "-bottom",
        i = "-width",
        g = {
            l: v + u + i,
            r: v + o + i,
            t: v + a + i,
            b: v + n + i
        },
        e = {
            l: d + u,
            r: d + o,
            t: d + a,
            b: d + n
        },
        z = [e.l, e.r, e.t, e.b],
        c = [g.l, g.r, g.t, g.b],
        k = ["position", "top", "left"];
    t.override({
        getX: function() {
            return t.getX(this.dom)
        },
        getY: function() {
            return t.getY(this.dom)
        },
        getXY: function() {
            return t.getXY(this.dom)
        },
        getOffsetsTo: function(B) {
            var D = this.getXY(),
                C = Ext.fly(B, "_internal").getXY();
            return [D[0] - C[0], D[1] - C[1]]
        },
        setX: function(B, C) {
            return this.setXY([B, this.getY()], C)
        },
        setY: function(C, B) {
            return this.setXY([this.getX(), C], B)
        },
        setLeft: function(B) {
            this.setStyle(p, this.addUnits(B));
            return this
        },
        setTop: function(B) {
            this.setStyle(s, this.addUnits(B));
            return this
        },
        setRight: function(B) {
            this.setStyle(m, this.addUnits(B));
            return this
        },
        setBottom: function(B) {
            this.setStyle(j, this.addUnits(B));
            return this
        },
        setXY: function(D, B) {
            var C = this;
            if (!B || !C.anim) {
                t.setXY(C.dom, D)
            } else {
                if (!Ext.isObject(B)) {
                    B = {}
                }
                C.animate(Ext.applyIf({
                    to: {
                        x: D[0],
                        y: D[1]
                    }
                }, B))
            }
            return C
        },
        pxRe: /^\d+(?:\.\d*)?px$/i,
        getLocalX: function() {
            var D = this,
                C, B = D.getStyle(p);
            if (!B || B === r) {
                return 0
            }
            if (B && D.pxRe.test(B)) {
                return parseFloat(B)
            }
            B = D.getX();
            C = D.dom.offsetParent;
            if (C) {
                B -= Ext.fly(C).getX()
            }
            return B
        },
        getLocalY: function() {
            var C = this,
                B, D = C.getStyle(s);
            if (!D || D === r) {
                return 0
            }
            if (D && C.pxRe.test(D)) {
                return parseFloat(D)
            }
            D = C.getY();
            B = C.dom.offsetParent;
            if (B) {
                D -= Ext.fly(B).getY()
            }
            return D
        },
        getLeft: function(B) {
            return B ? this.getLocalX() : this.getX()
        },
        getRight: function(B) {
            return (B ? this.getLocalX() : this.getX()) + this.getWidth()
        },
        getTop: function(B) {
            return B ? this.getLocalY() : this.getY()
        },
        getBottom: function(B) {
            return (B ? this.getLocalY() : this.getY()) + this.getHeight()
        },
        translatePoints: function(B, I) {
            var D = this,
                C = D.getStyle(k),
                E = C.position == "relative",
                H = parseFloat(C.left),
                G = parseFloat(C.top),
                F = D.getXY();
            if (Ext.isArray(B)) {
                I = B[1];
                B = B[0]
            }
            if (isNaN(H)) {
                H = E ? 0 : D.dom.offsetLeft
            }
            if (isNaN(G)) {
                G = E ? 0 : D.dom.offsetTop
            }
            H = (typeof B == "number") ? B - F[0] + H : undefined;
            G = (typeof I == "number") ? I - F[1] + G : undefined;
            return {
                left: H,
                top: G
            }
        },
        setBox: function(F, G, C) {
            var E = this,
                B = F.width,
                D = F.height;
            if ((G && !E.autoBoxAdjust) && !E.isBorderBox()) {
                B -= (E.getBorderWidth("lr") + E.getPadding("lr"));
                D -= (E.getBorderWidth("tb") + E.getPadding("tb"))
            }
            E.setBounds(F.x, F.y, B, D, C);
            return E
        },
        getBox: function(G, L) {
            var I = this,
                P, C, K, F, N, D, B, O, J, M, E, H;
            if (!L) {
                P = I.getXY()
            } else {
                P = I.getStyle([p, s]);
                P = [parseFloat(P.left) || 0, parseFloat(P.top) || 0]
            }
            M = I.getWidth();
            E = I.getHeight();
            if (!G) {
                H = {
                    x: P[0],
                    y: P[1],
                    0: P[0],
                    1: P[1],
                    width: M,
                    height: E
                }
            } else {
                F = I.getStyle(z);
                N = I.getStyle(c);
                D = (parseFloat(N[g.l]) || 0) + (parseFloat(F[e.l]) || 0);
                B = (parseFloat(N[g.r]) || 0) + (parseFloat(F[e.r]) || 0);
                O = (parseFloat(N[g.t]) || 0) + (parseFloat(F[e.t]) || 0);
                J = (parseFloat(N[g.b]) || 0) + (parseFloat(F[e.b]) || 0);
                H = {
                    x: P[0] + D,
                    y: P[1] + O,
                    0: P[0] + D,
                    1: P[1] + O,
                    width: M - (D + B),
                    height: E - (O + J)
                }
            }
            H.right = H.x + H.width;
            H.bottom = H.y + H.height;
            return H
        },
        getPageBox: function(E) {
            var G = this,
                C = G.dom,
                I = C.nodeName == x,
                J = I ? Ext.dom.AbstractElement.getViewWidth() : C.offsetWidth,
                F = I ? Ext.dom.AbstractElement.getViewHeight() : C.offsetHeight,
                L = G.getXY(),
                K = L[1],
                B = L[0] + J,
                H = L[1] + F,
                D = L[0];
            if (E) {
                return new Ext.util.Region(K, B, H, D)
            } else {
                return {
                    left: D,
                    top: K,
                    width: J,
                    height: F,
                    right: B,
                    bottom: H
                }
            }
        },
        setLocation: function(B, D, C) {
            return this.setXY([B, D], C)
        },
        moveTo: function(B, D, C) {
            return this.setXY([B, D], C)
        },
        position: function(F, E, B, D) {
            var C = this;
            if (!F && C.isStyle(q, l)) {
                C.setStyle(q, A)
            } else {
                if (F) {
                    C.setStyle(q, F)
                }
            }
            if (E) {
                C.setStyle(y, E)
            }
            if (B || D) {
                C.setXY([B || false, D || false])
            }
        },
        clearPositioning: function(B) {
            B = B || "";
            this.setStyle({
                left: B,
                right: B,
                top: B,
                bottom: B,
                "z-index": "",
                position: l
            });
            return this
        },
        getPositioning: function() {
            var B = this.getStyle([p, s, q, m, j, y]);
            B[m] = B[p] ? "" : B[m];
            B[j] = B[s] ? "" : B[j];
            return B
        },
        setPositioning: function(B) {
            var D = this,
                C = D.dom.style;
            D.setStyle(B);
            if (B.right == r) {
                C.right = ""
            }
            if (B.bottom == r) {
                C.bottom = ""
            }
            return D
        },
        move: function(J, C, D) {
            var G = this,
                M = G.getXY(),
                K = M[0],
                I = M[1],
                E = [K - C, I],
                L = [K + C, I],
                H = [K, I - C],
                B = [K, I + C],
                F = {
                    l: E,
                    left: E,
                    r: L,
                    right: L,
                    t: H,
                    top: H,
                    up: H,
                    b: B,
                    bottom: B,
                    down: B
                };
            J = J.toLowerCase();
            G.moveTo(F[J][0], F[J][1], D)
        },
        setLeftTop: function(D, C) {
            var B = this.dom.style;
            B.left = t.addUnits(D);
            B.top = t.addUnits(C);
            return this
        },
        getRegion: function() {
            return this.getPageBox(true)
        },
        getViewRegion: function() {
            var F = this,
                D = F.dom.nodeName == x,
                C, I, H, G, E, B;
            if (D) {
                C = F.getScroll();
                G = C.left;
                H = C.top;
                E = Ext.dom.AbstractElement.getViewportWidth();
                B = Ext.dom.AbstractElement.getViewportHeight()
            } else {
                I = F.getXY();
                G = I[0] + F.getBorderWidth("l") + F.getPadding("l");
                H = I[1] + F.getBorderWidth("t") + F.getPadding("t");
                E = F.getWidth(true);
                B = F.getHeight(true)
            }
            return new Ext.util.Region(H, G + E - 1, H + B - 1, G)
        },
        setBounds: function(C, G, E, B, D) {
            var F = this;
            if (!D || !F.anim) {
                F.setSize(E, B);
                F.setLocation(C, G)
            } else {
                if (!Ext.isObject(D)) {
                    D = {}
                }
                F.animate(Ext.applyIf({
                    to: {
                        x: C,
                        y: G,
                        width: F.adjustWidth(E),
                        height: F.adjustHeight(B)
                    }
                }, D))
            }
            return F
        },
        setRegion: function(C, B) {
            return this.setBounds(C.left, C.top, C.right - C.left, C.bottom - C.top, B)
        }
    })
}());
Ext.dom.Element.override({
    isScrollable: function() {
        var a = this.dom;
        return a.scrollHeight > a.clientHeight || a.scrollWidth > a.clientWidth
    },
    getScroll: function() {
        var k = this.dom,
            j = document,
            a = j.body,
            e = j.documentElement,
            c, i, g;
        if (k == j || k == a) {
            if (Ext.isIE && Ext.isStrict) {
                c = e.scrollLeft;
                i = e.scrollTop
            } else {
                c = window.pageXOffset;
                i = window.pageYOffset
            }
            g = {
                left: c || (a ? a.scrollLeft : 0),
                top: i || (a ? a.scrollTop : 0)
            }
        } else {
            g = {
                left: k.scrollLeft,
                top: k.scrollTop
            }
        }
        return g
    },
    scrollBy: function(c, a, d) {
        var e = this,
            g = e.dom;
        if (c.length) {
            d = a;
            a = c[1];
            c = c[0]
        } else {
            if (typeof c != "number") {
                d = a;
                a = c.y;
                c = c.x
            }
        }
        if (c) {
            e.scrollTo("left", Math.max(Math.min(g.scrollLeft + c, g.scrollWidth - g.clientWidth), 0), d)
        }
        if (a) {
            e.scrollTo("top", Math.max(Math.min(g.scrollTop + a, g.scrollHeight - g.clientHeight), 0), d)
        }
        return e
    },
    scrollTo: function(d, g, a) {
        var i = /top/i.test(d),
            e = this,
            j = e.dom,
            c, k;
        if (!a || !e.anim) {
            k = "scroll" + (i ? "Top" : "Left");
            j[k] = g;
            j[k] = g
        } else {
            c = {
                to: {}
            };
            c.to["scroll" + (i ? "Top" : "Left")] = g;
            if (Ext.isObject(a)) {
                Ext.applyIf(c, a)
            }
            e.animate(c)
        }
        return e
    },
    scrollIntoView: function(c, i, d) {
        c = Ext.getDom(c) || Ext.getBody().dom;
        var e = this.dom,
            k = this.getOffsetsTo(c),
            j = k[0] + c.scrollLeft,
            n = k[1] + c.scrollTop,
            a = n + e.offsetHeight,
            o = j + e.offsetWidth,
            r = c.clientHeight,
            q = parseInt(c.scrollTop, 10),
            g = parseInt(c.scrollLeft, 10),
            l = q + r,
            p = g + c.clientWidth,
            m;
        if (e.offsetHeight > r || n < q) {
            m = n
        } else {
            if (a > l) {
                m = a - r
            }
        }
        if (m != null) {
            Ext.get(c).scrollTo("top", m, d)
        }
        if (i !== false) {
            m = null;
            if (e.offsetWidth > c.clientWidth || j < g) {
                m = j
            } else {
                if (o > p) {
                    m = o - c.clientWidth
                }
            }
            if (m != null) {
                Ext.get(c).scrollTo("left", m, d)
            }
        }
        return this
    },
    scrollChildIntoView: function(c, a) {
        Ext.fly(c, "_scrollChildIntoView").scrollIntoView(this, a)
    },
    scroll: function(n, c, e) {
        if (!this.isScrollable()) {
            return false
        }
        var g = this.dom,
            i = g.scrollLeft,
            q = g.scrollTop,
            o = g.scrollWidth,
            m = g.scrollHeight,
            j = g.clientWidth,
            a = g.clientHeight,
            d = false,
            p, k = {
                l: Math.min(i + c, o - j),
                r: p = Math.max(i - c, 0),
                t: Math.max(q - c, 0),
                b: Math.min(q + c, m - a)
            };
        k.d = k.b;
        k.u = k.t;
        n = n.substr(0, 1);
        if ((p = k[n]) > -1) {
            d = true;
            this.scrollTo(n == "l" || n == "r" ? "left" : "top", p, this.anim(e))
        }
        return d
    }
});
(function() {
    var r = Ext.dom.Element,
        o = document.defaultView,
        p = /table-row|table-.*-group/,
        a = "_internal",
        t = "hidden",
        q = "height",
        i = "width",
        g = "isClipped",
        l = "overflow",
        n = "overflow-x",
        m = "overflow-y",
        u = "originalClip",
        c = /#document|body/i,
        v, e, s, j, x;
    if (!o || !o.getComputedStyle) {
        r.prototype.getStyle = function(C, B) {
            var O = this,
                J = O.dom,
                M = typeof C != "string",
                k = O.styleHooks,
                z = C,
                A = z,
                I = 1,
                E = B,
                N, F, y, D, H, K, G;
            if (M) {
                y = {};
                z = A[0];
                G = 0;
                if (!(I = A.length)) {
                    return y
                }
            }
            if (!J || J.documentElement) {
                return y || ""
            }
            F = J.style;
            if (B) {
                K = F
            } else {
                K = J.currentStyle;
                if (!K) {
                    E = true;
                    K = F
                }
            }
            do {
                D = k[z];
                if (!D) {
                    k[z] = D = {
                        name: r.normalize(z)
                    }
                }
                if (D.get) {
                    H = D.get(J, O, E, K)
                } else {
                    N = D.name;
                    if (D.canThrow) {
                        try {
                            H = K[N]
                        } catch (L) {
                            H = ""
                        }
                    } else {
                        H = K ? K[N] : ""
                    }
                }
                if (!M) {
                    return H
                }
                y[z] = H;
                z = A[++G]
            } while (G < I);
            return y
        }
    }
    r.override({
        getHeight: function(A, y) {
            var z = this,
                C = z.dom,
                B = z.isStyle("display", "none"),
                k, D;
            if (B) {
                return 0
            }
            k = Math.max(C.offsetHeight, C.clientHeight) || 0;
            if (Ext.supports.Direct2DBug) {
                D = z.adjustDirect2DDimension(q);
                if (y) {
                    k += D
                } else {
                    if (D > 0 && D < 0.5) {
                        k++
                    }
                }
            }
            if (A) {
                k -= z.getBorderWidth("tb") + z.getPadding("tb")
            }
            return (k < 0) ? 0 : k
        },
        getWidth: function(k, C) {
            var A = this,
                D = A.dom,
                B = A.isStyle("display", "none"),
                z, y, E;
            if (B) {
                return 0
            }
            if (Ext.supports.BoundingClientRect) {
                z = D.getBoundingClientRect();
                y = z.right - z.left;
                y = C ? y : Math.ceil(y)
            } else {
                y = D.offsetWidth
            }
            y = Math.max(y, D.clientWidth) || 0;
            if (Ext.supports.Direct2DBug) {
                E = A.adjustDirect2DDimension(i);
                if (C) {
                    y += E
                } else {
                    if (E > 0 && E < 0.5) {
                        y++
                    }
                }
            }
            if (k) {
                y -= A.getBorderWidth("lr") + A.getPadding("lr")
            }
            return (y < 0) ? 0 : y
        },
        setWidth: function(y, k) {
            var z = this;
            y = z.adjustWidth(y);
            if (!k || !z.anim) {
                z.dom.style.width = z.addUnits(y)
            } else {
                if (!Ext.isObject(k)) {
                    k = {}
                }
                z.animate(Ext.applyIf({
                    to: {
                        width: y
                    }
                }, k))
            }
            return z
        },
        setHeight: function(k, y) {
            var z = this;
            k = z.adjustHeight(k);
            if (!y || !z.anim) {
                z.dom.style.height = z.addUnits(k)
            } else {
                if (!Ext.isObject(y)) {
                    y = {}
                }
                z.animate(Ext.applyIf({
                    to: {
                        height: k
                    }
                }, y))
            }
            return z
        },
        applyStyles: function(k) {
            Ext.DomHelper.applyStyles(this.dom, k);
            return this
        },
        setSize: function(z, k, y) {
            var A = this;
            if (Ext.isObject(z)) {
                y = k;
                k = z.height;
                z = z.width
            }
            z = A.adjustWidth(z);
            k = A.adjustHeight(k);
            if (!y || !A.anim) {
                A.dom.style.width = A.addUnits(z);
                A.dom.style.height = A.addUnits(k)
            } else {
                if (y === true) {
                    y = {}
                }
                A.animate(Ext.applyIf({
                    to: {
                        width: z,
                        height: k
                    }
                }, y))
            }
            return A
        },
        getViewSize: function() {
            var z = this,
                A = z.dom,
                y = c.test(A.nodeName),
                k;
            if (y) {
                k = {
                    width: r.getViewWidth(),
                    height: r.getViewHeight()
                }
            } else {
                k = {
                    width: A.clientWidth,
                    height: A.clientHeight
                }
            }
            return k
        },
        getSize: function(k) {
            return {
                width: this.getWidth(k),
                height: this.getHeight(k)
            }
        },
        adjustWidth: function(k) {
            var y = this,
                z = (typeof k == "number");
            if (z && y.autoBoxAdjust && !y.isBorderBox()) {
                k -= (y.getBorderWidth("lr") + y.getPadding("lr"))
            }
            return (z && k < 0) ? 0 : k
        },
        adjustHeight: function(k) {
            var y = this,
                z = (typeof k == "number");
            if (z && y.autoBoxAdjust && !y.isBorderBox()) {
                k -= (y.getBorderWidth("tb") + y.getPadding("tb"))
            }
            return (z && k < 0) ? 0 : k
        },
        getColor: function(y, z, E) {
            var B = this.getStyle(y),
                A = E || E === "" ? E : "#",
                D, k, C = 0;
            if (!B || (/transparent|inherit/.test(B))) {
                return z
            }
            if (/^r/.test(B)) {
                B = B.slice(4, B.length - 1).split(",");
                k = B.length;
                for (; C < k; C++) {
                    D = parseInt(B[C], 10);
                    A += (D < 16 ? "0" : "") + D.toString(16)
                }
            } else {
                B = B.replace("#", "");
                A += B.length == 3 ? B.replace(/^(\w)(\w)(\w)$/, "$1$1$2$2$3$3") : B
            }
            return (A.length > 5 ? A.toLowerCase() : z)
        },
        setOpacity: function(y, k) {
            var z = this;
            if (!z.dom) {
                return z
            }
            if (!k || !z.anim) {
                z.setStyle("opacity", y)
            } else {
                if (typeof k != "object") {
                    k = {
                        duration: 350,
                        easing: "ease-in"
                    }
                }
                z.animate(Ext.applyIf({
                    to: {
                        opacity: y
                    }
                }, k))
            }
            return z
        },
        clearOpacity: function() {
            return this.setOpacity("")
        },
        adjustDirect2DDimension: function(z) {
            var E = this,
                y = E.dom,
                C = E.getStyle("display"),
                B = y.style.display,
                F = y.style.position,
                D = z === i ? 0 : 1,
                k = y.currentStyle,
                A;
            if (C === "inline") {
                y.style.display = "inline-block"
            }
            y.style.position = C.match(p) ? "absolute" : "static";
            A = (parseFloat(k[z]) || parseFloat(k.msTransformOrigin.split(" ")[D]) * 2) % 1;
            y.style.position = F;
            if (C === "inline") {
                y.style.display = B
            }
            return A
        },
        clip: function() {
            var y = this,
                z = (y.$cache || y.getCache()).data,
                k;
            if (!z[g]) {
                z[g] = true;
                k = y.getStyle([l, n, m]);
                z[u] = {
                    o: k[l],
                    x: k[n],
                    y: k[m]
                };
                y.setStyle(l, t);
                y.setStyle(n, t);
                y.setStyle(m, t)
            }
            return y
        },
        unclip: function() {
            var y = this,
                z = (y.$cache || y.getCache()).data,
                k;
            if (z[g]) {
                z[g] = false;
                k = z[u];
                if (k.o) {
                    y.setStyle(l, k.o)
                }
                if (k.x) {
                    y.setStyle(n, k.x)
                }
                if (k.y) {
                    y.setStyle(m, k.y)
                }
            }
            return y
        },
        boxWrap: function(k) {
            k = k || Ext.baseCSSPrefix + "box";
            var y = Ext.get(this.insertHtml("beforeBegin", "<div class='" + k + "'>" + Ext.String.format(r.boxMarkup, k) + "</div>"));
            Ext.DomQuery.selectNode("." + k + "-mc", y.dom).appendChild(this.dom);
            return y
        },
        getComputedHeight: function() {
            var y = this,
                k = Math.max(y.dom.offsetHeight, y.dom.clientHeight);
            if (!k) {
                k = parseFloat(y.getStyle(q)) || 0;
                if (!y.isBorderBox()) {
                    k += y.getFrameWidth("tb")
                }
            }
            return k
        },
        getComputedWidth: function() {
            var y = this,
                k = Math.max(y.dom.offsetWidth, y.dom.clientWidth);
            if (!k) {
                k = parseFloat(y.getStyle(i)) || 0;
                if (!y.isBorderBox()) {
                    k += y.getFrameWidth("lr")
                }
            }
            return k
        },
        getFrameWidth: function(y, k) {
            return (k && this.isBorderBox()) ? 0 : (this.getPadding(y) + this.getBorderWidth(y))
        },
        addClsOnOver: function(z, C, y) {
            var A = this,
                B = A.dom,
                k = Ext.isFunction(C);
            A.hover(function() {
                if (k && C.call(y || A, A) === false) {
                    return
                }
                Ext.fly(B, a).addCls(z)
            }, function() {
                Ext.fly(B, a).removeCls(z)
            });
            return A
        },
        addClsOnFocus: function(z, C, y) {
            var A = this,
                B = A.dom,
                k = Ext.isFunction(C);
            A.on("focus", function() {
                if (k && C.call(y || A, A) === false) {
                    return false
                }
                Ext.fly(B, a).addCls(z)
            });
            A.on("blur", function() {
                Ext.fly(B, a).removeCls(z)
            });
            return A
        },
        addClsOnClick: function(z, C, y) {
            var A = this,
                B = A.dom,
                k = Ext.isFunction(C);
            A.on("mousedown", function() {
                if (k && C.call(y || A, A) === false) {
                    return false
                }
                Ext.fly(B, a).addCls(z);
                var E = Ext.getDoc(),
                    D = function() {
                        Ext.fly(B, a).removeCls(z);
                        E.removeListener("mouseup", D)
                    };
                E.on("mouseup", D)
            });
            return A
        },
        getStyleSize: function() {
            var B = this,
                C = this.dom,
                y = c.test(C.nodeName),
                A, k, z;
            if (y) {
                return {
                    width: r.getViewWidth(),
                    height: r.getViewHeight()
                }
            }
            A = B.getStyle([q, i], true);
            if (A.width && A.width != "auto") {
                k = parseFloat(A.width);
                if (B.isBorderBox()) {
                    k -= B.getFrameWidth("lr")
                }
            }
            if (A.height && A.height != "auto") {
                z = parseFloat(A.height);
                if (B.isBorderBox()) {
                    z -= B.getFrameWidth("tb")
                }
            }
            return {
                width: k || B.getWidth(true),
                height: z || B.getHeight(true)
            }
        },
        selectable: function() {
            var k = this;
            k.dom.unselectable = "off";
            k.on("selectstart", function(y) {
                y.stopPropagation();
                return true
            });
            k.applyStyles("-moz-user-select: text; -khtml-user-select: text;");
            k.removeCls(Ext.baseCSSPrefix + "unselectable");
            return k
        },
        unselectable: function() {
            var k = this;
            k.dom.unselectable = "on";
            k.swallowEvent("selectstart", true);
            k.applyStyles("-moz-user-select:-moz-none;-khtml-user-select:none;");
            k.addCls(Ext.baseCSSPrefix + "unselectable");
            return k
        }
    });
    r.prototype.styleHooks = v = Ext.dom.AbstractElement.prototype.styleHooks;
    if (Ext.isIE6 || Ext.isIE7) {
        v.fontSize = v["font-size"] = {
            name: "fontSize",
            canThrow: true
        };
        v.fontStyle = v["font-style"] = {
            name: "fontStyle",
            canThrow: true
        };
        v.fontFamily = v["font-family"] = {
            name: "fontFamily",
            canThrow: true
        }
    }
    if (Ext.isIEQuirks || Ext.isIE && Ext.ieVersion <= 8) {
        function d(A, y, z, k) {
            if (k[this.styleName] == "none") {
                return "0px"
            }
            return k[this.name]
        }
        e = ["Top", "Right", "Bottom", "Left"];
        s = e.length;
        while (s--) {
            j = e[s];
            x = "border" + j + "Width";
            v["border-" + j.toLowerCase() + "-width"] = v[x] = {
                name: x,
                styleName: "border" + j + "Style",
                get: d
            }
        }
    }
}());
Ext.onReady(function() {
    var d = /alpha\(opacity=(.*)\)/i,
        c = /^\s+|\s+$/g,
        a = Ext.dom.Element.prototype.styleHooks;
    a.opacity = {
        name: "opacity",
        afterSet: function(i, g, e) {
            if (e.isLayer) {
                e.onOpacitySet(g)
            }
        }
    };
    if (!Ext.supports.Opacity && Ext.isIE) {
        Ext.apply(a.opacity, {
            get: function(j) {
                var i = j.style.filter,
                    g, e;
                if (i.match) {
                    g = i.match(d);
                    if (g) {
                        e = parseFloat(g[1]);
                        if (!isNaN(e)) {
                            return e ? e / 100 : 0
                        }
                    }
                }
                return 1
            },
            set: function(j, g) {
                var e = j.style,
                    i = e.filter.replace(d, "").replace(c, "");
                e.zoom = 1;
                if (typeof(g) == "number" && g >= 0 && g < 1) {
                    g *= 100;
                    e.filter = i + (i.length ? " " : "") + "alpha(opacity=" + g + ")"
                } else {
                    e.filter = i
                }
            }
        })
    }
});
Ext.dom.Element.override({
    select: function(a) {
        return Ext.dom.Element.select(a, false, this.dom)
    }
});
Ext.define("Ext.dom.CompositeElementLite", {
    alternateClassName: "Ext.CompositeElementLite",
    requires: ["Ext.dom.Element", "Ext.dom.Query"],
    statics: {
        importElementMethods: function() {
            var c, d = Ext.dom.Element.prototype,
                a = this.prototype;
            for (c in d) {
                if (typeof d[c] == "function") {
                    (function(e) {
                        a[e] = a[e] || function() {
                            return this.invoke(e, arguments)
                        }
                    }).call(a, c)
                }
            }
        }
    },
    constructor: function(c, a) {
        this.elements = [];
        this.add(c, a);
        this.el = new Ext.dom.AbstractElement.Fly()
    },
    isComposite: true,
    getElement: function(a) {
        return this.el.attach(a)
    },
    transformElement: function(a) {
        return Ext.getDom(a)
    },
    getCount: function() {
        return this.elements.length
    },
    add: function(d, a) {
        var g = this.elements,
            c, e;
        if (!d) {
            return this
        }
        if (typeof d == "string") {
            d = Ext.dom.Element.selectorFunction(d, a)
        } else {
            if (d.isComposite) {
                d = d.elements
            } else {
                if (!Ext.isIterable(d)) {
                    d = [d]
                }
            }
        }
        for (c = 0, e = d.length; c < e; ++c) {
            g.push(this.transformElement(d[c]))
        }
        return this
    },
    invoke: function(e, a) {
        var j = this.elements,
            g = j.length,
            d, c;
        e = Ext.dom.Element.prototype[e];
        for (c = 0; c < g; c++) {
            d = j[c];
            if (d) {
                e.apply(this.getElement(d), a)
            }
        }
        return this
    },
    item: function(c) {
        var d = this.elements[c],
            a = null;
        if (d) {
            a = this.getElement(d)
        }
        return a
    },
    addListener: function(c, l, k, j) {
        var g = this.elements,
            a = g.length,
            d, m;
        for (d = 0; d < a; d++) {
            m = g[d];
            if (m) {
                Ext.EventManager.on(m, c, l, k || m, j)
            }
        }
        return this
    },
    each: function(j, g) {
        var k = this,
            d = k.elements,
            a = d.length,
            c, l;
        for (c = 0; c < a; c++) {
            l = d[c];
            if (l) {
                l = this.getElement(l);
                if (j.call(g || l, l, k, c) === false) {
                    break
                }
            }
        }
        return k
    },
    fill: function(a) {
        var c = this;
        c.elements = [];
        c.add(a);
        return c
    },
    filter: function(c) {
        var k = this,
            d = k.elements,
            j = d.length,
            e = [],
            g = 0,
            l = typeof c == "function",
            m, a;
        for (; g < j; g++) {
            a = d[g];
            m = false;
            if (a) {
                a = k.getElement(a);
                if (l) {
                    m = c.call(a, a, k, g) !== false
                } else {
                    m = a.is(c)
                }
                if (m) {
                    e.push(k.transformElement(a))
                }
            }
        }
        k.elements = e;
        return k
    },
    indexOf: function(a) {
        return Ext.Array.indexOf(this.elements, this.transformElement(a))
    },
    replaceElement: function(g, e, a) {
        var c = !isNaN(g) ? g : this.indexOf(g),
            i;
        if (c > -1) {
            e = Ext.getDom(e);
            if (a) {
                i = this.elements[c];
                i.parentNode.insertBefore(e, i);
                Ext.removeNode(i)
            }
            Ext.Array.splice(this.elements, c, 1, e)
        }
        return this
    },
    clear: function() {
        this.elements = []
    },
    addElements: function(g, c) {
        if (!g) {
            return this
        }
        if (typeof g == "string") {
            g = Ext.dom.Element.selectorFunction(g, c)
        }
        var d = this.elements,
            a = g.length,
            i;
        for (i = 0; i < a; i++) {
            d.push(Ext.get(g[i]))
        }
        return this
    },
    first: function() {
        return this.item(0)
    },
    last: function() {
        return this.item(this.getCount() - 1)
    },
    contains: function(a) {
        return this.indexOf(a) != -1
    },
    removeElement: function(g, l) {
        g = [].concat(g);
        var e = this,
            i = e.elements,
            d = g.length,
            j, c, a;
        for (a = 0; a < d; a++) {
            j = g[a];
            if ((c = (i[j] || i[j = e.indexOf(j)]))) {
                if (l) {
                    if (c.dom) {
                        c.remove()
                    } else {
                        Ext.removeNode(c)
                    }
                }
                Ext.Array.erase(i, j, 1)
            }
        }
        return e
    }
}, function() {
    this.importElementMethods();
    this.prototype.on = this.prototype.addListener;
    if (Ext.DomQuery) {
        Ext.dom.Element.selectorFunction = Ext.DomQuery.select
    }
    Ext.dom.Element.select = function(a, c) {
        var d;
        if (typeof a == "string") {
            d = Ext.dom.Element.selectorFunction(a, c)
        } else {
            if (a.length !== undefined) {
                d = a
            } else {}
        }
        return new Ext.CompositeElementLite(d)
    };
    Ext.select = function() {
        return Ext.dom.Element.select.apply(Ext.dom.Element, arguments)
    }
});
Ext.define("Ext.dom.CompositeElement", {
    alternateClassName: "Ext.CompositeElement",
    extend: "Ext.dom.CompositeElementLite",
    getElement: function(a) {
        return a
    },
    transformElement: function(a) {
        return Ext.get(a)
    }
}, function() {
    Ext.dom.Element.select = function(a, e, c) {
        var d;
        if (typeof a == "string") {
            d = Ext.dom.Element.selectorFunction(a, c)
        } else {
            if (a.length !== undefined) {
                d = a
            } else {}
        }
        return (e === true) ? new Ext.CompositeElement(d) : new Ext.CompositeElementLite(d)
    }
});
Ext.select = Ext.Element.select;
Ext.define("Ext.util.Filter", {
    anyMatch: false,
    exactMatch: false,
    caseSensitive: false,
    constructor: function(a) {
        var c = this;
        Ext.apply(c, a);
        c.filter = c.filter || c.filterFn;
        if (c.filter === undefined) {
            if (c.property === undefined || c.value === undefined) {} else {
                c.filter = c.createFilterFn()
            }
            c.filterFn = c.filter
        }
    },
    createFilterFn: function() {
        var a = this,
            d = a.createValueMatcher(),
            c = a.property;
        return function(e) {
            var g = a.getRoot.call(a, e)[c];
            return d === null ? g === null : d.test(g)
        }
    },
    getRoot: function(c) {
        var a = this.root;
        return a === undefined ? c : c[a]
    },
    createValueMatcher: function() {
        var e = this,
            g = e.value,
            i = e.anyMatch,
            d = e.exactMatch,
            a = e.caseSensitive,
            c = Ext.String.escapeRegex;
        if (g === null) {
            return g
        }
        if (!g.exec) {
            g = String(g);
            if (i === true) {
                g = c(g)
            } else {
                g = "^" + c(g);
                if (d === true) {
                    g += "$"
                }
            }
            g = new RegExp(g, a ? "" : "i")
        }
        return g
    }
});
Ext.define("Ext.util.Observable", {
    requires: ["Ext.util.Event"],
    statics: {
        releaseCapture: function(a) {
            a.fireEvent = this.prototype.fireEvent
        },
        capture: function(d, c, a) {
            d.fireEvent = Ext.Function.createInterceptor(d.fireEvent, c, a)
        },
        observe: function(a, c) {
            if (a) {
                if (!a.isObservable) {
                    Ext.applyIf(a, new this());
                    this.capture(a.prototype, a.fireEvent, a)
                }
                if (Ext.isObject(c)) {
                    a.on(c)
                }
            }
            return a
        },
        prepareClass: function(e, d) {
            if (!e.HasListeners) {
                var c = Ext.util.Observable,
                    g = function() {},
                    a = e.superclass.HasListeners || (d && d.HasListeners) || c.HasListeners;
                e.prototype.HasListeners = e.HasListeners = g;
                g.prototype = e.hasListeners = new a()
            }
        }
    },
    isObservable: true,
    eventsSuspended: 0,
    constructor: function(a) {
        var c = this;
        Ext.apply(c, a);
        if (!c.hasListeners) {
            c.hasListeners = new c.HasListeners()
        }
        c.events = c.events || {};
        if (c.listeners) {
            c.on(c.listeners);
            c.listeners = null
        }
        if (c.bubbleEvents) {
            c.enableBubble(c.bubbleEvents)
        }
    },
    onClassExtended: function(a) {
        if (!a.HasListeners) {
            Ext.util.Observable.prepareClass(a)
        }
    },
    eventOptionsRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|element|vertical|horizontal|freezeEvent)$/,
    addManagedListener: function(k, e, i, g, d) {
        var j = this,
            a = j.managedListeners = j.managedListeners || [],
            c;
        if (typeof e !== "string") {
            d = e;
            for (e in d) {
                if (d.hasOwnProperty(e)) {
                    c = d[e];
                    if (!j.eventOptionsRe.test(e)) {
                        j.addManagedListener(k, e, c.fn || c, c.scope || d.scope, c.fn ? c : d)
                    }
                }
            }
        } else {
            a.push({
                item: k,
                ename: e,
                fn: i,
                scope: g,
                options: d
            });
            k.on(e, i, g, d)
        }
    },
    removeManagedListener: function(l, d, j, m) {
        var g = this,
            n, c, k, a, e;
        if (typeof d !== "string") {
            n = d;
            for (d in n) {
                if (n.hasOwnProperty(d)) {
                    c = n[d];
                    if (!g.eventOptionsRe.test(d)) {
                        g.removeManagedListener(l, d, c.fn || c, c.scope || n.scope)
                    }
                }
            }
        }
        k = g.managedListeners ? g.managedListeners.slice() : [];
        for (e = 0, a = k.length; e < a; e++) {
            g.removeManagedListenerItem(false, k[e], l, d, j, m)
        }
    },
    fireEvent: function(a) {
        a = a.toLowerCase();
        var g = this,
            d = g.events,
            e = d && d[a],
            c = true;
        if (e && g.hasListeners[a]) {
            c = g.continueFireEvent(a, Ext.Array.slice(arguments, 1), e.bubble)
        }
        return c
    },
    continueFireEvent: function(d, g, c) {
        var j = this,
            a, i, e = true;
        do {
            if (j.eventsSuspended) {
                if ((a = j.eventQueue)) {
                    a.push([d, g, c])
                }
                return e
            } else {
                i = j.events[d];
                if (i && i != true) {
                    if ((e = i.fire.apply(i, g)) === false) {
                        break
                    }
                }
            }
        } while (c && (j = j.getBubbleParent()));
        return e
    },
    getBubbleParent: function() {
        var c = this,
            a = c.getBubbleTarget && c.getBubbleTarget();
        if (a && a.isObservable) {
            return a
        }
        return null
    },
    addListener: function(d, i, k, l) {
        var g = this,
            c, a, e, j = 0;
        if (typeof d !== "string") {
            l = d;
            for (d in l) {
                if (l.hasOwnProperty(d)) {
                    c = l[d];
                    if (!g.eventOptionsRe.test(d)) {
                        g.addListener(d, c.fn || c, c.scope || l.scope, c.fn ? c : l)
                    }
                }
            }
        } else {
            d = d.toLowerCase();
            a = g.events[d];
            if (a && a.isEvent) {
                j = a.listeners.length
            } else {
                g.events[d] = a = new Ext.util.Event(g, d)
            }
            if (typeof i === "string") {
                i = k[i] || g[i]
            }
            a.addListener(i, k, l);
            if (a.listeners.length !== j) {
                e = g.hasListeners;
                if (e.hasOwnProperty(d)) {
                    ++e[d]
                } else {
                    e[d] = 1
                }
            }
        }
    },
    removeListener: function(d, g, e) {
        var j = this,
            c, i, a;
        if (typeof d !== "string") {
            a = d;
            for (d in a) {
                if (a.hasOwnProperty(d)) {
                    c = a[d];
                    if (!j.eventOptionsRe.test(d)) {
                        j.removeListener(d, c.fn || c, c.scope || a.scope)
                    }
                }
            }
        } else {
            d = d.toLowerCase();
            i = j.events[d];
            if (i && i.isEvent) {
                if (i.removeListener(g, e) && !--j.hasListeners[d]) {
                    delete j.hasListeners[d]
                }
            }
        }
    },
    clearListeners: function() {
        var c = this.events,
            d, a;
        for (a in c) {
            if (c.hasOwnProperty(a)) {
                d = c[a];
                if (d.isEvent) {
                    d.clearListeners()
                }
            }
        }
        this.clearManagedListeners()
    },
    clearManagedListeners: function() {
        var c = this.managedListeners || [],
            d = 0,
            a = c.length;
        for (; d < a; d++) {
            this.removeManagedListenerItem(true, c[d])
        }
        this.managedListeners = []
    },
    removeManagedListenerItem: function(c, a, i, d, g, e) {
        if (c || (a.item === i && a.ename === d && (!g || a.fn === g) && (!e || a.scope === e))) {
            a.item.un(a.ename, a.fn, a.scope);
            if (!c) {
                Ext.Array.remove(this.managedListeners, a)
            }
        }
    },
    addEvents: function(j) {
        var g = this,
            e = g.events || (g.events = {}),
            a, c, d;
        if (typeof j == "string") {
            for (c = arguments, d = c.length; d--;) {
                a = c[d];
                if (!e[a]) {
                    e[a] = true
                }
            }
        } else {
            Ext.applyIf(g.events, j)
        }
    },
    hasListener: function(a) {
        return !!this.hasListeners[a.toLowerCase()]
    },
    suspendEvents: function(a) {
        this.eventsSuspended += 1;
        if (a && !this.eventQueue) {
            this.eventQueue = []
        }
    },
    resumeEvents: function() {
        var a = this,
            e = a.eventQueue,
            d, c;
        if (a.eventsSuspended && !--a.eventsSuspended) {
            delete a.eventQueue;
            if (e) {
                d = e.length;
                for (c = 0; c < d; c++) {
                    a.continueFireEvent.apply(a, e[c])
                }
            }
        }
    },
    relayEvents: function(d, g, l) {
        var k = this,
            a = g.length,
            e = 0,
            j, c;
        for (; e < a; e++) {
            j = g[e];
            c = l ? l + j : j;
            k.mon(d, j, k.createRelayer(c))
        }
    },
    createRelayer: function(a, c) {
        var d = this;
        return function() {
            return d.fireEvent.apply(d, [a].concat(Array.prototype.slice.apply(arguments, c || [0, -1])))
        }
    },
    enableBubble: function(l) {
        if (l) {
            var j = this,
                k = (typeof l == "string") ? arguments : l,
                g = k.length,
                d = j.events,
                c, e, a;
            for (a = 0; a < g; ++a) {
                c = k[a].toLowerCase();
                e = d[c];
                if (!e || typeof e == "boolean") {
                    d[c] = e = new Ext.util.Event(j, c)
                }
                j.hasListeners[c] = (j.hasListeners[c] || 0) + 1;
                e.bubble = true
            }
        }
    }
}, function() {
    var a = this,
        e = a.prototype,
        c = function() {},
        g = function(i) {
            if (!i.HasListeners) {
                var j = i.prototype;
                a.prepareClass(i, this);
                i.onExtended(function(k) {
                    a.prepareClass(k)
                });
                if (j.onClassMixedIn) {
                    Ext.override(i, {
                        onClassMixedIn: function(k) {
                            g.call(this, k);
                            this.callParent(arguments)
                        }
                    })
                } else {
                    j.onClassMixedIn = function(k) {
                        g.call(this, k)
                    }
                }
            }
        };
    c.prototype = {};
    e.HasListeners = a.HasListeners = c;
    a.createAlias({
        on: "addListener",
        un: "removeListener",
        mon: "addManagedListener",
        mun: "removeManagedListener"
    });
    a.observeClass = a.observe;

    function d(o) {
        var n = (this.methodEvents = this.methodEvents || {})[o],
            k, j, l, m = this,
            i;
        if (!n) {
            this.methodEvents[o] = n = {};
            n.originalFn = this[o];
            n.methodName = o;
            n.before = [];
            n.after = [];
            i = function(r, q, p) {
                if ((j = r.apply(q || m, p)) !== undefined) {
                    if (typeof j == "object") {
                        if (j.returnValue !== undefined) {
                            k = j.returnValue
                        } else {
                            k = j
                        }
                        l = !!j.cancel
                    } else {
                        if (j === false) {
                            l = true
                        } else {
                            k = j
                        }
                    }
                }
            };
            this[o] = function() {
                var r = Array.prototype.slice.call(arguments, 0),
                    q, s, p;
                k = j = undefined;
                l = false;
                for (s = 0, p = n.before.length; s < p; s++) {
                    q = n.before[s];
                    i(q.fn, q.scope, r);
                    if (l) {
                        return k
                    }
                }
                if ((j = n.originalFn.apply(m, r)) !== undefined) {
                    k = j
                }
                for (s = 0, p = n.after.length; s < p; s++) {
                    q = n.after[s];
                    i(q.fn, q.scope, r);
                    if (l) {
                        return k
                    }
                }
                return k
            }
        }
        return n
    }
    Ext.apply(e, {
        onClassMixedIn: g,
        beforeMethod: function(k, j, i) {
            d.call(this, k).before.push({
                fn: j,
                scope: i
            })
        },
        afterMethod: function(k, j, i) {
            d.call(this, k).after.push({
                fn: j,
                scope: i
            })
        },
        removeMethodListener: function(o, m, l) {
            var n = this.getMethodEvent(o),
                k, j;
            for (k = 0, j = n.before.length; k < j; k++) {
                if (n.before[k].fn == m && n.before[k].scope == l) {
                    Ext.Array.erase(n.before, k, 1);
                    return
                }
            }
            for (k = 0, j = n.after.length; k < j; k++) {
                if (n.after[k].fn == m && n.after[k].scope == l) {
                    Ext.Array.erase(n.after, k, 1);
                    return
                }
            }
        },
        toggleEventLogging: function(i) {
            Ext.util.Observable[i ? "capture" : "releaseCapture"](this, function(j) {
                if (Ext.isDefined(Ext.global.console)) {
                    Ext.global.console.log(j, arguments)
                }
            })
        }
    })
});
Ext.define("Ext.util.AbstractMixedCollection", {
    requires: ["Ext.util.Filter"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    isMixedCollection: true,
    generation: 0,
    constructor: function(c, a) {
        var d = this;
        d.items = [];
        d.map = {};
        d.keys = [];
        d.length = 0;
        d.allowFunctions = c === true;
        if (a) {
            d.getKey = a
        }
        d.mixins.observable.constructor.call(d)
    },
    allowFunctions: false,
    add: function(c, g) {
        var e = this,
            i = g,
            d = c,
            a;
        if (arguments.length == 1) {
            i = d;
            d = e.getKey(i)
        }
        if (typeof d != "undefined" && d !== null) {
            a = e.map[d];
            if (typeof a != "undefined") {
                return e.replace(d, i)
            }
            e.map[d] = i
        }
        e.generation++;
        e.length++;
        e.items.push(i);
        e.keys.push(d);
        if (e.hasListeners.add) {
            e.fireEvent("add", e.length - 1, i, d)
        }
        return i
    },
    getKey: function(a) {
        return a.id
    },
    replace: function(d, g) {
        var e = this,
            a, c;
        if (arguments.length == 1) {
            g = arguments[0];
            d = e.getKey(g)
        }
        a = e.map[d];
        if (typeof d == "undefined" || d === null || typeof a == "undefined") {
            return e.add(d, g)
        }
        e.generation++;
        c = e.indexOfKey(d);
        e.items[c] = g;
        e.map[d] = g;
        if (e.hasListeners.replace) {
            e.fireEvent("replace", d, a, g)
        }
        return g
    },
    addAll: function(j) {
        var g = this,
            e = 0,
            c, a, d;
        if (arguments.length > 1 || Ext.isArray(j)) {
            c = arguments.length > 1 ? arguments : j;
            for (a = c.length; e < a; e++) {
                g.add(c[e])
            }
        } else {
            for (d in j) {
                if (j.hasOwnProperty(d)) {
                    if (g.allowFunctions || typeof j[d] != "function") {
                        g.add(d, j[d])
                    }
                }
            }
        }
    },
    each: function(g, e) {
        var c = [].concat(this.items),
            d = 0,
            a = c.length,
            j;
        for (; d < a; d++) {
            j = c[d];
            if (g.call(e || j, j, d, a) === false) {
                break
            }
        }
    },
    eachKey: function(g, e) {
        var j = this.keys,
            c = this.items,
            d = 0,
            a = j.length;
        for (; d < a; d++) {
            g.call(e || window, j[d], c[d], d, a)
        }
    },
    findBy: function(g, e) {
        var j = this.keys,
            c = this.items,
            d = 0,
            a = c.length;
        for (; d < a; d++) {
            if (g.call(e || window, c[d], j[d])) {
                return c[d]
            }
        }
        return null
    },
    find: function() {
        if (Ext.isDefined(Ext.global.console)) {
            Ext.global.console.warn("Ext.util.MixedCollection: find has been deprecated. Use findBy instead.")
        }
        return this.findBy.apply(this, arguments)
    },
    insert: function(a, c, g) {
        var e = this,
            d = c,
            i = g;
        if (arguments.length == 2) {
            i = d;
            d = e.getKey(i)
        }
        if (e.containsKey(d)) {
            e.suspendEvents();
            e.removeAtKey(d);
            e.resumeEvents()
        }
        if (a >= e.length) {
            return e.add(d, i)
        }
        e.generation++;
        e.length++;
        Ext.Array.splice(e.items, a, 0, i);
        if (typeof d != "undefined" && d !== null) {
            e.map[d] = i
        }
        Ext.Array.splice(e.keys, a, 0, d);
        if (e.hasListeners.add) {
            e.fireEvent("add", a, i, d)
        }
        return i
    },
    remove: function(a) {
        this.generation++;
        return this.removeAt(this.indexOf(a))
    },
    removeAll: function(c) {
        c = [].concat(c);
        var d, a = c.length;
        for (d = 0; d < a; d++) {
            this.remove(c[d])
        }
        return this
    },
    removeAt: function(a) {
        var d = this,
            e, c;
        if (a < d.length && a >= 0) {
            d.length--;
            e = d.items[a];
            Ext.Array.erase(d.items, a, 1);
            c = d.keys[a];
            if (typeof c != "undefined") {
                delete d.map[c]
            }
            Ext.Array.erase(d.keys, a, 1);
            if (d.hasListeners.remove) {
                d.fireEvent("remove", e, c)
            }
            d.generation++;
            return e
        }
        return false
    },
    removeAtKey: function(a) {
        return this.removeAt(this.indexOfKey(a))
    },
    getCount: function() {
        return this.length
    },
    indexOf: function(a) {
        return Ext.Array.indexOf(this.items, a)
    },
    indexOfKey: function(a) {
        return Ext.Array.indexOf(this.keys, a)
    },
    get: function(c) {
        var e = this,
            a = e.map[c],
            d = a !== undefined ? a : (typeof c == "number") ? e.items[c] : undefined;
        return typeof d != "function" || e.allowFunctions ? d : null
    },
    getAt: function(a) {
        return this.items[a]
    },
    getByKey: function(a) {
        return this.map[a]
    },
    contains: function(a) {
        return typeof this.map[this.getKey(a)] != "undefined"
    },
    containsKey: function(a) {
        return typeof this.map[a] != "undefined"
    },
    clear: function() {
        var a = this;
        a.length = 0;
        a.items = [];
        a.keys = [];
        a.map = {};
        a.generation++;
        if (a.hasListeners.clear) {
            a.fireEvent("clear")
        }
    },
    first: function() {
        return this.items[0]
    },
    last: function() {
        return this.items[this.length - 1]
    },
    sum: function(k, c, l, a) {
        var d = this.extractValues(k, c),
            j = d.length,
            g = 0,
            e;
        l = l || 0;
        a = (a || a === 0) ? a : j - 1;
        for (e = l; e <= a; e++) {
            g += d[e]
        }
        return g
    },
    collect: function(m, g, k) {
        var n = this.extractValues(m, g),
            a = n.length,
            c = {},
            d = [],
            l, j, e;
        for (e = 0; e < a; e++) {
            l = n[e];
            j = String(l);
            if ((k || !Ext.isEmpty(l)) && !c[j]) {
                c[j] = true;
                d.push(l)
            }
        }
        return d
    },
    extractValues: function(d, a) {
        var c = this.items;
        if (a) {
            c = Ext.Array.pluck(c, a)
        }
        return Ext.Array.pluck(c, d)
    },
    getRange: function(j, a) {
        var g = this,
            d = g.items,
            c = [],
            e;
        if (d.length < 1) {
            return c
        }
        j = j || 0;
        a = Math.min(typeof a == "undefined" ? g.length - 1 : a, g.length - 1);
        if (j <= a) {
            for (e = j; e <= a; e++) {
                c[c.length] = d[e]
            }
        } else {
            for (e = j; e >= a; e--) {
                c[c.length] = d[e]
            }
        }
        return c
    },
    filter: function(e, d, i, a) {
        var c = [],
            g;
        if (Ext.isString(e)) {
            c.push(new Ext.util.Filter({
                property: e,
                value: d,
                anyMatch: i,
                caseSensitive: a
            }))
        } else {
            if (Ext.isArray(e) || e instanceof Ext.util.Filter) {
                c = c.concat(e)
            }
        }
        g = function(j) {
            var o = true,
                p = c.length,
                k, n, m, l;
            for (k = 0; k < p; k++) {
                n = c[k];
                m = n.filterFn;
                l = n.scope;
                o = o && m.call(l, j)
            }
            return o
        };
        return this.filterBy(g)
    },
    filterBy: function(g, e) {
        var l = this,
            a = new this.self(),
            k = l.keys,
            c = l.items,
            j = c.length,
            d;
        a.getKey = l.getKey;
        for (d = 0; d < j; d++) {
            if (g.call(e || l, c[d], k[d])) {
                a.add(k[d], c[d])
            }
        }
        return a
    },
    findIndex: function(d, c, g, e, a) {
        if (Ext.isEmpty(c, false)) {
            return -1
        }
        c = this.createValueMatcher(c, e, a);
        return this.findIndexBy(function(i) {
            return i && c.test(i[d])
        }, null, g)
    },
    findIndexBy: function(g, e, l) {
        var k = this,
            j = k.keys,
            c = k.items,
            d = l || 0,
            a = c.length;
        for (; d < a; d++) {
            if (g.call(e || k, c[d], j[d])) {
                return d
            }
        }
        return -1
    },
    createValueMatcher: function(d, g, a, c) {
        if (!d.exec) {
            var e = Ext.String.escapeRegex;
            d = String(d);
            if (g === true) {
                d = e(d)
            } else {
                d = "^" + e(d);
                if (c === true) {
                    d += "$"
                }
            }
            d = new RegExp(d, a ? "" : "i")
        }
        return d
    },
    clone: function() {
        var g = this,
            j = new this.self(),
            e = g.keys,
            c = g.items,
            d = 0,
            a = c.length;
        for (; d < a; d++) {
            j.add(e[d], c[d])
        }
        j.getKey = g.getKey;
        return j
    }
});
Ext.define("Ext.util.Sorter", {
    direction: "ASC",
    constructor: function(a) {
        var c = this;
        Ext.apply(c, a);
        c.updateSortFunction()
    },
    createSortFunction: function(c) {
        var d = this,
            e = d.property,
            g = d.direction || "ASC",
            a = g.toUpperCase() == "DESC" ? -1 : 1;
        return function(j, i) {
            return a * c.call(d, j, i)
        }
    },
    defaultSorterFn: function(e, d) {
        var c = this,
            a = c.transform,
            i = c.getRoot(e)[c.property],
            g = c.getRoot(d)[c.property];
        if (a) {
            i = a(i);
            g = a(g)
        }
        return i > g ? 1 : (i < g ? -1 : 0)
    },
    getRoot: function(a) {
        return this.root === undefined ? a : a[this.root]
    },
    setDirection: function(c) {
        var a = this;
        a.direction = c ? c.toUpperCase() : c;
        a.updateSortFunction()
    },
    toggle: function() {
        var a = this;
        a.direction = Ext.String.toggle(a.direction, "ASC", "DESC");
        a.updateSortFunction()
    },
    updateSortFunction: function(a) {
        var c = this;
        a = a || c.sorterFn || c.defaultSorterFn;
        c.sort = c.createSortFunction(a)
    }
});
Ext.define("Ext.util.Sortable", {
    isSortable: true,
    defaultSortDirection: "ASC",
    requires: ["Ext.util.Sorter"],
    initSortable: function() {
        var a = this,
            c = a.sorters;
        a.sorters = new Ext.util.AbstractMixedCollection(false, function(d) {
            return d.id || d.property
        });
        if (c) {
            a.sorters.addAll(a.decodeSorters(c))
        }
    },
    sort: function(j, i, d, g) {
        var e = this,
            k, c, a;
        if (Ext.isArray(j)) {
            g = d;
            d = i;
            a = j
        } else {
            if (Ext.isObject(j)) {
                g = d;
                d = i;
                a = [j]
            } else {
                if (Ext.isString(j)) {
                    k = e.sorters.get(j);
                    if (!k) {
                        k = {
                            property: j,
                            direction: i
                        };
                        a = [k]
                    } else {
                        if (i === undefined) {
                            k.toggle()
                        } else {
                            k.setDirection(i)
                        }
                    }
                }
            }
        }
        if (a && a.length) {
            a = e.decodeSorters(a);
            if (Ext.isString(d)) {
                if (d === "prepend") {
                    j = e.sorters.clone().items;
                    e.sorters.clear();
                    e.sorters.addAll(a);
                    e.sorters.addAll(j)
                } else {
                    e.sorters.addAll(a)
                }
            } else {
                e.sorters.clear();
                e.sorters.addAll(a)
            }
        }
        if (g !== false) {
            e.onBeforeSort(a);
            j = e.sorters.items;
            if (j.length) {
                e.doSort(e.generateComparator())
            }
        }
        return j
    },
    generateComparator: function() {
        var a = this.sorters.getRange();
        return a.length ? this.createComparator(a) : this.emptyComparator
    },
    createComparator: function(a) {
        return function(e, d) {
            var c = a[0].sort(e, d),
                j = a.length,
                g = 1;
            for (; g < j; g++) {
                c = c || a[g].sort.call(this, e, d)
            }
            return c
        }
    },
    emptyComparator: function() {
        return 0
    },
    onBeforeSort: Ext.emptyFn,
    decodeSorters: function(j) {
        if (!Ext.isArray(j)) {
            if (j === undefined) {
                j = []
            } else {
                j = [j]
            }
        }
        var e = j.length,
            k = Ext.util.Sorter,
            a = this.model ? this.model.prototype.fields : null,
            g, c, d;
        for (d = 0; d < e; d++) {
            c = j[d];
            if (!(c instanceof k)) {
                if (Ext.isString(c)) {
                    c = {
                        property: c
                    }
                }
                Ext.applyIf(c, {
                    root: this.sortRoot,
                    direction: "ASC"
                });
                if (c.fn) {
                    c.sorterFn = c.fn
                }
                if (typeof c == "function") {
                    c = {
                        sorterFn: c
                    }
                }
                if (a && !c.transform) {
                    g = a.get(c.property);
                    c.transform = g ? g.sortType : undefined
                }
                j[d] = new Ext.util.Sorter(c)
            }
        }
        return j
    },
    getSorters: function() {
        return this.sorters.items
    },
    getFirstSorter: function() {
        var d = this.sorters.items,
            a = d.length,
            c = 0,
            e;
        for (; c < a; ++c) {
            e = d[c];
            if (!e.isGrouper) {
                return e
            }
        }
        return null
    }
});
Ext.define("Ext.util.MixedCollection", {
    extend: "Ext.util.AbstractMixedCollection",
    mixins: {
        sortable: "Ext.util.Sortable"
    },
    constructor: function() {
        var a = this;
        a.callParent(arguments);
        a.addEvents("sort");
        a.mixins.sortable.initSortable.call(a)
    },
    doSort: function(a) {
        this.sortBy(a)
    },
    _sort: function(n, a, m) {
        var l = this,
            e, g, d = String(a).toUpperCase() == "DESC" ? -1 : 1,
            k = [],
            o = l.keys,
            j = l.items;
        m = m || function(i, c) {
            return i - c
        };
        for (e = 0, g = j.length; e < g; e++) {
            k[k.length] = {
                key: o[e],
                value: j[e],
                index: e
            }
        }
        Ext.Array.sort(k, function(i, c) {
            var p = m(i[n], c[n]) * d;
            if (p === 0) {
                p = (i.index < c.index ? -1 : 1)
            }
            return p
        });
        for (e = 0, g = k.length; e < g; e++) {
            j[e] = k[e].value;
            o[e] = k[e].key
        }
        l.fireEvent("sort", l)
    },
    sortBy: function(d) {
        var k = this,
            c = k.items,
            j = k.keys,
            g = c.length,
            a = [],
            e;
        for (e = 0; e < g; e++) {
            a[e] = {
                key: j[e],
                value: c[e],
                index: e
            }
        }
        Ext.Array.sort(a, function(l, i) {
            var m = d(l.value, i.value);
            if (m === 0) {
                m = (l.index < i.index ? -1 : 1)
            }
            return m
        });
        for (e = 0; e < g; e++) {
            c[e] = a[e].value;
            j[e] = a[e].key
        }
        k.fireEvent("sort", k, c, j)
    },
    findInsertionIndex: function(g, e) {
        var i = this,
            c = i.items,
            k = 0,
            a = c.length - 1,
            d, j;
        if (!e) {
            e = i.generateComparator()
        }
        while (k <= a) {
            d = (k + a) >> 1;
            j = e(g, c[d]);
            if (j >= 0) {
                k = d + 1
            } else {
                if (j < 0) {
                    a = d - 1
                }
            }
        }
        return k
    },
    reorder: function(e) {
        var j = this,
            c = j.items,
            d = 0,
            i = c.length,
            a = [],
            g = [],
            k;
        j.suspendEvents();
        for (k in e) {
            a[e[k]] = c[k]
        }
        for (d = 0; d < i; d++) {
            if (e[d] == undefined) {
                g.push(c[d])
            }
        }
        for (d = 0; d < i; d++) {
            if (a[d] == undefined) {
                a[d] = g.shift()
            }
        }
        j.clear();
        j.addAll(a);
        j.resumeEvents();
        j.fireEvent("sort", j)
    },
    sortByKey: function(a, c) {
        this._sort("key", a, c || function(e, d) {
            var i = String(e).toUpperCase(),
                g = String(d).toUpperCase();
            return i > g ? 1 : (i < g ? -1 : 0)
        })
    }
});
Ext.define("Ext.data.proxy.Proxy", {
    alias: "proxy.proxy",
    alternateClassName: ["Ext.data.DataProxy", "Ext.data.Proxy"],
    uses: ["Ext.data.Batch", "Ext.data.Operation", "Ext.data.Model"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    batchOrder: "create,update,destroy",
    batchActions: true,
    defaultReaderType: "json",
    defaultWriterType: "json",
    isProxy: true,
    constructor: function(a) {
        a = a || {};
        if (a.model === undefined) {
            delete a.model
        }
        this.mixins.observable.constructor.call(this, a);
        if (this.model !== undefined && !(this.model instanceof Ext.data.Model)) {
            this.setModel(this.model)
        }
    },
    setModel: function(c, d) {
        this.model = Ext.ModelManager.getModel(c);
        var a = this.reader,
            e = this.writer;
        this.setReader(a);
        this.setWriter(e);
        if (d && this.store) {
            this.store.setModel(this.model)
        }
    },
    getModel: function() {
        return this.model
    },
    setReader: function(a) {
        var d = this,
            c = true;
        if (a === undefined || typeof a == "string") {
            a = {
                type: a
            };
            c = false
        }
        if (a.isReader) {
            a.setModel(d.model)
        } else {
            if (c) {
                a = Ext.apply({}, a)
            }
            Ext.applyIf(a, {
                proxy: d,
                model: d.model,
                type: d.defaultReaderType
            });
            a = Ext.createByAlias("reader." + a.type, a)
        }
        if (a.onMetaChange) {
            a.onMetaChange = Ext.Function.createSequence(a.onMetaChange, this.onMetaChange, this)
        }
        d.reader = a;
        return d.reader
    },
    getReader: function() {
        return this.reader
    },
    onMetaChange: function(a) {
        this.fireEvent("metachange", this, a)
    },
    setWriter: function(d) {
        var c = this,
            a = true;
        if (d === undefined || typeof d == "string") {
            d = {
                type: d
            };
            a = false
        }
        if (!d.isWriter) {
            if (a) {
                d = Ext.apply({}, d)
            }
            Ext.applyIf(d, {
                model: c.model,
                type: c.defaultWriterType
            });
            d = Ext.createByAlias("writer." + d.type, d)
        }
        c.writer = d;
        return c.writer
    },
    getWriter: function() {
        return this.writer
    },
    create: Ext.emptyFn,
    read: Ext.emptyFn,
    update: Ext.emptyFn,
    destroy: Ext.emptyFn,
    batch: function(q, n) {
        var m = this,
            l = m.batchActions,
            j, d, i, e, g, o, c, p, k;
        if (q.operations === undefined) {
            q = {
                operations: q,
                listeners: n
            }
        }
        if (q.batch) {
            if (Ext.isDefined(q.batch.runOperation)) {
                j = Ext.applyIf(q.batch, {
                    proxy: m,
                    listeners: {}
                })
            }
        } else {
            q.batch = {
                proxy: m,
                listeners: q.listeners || {}
            }
        }
        if (!j) {
            j = new Ext.data.Batch(q.batch)
        }
        j.on("complete", Ext.bind(m.onBatchComplete, m, [q], 0));
        i = m.batchOrder.split(",");
        e = i.length;
        for (o = 0; o < e; o++) {
            g = i[o];
            d = q.operations[g];
            if (d) {
                if (l) {
                    j.add(new Ext.data.Operation({
                        action: g,
                        records: d
                    }))
                } else {
                    p = d.length;
                    for (c = 0; c < p; c++) {
                        k = d[c];
                        j.add(new Ext.data.Operation({
                            action: g,
                            records: [k]
                        }))
                    }
                }
            }
        }
        j.start();
        return j
    },
    onBatchComplete: function(a, c) {
        var d = a.scope || this;
        if (c.hasException) {
            if (Ext.isFunction(a.failure)) {
                Ext.callback(a.failure, d, [c, a])
            }
        } else {
            if (Ext.isFunction(a.success)) {
                Ext.callback(a.success, d, [c, a])
            }
        }
        if (Ext.isFunction(a.callback)) {
            Ext.callback(a.callback, d, [c, a])
        }
    }
}, function() {
    Ext.data.DataProxy = this
});
Ext.define("Ext.data.Operation", {
    synchronous: true,
    action: undefined,
    filters: undefined,
    sorters: undefined,
    groupers: undefined,
    start: undefined,
    limit: undefined,
    batch: undefined,
    callback: undefined,
    scope: undefined,
    started: false,
    running: false,
    complete: false,
    success: undefined,
    exception: false,
    error: undefined,
    actionCommitRecordsRe: /^(?:create|update)$/i,
    actionSkipSyncRe: /^destroy$/i,
    constructor: function(a) {
        Ext.apply(this, a || {})
    },
    commitRecords: function(m) {
        var k = this,
            l, j, a, d, c, e, g;
        if (!k.actionSkipSyncRe.test(k.action)) {
            a = k.records;
            if (a && a.length) {
                if (a.length > 1) {
                    if (k.action == "update" || a[0].clientIdProperty) {
                        l = new Ext.util.MixedCollection();
                        l.addAll(m);
                        for (j = a.length; j--;) {
                            c = a[j];
                            d = l.findBy(k.matchClientRec, c);
                            c.copyFrom(d)
                        }
                    } else {
                        for (e = 0, g = a.length; e < g; ++e) {
                            c = a[e];
                            d = m[e];
                            if (c && d) {
                                k.updateRecord(c, d)
                            }
                        }
                    }
                } else {
                    this.updateRecord(a[0], m[0])
                }
                if (k.actionCommitRecordsRe.test(k.action)) {
                    for (j = a.length; j--;) {
                        a[j].commit()
                    }
                }
            }
        }
    },
    updateRecord: function(a, c) {
        if (c && (a.phantom || a.getId() === c.getId())) {
            a.copyFrom(c)
        }
    },
    matchClientRec: function(d) {
        var a = this,
            c = a.getId();
        if (c && d.getId() === c) {
            return true
        }
        return d.internalId === a.internalId
    },
    setStarted: function() {
        this.started = true;
        this.running = true
    },
    setCompleted: function() {
        this.complete = true;
        this.running = false
    },
    setSuccessful: function() {
        this.success = true
    },
    setException: function(a) {
        this.exception = true;
        this.success = false;
        this.running = false;
        this.error = a
    },
    hasException: function() {
        return this.exception === true
    },
    getError: function() {
        return this.error
    },
    getRecords: function() {
        var a = this.getResultSet();
        return this.records || (a ? a.records : null)
    },
    getResultSet: function() {
        return this.resultSet
    },
    isStarted: function() {
        return this.started === true
    },
    isRunning: function() {
        return this.running === true
    },
    isComplete: function() {
        return this.complete === true
    },
    wasSuccessful: function() {
        return this.isComplete() && this.success === true
    },
    setBatch: function(a) {
        this.batch = a
    },
    allowWrite: function() {
        return this.action != "read"
    }
});
Ext.define("Ext.data.AbstractStore", {
    requires: ["Ext.util.MixedCollection", "Ext.data.proxy.Proxy", "Ext.data.Operation", "Ext.util.Filter"],
    mixins: {
        observable: "Ext.util.Observable",
        sortable: "Ext.util.Sortable"
    },
    statics: {
        create: function(a) {
            if (!a.isStore) {
                if (!a.type) {
                    a.type = "store"
                }
                a = Ext.createByAlias("store." + a.type, a)
            }
            return a
        }
    },
    remoteSort: false,
    remoteFilter: false,
    autoLoad: undefined,
    autoSync: false,
    batchUpdateMode: "operation",
    filterOnLoad: true,
    sortOnLoad: true,
    implicitModel: false,
    defaultProxyType: "memory",
    isDestroyed: false,
    isStore: true,
    sortRoot: "data",
    constructor: function(a) {
        var d = this,
            c;
        Ext.apply(d, a);
        d.removed = [];
        d.mixins.observable.constructor.apply(d, arguments);
        d.model = Ext.ModelManager.getModel(d.model);
        Ext.applyIf(d, {
            modelDefaults: {}
        });
        if (!d.model && d.fields) {
            d.model = Ext.define("Ext.data.Store.ImplicitModel-" + (d.storeId || Ext.id()), {
                extend: "Ext.data.Model",
                fields: d.fields,
                proxy: d.proxy || d.defaultProxyType
            });
            delete d.fields;
            d.implicitModel = true
        }
        d.setProxy(d.proxy || d.model.getProxy());
        d.proxy.on("metachange", d.onMetaChange, d);
        if (d.id && !d.storeId) {
            d.storeId = d.id;
            delete d.id
        }
        if (d.storeId) {
            Ext.data.StoreManager.register(d)
        }
        d.mixins.sortable.initSortable.call(d);
        c = d.decodeFilters(d.filters);
        d.filters = new Ext.util.MixedCollection();
        d.filters.addAll(c)
    },
    setProxy: function(a) {
        var c = this;
        if (a instanceof Ext.data.proxy.Proxy) {
            a.setModel(c.model)
        } else {
            if (Ext.isString(a)) {
                a = {
                    type: a
                }
            }
            Ext.applyIf(a, {
                model: c.model
            });
            a = Ext.createByAlias("proxy." + a.type, a)
        }
        c.proxy = a;
        return c.proxy
    },
    getProxy: function() {
        return this.proxy
    },
    onMetaChange: function(a, c) {
        this.fireEvent("metachange", this, c)
    },
    create: function(g, d) {
        var e = this,
            a = Ext.ModelManager.create(Ext.applyIf(g, e.modelDefaults), e.model.modelName),
            c;
        d = d || {};
        Ext.applyIf(d, {
            action: "create",
            records: [a]
        });
        c = new Ext.data.Operation(d);
        e.proxy.create(c, e.onProxyWrite, e);
        return a
    },
    read: function() {
        return this.load.apply(this, arguments)
    },
    update: function(c) {
        var d = this,
            a;
        c = c || {};
        Ext.applyIf(c, {
            action: "update",
            records: d.getUpdatedRecords()
        });
        a = new Ext.data.Operation(c);
        return d.proxy.update(a, d.onProxyWrite, d)
    },
    onProxyWrite: function(c) {
        var d = this,
            e = c.wasSuccessful(),
            a = c.getRecords();
        switch (c.action) {
            case "create":
                d.onCreateRecords(a, c, e);
                break;
            case "update":
                d.onUpdateRecords(a, c, e);
                break;
            case "destroy":
                d.onDestroyRecords(a, c, e);
                break
        }
        if (e) {
            d.fireEvent("write", d, c);
            d.fireEvent("datachanged", d);
            d.fireEvent("refresh", d)
        }
        Ext.callback(c.callback, c.scope || d, [a, c, e])
    },
    onCreateRecords: Ext.emptyFn,
    onUpdateRecords: Ext.emptyFn,
    onDestroyRecords: function(c, a, d) {
        if (d) {
            this.removed = []
        }
    },
    destroy: function(c) {
        var d = this,
            a;
        c = c || {};
        Ext.applyIf(c, {
            action: "destroy",
            records: d.getRemovedRecords()
        });
        a = new Ext.data.Operation(c);
        return d.proxy.destroy(a, d.onProxyWrite, d)
    },
    onBatchOperationComplete: function(c, a) {
        return this.onProxyWrite(a)
    },
    onBatchComplete: function(d, a) {
        var j = this,
            c = d.operations,
            g = c.length,
            e;
        j.suspendEvents();
        for (e = 0; e < g; e++) {
            j.onProxyWrite(c[e])
        }
        j.resumeEvents();
        j.fireEvent("datachanged", j);
        j.fireEvent("refresh", j)
    },
    onBatchException: function(c, a) {},
    filterNew: function(a) {
        return a.phantom === true && a.isValid()
    },
    getNewRecords: function() {
        return []
    },
    getUpdatedRecords: function() {
        return []
    },
    getModifiedRecords: function() {
        return [].concat(this.getNewRecords(), this.getUpdatedRecords())
    },
    filterUpdated: function(a) {
        return a.dirty === true && a.phantom !== true && a.isValid()
    },
    getRemovedRecords: function() {
        return this.removed
    },
    filter: function(a, c) {},
    decodeFilters: function(g) {
        if (!Ext.isArray(g)) {
            if (g === undefined) {
                g = []
            } else {
                g = [g]
            }
        }
        var e = g.length,
            a = Ext.util.Filter,
            c, d;
        for (d = 0; d < e; d++) {
            c = g[d];
            if (!(c instanceof a)) {
                Ext.apply(c, {
                    root: "data"
                });
                if (c.fn) {
                    c.filterFn = c.fn
                }
                if (typeof c == "function") {
                    c = {
                        filterFn: c
                    }
                }
                g[d] = new a(c)
            }
        }
        return g
    },
    clearFilter: function(a) {},
    isFiltered: function() {},
    filterBy: function(c, a) {},
    sync: function(d) {
        var g = this,
            c = {},
            i = g.getNewRecords(),
            e = g.getUpdatedRecords(),
            a = g.getRemovedRecords(),
            j = false;
        if (i.length > 0) {
            c.create = i;
            j = true
        }
        if (e.length > 0) {
            c.update = e;
            j = true
        }
        if (a.length > 0) {
            c.destroy = a;
            j = true
        }
        if (j && g.fireEvent("beforesync", c) !== false) {
            d = d || {};
            g.proxy.batch(Ext.apply(d, {
                operations: c,
                listeners: g.getBatchListeners()
            }))
        }
        return g
    },
    getBatchListeners: function() {
        var c = this,
            a = {
                scope: c,
                exception: c.onBatchException
            };
        if (c.batchUpdateMode == "operation") {
            a.operationcomplete = c.onBatchOperationComplete
        } else {
            a.complete = c.onBatchComplete
        }
        return a
    },
    save: function() {
        return this.sync.apply(this, arguments)
    },
    load: function(c) {
        var d = this,
            a;
        c = Ext.apply({
            action: "read",
            filters: d.filters.items,
            sorters: d.getSorters()
        }, c);
        d.lastOptions = c;
        a = new Ext.data.Operation(c);
        if (d.fireEvent("beforeload", d, a) !== false) {
            d.loading = true;
            d.proxy.read(a, d.onProxyLoad, d)
        }
        return d
    },
    reload: function(a) {
        return this.load(Ext.apply(this.lastOptions, a))
    },
    afterEdit: function(a, g) {
        var e = this,
            c, d;
        if (e.autoSync && !e.autoSyncSuspended) {
            for (c = g.length; c--;) {
                if (a.fields.get(g[c]).persist) {
                    d = true;
                    break
                }
            }
            if (d) {
                e.sync()
            }
        }
        e.fireEvent("update", e, a, Ext.data.Model.EDIT, g)
    },
    afterReject: function(a) {
        this.fireEvent("update", this, a, Ext.data.Model.REJECT, null)
    },
    afterCommit: function(a) {
        this.fireEvent("update", this, a, Ext.data.Model.COMMIT, null)
    },
    destroyStore: function() {
        var a = this;
        if (!a.isDestroyed) {
            if (a.storeId) {
                Ext.data.StoreManager.unregister(a)
            }
            a.clearData();
            a.data = a.tree = a.sorters = a.filters = a.groupers = null;
            if (a.reader) {
                a.reader.destroyReader()
            }
            a.proxy = a.reader = a.writer = null;
            a.clearListeners();
            a.isDestroyed = true;
            if (a.implicitModel) {
                Ext.destroy(a.model)
            } else {
                a.model = null
            }
        }
    },
    doSort: function(a) {
        var c = this;
        if (c.remoteSort) {
            c.load()
        } else {
            c.data.sortBy(a);
            c.fireEvent("datachanged", c);
            c.fireEvent("refresh", c)
        }
    },
    clearData: Ext.emptyFn,
    getCount: Ext.emptyFn,
    getById: Ext.emptyFn,
    removeAll: Ext.emptyFn,
    isLoading: function() {
        return !!this.loading
    },
    suspendAutoSync: function() {
        this.autoSyncSuspended = true
    },
    resumeAutoSync: function() {
        this.autoSyncSuspended = false
    }
});
Ext.define("Ext.data.Tree", {
    alias: "data.tree",
    mixins: {
        observable: "Ext.util.Observable"
    },
    root: null,
    constructor: function(a) {
        var c = this;
        c.mixins.observable.constructor.call(c);
        if (a) {
            c.setRootNode(a)
        }
    },
    getRootNode: function() {
        return this.root
    },
    setRootNode: function(c) {
        var a = this;
        a.root = c;
        if (a.fireEvent("beforeappend", null, c) !== false) {
            c.set("root", true);
            c.updateInfo();
            c.commit();
            c.on({
                scope: a,
                insert: a.onNodeInsert,
                append: a.onNodeAppend,
                remove: a.onNodeRemove
            });
            a.relayEvents(c, ["append", "remove", "move", "insert", "beforeappend", "beforeremove", "beforemove", "beforeinsert", "expand", "collapse", "beforeexpand", "beforecollapse", "sort", "rootchange"]);
            a.nodeHash = {};
            a.registerNode(c);
            a.fireEvent("append", null, c);
            a.fireEvent("rootchange", c)
        }
        return c
    },
    flatten: function() {
        return Ext.Object.getValues(this.nodeHash)
    },
    onNodeInsert: function(a, c) {
        this.registerNode(c, true)
    },
    onNodeAppend: function(a, c) {
        this.registerNode(c, true)
    },
    onNodeRemove: function(a, c) {
        this.unregisterNode(c, true)
    },
    onNodeIdChanged: function(d, e, a) {
        var c = this.nodeHash;
        c[a] = d;
        delete c[e || d.internalId]
    },
    getNodeById: function(a) {
        return this.nodeHash[a]
    },
    registerNode: function(d, a) {
        var c = this;
        c.nodeHash[d.getId() || d.internalId] = d;
        d.on("idchanged", c.onNodeIdChanged, c);
        if (a === true) {
            d.eachChild(function(e) {
                c.registerNode(e, true)
            })
        }
    },
    unregisterNode: function(c, a) {
        delete this.nodeHash[c.getId() || c.internalId];
        if (a === true) {
            c.eachChild(function(d) {
                this.unregisterNode(d, true)
            }, this)
        }
    },
    sort: function(c, a) {
        this.getRootNode().sort(c, a)
    },
    filter: function(c, a) {
        this.getRootNode().filter(c, a)
    }
});
Ext.define("Ext.data.SortTypes", {
    singleton: true,
    none: function(a) {
        return a
    },
    stripTagsRE: /<\/?[^>]+>/gi,
    asText: function(a) {
        return String(a).replace(this.stripTagsRE, "")
    },
    asUCText: function(a) {
        return String(a).toUpperCase().replace(this.stripTagsRE, "")
    },
    asUCString: function(a) {
        return String(a).toUpperCase()
    },
    asDate: function(a) {
        if (!a) {
            return 0
        }
        if (Ext.isDate(a)) {
            return a.getTime()
        }
        return Date.parse(String(a))
    },
    asFloat: function(a) {
        var c = parseFloat(String(a).replace(/,/g, ""));
        return isNaN(c) ? 0 : c
    },
    asInt: function(a) {
        var c = parseInt(String(a).replace(/,/g, ""), 10);
        return isNaN(c) ? 0 : c
    }
});
Ext.define("Ext.data.Types", {
    singleton: true,
    requires: ["Ext.data.SortTypes"]
}, function() {
    var a = Ext.data.SortTypes;
    Ext.apply(Ext.data.Types, {
        stripRe: /[\$,%]/g,
        AUTO: {
            sortType: a.none,
            type: "auto"
        },
        STRING: {
            convert: function(d) {
                var c = this.useNull ? null : "";
                return (d === undefined || d === null) ? c : String(d)
            },
            sortType: a.asUCString,
            type: "string"
        },
        INT: {
            convert: function(c) {
                return c !== undefined && c !== null && c !== "" ? parseInt(String(c).replace(Ext.data.Types.stripRe, ""), 10) : (this.useNull ? null : 0)
            },
            sortType: a.none,
            type: "int"
        },
        FLOAT: {
            convert: function(c) {
                return c !== undefined && c !== null && c !== "" ? parseFloat(String(c).replace(Ext.data.Types.stripRe, ""), 10) : (this.useNull ? null : 0)
            },
            sortType: a.none,
            type: "float"
        },
        BOOL: {
            convert: function(c) {
                if (this.useNull && (c === undefined || c === null || c === "")) {
                    return null
                }
                return c === true || c === "true" || c == 1
            },
            sortType: a.none,
            type: "bool"
        },
        DATE: {
            convert: function(d) {
                var e = this.dateFormat,
                    c;
                if (!d) {
                    return null
                }
                if (Ext.isDate(d)) {
                    return d
                }
                if (e) {
                    if (e == "timestamp") {
                        return new Date(d * 1000)
                    }
                    if (e == "time") {
                        return new Date(parseInt(d, 10))
                    }
                    return Ext.Date.parse(d, e)
                }
                c = Date.parse(d);
                return c ? new Date(c) : null
            },
            sortType: a.asDate,
            type: "date"
        }
    });
    Ext.apply(Ext.data.Types, {
        BOOLEAN: this.BOOL,
        INTEGER: this.INT,
        NUMBER: this.FLOAT
    })
});
Ext.define("Ext.data.Field", {
    requires: ["Ext.data.Types", "Ext.data.SortTypes"],
    alias: "data.field",
    isField: true,
    constructor: function(c) {
        var e = this,
            d = Ext.data.Types,
            a;
        if (Ext.isString(c)) {
            c = {
                name: c
            }
        }
        Ext.apply(e, c);
        a = e.sortType;
        if (e.type) {
            if (Ext.isString(e.type)) {
                e.type = d[e.type.toUpperCase()] || d.AUTO
            }
        } else {
            e.type = d.AUTO
        }
        if (Ext.isString(a)) {
            e.sortType = Ext.data.SortTypes[a]
        } else {
            if (Ext.isEmpty(a)) {
                e.sortType = e.type.sortType
            }
        }
        if (!c.hasOwnProperty("convert")) {
            e.convert = e.type.convert
        } else {
            if (!e.convert && e.type.convert && !c.hasOwnProperty("defaultValue")) {
                e.defaultValue = e.type.convert(e.defaultValue)
            }
        }
        if (c.convert) {
            e.hasCustomConvert = true
        }
    },
    dateFormat: null,
    useNull: false,
    defaultValue: "",
    mapping: null,
    sortType: null,
    sortDir: "ASC",
    allowBlank: true,
    persist: true
});
Ext.define("Ext.data.NodeInterface", {
    requires: ["Ext.data.Field"],
    statics: {
        decorate: function(c) {
            var a, d;
            if (typeof c == "string") {
                c = Ext.ModelManager.getModel(c)
            } else {
                if (c.isModel) {
                    c = Ext.ModelManager.getModel(c.modelName)
                }
            }
            if (c.prototype.isNode) {
                return
            }
            a = c.prototype.idProperty;
            idField = c.prototype.fields.get(a);
            d = c.prototype.fields.get(a).type.type;
            c.override(this.getPrototypeBody());
            this.applyFields(c, [{
                name: "parentId",
                type: d,
                defaultValue: null,
                useNull: idField.useNull
            }, {
                name: "index",
                type: "int",
                defaultValue: null,
                persist: false
            }, {
                name: "depth",
                type: "int",
                defaultValue: 0,
                persist: false
            }, {
                name: "expanded",
                type: "bool",
                defaultValue: false,
                persist: false
            }, {
                name: "expandable",
                type: "bool",
                defaultValue: true,
                persist: false
            }, {
                name: "checked",
                type: "auto",
                defaultValue: null,
                persist: false
            }, {
                name: "leaf",
                type: "bool",
                defaultValue: false
            }, {
                name: "cls",
                type: "string",
                defaultValue: null,
                persist: false
            }, {
                name: "iconCls",
                type: "string",
                defaultValue: null,
                persist: false
            }, {
                name: "icon",
                type: "string",
                defaultValue: null,
                persist: false
            }, {
                name: "root",
                type: "boolean",
                defaultValue: false,
                persist: false
            }, {
                name: "isLast",
                type: "boolean",
                defaultValue: false,
                persist: false
            }, {
                name: "isFirst",
                type: "boolean",
                defaultValue: false,
                persist: false
            }, {
                name: "allowDrop",
                type: "boolean",
                defaultValue: true,
                persist: false
            }, {
                name: "allowDrag",
                type: "boolean",
                defaultValue: true,
                persist: false
            }, {
                name: "loaded",
                type: "boolean",
                defaultValue: false,
                persist: false
            }, {
                name: "loading",
                type: "boolean",
                defaultValue: false,
                persist: false
            }, {
                name: "href",
                type: "string",
                defaultValue: null,
                persist: false
            }, {
                name: "hrefTarget",
                type: "string",
                defaultValue: null,
                persist: false
            }, {
                name: "qtip",
                type: "string",
                defaultValue: null,
                persist: false
            }, {
                name: "qtitle",
                type: "string",
                defaultValue: null,
                persist: false
            }, {
                name: "children",
                type: "auto",
                defaultValue: null,
                persist: false
            }])
        },
        applyFields: function(d, c) {
            var k = d.prototype,
                a = k.fields,
                j = a.keys,
                g = c.length,
                l, e;
            for (e = 0; e < g; e++) {
                l = c[e];
                if (!Ext.Array.contains(j, l.name)) {
                    a.add(new Ext.data.Field(l))
                }
            }
        },
        getPrototypeBody: function() {
            return {
                isNode: true,
                constructor: function() {
                    var a = this;
                    this.callParent(arguments);
                    Ext.applyIf(a, {
                        firstChild: null,
                        lastChild: null,
                        parentNode: null,
                        previousSibling: null,
                        nextSibling: null,
                        childNodes: []
                    });
                    a.enableBubble(["append", "remove", "move", "insert", "beforeappend", "beforeremove", "beforemove", "beforeinsert", "expand", "collapse", "beforeexpand", "beforecollapse", "sort"]);
                    return a
                },
                createNode: function(a) {
                    if (Ext.isObject(a) && !a.isModel) {
                        a = Ext.ModelManager.create(a, this.modelName)
                    }
                    if (!a.childNodes) {
                        Ext.applyIf(a, {
                            firstChild: null,
                            lastChild: null,
                            parentNode: null,
                            previousSibling: null,
                            nextSibling: null,
                            childNodes: []
                        })
                    }
                    return a
                },
                isLeaf: function() {
                    return this.get("leaf") === true
                },
                setFirstChild: function(a) {
                    this.firstChild = a
                },
                setLastChild: function(a) {
                    this.lastChild = a
                },
                updateInfo: function(j) {
                    var o = this,
                        c = o.isRoot(),
                        m = o.parentNode,
                        e = (!m || c ? true : m.firstChild === o),
                        l = (!m || c ? true : m.lastChild === o),
                        k = 0,
                        p = o,
                        a = o.childNodes,
                        n = a.length,
                        g = 0,
                        d = o.phantom;
                    while (p.parentNode) {
                        ++k;
                        p = p.parentNode
                    }
                    o.beginEdit();
                    o.set({
                        isFirst: e,
                        isLast: l,
                        depth: k,
                        index: m ? m.indexOf(o) : 0,
                        parentId: m ? m.getId() : null
                    });
                    o.endEdit(true);
                    if (j) {
                        o.commit();
                        o.phantom = d
                    }
                    for (g = 0; g < n; g++) {
                        a[g].updateInfo(j)
                    }
                },
                isLast: function() {
                    return this.get("isLast")
                },
                isFirst: function() {
                    return this.get("isFirst")
                },
                hasChildNodes: function() {
                    return !this.isLeaf() && this.childNodes.length > 0
                },
                isExpandable: function() {
                    var a = this;
                    if (a.get("expandable")) {
                        return !(a.isLeaf() || (a.isLoaded() && !a.hasChildNodes()))
                    }
                    return false
                },
                triggerUIUpdate: function() {
                    this.afterEdit([])
                },
                appendChild: function(c, m, d) {
                    var k = this,
                        e, j, g, l, a;
                    if (Ext.isArray(c)) {
                        k.callStore("suspendAutoSync");
                        for (e = 0, j = c.length - 1; e < j; e++) {
                            k.appendChild(c[e])
                        }
                        k.callStore("resumeAutoSync");
                        k.appendChild(c[j])
                    } else {
                        c = k.createNode(c);
                        if (m !== true && (!k.hasListeners.beforeappend || k.fireEvent("beforeappend", k, c) === false)) {
                            return false
                        }
                        g = k.childNodes.length;
                        l = c.parentNode;
                        if (l) {
                            if (m !== true && (!k.hasListeners.beforeremove || c.fireEvent("beforemove", c, l, k, g) === false)) {
                                return false
                            }
                            l.removeChild(c, false, false, true)
                        }
                        g = k.childNodes.length;
                        if (g === 0) {
                            k.setFirstChild(c)
                        }
                        k.childNodes.push(c);
                        c.parentNode = k;
                        c.nextSibling = null;
                        k.setLastChild(c);
                        a = k.childNodes[g - 1];
                        if (a) {
                            c.previousSibling = a;
                            a.nextSibling = c;
                            a.updateInfo(d)
                        } else {
                            c.previousSibling = null
                        }
                        c.updateInfo(d);
                        if (!k.isLoaded()) {
                            k.set("loaded", true)
                        } else {
                            if (k.childNodes.length === 1) {
                                k.triggerUIUpdate()
                            }
                        }
                        if (!c.isLeaf() && c.phantom) {
                            c.set("loaded", true)
                        }
                        if (m !== true) {
                            k.fireEvent("append", k, c, g);
                            if (l) {
                                c.fireEvent("move", c, l, k, g)
                            }
                        }
                        return c
                    }
                },
                getBubbleTarget: function() {
                    return this.parentNode
                },
                removeChild: function(l, g, j, c) {
                    var k = this,
                        d = k.indexOf(l),
                        e, a;
                    if (d == -1 || (j !== true && (!k.hasListeners.beforeremove || k.fireEvent("beforeremove", k, l, !!c) === false))) {
                        return false
                    }
                    Ext.Array.erase(k.childNodes, d, 1);
                    if (k.firstChild == l) {
                        k.setFirstChild(l.nextSibling)
                    }
                    if (k.lastChild == l) {
                        k.setLastChild(l.previousSibling)
                    }
                    if (l.previousSibling) {
                        l.previousSibling.nextSibling = l.nextSibling
                    }
                    if (l.nextSibling) {
                        l.nextSibling.previousSibling = l.previousSibling
                    }
                    for (e = d > 0 ? d - 1 : 0, a = k.childNodes.length; e < a; e++) {
                        k.childNodes[e].updateInfo()
                    }
                    if (!k.childNodes.length) {
                        k.triggerUIUpdate()
                    }
                    if (j !== true) {
                        if (k.hasListeners.remove) {
                            k.fireEvent("remove", k, l, !!c)
                        }
                    }
                    if (g) {
                        l.destroy(true)
                    } else {
                        l.clear()
                    }
                    return l
                },
                copy: function(e, d) {
                    var j = this,
                        c = j.callOverridden(arguments),
                        a = j.childNodes ? j.childNodes.length : 0,
                        g;
                    if (d) {
                        for (g = 0; g < a; g++) {
                            c.appendChild(j.childNodes[g].copy(true))
                        }
                    }
                    return c
                },
                clear: function(a) {
                    var c = this;
                    c.parentNode = c.previousSibling = c.nextSibling = null;
                    if (a) {
                        c.firstChild = c.lastChild = null
                    }
                },
                destroy: function(c) {
                    var e = this,
                        d = e.destroyOptions,
                        a = e.childNodes,
                        g = a.length,
                        i;
                    if (c === true) {
                        e.clear(true);
                        for (i = 0; i < g; i++) {
                            a[i].destroy(true)
                        }
                        e.childNodes = null;
                        delete e.destroyOptions;
                        e.callOverridden([d])
                    } else {
                        e.destroyOptions = c;
                        e.remove(true)
                    }
                },
                insertBefore: function(c, j, n) {
                    var k = this,
                        g = k.indexOf(j),
                        l = c.parentNode,
                        m = g,
                        d, a, e;
                    if (!j) {
                        return k.appendChild(c)
                    }
                    if (c == j) {
                        return false
                    }
                    c = k.createNode(c);
                    if (n !== true && (!k.hasListeners.beforeinsert || k.fireEvent("beforeinsert", k, c, j) === false)) {
                        return false
                    }
                    if (l == k && k.indexOf(c) < g) {
                        m--
                    }
                    if (l) {
                        if (n !== true && (!k.hasListeners.beforeremove || c.fireEvent("beforemove", c, l, k, g, j) === false)) {
                            return false
                        }
                        l.removeChild(c, false, false, true)
                    }
                    if (m === 0) {
                        k.setFirstChild(c)
                    }
                    Ext.Array.splice(k.childNodes, m, 0, c);
                    c.parentNode = k;
                    c.nextSibling = j;
                    j.previousSibling = c;
                    a = k.childNodes[m - 1];
                    if (a) {
                        c.previousSibling = a;
                        a.nextSibling = c
                    } else {
                        c.previousSibling = null
                    }
                    for (e = m > 0 ? m - 1 : 0, d = k.childNodes.length; e < d; e++) {
                        k.childNodes[e].updateInfo()
                    }
                    if (!k.isLoaded()) {
                        k.set("loaded", true)
                    } else {
                        if (k.childNodes.length === 1) {
                            k.triggerUIUpdate()
                        }
                    }
                    if (!c.isLeaf() && c.phantom) {
                        c.set("loaded", true)
                    }
                    if (n !== true) {
                        if (k.hasListeners.insert) {
                            k.fireEvent("insert", k, c, j)
                        }
                        if (l && k.hasListeners.move) {
                            c.fireEvent("move", c, l, k, m, j)
                        }
                    }
                    return c
                },
                insertChild: function(a, d) {
                    var c = this.childNodes[a];
                    if (c) {
                        return this.insertBefore(d, c)
                    } else {
                        return this.appendChild(d)
                    }
                },
                remove: function(c, d) {
                    var a = this.parentNode;
                    if (a) {
                        a.removeChild(this, c, d)
                    }
                    return this
                },
                removeAll: function(a, c) {
                    var e = this.childNodes,
                        d;
                    while ((d = e[0])) {
                        this.removeChild(d, a, c)
                    }
                    return this
                },
                getChildAt: function(a) {
                    return this.childNodes[a]
                },
                replaceChild: function(a, e, d) {
                    var c = e ? e.nextSibling : null;
                    this.removeChild(e, false, d);
                    this.insertBefore(a, c, d);
                    return e
                },
                indexOf: function(a) {
                    return Ext.Array.indexOf(this.childNodes, a)
                },
                indexOfId: function(e) {
                    var d = this.childNodes,
                        a = d.length,
                        c = 0;
                    for (; c < a; ++c) {
                        if (d[c].getId() === e) {
                            return c
                        }
                    }
                    return -1
                },
                getPath: function(e, d) {
                    e = e || this.idProperty;
                    d = d || "/";
                    var c = [this.get(e)],
                        a = this.parentNode;
                    while (a) {
                        c.unshift(a.get(e));
                        a = a.parentNode
                    }
                    return d + c.join(d)
                },
                getDepth: function() {
                    return this.get("depth")
                },
                bubble: function(d, c, a) {
                    var e = this;
                    while (e) {
                        if (d.apply(c || e, a || [e]) === false) {
                            break
                        }
                        e = e.parentNode
                    }
                },
                cascade: function() {
                    if (Ext.isDefined(Ext.global.console)) {
                        Ext.global.console.warn("Ext.data.Node: cascade has been deprecated. Please use cascadeBy instead.")
                    }
                    return this.cascadeBy.apply(this, arguments)
                },
                cascadeBy: function(e, d, a) {
                    if (e.apply(d || this, a || [this]) !== false) {
                        var j = this.childNodes,
                            g = j.length,
                            c;
                        for (c = 0; c < g; c++) {
                            j[c].cascadeBy(e, d, a)
                        }
                    }
                },
                eachChild: function(e, d, a) {
                    var j = this.childNodes,
                        g = j.length,
                        c;
                    for (c = 0; c < g; c++) {
                        if (e.apply(d || this, a || [j[c]]) === false) {
                            break
                        }
                    }
                },
                findChild: function(c, d, a) {
                    return this.findChildBy(function() {
                        return this.get(c) == d
                    }, null, a)
                },
                findChildBy: function(k, j, c) {
                    var g = this.childNodes,
                        a = g.length,
                        e = 0,
                        l, d;
                    for (; e < a; e++) {
                        l = g[e];
                        if (k.call(j || l, l) === true) {
                            return l
                        } else {
                            if (c) {
                                d = l.findChildBy(k, j, c);
                                if (d !== null) {
                                    return d
                                }
                            }
                        }
                    }
                    return null
                },
                contains: function(a) {
                    return a.isAncestor(this)
                },
                isAncestor: function(a) {
                    var c = this.parentNode;
                    while (c) {
                        if (c == a) {
                            return true
                        }
                        c = c.parentNode
                    }
                    return false
                },
                sort: function(j, c, a) {
                    var e = this.childNodes,
                        g = e.length,
                        d, k;
                    if (g > 0) {
                        Ext.Array.sort(e, j);
                        for (d = 0; d < g; d++) {
                            k = e[d];
                            k.previousSibling = e[d - 1];
                            k.nextSibling = e[d + 1];
                            if (d === 0) {
                                this.setFirstChild(k)
                            }
                            if (d == g - 1) {
                                this.setLastChild(k)
                            }
                            k.updateInfo();
                            if (c && !k.isLeaf()) {
                                k.sort(j, true, true)
                            }
                        }
                        if (a !== true) {
                            this.fireEvent("sort", this, e)
                        }
                    }
                },
                isExpanded: function() {
                    return this.get("expanded")
                },
                isLoaded: function() {
                    return this.get("loaded")
                },
                isLoading: function() {
                    return this.get("loading")
                },
                isRoot: function() {
                    return !this.parentNode
                },
                isVisible: function() {
                    var a = this.parentNode;
                    while (a) {
                        if (!a.isExpanded()) {
                            return false
                        }
                        a = a.parentNode
                    }
                    return true
                },
                expand: function(a, e, c) {
                    var d = this;
                    if (!d.isLeaf()) {
                        if (d.isLoading()) {
                            d.on("expand", function() {
                                d.expand(a, e, c)
                            }, d, {
                                single: true
                            })
                        } else {
                            if (!d.isExpanded()) {
                                d.fireEvent("beforeexpand", d, function() {
                                    d.set("expanded", true);
                                    if (d.hasListeners.expand) {
                                        d.fireEvent("expand", d, d.childNodes, false)
                                    }
                                    if (a) {
                                        d.expandChildren(true, e, c)
                                    } else {
                                        Ext.callback(e, c || d, [d.childNodes])
                                    }
                                }, d)
                            } else {
                                if (a) {
                                    d.expandChildren(true, e, c)
                                } else {
                                    Ext.callback(e, c || d, [d.childNodes])
                                }
                            }
                        }
                    } else {
                        Ext.callback(e, c || d)
                    }
                },
                expandChildren: function(e, l, m) {
                    var k = this,
                        g = 0,
                        a = k.childNodes,
                        j = a.length,
                        d, c = 0;
                    for (; g < j; ++g) {
                        d = a[g];
                        if (!d.isLeaf()) {
                            c++;
                            a[g].expand(e, function() {
                                c--;
                                if (l && !c) {
                                    Ext.callback(l, m || k, [k.childNodes])
                                }
                            })
                        }
                    }
                    if (!c && l) {
                        Ext.callback(l, m || k, [k.childNodes])
                    }
                },
                collapse: function(a, e, c) {
                    var d = this;
                    if (!d.isLeaf()) {
                        if (!d.collapsing && d.isExpanded()) {
                            d.fireEvent("beforecollapse", d, function() {
                                d.set("expanded", false);
                                if (d.hasListeners.collapse) {
                                    d.fireEvent("collapse", d, d.childNodes, false)
                                }
                                if (a) {
                                    d.collapseChildren(true, e, c)
                                } else {
                                    Ext.callback(e, c || d, [d.childNodes])
                                }
                            }, d)
                        } else {
                            if (a) {
                                d.collapseChildren(true, e, c)
                            } else {
                                Ext.callback(e, c || d, [d.childNodes])
                            }
                        }
                    } else {
                        Ext.callback(e, c || d, [d.childNodes])
                    }
                },
                collapseChildren: function(e, l, m) {
                    var k = this,
                        g = 0,
                        c = k.childNodes,
                        j = c.length,
                        d, a = 0;
                    for (; g < j; ++g) {
                        d = c[g];
                        if (!d.isLeaf()) {
                            a++;
                            c[g].collapse(e, function() {
                                a--;
                                if (l && !a) {
                                    Ext.callback(l, m || k, [k.childNodes])
                                }
                            })
                        }
                    }
                    if (!a && l) {
                        Ext.callback(l, m || k, [k.childNodes])
                    }
                }
            }
        }
    }
});
Ext.define("Ext.data.TreeStore", {
    extend: "Ext.data.AbstractStore",
    alias: "store.tree",
    requires: ["Ext.util.Sorter", "Ext.data.Tree", "Ext.data.NodeInterface"],
    clearOnLoad: true,
    clearRemovedOnLoad: true,
    nodeParam: "node",
    defaultRootId: "root",
    defaultRootProperty: "children",
    rootProperty: "children",
    folderSort: false,
    constructor: function(d) {
        var g = this,
            c, a, e;
        d = Ext.apply({}, d);
        a = d.fields || g.fields;
        if (!a) {
            d.fields = [{
                name: "text",
                type: "string"
            }];
            e = d.defaultRootProperty || g.defaultRootProperty;
            if (e !== g.defaultRootProperty) {
                d.fields.push({
                    name: e,
                    type: "auto",
                    defaultValue: null,
                    persist: false
                })
            }
        }
        g.callParent([d]);
        g.tree = new Ext.data.Tree();
        g.relayEvents(g.tree, ["append", "remove", "move", "insert", "beforeappend", "beforeremove", "beforemove", "beforeinsert", "expand", "collapse", "beforeexpand", "beforecollapse", "sort", "rootchange"]);
        g.tree.on({
            scope: g,
            remove: g.onNodeRemove,
            beforeexpand: g.onBeforeNodeExpand,
            beforecollapse: g.onBeforeNodeCollapse,
            append: g.onNodeAdded,
            insert: g.onNodeAdded,
            sort: g.onNodeSort
        });
        g.onBeforeSort();
        c = g.root;
        if (c) {
            delete g.root;
            g.setRootNode(c)
        }
        if (Ext.isDefined(g.nodeParameter)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn("Ext.data.TreeStore: nodeParameter has been deprecated. Please use nodeParam instead.")
            }
            g.nodeParam = g.nodeParameter;
            delete g.nodeParameter
        }
    },
    setProxy: function(d) {
        var a, c;
        if (d instanceof Ext.data.proxy.Proxy) {
            c = Ext.isEmpty(d.getReader().root)
        } else {
            if (Ext.isString(d)) {
                c = true
            } else {
                a = d.reader;
                c = !(a && !Ext.isEmpty(a.root))
            }
        }
        d = this.callParent(arguments);
        if (c) {
            a = d.getReader();
            a.root = this.defaultRootProperty;
            a.buildExtractors(true)
        }
    },
    onBeforeSort: function() {
        if (this.folderSort) {
            this.sort({
                property: "leaf",
                direction: "ASC"
            }, "prepend", false)
        }
    },
    onBeforeNodeExpand: function(c, d, a) {
        if (c.isLoaded()) {
            Ext.callback(d, a || c, [c.childNodes])
        } else {
            if (c.isLoading()) {
                this.on("load", function() {
                    Ext.callback(d, a || c, [c.childNodes])
                }, this, {
                    single: true
                })
            } else {
                this.read({
                    node: c,
                    callback: function() {
                        Ext.callback(d, a || c, [c.childNodes])
                    }
                })
            }
        }
    },
    getNewRecords: function() {
        return Ext.Array.filter(this.tree.flatten(), this.filterNew)
    },
    getUpdatedRecords: function() {
        return Ext.Array.filter(this.tree.flatten(), this.filterUpdated)
    },
    onBeforeNodeCollapse: function(c, d, a) {
        d.call(a || c, c.childNodes)
    },
    onNodeRemove: function(c, e, a) {
        var d = this,
            g = d.removed;
        if (!e.isReplace && Ext.Array.indexOf(g, e) == -1) {
            g.push(e)
        }
        if (d.autoSync && !d.autoSyncSuspended && !a) {
            d.sync()
        }
    },
    onNodeAdded: function(d, g) {
        var e = this,
            c = e.getProxy(),
            a = c.getReader(),
            i = g.raw || g[g.persistenceProperty],
            j;
        Ext.Array.remove(e.removed, g);
        if (!g.isLeaf()) {
            j = a.getRoot(i);
            if (j) {
                e.fillNode(g, a.extractData(j));
                delete i[a.root]
            }
        }
        if (e.autoSync && !e.autoSyncSuspended && (g.phantom || g.dirty)) {
            e.sync()
        }
    },
    onNodeSort: function() {
        if (this.autoSync && !this.autoSyncSuspended) {
            this.sync()
        }
    },
    setRootNode: function(a, g) {
        var e = this,
            d = e.model,
            c = d.prototype.idProperty;
        a = a || {};
        if (!a.isModel) {
            Ext.applyIf(a, {
                id: e.defaultRootId,
                text: "Root",
                allowDrag: false
            });
            if (a[c] === undefined) {
                a[c] = e.defaultRootId
            }
            Ext.data.NodeInterface.decorate(d);
            a = Ext.ModelManager.create(a, d)
        } else {
            if (a.isModel && !a.isNode) {
                Ext.data.NodeInterface.decorate(d)
            }
        }
        e.getProxy().getReader().buildExtractors(true);
        e.tree.setRootNode(a);
        if (g !== true && !a.isLoaded() && (e.autoLoad === true || a.isExpanded())) {
            e.load({
                node: a
            })
        }
        return a
    },
    getRootNode: function() {
        return this.tree.getRootNode()
    },
    getNodeById: function(a) {
        return this.tree.getNodeById(a)
    },
    getById: function(a) {
        return this.getNodeById(a)
    },
    load: function(a) {
        a = a || {};
        a.params = a.params || {};
        var d = this,
            c = a.node || d.tree.getRootNode();
        if (!c) {
            c = d.setRootNode({
                expanded: true
            }, true)
        }
        a.id = c.getId();
        if (d.clearOnLoad) {
            if (d.clearRemovedOnLoad) {
                d.clearRemoved(c)
            }
            d.tree.un("remove", d.onNodeRemove, d);
            c.removeAll(false);
            d.tree.on("remove", d.onNodeRemove, d)
        }
        Ext.applyIf(a, {
            node: c
        });
        a.params[d.nodeParam] = c ? c.getId() : "root";
        if (c) {
            c.set("loading", true)
        }
        return d.callParent([a])
    },
    clearRemoved: function(c) {
        var m = this,
            g = m.removed,
            a = c.getId(),
            e = g.length,
            d = e,
            p = {},
            k = [],
            o = {},
            l, j, n;
        if (c === m.getRootNode()) {
            m.removed = [];
            return
        }
        for (; d--;) {
            l = g[d];
            o[l.getId()] = l
        }
        for (d = e; d--;) {
            l = g[d];
            j = l;
            while (j && j.getId() !== a) {
                n = j.get("parentId");
                j = j.parentNode || m.getNodeById(n) || o[n]
            }
            if (j) {
                p[l.getId()] = l
            }
        }
        for (d = 0; d < e; d++) {
            l = g[d];
            if (!p[l.getId()]) {
                k.push(l)
            }
        }
        m.removed = k
    },
    fillNode: function(c, d) {
        var k = this,
            g = d ? d.length : 0,
            j = k.sorters,
            e, m, l = false,
            a = g && k.sortOnLoad && !k.remoteSort && j && j.items && j.items.length,
            o, n;
        for (e = 1; e < g; e++) {
            o = d[e];
            n = d[e - 1];
            l = o[o.persistenceProperty].index != n[n.persistenceProperty].index;
            if (l) {
                break
            }
        }
        if (a) {
            if (l) {
                k.sorters.insert(0, k.indexSorter)
            }
            m = new Ext.util.MixedCollection();
            m.addAll(d);
            m.sort(k.sorters.items);
            d = m.items;
            k.sorters.remove(k.indexSorter)
        } else {
            if (l) {
                Ext.Array.sort(d, k.sortByIndex)
            }
        }
        c.set("loaded", true);
        for (e = 0; e < g; e++) {
            c.appendChild(d[e], undefined, true)
        }
        return d
    },
    sortByIndex: function(c, a) {
        return c[c.persistenceProperty].index - a[a.persistenceProperty].index
    },
    onProxyLoad: function(c) {
        var e = this,
            g = c.wasSuccessful(),
            a = c.getRecords(),
            d = c.node;
        e.loading = false;
        d.set("loading", false);
        if (g) {
            if (!e.clearOnLoad) {
                a = e.cleanRecords(d, a)
            }
            a = e.fillNode(d, a)
        }
        e.fireEvent("read", e, c.node, a, g);
        e.fireEvent("load", e, c.node, a, g);
        Ext.callback(c.callback, c.scope || e, [a, c, g])
    },
    onCreateRecords: function(d) {
        this.callParent(arguments);
        var e = 0,
            c = d.length,
            a = this.tree,
            g;
        for (; e < c; ++e) {
            g = d[e];
            a.onNodeIdChanged(g, null, g.getId())
        }
    },
    cleanRecords: function(j, c) {
        var g = {},
            l = j.childNodes,
            e = 0,
            a = l.length,
            d = [],
            k;
        for (; e < a; ++e) {
            g[l[e].getId()] = true
        }
        for (e = 0, a = c.length; e < a; ++e) {
            k = c[e];
            if (!g[k.getId()]) {
                d.push(k)
            }
        }
        return d
    },
    removeAll: function() {
        var a = this.getRootNode();
        if (a) {
            a.destroy(true)
        }
        this.fireEvent("clear", this)
    },
    doSort: function(a) {
        var c = this;
        if (c.remoteSort) {
            c.load()
        } else {
            c.tree.sort(a, true);
            c.fireEvent("datachanged", c);
            c.fireEvent("refresh", c)
        }
        c.fireEvent("sort", c)
    }
}, function() {
    var a = this.prototype;
    a.indexSorter = new Ext.util.Sorter({
        sorterFn: a.sortByIndex
    })
});
Ext.define("Ext.data.ResultSet", {
    loaded: true,
    count: 0,
    total: 0,
    success: false,
    constructor: function(a) {
        Ext.apply(this, a);
        this.totalRecords = this.total;
        if (a.count === undefined) {
            this.count = this.records.length
        }
    }
});
Ext.define("Ext.Template", {
    requires: ["Ext.dom.Helper", "Ext.util.Format"],
    inheritableStatics: {
        from: function(c, a) {
            c = Ext.getDom(c);
            return new this(c.value || c.innerHTML, a || "")
        }
    },
    constructor: function(e) {
        var j = this,
            c = arguments,
            a = [],
            d = 0,
            g = c.length,
            k;
        j.initialConfig = {};
        if (g === 1 && Ext.isArray(e)) {
            c = e;
            g = c.length
        }
        if (g > 1) {
            for (; d < g; d++) {
                k = c[d];
                if (typeof k == "object") {
                    Ext.apply(j.initialConfig, k);
                    Ext.apply(j, k)
                } else {
                    a.push(k)
                }
            }
        } else {
            a.push(e)
        }
        j.html = a.join("");
        if (j.compiled) {
            j.compile()
        }
    },
    isTemplate: true,
    disableFormats: false,
    re: /\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,
    apply: function(a) {
        var j = this,
            e = j.disableFormats !== true,
            i = Ext.util.Format,
            d = j,
            c;
        if (j.compiled) {
            return j.compiled(a).join("")
        }

        function g(k, n, o, l) {
            if (o && e) {
                if (l) {
                    l = [a[n]].concat(Ext.functionFactory("return [" + l + "];")())
                } else {
                    l = [a[n]]
                }
                if (o.substr(0, 5) == "this.") {
                    return d[o.substr(5)].apply(d, l)
                } else {
                    return i[o].apply(i, l)
                }
            } else {
                return a[n] !== undefined ? a[n] : ""
            }
        }
        c = j.html.replace(j.re, g);
        return c
    },
    applyOut: function(a, c) {
        var d = this;
        if (d.compiled) {
            c.push.apply(c, d.compiled(a))
        } else {
            c.push(d.apply(a))
        }
        return c
    },
    applyTemplate: function() {
        return this.apply.apply(this, arguments)
    },
    set: function(a, d) {
        var c = this;
        c.html = a;
        c.compiled = null;
        return d ? c.compile() : c
    },
    compileARe: /\\/g,
    compileBRe: /(\r\n|\n)/g,
    compileCRe: /'/g,
    compile: function() {
        var me = this,
            fm = Ext.util.Format,
            useFormat = me.disableFormats !== true,
            body, bodyReturn;

        function fn(m, name, format, args) {
            if (format && useFormat) {
                args = args ? "," + args : "";
                if (format.substr(0, 5) != "this.") {
                    format = "fm." + format + "("
                } else {
                    format = "this." + format.substr(5) + "("
                }
            } else {
                args = "";
                format = "(values['" + name + "'] == undefined ? '' : "
            }
            return "'," + format + "values['" + name + "']" + args + ") ,'"
        }
        bodyReturn = me.html.replace(me.compileARe, "\\\\").replace(me.compileBRe, "\\n").replace(me.compileCRe, "\\'").replace(me.re, fn);
        body = "this.compiled = function(values){ return ['" + bodyReturn + "'];};";
        eval(body);
        return me
    },
    insertFirst: function(c, a, d) {
        return this.doInsert("afterBegin", c, a, d)
    },
    insertBefore: function(c, a, d) {
        return this.doInsert("beforeBegin", c, a, d)
    },
    insertAfter: function(c, a, d) {
        return this.doInsert("afterEnd", c, a, d)
    },
    append: function(c, a, d) {
        return this.doInsert("beforeEnd", c, a, d)
    },
    doInsert: function(c, e, a, g) {
        var d = Ext.DomHelper.insertHtml(c, Ext.getDom(e), this.apply(a));
        return g ? Ext.get(d) : d
    },
    overwrite: function(d, a, e) {
        var c = Ext.DomHelper.overwrite(Ext.getDom(d), this.apply(a));
        return e ? Ext.get(c) : c
    }
});
Ext.define("Ext.XTemplateParser", {
    constructor: function(a) {
        Ext.apply(this, a)
    },
    doTpl: Ext.emptyFn,
    parse: function(o) {
        var y = this,
            r = o.length,
            q = {
                elseif: "elif"
            },
            u = y.topRe,
            d = y.actionsRe,
            g, e, l, p, j, n, k, x, v, c, i, a;
        y.level = 0;
        y.stack = e = [];
        for (g = 0; g < r; g = c) {
            u.lastIndex = g;
            p = u.exec(o);
            if (!p) {
                y.doText(o.substring(g, r));
                break
            }
            v = p.index;
            c = u.lastIndex;
            if (g < v) {
                y.doText(o.substring(g, v))
            }
            if (p[1]) {
                c = o.indexOf("%}", v + 2);
                y.doEval(o.substring(v + 2, c));
                c += 2
            } else {
                if (p[2]) {
                    c = o.indexOf("]}", v + 2);
                    y.doExpr(o.substring(v + 2, c));
                    c += 2
                } else {
                    if (p[3]) {
                        y.doTag(p[3])
                    } else {
                        if (p[4]) {
                            i = null;
                            while ((x = d.exec(p[4])) !== null) {
                                l = x[2] || x[3];
                                if (l) {
                                    l = Ext.String.htmlDecode(l);
                                    j = x[1];
                                    j = q[j] || j;
                                    i = i || {};
                                    n = i[j];
                                    if (typeof n == "string") {
                                        i[j] = [n, l]
                                    } else {
                                        if (n) {
                                            i[j].push(l)
                                        } else {
                                            i[j] = l
                                        }
                                    }
                                }
                            }
                            if (!i) {
                                if (y.elseRe.test(p[4])) {
                                    y.doElse()
                                } else {
                                    if (y.defaultRe.test(p[4])) {
                                        y.doDefault()
                                    } else {
                                        y.doTpl();
                                        e.push({
                                            type: "tpl"
                                        })
                                    }
                                }
                            } else {
                                if (i["if"]) {
                                    y.doIf(i["if"], i);
                                    e.push({
                                        type: "if"
                                    })
                                } else {
                                    if (i["switch"]) {
                                        y.doSwitch(i["switch"], i);
                                        e.push({
                                            type: "switch"
                                        })
                                    } else {
                                        if (i["case"]) {
                                            y.doCase(i["case"], i)
                                        } else {
                                            if (i.elif) {
                                                y.doElseIf(i.elif, i)
                                            } else {
                                                if (i["for"]) {
                                                    ++y.level;
                                                    if (a = y.propRe.exec(p[4])) {
                                                        i.propName = a[1] || a[2]
                                                    }
                                                    y.doFor(i["for"], i);
                                                    e.push({
                                                        type: "for",
                                                        actions: i
                                                    })
                                                } else {
                                                    if (i.exec) {
                                                        y.doExec(i.exec, i);
                                                        e.push({
                                                            type: "exec",
                                                            actions: i
                                                        })
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (p[0].length === 5) {
                                e.push({
                                    type: "tpl"
                                })
                            } else {
                                k = e.pop();
                                y.doEnd(k.type, k.actions);
                                if (k.type == "for") {
                                    --y.level
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    topRe: /(?:(\{\%)|(\{\[)|\{([^{}]*)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g,
    actionsRe: /\s*(elif|elseif|if|for|exec|switch|case|eval)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g,
    propRe: /prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/,
    defaultRe: /^\s*default\s*$/,
    elseRe: /^\s*else\s*$/
});
Ext.define("Ext.XTemplateCompiler", {
    extend: "Ext.XTemplateParser",
    useEval: Ext.isGecko,
    useIndex: Ext.isIE6 || Ext.isIE7,
    useFormat: true,
    propNameRe: /^[\w\d\$]*$/,
    compile: function(a) {
        var d = this,
            c = d.generate(a);
        return d.useEval ? d.evalTpl(c) : (new Function("Ext", c))(Ext)
    },
    generate: function(a) {
        var e = this,
            c = "var fm=Ext.util.Format,ts=Object.prototype.toString;",
            d;
        e.maxLevel = 0;
        e.body = ["var c0=values, a0=" + e.createArrayTest(0) + ", p0=parent, n0=xcount, i0=xindex, v;\n"];
        if (e.definitions) {
            if (typeof e.definitions === "string") {
                e.definitions = [e.definitions, c]
            } else {
                e.definitions.push(c)
            }
        } else {
            e.definitions = [c]
        }
        e.switches = [];
        e.parse(a);
        e.definitions.push((e.useEval ? "$=" : "return") + " function (" + e.fnArgs + ") {", e.body.join(""), "}");
        d = e.definitions.join("\n");
        e.definitions.length = e.body.length = e.switches.length = 0;
        delete e.definitions;
        delete e.body;
        delete e.switches;
        return d
    },
    doText: function(d) {
        var c = this,
            a = c.body;
        d = d.replace(c.aposRe, "\\'").replace(c.newLineRe, "\\n");
        if (c.useIndex) {
            a.push("out[out.length]='", d, "'\n")
        } else {
            a.push("out.push('", d, "')\n")
        }
    },
    doExpr: function(c) {
        var a = this.body;
        a.push("if ((v=" + c + ")!==undefined) out");
        if (this.useIndex) {
            a.push("[out.length]=v+''\n")
        } else {
            a.push(".push(v+'')\n")
        }
    },
    doTag: function(a) {
        this.doExpr(this.parseTag(a))
    },
    doElse: function() {
        this.body.push("} else {\n")
    },
    doEval: function(a) {
        this.body.push(a, "\n")
    },
    doIf: function(c, d) {
        var a = this;
        if (c === ".") {
            a.body.push("if (values) {\n")
        } else {
            if (a.propNameRe.test(c)) {
                a.body.push("if (", a.parseTag(c), ") {\n")
            } else {
                a.body.push("if (", a.addFn(c), a.callFn, ") {\n")
            }
        }
        if (d.exec) {
            a.doExec(d.exec)
        }
    },
    doElseIf: function(c, d) {
        var a = this;
        if (c === ".") {
            a.body.push("else if (values) {\n")
        } else {
            if (a.propNameRe.test(c)) {
                a.body.push("} else if (", a.parseTag(c), ") {\n")
            } else {
                a.body.push("} else if (", a.addFn(c), a.callFn, ") {\n")
            }
        }
        if (d.exec) {
            a.doExec(d.exec)
        }
    },
    doSwitch: function(c) {
        var a = this;
        if (c === ".") {
            a.body.push("switch (values) {\n")
        } else {
            if (a.propNameRe.test(c)) {
                a.body.push("switch (", a.parseTag(c), ") {\n")
            } else {
                a.body.push("switch (", a.addFn(c), a.callFn, ") {\n")
            }
        }
        a.switches.push(0)
    },
    doCase: function(g) {
        var e = this,
            d = Ext.isArray(g) ? g : [g],
            j = e.switches.length - 1,
            a, c;
        if (e.switches[j]) {
            e.body.push("break;\n")
        } else {
            e.switches[j] ++
        }
        for (c = 0, j = d.length; c < j; ++c) {
            a = e.intRe.exec(d[c]);
            d[c] = a ? a[1] : ("'" + d[c].replace(e.aposRe, "\\'") + "'")
        }
        e.body.push("case ", d.join(": case "), ":\n")
    },
    doDefault: function() {
        var a = this,
            c = a.switches.length - 1;
        if (a.switches[c]) {
            a.body.push("break;\n")
        } else {
            a.switches[c] ++
        }
        a.body.push("default:\n")
    },
    doEnd: function(c, e) {
        var d = this,
            a = d.level - 1;
        if (c == "for") {
            if (e.exec) {
                d.doExec(e.exec)
            }
            d.body.push("}\n");
            d.body.push("parent=p", a, ";values=r", a + 1, ";xcount=n", a, ";xindex=i", a, "\n")
        } else {
            if (c == "if" || c == "switch") {
                d.body.push("}\n")
            }
        }
    },
    doFor: function(i, k) {
        var g = this,
            e, c = g.level,
            a = c - 1,
            d = "p" + c,
            j;
        if (i === ".") {
            e = "values"
        } else {
            if (g.propNameRe.test(i)) {
                e = g.parseTag(i)
            } else {
                e = g.addFn(i) + g.callFn
            }
        }
        if (g.maxLevel < c) {
            g.maxLevel = c;
            g.body.push("var ")
        }
        if (i == ".") {
            j = "c" + c
        } else {
            j = "a" + a + "?c" + a + "[i" + a + "]:p" + c
        }
        g.body.push("i", c, "=0,n", c, "=0,c", c, "=", e, ",a", c, "=", g.createArrayTest(c), ",p", c, "=c", a, ",r", c, "=values;\n", "parent=", j, "\n", "if (c", c, "){if(a", c, "){n", c, "=c", c, ".length;}else if (c", c, ".isMixedCollection){c", c, "=c", c, ".items;n", c, "=c", c, ".length;}else if(c", c, ".isStore){c", c, "=c", c, ".data.items;n", c, "=c", c, ".length;}else{c", c, "=[c", c, "];n", c, "=1;}}\n", "for (xcount=n", c, ";i", c, "<n" + c + ";++i", c, "){\n", "values=c", c, "[i", c, "]");
        if (k.propName) {
            g.body.push(".", k.propName)
        }
        g.body.push("\n", "xindex=i", c, "+1\n")
    },
    createArrayTest: ("isArray" in Array) ? function(a) {
        return "Array.isArray(c" + a + ")"
    } : function(a) {
        return "ts.call(c" + a + ')==="[object Array]"'
    },
    doExec: function(d, e) {
        var c = this,
            a = "f" + c.definitions.length;
        c.definitions.push("function " + a + "(" + c.fnArgs + ") {", " try { with(values) {", "  " + d, " }} catch(e) {", "}", "}");
        c.body.push(a + c.callFn + "\n")
    },
    addFn: function(a) {
        var d = this,
            c = "f" + d.definitions.length;
        if (a === ".") {
            d.definitions.push("function " + c + "(" + d.fnArgs + ") {", " return values", "}")
        } else {
            if (a === "..") {
                d.definitions.push("function " + c + "(" + d.fnArgs + ") {", " return parent", "}")
            } else {
                d.definitions.push("function " + c + "(" + d.fnArgs + ") {", " try { with(values) {", "  return(" + a + ")", " }} catch(e) {", "}", "}")
            }
        }
        return c
    },
    parseTag: function(c) {
        var j = this,
            a = j.tagRe.exec(c),
            g = a[1],
            k = a[2],
            e = a[3],
            i = a[4],
            d;
        if (g == ".") {
            if (!j.validTypes) {
                j.definitions.push("var validTypes={string:1,number:1,boolean:1};");
                j.validTypes = true
            }
            d = 'validTypes[typeof values] || ts.call(values) === "[object Date]" ? values : ""'
        } else {
            if (g == "#") {
                d = "xindex"
            } else {
                if (g.substr(0, 7) == "parent.") {
                    d = g
                } else {
                    if (isNaN(g) && g.indexOf("-") == -1 && g.indexOf(".") != -1) {
                        d = "values." + g
                    } else {
                        d = "values['" + g + "']"
                    }
                }
            }
        }
        if (i) {
            d = "(" + d + i + ")"
        }
        if (k && j.useFormat) {
            e = e ? "," + e : "";
            if (k.substr(0, 5) != "this.") {
                k = "fm." + k + "("
            } else {
                k += "("
            }
        } else {
            return d
        }
        return k + d + e + ")"
    },
    evalTpl: function($) {
        eval($);
        return $
    },
    newLineRe: /\r\n|\r|\n/g,
    aposRe: /[']/g,
    intRe: /^\s*(\d+)\s*$/,
    tagRe: /([\w-\.\#]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?/
}, function() {
    var a = this.prototype;
    a.fnArgs = "out,values,parent,xindex,xcount";
    a.callFn = ".call(this," + a.fnArgs + ")"
});
Ext.define("Ext.XTemplate", {
    extend: "Ext.Template",
    requires: "Ext.XTemplateCompiler",
    emptyObj: {},
    apply: function(a, c) {
        return this.applyOut(a, [], c).join("")
    },
    applyOut: function(a, c, g) {
        var i = this,
            d;
        if (!i.fn) {
            d = new Ext.XTemplateCompiler({
                useFormat: i.disableFormats !== true,
                definitions: i.definitions
            });
            i.fn = d.compile(i.html)
        }
        try {
            i.fn.call(i, c, a, g || i.emptyObj, 1, 1)
        } catch (j) {}
        return c
    },
    compile: function() {
        return this
    },
    statics: {
        getTpl: function(a, d) {
            var c = a[d],
                e;
            if (c && !c.isTemplate) {
                c = Ext.ClassManager.dynInstantiate("Ext.XTemplate", c);
                if (a.hasOwnProperty(d)) {
                    a[d] = c
                } else {
                    for (e = a.self.prototype; e; e = e.superclass) {
                        if (e.hasOwnProperty(d)) {
                            e[d] = c;
                            break
                        }
                    }
                }
            }
            return c || null
        }
    }
});
Ext.define("Ext.data.reader.Reader", {
    requires: ["Ext.data.ResultSet", "Ext.XTemplate"],
    alternateClassName: ["Ext.data.Reader", "Ext.data.DataReader"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    totalProperty: "total",
    successProperty: "success",
    root: "",
    implicitIncludes: true,
    readRecordsOnFailure: true,
    isReader: true,
    applyDefaults: true,
    lastFieldGeneration: null,
    constructor: function(a) {
        var c = this;
        c.mixins.observable.constructor.call(c, a);
        c.fieldCount = 0;
        c.model = Ext.ModelManager.getModel(c.model);
        c.accessExpressionFn = Ext.Function.bind(c.createFieldAccessExpression, c);
        if (c.model && c.model.prototype.fields) {
            c.buildExtractors()
        }
        this.addEvents("exception")
    },
    setModel: function(a, d) {
        var c = this;
        c.model = Ext.ModelManager.getModel(a);
        c.buildExtractors(true);
        if (d && c.proxy) {
            c.proxy.setModel(c.model, true)
        }
    },
    read: function(a) {
        var c;
        if (a) {
            c = a.responseText ? this.getResponseData(a) : this.readRecords(a)
        }
        return c || this.nullResultSet
    },
    readRecords: function(d) {
        var e = this,
            k, c, a, i, g, j, l;
        if (e.lastFieldGeneration !== e.model.prototype.fields.generation) {
            e.buildExtractors(true)
        }
        e.rawData = d;
        d = e.getData(d);
        k = true;
        c = 0;
        a = [];
        if (e.successProperty) {
            j = e.getSuccess(d);
            if (j === false || j === "false") {
                k = false
            }
        }
        if (e.messageProperty) {
            l = e.getMessage(d)
        }
        if (e.readRecordsOnFailure || k) {
            i = Ext.isArray(d) ? d : e.getRoot(d);
            if (i) {
                g = i.length
            }
            if (e.totalProperty) {
                j = parseInt(e.getTotal(d), 10);
                if (!isNaN(j)) {
                    g = j
                }
            }
            if (i) {
                a = e.extractData(i);
                c = a.length
            }
        }
        return new Ext.data.ResultSet({
            total: g || c,
            count: c,
            records: a,
            success: k,
            message: l
        })
    },
    extractData: function(m) {
        var l = this,
            e = [],
            c = l.model,
            a = m.length,
            g, d, k, j;
        if (!m.length && Ext.isObject(m)) {
            m = [m];
            a = 1
        }
        for (j = 0; j < a; j++) {
            d = m[j];
            if (!d.isModel) {
                k = new c(undefined, l.getId(d), d, g = {});
                k.phantom = false;
                l.convertRecordData(g, d, k);
                e.push(k);
                if (l.implicitIncludes) {
                    l.readAssociated(k, d)
                }
            } else {
                e.push(d)
            }
        }
        return e
    },
    readAssociated: function(k, g) {
        var e = k.associations.items,
            j = 0,
            a = e.length,
            d, c, m, l;
        for (; j < a; j++) {
            d = e[j];
            c = this.getAssociatedDataRoot(g, d.associationKey || d.name);
            if (c) {
                l = d.getReader();
                if (!l) {
                    m = d.associatedModel.proxy;
                    if (m) {
                        l = m.getReader()
                    } else {
                        l = new this.constructor({
                            model: d.associatedName
                        })
                    }
                }
                d.read(k, l, c)
            }
        }
    },
    getAssociatedDataRoot: function(c, a) {
        return c[a]
    },
    getFields: function() {
        return this.model.prototype.fields.items
    },
    getData: function(a) {
        return a
    },
    getRoot: function(a) {
        return a
    },
    getResponseData: function(a) {},
    onMetaChange: function(g) {
        var e = this,
            c = g.fields || e.getFields(),
            d, a;
        e.metaData = g;
        e.root = g.root || e.root;
        e.idProperty = g.idProperty || e.idProperty;
        e.totalProperty = g.totalProperty || e.totalProperty;
        e.successProperty = g.successProperty || e.successProperty;
        e.messageProperty = g.messageProperty || e.messageProperty;
        a = g.clientIdProperty;
        if (e.model) {
            e.model.setFields(c, e.idProperty, a);
            e.setModel(e.model, true)
        } else {
            d = Ext.define("Ext.data.reader.Json-Model" + Ext.id(), {
                extend: "Ext.data.Model",
                fields: c,
                clientIdProperty: a
            });
            if (e.idProperty) {
                d.idProperty = e.idProperty
            }
            e.setModel(d, true)
        }
    },
    getIdProperty: function() {
        return this.idProperty || this.model.prototype.idProperty
    },
    buildExtractors: function(c) {
        var i = this,
            l = i.getIdProperty(),
            k = i.totalProperty,
            g = i.successProperty,
            j = i.messageProperty,
            e, d, a;
        if (c === true) {
            delete i.convertRecordData
        }
        if (i.convertRecordData) {
            return
        }
        if (k) {
            i.getTotal = i.createAccessor(k)
        }
        if (g) {
            i.getSuccess = i.createAccessor(g)
        }
        if (j) {
            i.getMessage = i.createAccessor(j)
        }
        if (l) {
            d = i.model.prototype.fields.get(l);
            if (d) {
                a = d.mapping;
                l = (a !== undefined && a !== null) ? a : l
            }
            e = i.createAccessor(l);
            i.getId = function(m) {
                var n = e.call(i, m);
                return (n === undefined || n === "") ? null : n
            }
        } else {
            i.getId = function() {
                return null
            }
        }
        i.convertRecordData = i.buildRecordDataExtractor();
        i.lastFieldGeneration = i.model.prototype.fields.generation
    },
    recordDataExtractorTemplate: ["var me = this\n", "    ,fields = me.model.prototype.fields\n", "    ,value\n", "    ,internalId\n", '<tpl for="fields">', '    ,__field{#} = fields.get("{name}")\n', "</tpl>", ";\n", "return function(dest, source, record) {\n", '<tpl for="fields">', '    value = {[ this.createFieldAccessExpression(values, "__field" + xindex, "source") ]};\n', '<tpl if="hasCustomConvert">', '    dest["{name}"] = value === undefined ? __field{#}.convert(__field{#}.defaultValue, record) : __field{#}.convert(value, record);\n', '<tpl elseif="defaultValue !== undefined">', "    if (value === undefined) {\n", "        if (me.applyDefaults) {\n", '<tpl if="convert">', '            dest["{name}"] = __field{#}.convert(__field{#}.defaultValue, record);\n', "<tpl else>", '            dest["{name}"] = __field{#}.defaultValue\n', "</tpl>", "        };\n", "    } else {\n", '<tpl if="convert">', '        dest["{name}"] = __field{#}.convert(value, record);\n', "<tpl else>", '        dest["{name}"] = value;\n', "</tpl>", "    };", "<tpl else>", "    if (value !== undefined) {\n", '<tpl if="convert">', '        dest["{name}"] = __field{#}.convert(value, record);\n', "<tpl else>", '        dest["{name}"] = value;\n', "</tpl>", "    }\n", "</tpl>", "</tpl>", '<tpl if="clientIdProp">', '    if (record && (internalId = {[ this.createFieldAccessExpression({mapping: values.clientIdProp}, null, "source") ]})) {\n', '        record.{["internalId"]} = internalId;\n', "    }\n", "</tpl>", "};"],
    buildRecordDataExtractor: function() {
        var d = this,
            a = d.model.prototype,
            c = {
                clientIdProp: a.clientIdProperty,
                fields: a.fields.items
            };
        d.recordDataExtractorTemplate.createFieldAccessExpression = d.accessExpressionFn;
        return Ext.functionFactory(d.recordDataExtractorTemplate.apply(c)).call(d)
    },
    destroyReader: function() {
        var a = this;
        delete a.proxy;
        delete a.model;
        delete a.convertRecordData;
        delete a.getId;
        delete a.getTotal;
        delete a.getSuccess;
        delete a.getMessage
    }
}, function() {
    var a = this.prototype;
    Ext.apply(a, {
        nullResultSet: new Ext.data.ResultSet({
            total: 0,
            count: 0,
            records: [],
            success: true
        }),
        recordDataExtractorTemplate: new Ext.XTemplate(a.recordDataExtractorTemplate)
    })
});
Ext.define("Ext.data.reader.Json", {
    extend: "Ext.data.reader.Reader",
    alternateClassName: "Ext.data.JsonReader",
    alias: "reader.json",
    root: "",
    useSimpleAccessors: false,
    readRecords: function(a) {
        if (a.metaData) {
            this.onMetaChange(a.metaData)
        }
        this.jsonData = a;
        return this.callParent([a])
    },
    getResponseData: function(a) {
        var e, c;
        try {
            e = Ext.decode(a.responseText);
            return this.readRecords(e)
        } catch (d) {
            c = new Ext.data.ResultSet({
                total: 0,
                count: 0,
                records: [],
                success: false,
                message: d.message
            });
            this.fireEvent("exception", this, a, c);
            Ext.Logger.warn("Unable to parse the JSON returned by the server");
            return c
        }
    },
    buildExtractors: function() {
        var a = this;
        a.callParent(arguments);
        if (a.root) {
            a.getRoot = a.createAccessor(a.root)
        } else {
            a.getRoot = function(c) {
                return c
            }
        }
    },
    extractData: function(a) {
        var g = this.record,
            e = [],
            d, c;
        if (g) {
            d = a.length;
            if (!d && Ext.isObject(a)) {
                d = 1;
                a = [a]
            }
            for (c = 0; c < d; c++) {
                e[c] = a[c][g]
            }
        } else {
            e = a
        }
        return this.callParent([e])
    },
    createAccessor: (function() {
        var a = /[\[\.]/;
        return function(d) {
            if (Ext.isEmpty(d)) {
                return Ext.emptyFn
            }
            if (Ext.isFunction(d)) {
                return d
            }
            if (this.useSimpleAccessors !== true) {
                var c = String(d).search(a);
                if (c >= 0) {
                    return Ext.functionFactory("obj", "return obj" + (c > 0 ? "." : "") + d)
                }
            }
            return function(e) {
                return e[d]
            }
        }
    }()),
    createFieldAccessExpression: (function() {
        var a = /[\[\.]/;
        return function(k, e, d) {
            var g = this,
                i = (k.mapping !== null),
                j = i ? k.mapping : k.name,
                c, l;
            if (typeof j === "function") {
                c = e + ".mapping(" + d + ", this)"
            } else {
                if (this.useSimpleAccessors === true || ((l = String(j).search(a)) < 0)) {
                    if (!i || isNaN(j)) {
                        j = '"' + j + '"'
                    }
                    c = d + "[" + j + "]"
                } else {
                    c = d + (l > 0 ? "." : "") + j
                }
            }
            return c
        }
    }())
});
Ext.define("Ext.data.writer.Writer", {
    alias: "writer.base",
    alternateClassName: ["Ext.data.DataWriter", "Ext.data.Writer"],
    writeAllFields: true,
    nameProperty: "name",
    isWriter: true,
    constructor: function(a) {
        Ext.apply(this, a)
    },
    write: function(g) {
        var d = g.operation,
            c = d.records || [],
            a = c.length,
            e = 0,
            j = [];
        for (; e < a; e++) {
            j.push(this.getRecordData(c[e], d))
        }
        return this.writeRecords(g, j)
    },
    getRecordData: function(i, e) {
        var p = i.phantom === true,
            c = this.writeAllFields || p,
            d = this.nameProperty,
            j = i.fields,
            r = j.items,
            g = {},
            n = i.clientIdProperty,
            m, a, l, q, o, k, s;
        if (c) {
            s = r.length;
            for (k = 0; k < s; k++) {
                l = r[k];
                if (l.persist) {
                    a = l[d] || l.name;
                    o = i.get(l.name);
                    if (l.serialize) {
                        g[a] = l.serialize(o, i)
                    } else {
                        if (l.type === Ext.data.Types.DATE && l.dateFormat) {
                            g[a] = Ext.Date.format(o, l.dateFormat)
                        } else {
                            g[a] = o
                        }
                    }
                }
            }
        } else {
            m = i.getChanges();
            for (q in m) {
                if (m.hasOwnProperty(q)) {
                    l = j.get(q);
                    if (l.persist) {
                        a = l[d] || l.name;
                        o = i.get(l.name);
                        if (l.serialize) {
                            g[a] = l.serialize(o, i)
                        } else {
                            if (l.type === Ext.data.Types.DATE && l.dateFormat) {
                                g[a] = Ext.Date.format(o, l.dateFormat)
                            } else {
                                g[a] = o
                            }
                        }
                    }
                }
            }
        }
        if (p) {
            if (n && e && e.records.length > 1) {
                g[n] = i.internalId
            }
        } else {
            g[i.idProperty] = i.getId()
        }
        return g
    }
});
Ext.define("Ext.data.writer.Json", {
    extend: "Ext.data.writer.Writer",
    alternateClassName: "Ext.data.JsonWriter",
    alias: "writer.json",
    root: undefined,
    encode: false,
    allowSingle: true,
    writeRecords: function(c, d) {
        var a = this.root;
        if (this.allowSingle && d.length == 1) {
            d = d[0]
        }
        if (this.encode) {
            if (a) {
                c.params[a] = Ext.encode(d)
            } else {}
        } else {
            c.jsonData = c.jsonData || {};
            if (a) {
                c.jsonData[a] = d
            } else {
                c.jsonData = d
            }
        }
        return c
    }
});
Ext.define("Ext.data.proxy.Server", {
    extend: "Ext.data.proxy.Proxy",
    alias: "proxy.server",
    alternateClassName: "Ext.data.ServerProxy",
    uses: ["Ext.data.Request"],
    pageParam: "page",
    startParam: "start",
    limitParam: "limit",
    groupParam: "group",
    groupDirectionParam: "groupDir",
    sortParam: "sort",
    filterParam: "filter",
    directionParam: "dir",
    simpleSortMode: false,
    simpleGroupMode: false,
    noCache: true,
    cacheString: "_dc",
    timeout: 30000,
    constructor: function(a) {
        var c = this;
        a = a || {};
        c.callParent([a]);
        c.extraParams = a.extraParams || {};
        c.api = Ext.apply({}, a.api || c.api);
        c.nocache = c.noCache
    },
    create: function() {
        return this.doRequest.apply(this, arguments)
    },
    read: function() {
        return this.doRequest.apply(this, arguments)
    },
    update: function() {
        return this.doRequest.apply(this, arguments)
    },
    destroy: function() {
        return this.doRequest.apply(this, arguments)
    },
    setExtraParam: function(a, c) {
        this.extraParams[a] = c
    },
    buildRequest: function(a) {
        var d = this,
            e = Ext.applyIf(a.params || {}, d.extraParams || {}),
            c;
        e = Ext.applyIf(e, d.getParams(a));
        if (a.id !== undefined && e.id === undefined) {
            e.id = a.id
        }
        c = new Ext.data.Request({
            params: e,
            action: a.action,
            records: a.records,
            operation: a,
            url: a.url,
            proxy: d
        });
        c.url = d.buildUrl(c);
        a.request = c;
        return c
    },
    processResponse: function(j, a, d, c, i, k) {
        var g = this,
            e, l;
        if (j === true) {
            e = g.getReader();
            e.applyDefaults = a.action === "read";
            l = e.read(g.extractResponseData(c));
            if (l.success !== false) {
                Ext.apply(a, {
                    response: c,
                    resultSet: l
                });
                a.commitRecords(l.records);
                a.setCompleted();
                a.setSuccessful()
            } else {
                a.setException(l.message);
                g.fireEvent("exception", this, c, a)
            }
        } else {
            g.setException(a, c);
            g.fireEvent("exception", this, c, a)
        }
        if (typeof i == "function") {
            i.call(k || g, a)
        }
        g.afterRequest(d, j)
    },
    setException: function(c, a) {
        c.setException({
            status: a.status,
            statusText: a.statusText
        })
    },
    extractResponseData: function(a) {
        return a
    },
    applyEncoding: function(a) {
        return Ext.encode(a)
    },
    encodeSorters: function(e) {
        var c = [],
            d = e.length,
            a = 0;
        for (; a < d; a++) {
            c[a] = {
                property: e[a].property,
                direction: e[a].direction
            }
        }
        return this.applyEncoding(c)
    },
    encodeFilters: function(e) {
        var c = [],
            d = e.length,
            a = 0;
        for (; a < d; a++) {
            c[a] = {
                property: e[a].property,
                value: e[a].value
            }
        }
        return this.applyEncoding(c)
    },
    getParams: function(p) {
        var x = this,
            v = {},
            s = Ext.isDefined,
            t = p.groupers,
            a = p.sorters,
            n = p.filters,
            k = p.page,
            j = p.start,
            u = p.limit,
            l = x.simpleSortMode,
            e = x.simpleGroupMode,
            r = x.pageParam,
            i = x.startParam,
            c = x.limitParam,
            d = x.groupParam,
            m = x.groupDirectionParam,
            g = x.sortParam,
            q = x.filterParam,
            o = x.directionParam;
        if (r && s(k)) {
            v[r] = k
        }
        if (i && s(j)) {
            v[i] = j
        }
        if (c && s(u)) {
            v[c] = u
        }
        if (d && t && t.length > 0) {
            if (e) {
                v[d] = t[0].property;
                v[m] = t[0].direction || "ASC"
            } else {
                v[d] = x.encodeSorters(t)
            }
        }
        if (g && a && a.length > 0) {
            if (l) {
                v[g] = a[0].property;
                v[o] = a[0].direction
            } else {
                v[g] = x.encodeSorters(a)
            }
        }
        if (q && n && n.length > 0) {
            v[q] = x.encodeFilters(n)
        }
        return v
    },
    buildUrl: function(d) {
        var c = this,
            a = c.getUrl(d);
        if (c.noCache) {
            a = Ext.urlAppend(a, Ext.String.format("{0}={1}", c.cacheString, Ext.Date.now()))
        }
        return a
    },
    getUrl: function(a) {
        return a.url || this.api[a.action] || this.url
    },
    doRequest: function(a, d, c) {},
    afterRequest: Ext.emptyFn,
    onDestroy: function() {
        Ext.destroy(this.reader, this.writer)
    }
});
Ext.define("Ext.data.Connection", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    statics: {
        requestId: 0
    },
    url: null,
    async: true,
    method: null,
    username: "",
    password: "",
    disableCaching: true,
    withCredentials: false,
    cors: false,
    disableCachingParam: "_dc",
    timeout: 30000,
    useDefaultHeader: true,
    defaultPostHeader: "application/x-www-form-urlencoded; charset=UTF-8",
    useDefaultXhrHeader: true,
    defaultXhrHeader: "XMLHttpRequest",
    constructor: function(a) {
        a = a || {};
        Ext.apply(this, a);
        this.requests = {};
        this.mixins.observable.constructor.call(this)
    },
    request: function(m) {
        m = m || {};
        var i = this,
            l = m.scope || window,
            g = m.username || i.username,
            j = m.password || i.password || "",
            c, d, e, a, k;
        if (i.fireEvent("beforerequest", i, m) !== false) {
            d = i.setOptions(m, l);
            if (i.isFormUpload(m)) {
                i.upload(m.form, d.url, d.data, m);
                return null
            }
            if (m.autoAbort || i.autoAbort) {
                i.abort()
            }
            c = m.async !== false ? (m.async || i.async) : false;
            k = i.openRequest(m, d, c, g, j);
            a = i.setupHeaders(k, m, d.data, d.params);
            e = {
                id: ++Ext.data.Connection.requestId,
                xhr: k,
                headers: a,
                options: m,
                async: c,
                timeout: setTimeout(function() {
                    e.timedout = true;
                    i.abort(e)
                }, m.timeout || i.timeout)
            };
            i.requests[e.id] = e;
            i.latestId = e.id;
            if (c) {
                k.onreadystatechange = Ext.Function.bind(i.onStateChange, i, [e])
            }
            k.send(d.data);
            if (!c) {
                return i.onComplete(e)
            }
            return e
        } else {
            Ext.callback(m.callback, m.scope, [m, undefined, undefined]);
            return null
        }
    },
    upload: function(c, i, t, g) {
        c = Ext.getDom(c);
        g = g || {};
        var o = Ext.id(),
            m = document.createElement("iframe"),
            d = [],
            e = "multipart/form-data",
            s = {
                target: c.target,
                method: c.method,
                encoding: c.encoding,
                enctype: c.enctype,
                action: c.action
            },
            a = function(v, x) {
                j = document.createElement("input");
                Ext.fly(j).set({
                    type: "hidden",
                    value: x,
                    name: v
                });
                c.appendChild(j);
                d.push(j)
            },
            j, l, q, u, p, k, n, r;
        Ext.fly(m).set({
            id: o,
            name: o,
            cls: Ext.baseCSSPrefix + "hide-display",
            src: Ext.SSL_SECURE_URL
        });
        document.body.appendChild(m);
        if (document.frames) {
            document.frames[o].name = o
        }
        Ext.fly(c).set({
            target: o,
            method: "POST",
            enctype: e,
            encoding: e,
            action: i || s.action
        });
        if (t) {
            l = Ext.Object.fromQueryString(t) || {};
            for (u in l) {
                if (l.hasOwnProperty(u)) {
                    q = l[u];
                    if (Ext.isArray(q)) {
                        p = q.length;
                        for (k = 0; k < p; k++) {
                            a(u, q[k])
                        }
                    } else {
                        a(u, q)
                    }
                }
            }
        }
        Ext.fly(m).on("load", Ext.Function.bind(this.onUploadComplete, this, [m, g]), null, {
            single: true
        });
        c.submit();
        Ext.fly(c).set(s);
        n = d.length;
        for (r = 0; r < n; r++) {
            Ext.removeNode(d[r])
        }
    },
    onUploadComplete: function(k, d) {
        var g = this,
            c = {
                responseText: "",
                responseXML: null
            },
            j, a;
        try {
            j = k.contentWindow.document || k.contentDocument || window.frames[k.id].document;
            if (j) {
                if (j.body) {
                    if ((a = j.body.firstChild) && /pre/i.test(a.tagName)) {
                        c.responseText = a.innerText
                    } else {
                        if (a = j.getElementsByTagName("textarea")[0]) {
                            c.responseText = a.value
                        } else {
                            c.responseText = j.body.textContent || j.body.innerText
                        }
                    }
                }
                c.responseXML = j.XMLDocument || j
            }
        } catch (i) {}
        g.fireEvent("requestcomplete", g, c, d);
        Ext.callback(d.success, d.scope, [c, d]);
        Ext.callback(d.callback, d.scope, [d, true, c]);
        setTimeout(function() {
            Ext.removeNode(k)
        }, 100)
    },
    isFormUpload: function(a) {
        var c = this.getForm(a);
        if (c) {
            return (a.isUpload || (/multipart\/form-data/i).test(c.getAttribute("enctype")))
        }
        return false
    },
    getForm: function(a) {
        return Ext.getDom(a.form) || null
    },
    setOptions: function(n, m) {
        var k = this,
            g = n.params || {},
            j = k.extraParams,
            e = n.urlParams,
            d = n.url || k.url,
            l = n.jsonData,
            c, a, i;
        if (Ext.isFunction(g)) {
            g = g.call(m, n)
        }
        if (Ext.isFunction(d)) {
            d = d.call(m, n)
        }
        d = this.setupUrl(n, d);
        i = n.rawData || n.xmlData || l || null;
        if (l && !Ext.isPrimitive(l)) {
            i = Ext.encode(i)
        }
        if (Ext.isObject(g)) {
            g = Ext.Object.toQueryString(g)
        }
        if (Ext.isObject(j)) {
            j = Ext.Object.toQueryString(j)
        }
        g = g + ((j) ? ((g) ? "&" : "") + j : "");
        e = Ext.isObject(e) ? Ext.Object.toQueryString(e) : e;
        g = this.setupParams(n, g);
        c = (n.method || k.method || ((g || i) ? "POST" : "GET")).toUpperCase();
        this.setupMethod(n, c);
        a = n.disableCaching !== false ? (n.disableCaching || k.disableCaching) : false;
        if (c === "GET" && a) {
            d = Ext.urlAppend(d, (n.disableCachingParam || k.disableCachingParam) + "=" + (new Date().getTime()))
        }
        if ((c == "GET" || i) && g) {
            d = Ext.urlAppend(d, g);
            g = null
        }
        if (e) {
            d = Ext.urlAppend(d, e)
        }
        return {
            url: d,
            method: c,
            data: i || g || null
        }
    },
    setupUrl: function(c, a) {
        var d = this.getForm(c);
        if (d) {
            a = a || d.action
        }
        return a
    },
    setupParams: function(a, e) {
        var d = this.getForm(a),
            c;
        if (d && !this.isFormUpload(a)) {
            c = Ext.Element.serializeForm(d);
            e = e ? (e + "&" + c) : c
        }
        return e
    },
    setupMethod: function(a, c) {
        if (this.isFormUpload(a)) {
            return "POST"
        }
        return c
    },
    setupHeaders: function(o, p, g, d) {
        var k = this,
            c = Ext.apply({}, p.headers || {}, k.defaultHeaders || {}),
            n = k.defaultPostHeader,
            l = p.jsonData,
            a = p.xmlData,
            m, i;
        if (!c["Content-Type"] && (g || d)) {
            if (g) {
                if (p.rawData) {
                    n = "text/plain"
                } else {
                    if (a && Ext.isDefined(a)) {
                        n = "text/xml"
                    } else {
                        if (l && Ext.isDefined(l)) {
                            n = "application/json"
                        }
                    }
                }
            }
            c["Content-Type"] = n
        }
        if (k.useDefaultXhrHeader && !c["X-Requested-With"]) {
            c["X-Requested-With"] = k.defaultXhrHeader
        }
        try {
            for (m in c) {
                if (c.hasOwnProperty(m)) {
                    i = c[m];
                    o.setRequestHeader(m, i)
                }
            }
        } catch (j) {
            k.fireEvent("exception", m, i)
        }
        return c
    },
    newRequest: function(a) {
        var c;
        if ((a.cors || this.cors) && Ext.isIE && Ext.ieVersion >= 8) {
            c = new XDomainRequest()
        } else {
            c = this.getXhrInstance()
        }
        return c
    },
    openRequest: function(d, a, e, i, c) {
        var g = this.newRequest(d);
        if (i) {
            g.open(a.method, a.url, e, i, c)
        } else {
            g.open(a.method, a.url, e)
        }
        if (d.withCredentials || this.withCredentials) {
            g.withCredentials = true
        }
        return g
    },
    getXhrInstance: (function() {
        var c = [function() {
                return new XMLHttpRequest()
            }, function() {
                return new ActiveXObject("MSXML2.XMLHTTP.3.0")
            }, function() {
                return new ActiveXObject("MSXML2.XMLHTTP")
            }, function() {
                return new ActiveXObject("Microsoft.XMLHTTP")
            }],
            d = 0,
            a = c.length,
            j;
        for (; d < a; ++d) {
            try {
                j = c[d];
                j();
                break
            } catch (g) {}
        }
        return j
    }()),
    isLoading: function(a) {
        if (!a) {
            a = this.getLatest()
        }
        if (!(a && a.xhr)) {
            return false
        }
        var c = a.xhr.readyState;
        return !(c === 0 || c == 4)
    },
    abort: function(c) {
        var a = this,
            g;
        if (!c) {
            c = a.getLatest()
        }
        if (c && a.isLoading(c)) {
            g = c.xhr;
            try {
                g.onreadystatechange = null
            } catch (d) {
                g = Ext.emptyFn
            }
            g.abort();
            a.clearTimeout(c);
            if (!c.timedout) {
                c.aborted = true
            }
            a.onComplete(c);
            a.cleanup(c)
        }
    },
    abortAll: function() {
        var c = this.requests,
            a;
        for (a in c) {
            if (c.hasOwnProperty(a)) {
                this.abort(c[a])
            }
        }
    },
    getLatest: function() {
        var c = this.latestId,
            a;
        if (c) {
            a = this.requests[c]
        }
        return a || null
    },
    onStateChange: function(a) {
        if (a.xhr.readyState == 4) {
            this.clearTimeout(a);
            this.onComplete(a);
            this.cleanup(a)
        }
    },
    clearTimeout: function(a) {
        clearTimeout(a.timeout);
        delete a.timeout
    },
    cleanup: function(a) {
        a.xhr = null;
        delete a.xhr
    },
    onComplete: function(i) {
        var g = this,
            d = i.options,
            a, k, c;
        try {
            a = g.parseStatus(i.xhr.status)
        } catch (j) {
            a = {
                success: false,
                isException: false
            }
        }
        k = a.success;
        if (k) {
            c = g.createResponse(i);
            g.fireEvent("requestcomplete", g, c, d);
            Ext.callback(d.success, d.scope, [c, d])
        } else {
            if (a.isException || i.aborted || i.timedout) {
                c = g.createException(i)
            } else {
                c = g.createResponse(i)
            }
            g.fireEvent("requestexception", g, c, d);
            Ext.callback(d.failure, d.scope, [c, d])
        }
        Ext.callback(d.callback, d.scope, [d, k, c]);
        delete g.requests[i.id];
        return c
    },
    parseStatus: function(a) {
        a = a == 1223 ? 204 : a;
        var d = (a >= 200 && a < 300) || a == 304,
            c = false;
        if (!d) {
            switch (a) {
                case 12002:
                case 12029:
                case 12030:
                case 12031:
                case 12152:
                case 13030:
                    c = true;
                    break
            }
        }
        return {
            success: d,
            isException: c
        }
    },
    createResponse: function(d) {
        var k = d.xhr,
            a = {},
            l = k.getAllResponseHeaders().replace(/\r\n/g, "\n").split("\n"),
            e = l.length,
            m, g, j, i, c;
        while (e--) {
            m = l[e];
            g = m.indexOf(":");
            if (g >= 0) {
                j = m.substr(0, g).toLowerCase();
                if (m.charAt(g + 1) == " ") {
                    ++g
                }
                a[j] = m.substr(g + 1)
            }
        }
        d.xhr = null;
        delete d.xhr;
        c = {
            request: d,
            requestId: d.id,
            status: k.status,
            statusText: k.statusText,
            getResponseHeader: function(n) {
                return a[n.toLowerCase()]
            },
            getAllResponseHeaders: function() {
                return a
            },
            responseText: k.responseText,
            responseXML: k.responseXML
        };
        k = null;
        return c
    },
    createException: function(a) {
        return {
            request: a,
            requestId: a.id,
            status: a.aborted ? -1 : 0,
            statusText: a.aborted ? "transaction aborted" : "communication failure",
            aborted: a.aborted,
            timedout: a.timedout
        }
    }
});
Ext.define("Ext.Ajax", {
    extend: "Ext.data.Connection",
    singleton: true,
    autoAbort: false
});
Ext.define("Ext.data.proxy.Ajax", {
    requires: ["Ext.util.MixedCollection", "Ext.Ajax"],
    extend: "Ext.data.proxy.Server",
    alias: "proxy.ajax",
    alternateClassName: ["Ext.data.HttpProxy", "Ext.data.AjaxProxy"],
    actionMethods: {
        create: "POST",
        read: "GET",
        update: "POST",
        destroy: "POST"
    },
    doRequest: function(a, g, c) {
        var e = this.getWriter(),
            d = this.buildRequest(a, g, c);
        if (a.allowWrite()) {
            d = e.write(d)
        }
        Ext.apply(d, {
            headers: this.headers,
            timeout: this.timeout,
            scope: this,
            callback: this.createRequestCallback(d, a, g, c),
            method: this.getMethod(d),
            disableCaching: false
        });
        Ext.Ajax.request(d);
        return d
    },
    getMethod: function(a) {
        return this.actionMethods[a.action]
    },
    createRequestCallback: function(e, a, g, c) {
        var d = this;
        return function(j, k, i) {
            d.processResponse(k, a, e, i, g, c)
        }
    }
}, function() {
    Ext.data.HttpProxy = this
});
Ext.define("Ext.util.HashMap", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    constructor: function(a) {
        a = a || {};
        var d = this,
            c = a.keyFn;
        d.addEvents("add", "clear", "remove", "replace");
        d.mixins.observable.constructor.call(d, a);
        d.clear(true);
        if (c) {
            d.getKey = c
        }
    },
    getCount: function() {
        return this.length
    },
    getData: function(a, c) {
        if (c === undefined) {
            c = a;
            a = this.getKey(c)
        }
        return [a, c]
    },
    getKey: function(a) {
        return a.id
    },
    add: function(a, d) {
        var c = this;
        if (d === undefined) {
            d = a;
            a = c.getKey(d)
        }
        if (c.containsKey(a)) {
            return c.replace(a, d)
        }
        c.map[a] = d;
        ++c.length;
        if (c.hasListeners.add) {
            c.fireEvent("add", c, a, d)
        }
        return d
    },
    replace: function(c, e) {
        var d = this,
            g = d.map,
            a;
        if (e === undefined) {
            e = c;
            c = d.getKey(e)
        }
        if (!d.containsKey(c)) {
            d.add(c, e)
        }
        a = g[c];
        g[c] = e;
        if (d.hasListeners.replace) {
            d.fireEvent("replace", d, c, e, a)
        }
        return e
    },
    remove: function(c) {
        var a = this.findKey(c);
        if (a !== undefined) {
            return this.removeAtKey(a)
        }
        return false
    },
    removeAtKey: function(a) {
        var c = this,
            d;
        if (c.containsKey(a)) {
            d = c.map[a];
            delete c.map[a];
            --c.length;
            if (c.hasListeners.remove) {
                c.fireEvent("remove", c, a, d)
            }
            return true
        }
        return false
    },
    get: function(a) {
        return this.map[a]
    },
    clear: function(a) {
        var c = this;
        c.map = {};
        c.length = 0;
        if (a !== true && c.hasListeners.clear) {
            c.fireEvent("clear", c)
        }
        return c
    },
    containsKey: function(a) {
        return this.map[a] !== undefined
    },
    contains: function(a) {
        return this.containsKey(this.findKey(a))
    },
    getKeys: function() {
        return this.getArray(true)
    },
    getValues: function() {
        return this.getArray(false)
    },
    getArray: function(e) {
        var a = [],
            c, d = this.map;
        for (c in d) {
            if (d.hasOwnProperty(c)) {
                a.push(e ? c : d[c])
            }
        }
        return a
    },
    each: function(e, d) {
        var a = Ext.apply({}, this.map),
            c, g = this.length;
        d = d || this;
        for (c in a) {
            if (a.hasOwnProperty(c)) {
                if (e.call(d, c, a[c], g) === false) {
                    break
                }
            }
        }
        return this
    },
    clone: function() {
        var d = new this.self(),
            c = this.map,
            a;
        d.suspendEvents();
        for (a in c) {
            if (c.hasOwnProperty(a)) {
                d.add(a, c[a])
            }
        }
        d.resumeEvents();
        return d
    },
    findKey: function(c) {
        var a, d = this.map;
        for (a in d) {
            if (d.hasOwnProperty(a) && d[a] === c) {
                return a
            }
        }
        return undefined
    }
});
Ext.define("Ext.AbstractManager", {
    requires: ["Ext.util.HashMap"],
    typeName: "type",
    constructor: function(a) {
        Ext.apply(this, a || {});
        this.all = new Ext.util.HashMap();
        this.types = {}
    },
    get: function(a) {
        return this.all.get(a)
    },
    register: function(a) {
        this.all.add(a)
    },
    unregister: function(a) {
        this.all.remove(a)
    },
    registerType: function(c, a) {
        this.types[c] = a;
        a[this.typeName] = c
    },
    isRegistered: function(a) {
        return this.types[a] !== undefined
    },
    create: function(a, e) {
        var c = a[this.typeName] || a.type || e,
            d = this.types[c];
        return new d(a)
    },
    onAvailable: function(i, d, c) {
        var a = this.all,
            e, g;
        if (a.containsKey(i)) {
            e = a.get(i);
            d.call(c || e, e)
        } else {
            g = function(l, j, k) {
                if (j == i) {
                    d.call(c || k, k);
                    a.un("add", g)
                }
            };
            a.on("add", g)
        }
    },
    each: function(c, a) {
        this.all.each(c, a || this)
    },
    getCount: function() {
        return this.all.getCount()
    }
});
Ext.define("Ext.data.association.Association", {
    alternateClassName: "Ext.data.Association",
    primaryKey: "id",
    defaultReaderType: "json",
    isAssociation: true,
    initialConfig: null,
    statics: {
        AUTO_ID: 1000,
        create: function(a) {
            if (Ext.isString(a)) {
                a = {
                    type: a
                }
            }
            switch (a.type) {
                case "belongsTo":
                    return new Ext.data.association.BelongsTo(a);
                case "hasMany":
                    return new Ext.data.association.HasMany(a);
                case "hasOne":
                    return new Ext.data.association.HasOne(a);
                default:
            }
            return a
        }
    },
    constructor: function(a) {
        Ext.apply(this, a);
        var e = this,
            c = Ext.ModelManager.types,
            d = a.ownerModel,
            i = a.associatedModel,
            g = c[d],
            j = c[i];
        e.initialConfig = a;
        e.ownerModel = g;
        e.associatedModel = j;
        Ext.applyIf(e, {
            ownerName: d,
            associatedName: i
        });
        e.associationId = "association" + (++e.statics().AUTO_ID)
    },
    getReader: function() {
        var d = this,
            a = d.reader,
            c = d.associatedModel;
        if (a) {
            if (Ext.isString(a)) {
                a = {
                    type: a
                }
            }
            if (a.isReader) {
                a.setModel(c)
            } else {
                Ext.applyIf(a, {
                    model: c,
                    type: d.defaultReaderType
                })
            }
            d.reader = Ext.createByAlias("reader." + a.type, a)
        }
        return d.reader || null
    }
});
Ext.define("Ext.ModelManager", {
    extend: "Ext.AbstractManager",
    alternateClassName: "Ext.ModelMgr",
    requires: ["Ext.data.association.Association"],
    singleton: true,
    typeName: "mtype",
    associationStack: [],
    registerType: function(d, c) {
        var e = c.prototype,
            a;
        if (e && e.isModel) {
            a = c
        } else {
            if (!c.extend) {
                c.extend = "Ext.data.Model"
            }
            a = Ext.define(d, c)
        }
        this.types[d] = a;
        return a
    },
    onModelDefined: function(d) {
        var a = this.associationStack,
            j = a.length,
            g = [],
            c, e, k;
        for (e = 0; e < j; e++) {
            c = a[e];
            if (c.associatedModel == d.modelName) {
                g.push(c)
            }
        }
        for (e = 0, j = g.length; e < j; e++) {
            k = g[e];
            this.types[k.ownerModel].prototype.associations.add(Ext.data.association.Association.create(k));
            Ext.Array.remove(a, k)
        }
    },
    registerDeferredAssociation: function(a) {
        this.associationStack.push(a)
    },
    getModel: function(c) {
        var a = c;
        if (typeof a == "string") {
            a = this.types[a]
        }
        return a
    },
    create: function(c, a, e) {
        var d = typeof a == "function" ? a : this.types[a || c.name];
        return new d(c, e)
    }
}, function() {
    Ext.regModel = function() {
        return this.ModelManager.registerType.apply(this.ModelManager, arguments)
    }
});
Ext.define("Ext.data.IdGenerator", {
    isGenerator: true,
    constructor: function(a) {
        var c = this;
        Ext.apply(c, a);
        if (c.id) {
            Ext.data.IdGenerator.all[c.id] = c
        }
    },
    getRecId: function(a) {
        return a.modelName + "-" + a.internalId
    },
    statics: {
        all: {},
        get: function(a) {
            var d, e, c;
            if (typeof a == "string") {
                e = c = a;
                a = null
            } else {
                if (a.isGenerator) {
                    return a
                } else {
                    e = a.id || a.type;
                    c = a.type
                }
            }
            d = this.all[e];
            if (!d) {
                d = Ext.create("idgen." + c, a)
            }
            return d
        }
    }
});
Ext.define("Ext.data.Errors", {
    extend: "Ext.util.MixedCollection",
    isValid: function() {
        return this.length === 0
    },
    getByField: function(g) {
        var e = [],
            a, d, c;
        for (c = 0; c < this.length; c++) {
            a = this.items[c];
            if (a.field == g) {
                e.push(a)
            }
        }
        return e
    }
});
Ext.define("Ext.data.validations", {
    singleton: true,
    presenceMessage: "must be present",
    lengthMessage: "is the wrong length",
    formatMessage: "is the wrong format",
    inclusionMessage: "is not included in the list of acceptable values",
    exclusionMessage: "is not an acceptable value",
    emailMessage: "is not a valid email address",
    emailRe: /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/,
    presence: function(a, c) {
        if (arguments.length === 1) {
            c = a
        }
        return !!c || c === 0
    },
    length: function(c, g) {
        if (g === undefined || g === null) {
            return false
        }
        var e = g.length,
            d = c.min,
            a = c.max;
        if ((d && e < d) || (a && e > a)) {
            return false
        } else {
            return true
        }
    },
    email: function(c, a) {
        return Ext.data.validations.emailRe.test(a)
    },
    format: function(a, c) {
        return !!(a.matcher && a.matcher.test(c))
    },
    inclusion: function(a, c) {
        return a.list && Ext.Array.indexOf(a.list, c) != -1
    },
    exclusion: function(a, c) {
        return a.list && Ext.Array.indexOf(a.list, c) == -1
    }
});
Ext.define("Ext.data.Model", {
    alternateClassName: "Ext.data.Record",
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.ModelManager", "Ext.data.IdGenerator", "Ext.data.Field", "Ext.data.Errors", "Ext.data.Operation", "Ext.data.validations", "Ext.util.MixedCollection"],
    compareConvertFields: function(a, e) {
        var d = a.convert && a.type && a.convert !== a.type.convert,
            c = e.convert && e.type && e.convert !== e.type.convert;
        if (d && !c) {
            return 1
        }
        if (!d && c) {
            return -1
        }
        return 0
    },
    itemNameFn: function(a) {
        return a.name
    },
    onClassExtended: function(c, d, a) {
        var e = a.onBeforeCreated;
        a.onBeforeCreated = function(j, G) {
            var F = this,
                H = Ext.getClassName(j),
                t = j.prototype,
                A = j.prototype.superclass,
                l = G.validations || [],
                v = G.fields || [],
                k, o = G.associations || [],
                g = function(J, L) {
                    var K = 0,
                        I, M;
                    if (J) {
                        J = Ext.Array.from(J);
                        for (I = J.length; K < I; ++K) {
                            M = J[K];
                            if (!Ext.isObject(M)) {
                                M = {
                                    model: M
                                }
                            }
                            M.type = L;
                            o.push(M)
                        }
                    }
                },
                x = G.idgen,
                D = new Ext.util.MixedCollection(false, t.itemNameFn),
                B = new Ext.util.MixedCollection(false, t.itemNameFn),
                s = A.validations,
                E = A.fields,
                n = A.associations,
                C, z, q, r = [],
                p = G.idProperty || j.prototype.idProperty,
                y = function(J, I, i) {
                    var K, L;
                    if (D.events.add.firing) {
                        L = J;
                        K = I
                    } else {
                        K = i;
                        L = I.originalIndex
                    }
                    K.originalIndex = L;
                    if (K.mapping === p || (K.mapping == null && K.name === p)) {
                        K.defaultValue = undefined
                    }
                },
                u = G.proxy || j.prototype.proxy || j.prototype.defaultProxyType,
                m = function() {
                    D.sortBy(t.compareConvertFields)
                };
            j.modelName = H;
            t.modelName = H;
            if (s) {
                l = s.concat(l)
            }
            G.validations = l;
            if (E) {
                v = E.items.concat(v)
            }
            D.on({
                add: y,
                replace: y
            });
            for (z = 0, q = v.length; z < q; ++z) {
                k = v[z];
                D.add(k.isField ? k : new Ext.data.Field(k))
            }
            if (!D.get(p)) {
                D.add(new Ext.data.Field(p))
            }
            m();
            D.on({
                add: m,
                replace: m
            });
            G.fields = D;
            if (x) {
                G.idgen = Ext.data.IdGenerator.get(x)
            }
            g(G.belongsTo, "belongsTo");
            delete G.belongsTo;
            g(G.hasMany, "hasMany");
            delete G.hasMany;
            g(G.hasOne, "hasOne");
            delete G.hasOne;
            if (n) {
                o = n.items.concat(o)
            }
            for (z = 0, q = o.length; z < q; ++z) {
                r.push("association." + o[z].type.toLowerCase())
            }
            if (u && !u.isProxy) {
                r.push("proxy." + (typeof u === "string" ? u : u.type))
            }
            Ext.require(r, function() {
                Ext.ModelManager.registerType(H, j);
                for (z = 0, q = o.length; z < q; ++z) {
                    C = o[z];
                    if (C.isAssociation) {
                        C = Ext.applyIf({
                            ownerModel: H,
                            associatedModel: C.model
                        }, C.initialConfig)
                    } else {
                        Ext.apply(C, {
                            ownerModel: H,
                            associatedModel: C.model
                        })
                    }
                    if (Ext.ModelManager.getModel(C.model) === undefined) {
                        Ext.ModelManager.registerDeferredAssociation(C)
                    } else {
                        B.add(Ext.data.association.Association.create(C))
                    }
                }
                G.associations = B;
                e.call(F, j, G, a);
                j.setProxy(u);
                Ext.ModelManager.onModelDefined(j)
            })
        }
    },
    inheritableStatics: {
        setProxy: function(a) {
            if (!a.isProxy) {
                if (typeof a == "string") {
                    a = {
                        type: a
                    }
                }
                a = Ext.createByAlias("proxy." + a.type, a)
            }
            a.setModel(this);
            this.proxy = this.prototype.proxy = a;
            return a
        },
        getProxy: function() {
            return this.proxy
        },
        setFields: function(d, e, c) {
            var l = this,
                k = l.prototype,
                j = k.fields,
                a = d ? d.length : 0,
                g = 0;
            if (e) {
                k.idProperty = e
            }
            if (c) {
                k.clientIdProperty = c
            }
            if (j) {
                j.clear()
            } else {
                j = l.prototype.fields = new Ext.util.MixedCollection(false, function(i) {
                    return i.name
                })
            }
            for (; g < a; g++) {
                j.add(new Ext.data.Field(d[g]))
            }
            if (!j.get(k.idProperty)) {
                j.add(new Ext.data.Field(k.idProperty))
            }
            l.fields = j;
            return j
        },
        getFields: function() {
            return this.prototype.fields.items
        },
        load: function(i, d) {
            d = Ext.apply({}, d);
            d = Ext.applyIf(d, {
                action: "read",
                id: i
            });
            var c = new Ext.data.Operation(d),
                e = d.scope || this,
                a = null,
                g;
            g = function(j) {
                if (j.wasSuccessful()) {
                    a = j.getRecords()[0];
                    Ext.callback(d.success, e, [a, j])
                } else {
                    Ext.callback(d.failure, e, [a, j])
                }
                Ext.callback(d.callback, e, [a, j])
            };
            this.proxy.read(c, g, this)
        }
    },
    statics: {
        PREFIX: "ext-record",
        AUTO_ID: 1,
        EDIT: "edit",
        REJECT: "reject",
        COMMIT: "commit",
        id: function(a) {
            var c = [this.PREFIX, "-", this.AUTO_ID++].join("");
            a.phantom = true;
            a.internalId = c;
            return c
        }
    },
    idgen: {
        isGenerator: true,
        type: "default",
        generate: function() {
            return null
        },
        getRecId: function(a) {
            return a.modelName + "-" + a.internalId
        }
    },
    editing: false,
    dirty: false,
    persistenceProperty: "data",
    evented: false,
    isModel: true,
    phantom: false,
    idProperty: "id",
    clientIdProperty: null,
    defaultProxyType: "ajax",
    constructor: function(l, e, q, c) {
        l = l || {};
        var n = this,
            m, g, o, a, p, j, d, k;
        n.internalId = (e || e === 0) ? e : Ext.data.Model.id(n);
        n.raw = q || l;
        if (!n.data) {
            n.data = {}
        }
        n.modified = {};
        if (n.persistanceProperty) {
            n.persistenceProperty = n.persistanceProperty
        }
        n[n.persistenceProperty] = c || {};
        n.mixins.observable.constructor.call(n);
        if (!c) {
            m = n.fields.items;
            g = m.length;
            k = 0;
            d = n[n.persistenceProperty];
            if (Ext.isArray(l)) {
                for (; k < g; k++) {
                    o = m[k];
                    a = o.name;
                    p = l[o.originalIndex];
                    if (p === undefined) {
                        p = o.defaultValue
                    }
                    if (o.convert) {
                        p = o.convert(p, n)
                    }
                    if (p !== undefined) {
                        d[a] = p
                    }
                }
            } else {
                for (; k < g; k++) {
                    o = m[k];
                    a = o.name;
                    p = l[a];
                    if (p === undefined) {
                        p = o.defaultValue
                    }
                    if (o.convert) {
                        p = o.convert(p, n)
                    }
                    if (p !== undefined) {
                        d[a] = p
                    }
                }
            }
        }
        n.stores = [];
        if (n.getId()) {
            n.phantom = false
        } else {
            if (n.phantom) {
                j = n.idgen.generate();
                if (j !== null) {
                    n.setId(j)
                }
            }
        }
        n.dirty = false;
        n.modified = {};
        if (typeof n.init == "function") {
            n.init()
        }
        n.id = n.idgen.getRecId(n)
    },
    get: function(a) {
        return this[this.persistenceProperty][a]
    },
    _singleProp: {},
    set: function(t, c) {
        var l = this,
            j = l[l.persistenceProperty],
            k = l.fields,
            s = l.modified,
            q = (typeof t == "string"),
            r, m, i, p, g, a, d, e, n, o;
        if (q) {
            o = l._singleProp;
            o[t] = c
        } else {
            o = t
        }
        for (a in o) {
            if (o.hasOwnProperty(a)) {
                n = o[a];
                if (k && (m = k.get(a)) && m.convert) {
                    n = m.convert(n, l)
                }
                r = j[a];
                if (l.isEqual(r, n)) {
                    continue
                }
                j[a] = n;
                (g || (g = [])).push(a);
                if (m && m.persist) {
                    if (s.hasOwnProperty(a)) {
                        if (l.isEqual(s[a], n)) {
                            delete s[a];
                            l.dirty = false;
                            for (p in s) {
                                if (s.hasOwnProperty(p)) {
                                    l.dirty = true;
                                    break
                                }
                            }
                        }
                    } else {
                        l.dirty = true;
                        s[a] = r
                    }
                }
                if (a == l.idProperty) {
                    i = true;
                    d = r;
                    e = n
                }
            }
        }
        if (q) {
            delete o[t]
        }
        if (i) {
            l.fireEvent("idchanged", l, d, e)
        }
        if (!l.editing && g) {
            l.afterEdit(g)
        }
        return g || null
    },
    copyFrom: function(j) {
        if (j) {
            var g = this,
                d = g.fields.items,
                m = d.length,
                k, a = 0,
                e = g[g.persistenceProperty],
                c = j[j.persistenceProperty],
                l;
            for (; a < m; a++) {
                k = d[a];
                l = c[k.name];
                if (l !== undefined) {
                    e[k.name] = l
                }
            }
            if (g.phantom && !j.phantom) {
                g.setId(j.getId())
            }
        }
    },
    isEqual: function(d, c) {
        if (Ext.isDate(d) && Ext.isDate(c)) {
            return Ext.Date.isEqual(d, c)
        }
        return d === c
    },
    beginEdit: function() {
        var a = this;
        if (!a.editing) {
            a.editing = true;
            a.dirtySave = a.dirty;
            a.dataSave = Ext.apply({}, a[a.persistenceProperty]);
            a.modifiedSave = Ext.apply({}, a.modified)
        }
    },
    cancelEdit: function() {
        var a = this;
        if (a.editing) {
            a.editing = false;
            a.modified = a.modifiedSave;
            a[a.persistenceProperty] = a.dataSave;
            a.dirty = a.dirtySave;
            delete a.modifiedSave;
            delete a.dataSave;
            delete a.dirtySave
        }
    },
    endEdit: function(a, d) {
        var c = this,
            e;
        if (c.editing) {
            c.editing = false;
            if (!d) {
                d = c.getModifiedFieldNames()
            }
            e = c.dirty || d.length > 0;
            delete c.modifiedSave;
            delete c.dataSave;
            delete c.dirtySave;
            if (e && a !== true) {
                c.afterEdit(d)
            }
        }
    },
    getModifiedFieldNames: function() {
        var e = this,
            d = e.dataSave,
            g = e[e.persistenceProperty],
            a = [],
            c;
        for (c in g) {
            if (g.hasOwnProperty(c)) {
                if (!e.isEqual(g[c], d[c])) {
                    a.push(c)
                }
            }
        }
        return a
    },
    getChanges: function() {
        var a = this.modified,
            c = {},
            d;
        for (d in a) {
            if (a.hasOwnProperty(d)) {
                c[d] = this.get(d)
            }
        }
        return c
    },
    isModified: function(a) {
        return this.modified.hasOwnProperty(a)
    },
    setDirty: function() {
        var d = this,
            a = d.fields.items,
            i = a.length,
            g, c, e;
        d.dirty = true;
        for (e = 0; e < i; e++) {
            g = a[e];
            if (g.persist) {
                c = g.name;
                d.modified[c] = d.get(c)
            }
        }
    },
    reject: function(a) {
        var d = this,
            c = d.modified,
            e;
        for (e in c) {
            if (c.hasOwnProperty(e)) {
                if (typeof c[e] != "function") {
                    d[d.persistenceProperty][e] = c[e]
                }
            }
        }
        d.dirty = false;
        d.editing = false;
        d.modified = {};
        if (a !== true) {
            d.afterReject()
        }
    },
    commit: function(a) {
        var c = this;
        c.phantom = c.dirty = c.editing = false;
        c.modified = {};
        if (a !== true) {
            c.afterCommit()
        }
    },
    copy: function(a) {
        var c = this;
        return new c.self(c.raw, a, null, Ext.apply({}, c[c.persistenceProperty]))
    },
    setProxy: function(a) {
        if (!a.isProxy) {
            if (typeof a === "string") {
                a = {
                    type: a
                }
            }
            a = Ext.createByAlias("proxy." + a.type, a)
        }
        a.setModel(this.self);
        this.proxy = a;
        return a
    },
    getProxy: function() {
        return this.proxy
    },
    validate: function() {
        var m = new Ext.data.Errors(),
            d = this.validations,
            g = Ext.data.validations,
            c, e, l, a, k, j;
        if (d) {
            c = d.length;
            for (j = 0; j < c; j++) {
                e = d[j];
                l = e.field || e.name;
                k = e.type;
                a = g[k](e, this.get(l));
                if (!a) {
                    m.add({
                        field: l,
                        message: e.message || g[k + "Message"]
                    })
                }
            }
        }
        return m
    },
    isValid: function() {
        return this.validate().isValid()
    },
    save: function(o) {
        o = Ext.apply({}, o);
        var j = this,
            c = j.phantom ? "create" : "update",
            n = o.scope || j,
            l = j.stores,
            d = 0,
            g, k, e, a, m;
        Ext.apply(o, {
            records: [j],
            action: c
        });
        a = new Ext.data.Operation(o);
        m = function(i) {
            e = [j, i];
            if (i.wasSuccessful()) {
                for (g = l.length; d < g; d++) {
                    k = l[d];
                    k.fireEvent("write", k, i);
                    k.fireEvent("datachanged", k)
                }
                Ext.callback(o.success, n, e)
            } else {
                Ext.callback(o.failure, n, e)
            }
            Ext.callback(o.callback, n, e)
        };
        j.getProxy()[c](a, m, j);
        return j
    },
    destroy: function(n) {
        n = Ext.apply({}, n);
        var g = this,
            m = n.scope || g,
            k = g.stores,
            c = 0,
            e, j, d, a, l;
        Ext.apply(n, {
            records: [g],
            action: "destroy"
        });
        a = new Ext.data.Operation(n);
        l = function(i) {
            d = [g, i];
            if (i.wasSuccessful()) {
                for (e = k.length; c < e; c++) {
                    j = k[c];
                    j.fireEvent("write", j, i);
                    j.fireEvent("datachanged", j)
                }
                g.clearListeners();
                Ext.callback(n.success, m, d)
            } else {
                Ext.callback(n.failure, m, d)
            }
            Ext.callback(n.callback, m, d)
        };
        g.getProxy().destroy(a, l, g);
        return g
    },
    getId: function() {
        return this.get(this.idProperty)
    },
    getObservableId: function() {
        return this.id
    },
    setId: function(a) {
        this.set(this.idProperty, a);
        this.phantom = !(a || a === 0)
    },
    join: function(a) {
        Ext.Array.include(this.stores, a);
        this.store = this.stores[0]
    },
    unjoin: function(a) {
        Ext.Array.remove(this.stores, a);
        this.store = this.stores[0] || null
    },
    afterEdit: function(a) {
        this.callStore("afterEdit", a)
    },
    afterReject: function() {
        this.callStore("afterReject")
    },
    afterCommit: function() {
        this.callStore("afterCommit")
    },
    callStore: function(j) {
        var e = Ext.Array.clone(arguments),
            c = this.stores,
            g = 0,
            a = c.length,
            d, k;
        e[0] = this;
        for (; g < a; ++g) {
            d = c[g];
            if (d && typeof d[j] == "function") {
                d[j].apply(d, e)
            }
            k = d.treeStore;
            if (k && typeof k[j] == "function") {
                k[j].apply(k, e)
            }
        }
    },
    getData: function(d) {
        var e = this,
            a = e.fields.items,
            j = a.length,
            i = {},
            c, g;
        for (g = 0; g < j; g++) {
            c = a[g].name;
            i[c] = e.get(c)
        }
        if (d === true) {
            Ext.apply(i, e.getAssociatedData())
        }
        return i
    },
    getAssociatedData: function() {
        return this.prepareAssociatedData({}, 1)
    },
    prepareAssociatedData: function(z, C) {
        var B = this,
            v = B.associations.items,
            g = v.length,
            A = {},
            s = [],
            y = [],
            p = [],
            r, c, a, q, k, n, m, x, l, d, u, t, e, D;
        for (u = 0; u < g; u++) {
            d = v[u];
            x = d.associationId;
            m = z[x];
            if (m && m !== C) {
                continue
            }
            z[x] = C;
            e = d.type;
            D = d.name;
            if (e == "hasMany") {
                r = B[d.storeName];
                A[D] = [];
                if (r && r.getCount() > 0) {
                    c = r.data.items;
                    l = c.length;
                    for (t = 0; t < l; t++) {
                        a = c[t];
                        A[D][t] = a.getData();
                        s.push(a);
                        y.push(D);
                        p.push(t)
                    }
                }
            } else {
                if (e == "belongsTo" || e == "hasOne") {
                    a = B[d.instanceName];
                    if (a !== undefined) {
                        A[D] = a.getData();
                        s.push(a);
                        y.push(D);
                        p.push(-1)
                    }
                }
            }
        }
        for (u = 0, l = s.length; u < l; ++u) {
            a = s[u];
            q = A[y[u]];
            k = p[u];
            n = a.prepareAssociatedData(z, C + 1);
            if (k === -1) {
                Ext.apply(q, n)
            } else {
                Ext.apply(q[k], n)
            }
        }
        return A
    }
});
Ext.define("DemoApp.model.PlanChunk", {
    extend: "Ext.data.Model",
    fields: [{
        name: "type",
        type: "string"
    }, {
        name: "name",
        type: "string"
    }, {
        name: "label",
        type: "string"
    }, {
        name: "mode",
        type: "string"
    }, {
        name: "start",
        type: "date",
        dateFormat: "c"
    }, {
        name: "geometry",
        type: "string"
    }, {
        name: "originalWpts",
        type: "string"
    }, {
        name: "projectedWpts",
        type: "string"
    }, {
        name: "duration",
        type: "string"
    }, {
        name: "quality",
        type: "int"
    }, {
        name: "distance",
        type: "string"
    }]
});
Ext.define("DemoApp.store.PlanChunks", {
    extend: "Ext.data.TreeStore",
    requires: "DemoApp.model.PlanChunk",
    model: "DemoApp.model.PlanChunk",
    proxy: {
        type: "ajax",
        url: "mockupdata/matchingresults.json",
        reader: {
            type: "json"
        }
    },
    root: {
        children: [],
        expanded: false
    }
});
Ext.define("Ext.layout.Layout", {
    requires: ["Ext.XTemplate"],
    uses: ["Ext.layout.Context"],
    isLayout: true,
    initialized: false,
    running: false,
    autoSizePolicy: {
        setsWidth: 0,
        setsHeight: 0
    },
    statics: {
        layoutsByType: {},
        create: function(i, g) {
            var m = Ext.ClassManager,
                d = this.layoutsByType,
                e, j, c, a, k, l;
            if (!i || typeof i === "string") {
                k = i || g;
                c = {}
            } else {
                if (i.isLayout) {
                    return i
                } else {
                    c = i;
                    k = i.type || g
                }
            }
            if (!(a = d[k])) {
                e = "layout." + k;
                j = m.getNameByAlias(e);
                if (!j) {
                    l = true
                }
                a = m.get(j);
                if (l || !a) {
                    return m.instantiateByAlias(e, c || {})
                }
                d[k] = a
            }
            return new a(c)
        }
    },
    constructor: function(a) {
        var c = this;
        c.id = Ext.id(null, c.type + "-");
        Ext.apply(c, a);
        c.layoutCount = 0
    },
    beginLayout: Ext.emptyFn,
    beginLayoutCycle: function(d) {
        var c = this,
            a = c.context,
            e;
        if (c.lastWidthModel != d.widthModel) {
            if (c.lastWidthModel) {
                e = true
            }
            c.lastWidthModel = d.widthModel
        }
        if (c.lastHeightModel != d.heightModel) {
            if (c.lastWidthModel) {
                e = true
            }
            c.lastHeightModel = d.heightModel
        }
        if (e) {
            (a = d.context).clearTriggers(c, false);
            a.clearTriggers(c, true);
            c.triggerCount = 0
        }
    },
    finishedLayout: function() {
        this.ownerContext = null
    },
    redoLayout: Ext.emptyFn,
    undoLayout: Ext.emptyFn,
    getAnimatePolicy: function() {
        return this.animatePolicy
    },
    getItemSizePolicy: function(a) {
        return this.autoSizePolicy
    },
    isItemBoxParent: function(a) {
        return false
    },
    isItemLayoutRoot: function(e) {
        var d = e.getSizeModel(),
            c = d.width,
            a = d.height;
        if (!e.componentLayout.lastComponentSize && (c.calculated || a.calculated)) {
            return false
        }
        return !c.shrinkWrap && !a.shrinkWrap
    },
    isItemShrinkWrap: function(a) {
        return a.shrinkWrap
    },
    isRunning: function() {
        return !!this.ownerContext
    },
    getItemsRenderTree: function(e, c) {
        var k = e.length,
            g, j, d, a;
        if (k) {
            a = [];
            for (g = 0; g < k; ++g) {
                j = e[g];
                if (!j.rendered) {
                    if (c && (c[j.id] !== undefined)) {
                        d = c[j.id]
                    } else {
                        this.configureItem(j);
                        d = j.getRenderTree();
                        if (c) {
                            c[j.id] = d
                        }
                    }
                    if (d) {
                        a.push(d)
                    }
                }
            }
        }
        return a
    },
    finishRender: Ext.emptyFn,
    finishRenderItems: function(g, a) {
        var e = a.length,
            c, d;
        for (c = 0; c < e; c++) {
            d = a[c];
            if (d.rendering) {
                d.finishRender(c);
                this.afterRenderItem(d)
            }
        }
    },
    renderChildren: function() {
        var c = this,
            a = c.getLayoutItems(),
            d = c.getRenderTarget();
        c.renderItems(a, d)
    },
    renderItems: function(a, j) {
        var g = this,
            e = a.length,
            c = 0,
            d;
        if (e) {
            Ext.suspendLayouts();
            for (; c < e; c++) {
                d = a[c];
                if (d && !d.rendered) {
                    g.renderItem(d, j, c)
                } else {
                    if (!g.isValidParent(d, j, c)) {
                        g.moveItem(d, j, c)
                    } else {
                        g.configureItem(d)
                    }
                }
            }
            Ext.resumeLayouts(true)
        }
    },
    isValidParent: function(e, g, a) {
        var c = e.el ? e.el.dom : Ext.getDom(e),
            d = (g && g.dom) || g;
        if (c.parentNode && c.parentNode.className.indexOf(Ext.baseCSSPrefix + "resizable-wrap") !== -1) {
            c = c.parentNode
        }
        if (c && d) {
            if (typeof a == "number") {
                return c === d.childNodes[a]
            }
            return c.parentNode === d
        }
        return false
    },
    configureItem: function(a) {
        a.ownerLayout = this
    },
    renderItem: function(d, e, a) {
        var c = this;
        if (!d.rendered) {
            c.configureItem(d);
            d.render(e, a);
            c.afterRenderItem(d)
        }
    },
    moveItem: function(c, d, a) {
        d = d.dom || d;
        if (typeof a == "number") {
            a = d.childNodes[a]
        }
        d.insertBefore(c.el.dom, a || null);
        c.container = Ext.get(d);
        this.configureItem(c)
    },
    onContentChange: function() {
        this.owner.updateLayout();
        return true
    },
    initLayout: function() {
        this.initialized = true
    },
    setOwner: function(a) {
        this.owner = a
    },
    getLayoutItems: function() {
        return []
    },
    afterRenderItem: Ext.emptyFn,
    onAdd: Ext.emptyFn,
    onRemove: Ext.emptyFn,
    onDestroy: Ext.emptyFn,
    afterRemove: function(g) {
        var e = this,
            d = g.el,
            c = e.owner,
            a;
        if (g.rendered) {
            a = [].concat(e.itemCls || []);
            if (c.itemCls) {
                a = Ext.Array.push(a, c.itemCls)
            }
            if (a.length) {
                d.removeCls(a)
            }
        }
        delete g.ownerLayout
    },
    destroy: function() {
        var a = this,
            c;
        if (a.targetCls) {
            c = a.getTarget();
            if (c) {
                c.removeCls(a.targetCls)
            }
        }
        a.onDestroy()
    },
    sortWeightedItems: function(a, e) {
        for (var c = 0, d = a.length; c < d; ++c) {
            a[c].$i = c
        }
        Ext.Array.sort(a, function(i, g) {
            var j = g.weight - i.weight;
            if (!j) {
                j = i.$i - g.$i;
                if (i[e]) {
                    j = -j
                }
            }
            return j
        });
        for (c = 0; c < d; ++c) {
            delete a[c].$i
        }
    }
}, function() {
    var o = this,
        m = {},
        p = [],
        k, g, c, a, e;
    o.prototype.sizeModels = o.sizeModels = m;
    var l = function(j) {
        var n = this,
            i = j.name;
        Ext.apply(Ext.apply(n, d), j);
        n[i] = true;
        l[i] = m[i] = n;
        n.fixed = !(n.auto = n.natural || n.shrinkWrap);
        n.ordinal = p.length;
        p.push(n)
    };
    Ext.layout.SizeModel = l;
    var d = {
        calculated: false,
        configured: false,
        constrainedMax: false,
        constrainedMin: false,
        natural: false,
        shrinkWrap: false,
        calculatedFromConfigured: false,
        calculatedFromNatural: false,
        calculatedFromShrinkWrap: false,
        names: null
    };
    new l({
        name: "calculated"
    });
    new l({
        name: "configured",
        names: {
            width: "width",
            height: "height"
        }
    });
    new l({
        name: "natural"
    });
    new l({
        name: "shrinkWrap"
    });
    new l({
        name: "calculatedFromConfigured",
        configured: true,
        names: {
            width: "width",
            height: "height"
        }
    });
    new l({
        name: "calculatedFromNatural",
        natural: true
    });
    new l({
        name: "calculatedFromShrinkWrap",
        shrinkWrap: true
    });
    new l({
        name: "constrainedMax",
        configured: true,
        constrained: true,
        names: {
            width: "maxWidth",
            height: "maxHeight"
        }
    });
    new l({
        name: "constrainedMin",
        configured: true,
        constrained: true,
        names: {
            width: "minWidth",
            height: "minHeight"
        }
    });
    for (k = 0, c = p.length; k < c; ++k) {
        e = p[k];
        e.pairsByHeightOrdinal = a = [];
        for (g = 0; g < c; ++g) {
            a.push({
                width: e,
                height: p[g]
            })
        }
    }
});
Ext.define("Ext.layout.component.Component", {
    extend: "Ext.layout.Layout",
    type: "component",
    isComponentLayout: true,
    nullBox: {},
    usesContentHeight: true,
    usesContentWidth: true,
    usesHeight: true,
    usesWidth: true,
    beginLayoutCycle: function(d, r) {
        var m = this,
            c = m.owner,
            g = d.ownerCtContext,
            i = d.heightModel,
            j = d.widthModel,
            k = c.el.dom === document.body,
            e = c.lastBox || m.nullBox,
            p = c.el.lastBox || m.nullBox,
            a = !k,
            o, q, n, l;
        m.callParent(arguments);
        if (r) {
            if (m.usesContentWidth) {
                ++d.consumersContentWidth
            }
            if (m.usesContentHeight) {
                ++d.consumersContentHeight
            }
            if (m.usesWidth) {
                ++d.consumersWidth
            }
            if (m.usesHeight) {
                ++d.consumersHeight
            }
            if (g && !g.hasRawContent) {
                o = c.ownerLayout;
                if (o.usesWidth) {
                    ++d.consumersWidth
                }
                if (o.usesHeight) {
                    ++d.consumersHeight
                }
            }
        }
        if (j.configured) {
            n = j.names.width;
            if (!k) {
                a = r ? c[n] !== p.width : j.constrained
            }
            d.setWidth(c[n], a)
        } else {
            if (d.isTopLevel) {
                if (j.calculated) {
                    q = e.width;
                    d.setWidth(q, q != p.width)
                }
                q = e.x;
                d.setProp("x", q, q != p.x)
            }
        }
        if (i.configured) {
            l = i.names.height;
            if (!k) {
                a = r ? c[l] !== p.height : i.constrained
            }
            d.setHeight(c[l], a)
        } else {
            if (d.isTopLevel) {
                if (i.calculated) {
                    q = e.height;
                    d.setHeight(q, q != p.height)
                }
                q = e.y;
                d.setProp("y", q, q != p.y)
            }
        }
    },
    finishedLayout: function(c) {
        var k = this,
            n = c.children,
            a = k.owner,
            g, d, m, e, j, l;
        if (n) {
            g = n.length;
            for (d = 0; d < g; d++) {
                m = n[d];
                m.el.lastBox = m.props
            }
        }
        c.previousSize = k.lastComponentSize;
        k.lastComponentSize = a.el.lastBox = j = c.props;
        a.lastBox = e = {};
        l = j.x;
        if (l !== undefined) {
            e.x = l
        }
        l = j.y;
        if (l !== undefined) {
            e.y = l
        }
        l = j.width;
        if (l !== undefined) {
            e.width = l
        }
        l = j.height;
        if (l !== undefined) {
            e.height = l
        }
        k.callParent(arguments)
    },
    notifyOwner: function(e) {
        var d = this,
            a = d.lastComponentSize,
            g = e.previousSize,
            c = [a.width, a.height];
        if (g) {
            c.push(g.width, g.height)
        }
        d.owner.afterComponentLayout.apply(d.owner, c)
    },
    getTarget: function() {
        return this.owner.el
    },
    getRenderTarget: function() {
        return this.owner.el
    },
    cacheTargetInfo: function(c) {
        var a = this,
            e = a.targetInfo,
            d;
        if (!e) {
            d = c.getEl("getTarget", a);
            a.targetInfo = e = {
                padding: d.getPaddingInfo(),
                border: d.getBorderInfo()
            }
        }
        return e
    },
    measureAutoDimensions: function(o, k) {
        var v = this,
            a = v.owner,
            s = a.layout,
            e = o.heightModel,
            j = o.widthModel,
            d = o.boxParent,
            p = o.isBoxParent,
            c = o.props,
            l, x = {
                gotWidth: false,
                gotHeight: false,
                isContainer: (l = !o.hasRawContent)
            },
            u = k || 3,
            r, g, m = 0,
            i = 0,
            n, q, t;
        if (j.shrinkWrap && o.consumersContentWidth) {
            ++m;
            r = !(u & 1);
            if (l) {
                if (r) {
                    x.contentWidth = 0;
                    x.gotWidth = true;
                    ++i
                } else {
                    if ((x.contentWidth = o.getProp("contentWidth")) !== undefined) {
                        x.gotWidth = true;
                        ++i
                    }
                }
            } else {
                q = c.contentWidth;
                if (typeof q == "number") {
                    x.contentWidth = q;
                    x.gotWidth = true;
                    ++i
                } else {
                    if (r) {
                        n = true
                    } else {
                        if (!o.hasDomProp("containerChildrenDone")) {
                            n = false
                        } else {
                            if (p || !d || d.widthModel.shrinkWrap) {
                                n = true
                            } else {
                                n = d.hasDomProp("width")
                            }
                        }
                    }
                    if (n) {
                        if (r) {
                            t = 0
                        } else {
                            if (s && s.measureContentWidth) {
                                t = s.measureContentWidth(o)
                            } else {
                                t = v.measureContentWidth(o)
                            }
                        }
                        if (!isNaN(x.contentWidth = t)) {
                            o.setContentWidth(t, true);
                            x.gotWidth = true;
                            ++i
                        }
                    }
                }
            }
        } else {
            if (j.natural && o.consumersWidth) {
                ++m;
                q = c.width;
                if (typeof q == "number") {
                    x.width = q;
                    x.gotWidth = true;
                    ++i
                } else {
                    if (p || !d) {
                        n = true
                    } else {
                        n = d.hasDomProp("width")
                    }
                    if (n) {
                        if (!isNaN(x.width = v.measureOwnerWidth(o))) {
                            o.setWidth(x.width, false);
                            x.gotWidth = true;
                            ++i
                        }
                    }
                }
            }
        }
        if (e.shrinkWrap && o.consumersContentHeight) {
            ++m;
            g = !(u & 2);
            if (l) {
                if (g) {
                    x.contentHeight = 0;
                    x.gotHeight = true;
                    ++i
                } else {
                    if ((x.contentHeight = o.getProp("contentHeight")) !== undefined) {
                        x.gotHeight = true;
                        ++i
                    }
                }
            } else {
                q = c.contentHeight;
                if (typeof q == "number") {
                    x.contentHeight = q;
                    x.gotHeight = true;
                    ++i
                } else {
                    if (g) {
                        n = true
                    } else {
                        if (!o.hasDomProp("containerChildrenDone")) {
                            n = false
                        } else {
                            if (a.noWrap) {
                                n = true
                            } else {
                                if (!j.shrinkWrap) {
                                    n = (o.bodyContext || o).hasDomProp("width")
                                } else {
                                    if (p || !d || d.widthModel.shrinkWrap) {
                                        n = true
                                    } else {
                                        n = d.hasDomProp("width")
                                    }
                                }
                            }
                        }
                    }
                    if (n) {
                        if (g) {
                            t = 0
                        } else {
                            if (s && s.measureContentHeight) {
                                t = s.measureContentHeight(o)
                            } else {
                                t = v.measureContentHeight(o)
                            }
                        }
                        if (!isNaN(x.contentHeight = t)) {
                            o.setContentHeight(t, true);
                            x.gotHeight = true;
                            ++i
                        }
                    }
                }
            }
        } else {
            if (e.natural && o.consumersHeight) {
                ++m;
                q = c.height;
                if (typeof q == "number") {
                    x.height = q;
                    x.gotHeight = true;
                    ++i
                } else {
                    if (p || !d) {
                        n = true
                    } else {
                        n = d.hasDomProp("width")
                    }
                    if (n) {
                        if (!isNaN(x.height = v.measureOwnerHeight(o))) {
                            o.setHeight(x.height, false);
                            x.gotHeight = true;
                            ++i
                        }
                    }
                }
            }
        }
        if (d) {
            o.onBoxMeasured()
        }
        x.gotAll = i == m;
        return x
    },
    measureContentWidth: function(a) {
        return a.el.getWidth() - a.getFrameInfo().width
    },
    measureContentHeight: function(a) {
        return a.el.getHeight() - a.getFrameInfo().height
    },
    measureOwnerHeight: function(a) {
        return a.el.getHeight()
    },
    measureOwnerWidth: function(a) {
        return a.el.getWidth()
    }
});
Ext.define("Ext.layout.component.Auto", {
    alias: "layout.autocomponent",
    extend: "Ext.layout.component.Component",
    type: "autocomponent",
    setHeightInDom: false,
    setWidthInDom: false,
    waitForOuterHeightInDom: false,
    waitForOuterWidthInDom: false,
    beginLayoutCycle: function(e, c) {
        var d = this,
            i = d.lastWidthModel,
            g = d.lastHeightModel,
            a = d.owner;
        d.callParent(arguments);
        if (i && i.fixed && e.widthModel.shrinkWrap) {
            a.el.setWidth(null)
        }
        if (g && g.fixed && e.heightModel.shrinkWrap) {
            a.el.setHeight(null)
        }
    },
    calculate: function(j) {
        var i = this,
            g = i.measureAutoDimensions(j),
            c = j.heightModel,
            d = j.widthModel,
            e, a;
        if (g.gotWidth) {
            if (d.shrinkWrap) {
                i.publishOwnerWidth(j, g.contentWidth)
            } else {
                if (i.publishInnerWidth) {
                    i.publishInnerWidth(j, g.width)
                }
            }
        } else {
            if (!d.auto && i.publishInnerWidth) {
                e = i.waitForOuterWidthInDom ? j.getDomProp("width") : j.getProp("width");
                if (e === undefined) {
                    i.done = false
                } else {
                    i.publishInnerWidth(j, e)
                }
            }
        }
        if (g.gotHeight) {
            if (c.shrinkWrap) {
                i.publishOwnerHeight(j, g.contentHeight)
            } else {
                if (i.publishInnerHeight) {
                    i.publishInnerHeight(j, g.height)
                }
            }
        } else {
            if (!c.auto && i.publishInnerHeight) {
                a = i.waitForOuterHeightInDom ? j.getDomProp("height") : j.getProp("height");
                if (a === undefined) {
                    i.done = false
                } else {
                    i.publishInnerHeight(j, a)
                }
            }
        }
        if (!g.gotAll) {
            i.done = false
        }
    },
    calculateOwnerHeightFromContentHeight: function(c, a) {
        return a + c.getFrameInfo().height
    },
    calculateOwnerWidthFromContentWidth: function(c, a) {
        return a + c.getFrameInfo().width
    },
    publishOwnerHeight: function(k, i) {
        var g = this,
            c = g.owner,
            a = g.calculateOwnerHeightFromContentHeight(k, i),
            j, e, d;
        if (isNaN(a)) {
            g.done = false
        } else {
            j = Ext.Number.constrain(a, c.minHeight, c.maxHeight);
            if (j == a) {
                e = g.setHeightInDom
            } else {
                d = g.sizeModels[(j < a) ? "constrainedMax" : "constrainedMin"];
                a = j;
                if (k.heightModel.calculatedFromShrinkWrap) {
                    k.heightModel = d
                } else {
                    k.invalidate({
                        heightModel: d
                    })
                }
            }
            k.setHeight(a, e)
        }
    },
    publishOwnerWidth: function(j, c) {
        var i = this,
            a = i.owner,
            g = i.calculateOwnerWidthFromContentWidth(j, c),
            k, e, d;
        if (isNaN(g)) {
            i.done = false
        } else {
            k = Ext.Number.constrain(g, a.minWidth, a.maxWidth);
            if (k == g) {
                e = i.setWidthInDom
            } else {
                d = i.sizeModels[(k < g) ? "constrainedMax" : "constrainedMin"];
                g = k;
                if (j.widthModel.calculatedFromShrinkWrap) {
                    j.widthModel = d
                } else {
                    j.invalidate({
                        widthModel: d
                    })
                }
            }
            j.setWidth(g, e)
        }
    }
});
Ext.define("Ext.util.ElementContainer", {
    childEls: [],
    constructor: function() {
        var c = this,
            a;
        if (c.hasOwnProperty("childEls")) {
            a = c.childEls;
            delete c.childEls;
            c.addChildEls.apply(c, a)
        }
    },
    destroy: function() {
        var g = this,
            e = g.getChildEls(),
            j, a, d, c;
        for (d = e.length; d--;) {
            a = e[d];
            if (typeof a != "string") {
                a = a.name
            }
            j = g[a];
            if (j) {
                g[a] = null;
                j.remove()
            }
        }
    },
    addChildEls: function() {
        var c = this,
            a = arguments;
        if (c.hasOwnProperty("childEls")) {
            c.childEls.push.apply(c.childEls, a)
        } else {
            c.childEls = c.getChildEls().concat(Array.prototype.slice.call(a))
        }
        c.prune(c.childEls, false)
    },
    applyChildEls: function(c, a) {
        var g = this,
            j = g.getChildEls(),
            l, m, e, d, k;
        l = (a || g.id) + "-";
        for (e = j.length; e--;) {
            m = j[e];
            if (typeof m == "string") {
                k = c.getById(l + m)
            } else {
                if ((d = m.select)) {
                    k = Ext.select(d, true, c.dom)
                } else {
                    if ((d = m.selectNode)) {
                        k = Ext.get(Ext.DomQuery.selectNode(d, c.dom))
                    } else {
                        k = c.getById(m.id || (l + m.itemId))
                    }
                }
                m = m.name
            }
            g[m] = k
        }
    },
    getChildEls: function() {
        var c = this,
            a;
        if (c.hasOwnProperty("childEls")) {
            return c.childEls
        }
        a = c.self;
        return a.$childEls || c.getClassChildEls(a)
    },
    getClassChildEls: function(q) {
        var m = this,
            r = q.$childEls,
            o, e, c, l, p, k, a, d, g, j, n;
        if (!r) {
            j = q.superclass;
            if (j) {
                j = j.self;
                d = [j.$childEls || m.getClassChildEls(j)];
                n = j.prototype.mixins || {}
            } else {
                d = [];
                n = {}
            }
            g = q.prototype;
            k = g.mixins;
            for (a in k) {
                if (k.hasOwnProperty(a) && !n.hasOwnProperty(a)) {
                    p = k[a].self;
                    d.push(p.$childEls || m.getClassChildEls(p))
                }
            }
            d.push(g.hasOwnProperty("childEls") && g.childEls);
            for (e = 0, c = d.length; e < c; ++e) {
                o = d[e];
                if (o && o.length) {
                    if (!r) {
                        r = o
                    } else {
                        if (!l) {
                            l = true;
                            r = r.slice(0)
                        }
                        r.push.apply(r, o)
                    }
                }
            }
            q.$childEls = r = (r ? m.prune(r, !l) : [])
        }
        return r
    },
    prune: function(d, g) {
        var c = d.length,
            e = {},
            a;
        while (c--) {
            a = d[c];
            if (typeof a != "string") {
                a = a.name
            }
            if (!e[a]) {
                e[a] = 1
            } else {
                if (g) {
                    g = false;
                    d = d.slice(0)
                }
                Ext.Array.erase(d, c, 1)
            }
        }
        return d
    },
    removeChildEls: function(j) {
        var g = this,
            a = g.getChildEls(),
            e = (g.childEls = []),
            k, c, d;
        for (c = 0, k = a.length; c < k; ++c) {
            d = a[c];
            if (!j(d)) {
                e.push(d)
            }
        }
    }
});
Ext.define("Ext.layout.container.Container", {
    extend: "Ext.layout.Layout",
    alternateClassName: "Ext.layout.ContainerLayout",
    mixins: {
        elementCt: "Ext.util.ElementContainer"
    },
    requires: ["Ext.XTemplate"],
    type: "container",
    manageOverflow: 0,
    beginCollapse: Ext.emptyFn,
    beginExpand: Ext.emptyFn,
    animatePolicy: null,
    childEls: ["overflowPadderEl"],
    renderTpl: ["{%this.renderBody(out,values)%}"],
    usesContainerHeight: true,
    usesContainerWidth: true,
    usesHeight: true,
    usesWidth: true,
    reserveScrollbar: false,
    lastOverflowAdjust: {
        width: 0,
        height: 0
    },
    constructor: function() {
        this.callParent(arguments);
        this.mixins.elementCt.constructor.call(this)
    },
    destroy: function() {
        this.callParent();
        this.mixins.elementCt.destroy.call(this)
    },
    initLayout: function() {
        var c = this,
            a = Ext.getScrollbarSize().width;
        c.callParent();
        if (a && c.manageOverflow && !c.hasOwnProperty("lastOverflowAdjust")) {
            if (c.owner.autoScroll || c.reserveScrollbar) {
                c.lastOverflowAdjust = {
                    width: a,
                    height: 0
                }
            }
        }
    },
    beginLayout: function(a) {
        this.callParent(arguments);
        a.targetContext = a.getEl("getTarget", this);
        this.cacheChildItems(a)
    },
    beginLayoutCycle: function(d, a) {
        var c = this,
            e = c.overflowPadderEl;
        c.callParent(arguments);
        if (!d.state.overflowAdjust) {
            d.state.overflowAdjust = c.lastOverflowAdjust
        }
        if (a) {
            if (c.usesContainerHeight) {
                ++d.consumersContainerHeight
            }
            if (c.usesContainerWidth) {
                ++d.consumersContainerWidth
            }
        }
        if (e) {
            e.setStyle("display", "none")
        }
    },
    completeLayout: function(a) {
        this.lastOverflowAdjust = a.state.overflowAdjust
    },
    cacheChildItems: function(g) {
        var d = g.context,
            j = [],
            a = this.getVisibleItems(),
            e = a.length,
            c;
        g.childItems = j;
        g.visibleItems = a;
        for (c = 0; c < e; ++c) {
            j.push(d.getCmp(a[c]))
        }
    },
    cacheElements: function() {
        var a = this.owner;
        this.applyChildEls(a.el, a.id)
    },
    calculateContentSize: function(s, o) {
        var E = this,
            e = (o || 0) | E.manageOverflow | ((s.widthModel.shrinkWrap ? 1 : 0) | (s.heightModel.shrinkWrap ? 2 : 0)),
            d = (e & 1) || undefined,
            l = (e & 2) || undefined,
            c = s.childItems,
            j = c.length,
            z = 0,
            x = 0,
            p = 0,
            g = s.props,
            t, r, q, D, k, n, v, C, B, u, A, a, y, m;
        if (d) {
            if (isNaN(g.contentWidth)) {
                ++p
            } else {
                d = undefined
            }
        }
        if (l) {
            if (isNaN(g.contentHeight)) {
                ++p
            } else {
                l = undefined
            }
        }
        if (p) {
            for (A = 0; A < j; ++A) {
                v = c[A];
                n = v.target;
                u = l && v.getProp("height");
                y = d && v.getProp("width");
                a = v.getMarginInfo();
                if ((d && isNaN(n.x)) || (l && isNaN(n.y))) {
                    m = n.el.getXY();
                    if (!t) {
                        t = s.targetContext.el.getXY();
                        k = s.targetContext.getBorderInfo();
                        r = t[0] + k.left;
                        q = t[1] + k.top
                    }
                    C = m[0] - r;
                    B = m[1] - q
                } else {
                    C = n.x;
                    B = n.y
                }
                u += a.bottom;
                y += a.right;
                z = Math.max(z, B + u);
                x = Math.max(x, C + y);
                if (isNaN(z) && isNaN(x)) {
                    E.done = false;
                    return
                }
            }
            if (d || l) {
                D = s.targetContext.getPaddingInfo()
            }
            if (d && !s.setContentWidth(x + D.right)) {
                E.done = false
            }
            if (l && !s.setContentHeight(z + D.bottom)) {
                E.done = false
            }
        }
    },
    calculateOverflow: function(p, u, j) {
        var z = this,
            a = z.owner,
            n = z.manageOverflow,
            e = p.state,
            o = e.overflowAdjust,
            i, m, d, q, c, s, v, l, t, g, r, x, k, y;
        if (n && !e.secondPass && !z.reserveScrollbar) {
            if (a.autoScroll) {
                k = y = true
            } else {
                if (a.overflowX) {
                    k = a.overflowX == "auto"
                } else {
                    s = p.targetContext.getStyle("overflow-x");
                    k = s && s != "hidden" && s != "scroll"
                }
                if (a.overflowY) {
                    y = a.overflowY == "auto"
                } else {
                    s = p.targetContext.getStyle("overflow-y");
                    y = s && s != "hidden" && s != "scroll"
                }
            }
            if (!u.gotWidth) {
                k = false
            }
            if (!u.gotHeight) {
                y = false
            }
            if (k || y) {
                v = Ext.getScrollbarSize();
                l = p.peek("contentWidth");
                t = p.peek("contentHeight");
                g = u.width;
                r = u.height;
                x = z.getScrollbarsNeeded(g, r, l, t);
                e.overflowState = x;
                if (typeof j == "number") {
                    x &= ~j
                }
                o = {
                    width: (k && (x & 2)) ? v.width : 0,
                    height: (y && (x & 1)) ? v.height : 0
                };
                if (o.width !== z.lastOverflowAdjust.width || o.height !== z.lastOverflowAdjust.height) {
                    z.done = false;
                    p.invalidate({
                        state: {
                            overflowAdjust: o,
                            overflowState: e.overflowState,
                            secondPass: true
                        }
                    })
                }
            }
        }
        if (!z.done) {
            return
        }
        d = p.padElContext || (p.padElContext = p.getEl("overflowPadderEl", z));
        if (d) {
            x = e.overflowState;
            i = u.width;
            m = 0;
            if (x) {
                q = p.targetContext.getPaddingInfo();
                c = z.scrollRangeFlags;
                if ((x & 2) && (c & 1)) {
                    m += q.bottom
                }
                if ((x & 1) && (c & 4)) {
                    i += q.right
                }
                d.setProp("display", "");
                d.setSize(i, m)
            } else {
                d.setProp("display", "none")
            }
        }
    },
    configureItem: function(d) {
        var c = this,
            a = c.owner.itemCls,
            e = [].concat(c.itemCls || []);
        c.callParent(arguments);
        if (a) {
            e = Ext.Array.push(e, a)
        }
        d.addCls(e)
    },
    doRenderBody: function(a, c) {
        this.renderItems(a, c);
        this.renderContent(a, c)
    },
    doRenderContainer: function(c, g) {
        var d = g.$comp.layout,
            a = d.getRenderTpl(),
            e = d.getRenderData();
        a.applyOut(e, c)
    },
    doRenderItems: function(c, e) {
        var d = e.$layout,
            a = d.getRenderTree();
        if (a) {
            Ext.DomHelper.generateMarkup(a, c)
        }
    },
    doRenderPadder: function(c, e) {
        var d = e.$layout,
            a = d.owner,
            g = d.getScrollRangeFlags();
        if (d.manageOverflow == 2) {
            if (g & 5) {
                c.push('<div id="', a.id, '-overflowPadderEl" ', 'style="font-size: 1px; width:1px; height: 1px;');
                c.push('"></div>');
                d.scrollRangeFlags = g
            }
        }
    },
    finishRender: function() {
        var c = this,
            d, a;
        c.callParent();
        c.cacheElements();
        d = c.getRenderTarget();
        a = c.getLayoutItems();
        if (c.targetCls) {
            c.getTarget().addCls(c.targetCls)
        }
        c.finishRenderItems(d, a)
    },
    notifyOwner: function() {
        this.owner.afterLayout(this)
    },
    getContainerSize: function(d, j) {
        var e = d.targetContext,
            i = e.getFrameInfo(),
            m = e.getPaddingInfo(),
            l = 0,
            n = 0,
            a = d.state.overflowAdjust,
            g, k, c, o;
        if (!d.widthModel.shrinkWrap) {
            ++n;
            c = j ? e.getDomProp("width") : e.getProp("width");
            g = (typeof c == "number");
            if (g) {
                ++l;
                c -= i.width + m.width;
                if (a) {
                    c -= a.width
                }
            }
        }
        if (!d.heightModel.shrinkWrap) {
            ++n;
            o = j ? e.getDomProp("height") : e.getProp("height");
            k = (typeof o == "number");
            if (k) {
                ++l;
                o -= i.height + m.height;
                if (a) {
                    o -= a.height
                }
            }
        }
        return {
            width: c,
            height: o,
            needed: n,
            got: l,
            gotAll: l == n,
            gotWidth: g,
            gotHeight: k
        }
    },
    getLayoutItems: function() {
        var a = this.owner,
            c = a && a.items;
        return (c && c.items) || []
    },
    getRenderData: function() {
        var a = this.owner;
        return {
            $comp: a,
            $layout: this,
            ownerId: a.id
        }
    },
    getRenderedItems: function() {
        var g = this,
            k = g.getRenderTarget(),
            a = g.getLayoutItems(),
            e = a.length,
            j = [],
            c, d;
        for (c = 0; c < e; c++) {
            d = a[c];
            if (d.rendered && g.isValidParent(d, k, c)) {
                j.push(d)
            }
        }
        return j
    },
    getRenderTarget: function() {
        return this.owner.getTargetEl()
    },
    getElementTarget: function() {
        return this.getRenderTarget()
    },
    getRenderTpl: function() {
        var a = this,
            c = Ext.XTemplate.getTpl(this, "renderTpl");
        if (!c.renderContent) {
            a.owner.setupRenderTpl(c)
        }
        return c
    },
    getRenderTree: function() {
        var a, d = this.owner.items,
            e, c = {};
        do {
            e = d.generation;
            a = this.getItemsRenderTree(this.getLayoutItems(), c)
        } while (d.generation !== e);
        return a
    },
    getScrollbarsNeeded: function(d, k, c, j) {
        var a = Ext.getScrollbarSize(),
            g = typeof d == "number",
            l = typeof k == "number",
            i = 0,
            e = 0;
        if (!a.width) {
            return 0
        }
        if (l && k < j) {
            e = 2;
            d -= a.width
        }
        if (g && d < c) {
            i = 1;
            if (!e && l) {
                k -= a.height;
                if (k < j) {
                    e = 2
                }
            }
        }
        return e + i
    },
    getScrollRangeFlags: (function() {
        var a = -1;
        return function() {
            if (a < 0) {
                var i = Ext.getBody().createChild({
                        cls: Ext.baseCSSPrefix + "border-box",
                        style: {
                            width: "100px",
                            height: "100px",
                            padding: "10px",
                            overflow: "auto"
                        },
                        children: [{
                            style: {
                                border: "1px solid red",
                                width: "150px",
                                height: "150px",
                                margin: "0 5px 5px 0"
                            }
                        }]
                    }),
                    e = i.dom.scrollHeight,
                    d = i.dom.scrollWidth,
                    g = {
                        175: 0,
                        165: 1,
                        170: 2,
                        160: 3
                    },
                    c = {
                        175: 0,
                        165: 4,
                        170: 8,
                        160: 12
                    };
                a = (g[e] || 0) | (c[d] || 0);
                i.remove()
            }
            return a
        }
    }()),
    getTarget: function() {
        return this.owner.getTargetEl()
    },
    getVisibleItems: function() {
        var j = this.getRenderTarget(),
            c = this.getLayoutItems(),
            g = c.length,
            a = [],
            d, e;
        for (d = 0; d < g; d++) {
            e = c[d];
            if (e.rendered && this.isValidParent(e, j, d) && e.hidden !== true) {
                a.push(e)
            }
        }
        return a
    },
    setupRenderTpl: function(c) {
        var a = this;
        c.renderBody = a.doRenderBody;
        c.renderContainer = a.doRenderContainer;
        c.renderItems = a.doRenderItems;
        c.renderPadder = a.doRenderPadder
    }
});
Ext.define("Ext.ComponentManager", {
    extend: "Ext.AbstractManager",
    alternateClassName: "Ext.ComponentMgr",
    singleton: true,
    typeName: "xtype",
    create: function(a, c) {
        if (typeof a == "string") {
            return Ext.widget(a)
        }
        if (a.isComponent) {
            return a
        }
        return Ext.widget(a.xtype || c, a)
    },
    registerType: function(c, a) {
        this.types[c] = a;
        a[this.typeName] = c;
        a.prototype[this.typeName] = c
    }
});
Ext.define("Ext.ComponentQuery", {
    singleton: true,
    requires: ["Ext.ComponentManager"]
}, function() {
    var j = this,
        m = ["var r = [],", "i = 0,", "it = items,", "l = it.length,", "c;", "for (; i < l; i++) {", "c = it[i];", "if (c.{0}) {", "r.push(c);", "}", "}", "return r;"].join(""),
        g = function(r, q) {
            return q.method.apply(this, [r].concat(q.args))
        },
        a = function(s, x) {
            var q = [],
                t = 0,
                v = s.length,
                u, r = x !== ">";
            for (; t < v; t++) {
                u = s[t];
                if (u.getRefItems) {
                    q = q.concat(u.getRefItems(r))
                }
            }
            return q
        },
        i = function(r) {
            var q = [],
                s = 0,
                u = r.length,
                t;
            for (; s < u; s++) {
                t = r[s];
                while (!!(t = (t.ownerCt || t.floatParent))) {
                    q.push(t)
                }
            }
            return q
        },
        o = function(r, x, v) {
            if (x === "*") {
                return r.slice()
            } else {
                var q = [],
                    s = 0,
                    u = r.length,
                    t;
                for (; s < u; s++) {
                    t = r[s];
                    if (t.isXType(x, v)) {
                        q.push(t)
                    }
                }
                return q
            }
        },
        l = function(r, u) {
            var x = Ext.Array,
                q = [],
                s = 0,
                v = r.length,
                t;
            for (; s < v; s++) {
                t = r[s];
                if (t.hasCls(u)) {
                    q.push(t)
                }
            }
            return q
        },
        p = function(s, y, r, x) {
            var q = [],
                t = 0,
                v = s.length,
                u;
            for (; t < v; t++) {
                u = s[t];
                if (!x ? !!u[y] : (String(u[y]) === x)) {
                    q.push(u)
                }
            }
            return q
        },
        e = function(r, v) {
            var q = [],
                s = 0,
                u = r.length,
                t;
            for (; s < u; s++) {
                t = r[s];
                if (t.getItemId() === v) {
                    q.push(t)
                }
            }
            return q
        },
        n = function(q, r, s) {
            return j.pseudos[r](q, s)
        },
        k = /^(\s?([>\^])\s?|\s|$)/,
        d = /^(#)?([\w\-]+|\*)(?:\((true|false)\))?/,
        c = [{
            re: /^\.([\w\-]+)(?:\((true|false)\))?/,
            method: o
        }, {
            re: /^(?:[\[](?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]])/,
            method: p
        }, {
            re: /^#([\w\-]+)/,
            method: e
        }, {
            re: /^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/,
            method: n
        }, {
            re: /^(?:\{([^\}]+)\})/,
            method: m
        }];
    j.Query = Ext.extend(Object, {
        constructor: function(q) {
            q = q || {};
            Ext.apply(this, q)
        },
        execute: function(r) {
            var t = this.operations,
                u = 0,
                v = t.length,
                s, q;
            if (!r) {
                q = Ext.ComponentManager.all.getArray()
            } else {
                if (Ext.isArray(r)) {
                    q = r
                } else {
                    if (r.isMixedCollection) {
                        q = r.items
                    }
                }
            }
            for (; u < v; u++) {
                s = t[u];
                if (s.mode === "^") {
                    q = i(q || [r])
                } else {
                    if (s.mode) {
                        q = a(q || [r], s.mode)
                    } else {
                        q = g(q || a([r]), s)
                    }
                }
                if (u === v - 1) {
                    return q
                }
            }
            return []
        },
        is: function(s) {
            var r = this.operations,
                v = Ext.isArray(s) ? s : [s],
                q = v.length,
                x = r[r.length - 1],
                u, t;
            v = g(v, x);
            if (v.length === q) {
                if (r.length > 1) {
                    for (t = 0, u = v.length; t < u; t++) {
                        if (Ext.Array.indexOf(this.execute(), v[t]) === -1) {
                            return false
                        }
                    }
                }
                return true
            }
            return false
        }
    });
    Ext.apply(this, {
        cache: {},
        pseudos: {
            not: function(x, q) {
                var y = Ext.ComponentQuery,
                    u = 0,
                    v = x.length,
                    t = [],
                    s = -1,
                    r;
                for (; u < v; ++u) {
                    r = x[u];
                    if (!y.is(r, q)) {
                        t[++s] = r
                    }
                }
                return t
            },
            first: function(r) {
                var q = [];
                if (r.length > 0) {
                    q.push(r[0])
                }
                return q
            },
            last: function(s) {
                var q = s.length,
                    r = [];
                if (q > 0) {
                    r.push(s[q - 1])
                }
                return r
            }
        },
        query: function(r, z) {
            var A = r.split(","),
                q = A.length,
                s = 0,
                t = [],
                B = [],
                y = {},
                v, u, x;
            for (; s < q; s++) {
                r = Ext.String.trim(A[s]);
                v = this.cache[r] || (this.cache[r] = this.parse(r));
                t = t.concat(v.execute(z))
            }
            if (q > 1) {
                u = t.length;
                for (s = 0; s < u; s++) {
                    x = t[s];
                    if (!y[x.id]) {
                        B.push(x);
                        y[x.id] = true
                    }
                }
                t = B
            }
            return t
        },
        is: function(r, q) {
            if (!q) {
                return true
            }
            var t = q.split(","),
                u = t.length,
                s = 0,
                v;
            for (; s < u; s++) {
                q = Ext.String.trim(t[s]);
                v = this.cache[q] || (this.cache[q] = this.parse(q));
                if (v.is(r)) {
                    return true
                }
            }
            return false
        },
        parse: function(t) {
            var r = [],
                s = c.length,
                y, u, z, A, B, v, x, q;
            while (t && y !== t) {
                y = t;
                u = t.match(d);
                if (u) {
                    z = u[1];
                    if (z === "#") {
                        r.push({
                            method: e,
                            args: [Ext.String.trim(u[2])]
                        })
                    } else {
                        if (z === ".") {
                            r.push({
                                method: l,
                                args: [Ext.String.trim(u[2])]
                            })
                        } else {
                            r.push({
                                method: o,
                                args: [Ext.String.trim(u[2]), Boolean(u[3])]
                            })
                        }
                    }
                    t = t.replace(u[0], "")
                }
                while (!(A = t.match(k))) {
                    for (v = 0; t && v < s; v++) {
                        x = c[v];
                        B = t.match(x.re);
                        q = x.method;
                        if (B) {
                            r.push({
                                method: Ext.isString(x.method) ? Ext.functionFactory("items", Ext.String.format.apply(Ext.String, [q].concat(B.slice(1)))) : x.method,
                                args: B.slice(1)
                            });
                            t = t.replace(B[0], "");
                            break
                        }
                        if (v === (s - 1)) {
                            Ext.Error.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"')
                        }
                    }
                }
                if (A[1]) {
                    r.push({
                        mode: A[2] || A[1]
                    });
                    t = t.replace(A[0], "")
                }
            }
            return new j.Query({
                operations: r
            })
        }
    })
});
Ext.define("Ext.util.ProtoElement", (function() {
    var c = Ext.String.splitWords,
        a = Ext.Array.toMap;
    return {
        isProtoEl: true,
        clsProp: "cls",
        styleProp: "style",
        removedProp: "removed",
        styleIsText: false,
        constructor: function(d) {
            var e = this;
            Ext.apply(e, d);
            e.classList = c(e.cls);
            e.classMap = a(e.classList);
            delete e.cls;
            if (Ext.isFunction(e.style)) {
                e.styleFn = e.style;
                delete e.style
            } else {
                if (typeof e.style == "string") {
                    e.style = Ext.Element.parseStyles(e.style)
                } else {
                    if (e.style) {
                        e.style = Ext.apply({}, e.style)
                    }
                }
            }
        },
        flush: function() {
            this.flushClassList = [];
            this.removedClasses = {};
            delete this.style
        },
        addCls: function(o) {
            var m = this,
                n = c(o),
                e = n.length,
                k = m.classList,
                d = m.classMap,
                g = m.flushClassList,
                j = 0,
                l;
            for (; j < e; ++j) {
                l = n[j];
                if (!d[l]) {
                    d[l] = true;
                    k.push(l);
                    if (g) {
                        g.push(l);
                        delete m.removedClasses[l]
                    }
                }
            }
            return m
        },
        hasCls: function(d) {
            return d in this.classMap
        },
        removeCls: function(p) {
            var o = this,
                m = o.classList,
                g = (o.classList = []),
                k = a(c(p)),
                e = m.length,
                d = o.classMap,
                l = o.removedClasses,
                j, n;
            for (j = 0; j < e; ++j) {
                n = m[j];
                if (k[n]) {
                    if (l) {
                        if (d[n]) {
                            l[n] = true;
                            Ext.Array.remove(o.flushClassList, n)
                        }
                    }
                    delete d[n]
                } else {
                    g.push(n)
                }
            }
            return o
        },
        setStyle: function(i, g) {
            var e = this,
                d = e.style || (e.style = {});
            if (typeof i == "string") {
                if (arguments.length === 1) {
                    e.setStyle(Ext.Element.parseStyles(i))
                } else {
                    d[i] = g
                }
            } else {
                Ext.apply(d, i)
            }
            return e
        },
        writeTo: function(j) {
            var g = this,
                i = g.flushClassList || g.classList,
                e = g.removedClasses,
                d;
            if (g.styleFn) {
                d = Ext.apply({}, g.styleFn());
                Ext.apply(d, g.style)
            } else {
                d = g.style
            }
            j[g.clsProp] = i.join(" ");
            if (d) {
                j[g.styleProp] = g.styleIsText ? Ext.DomHelper.generateStyles(d) : d
            }
            if (e) {
                e = Ext.Object.getKeys(e);
                if (e.length) {
                    j[g.removedProp] = e.join(" ")
                }
            }
            return j
        }
    }
}()));
Ext.define("Ext.util.Animate", {
    requires: ["Ext.Element", "Ext.CompositeElementLite"],
    uses: ["Ext.fx.Manager", "Ext.fx.Anim"],
    animate: function(a) {
        var c = this;
        if (Ext.fx.Manager.hasFxBlock(c.id)) {
            return c
        }
        Ext.fx.Manager.queueFx(new Ext.fx.Anim(c.anim(a)));
        return this
    },
    anim: function(a) {
        if (!Ext.isObject(a)) {
            return (a) ? {} : false
        }
        var c = this;
        if (a.stopAnimation) {
            c.stopAnimation()
        }
        Ext.applyIf(a, Ext.fx.Manager.getFxDefaults(c.id));
        return Ext.apply({
            target: c,
            paused: true
        }, a)
    },
    stopFx: Ext.Function.alias(Ext.util.Animate, "stopAnimation"),
    stopAnimation: function() {
        Ext.fx.Manager.stopAnimation(this.id);
        return this
    },
    syncFx: function() {
        Ext.fx.Manager.setFxDefaults(this.id, {
            concurrent: true
        });
        return this
    },
    sequenceFx: function() {
        Ext.fx.Manager.setFxDefaults(this.id, {
            concurrent: false
        });
        return this
    },
    hasActiveFx: Ext.Function.alias(Ext.util.Animate, "getActiveAnimation"),
    getActiveAnimation: function() {
        return Ext.fx.Manager.getActiveAnimation(this.id)
    }
}, function() {
    Ext.applyIf(Ext.Element.prototype, this.prototype);
    Ext.CompositeElementLite.importElementMethods()
});
Ext.define("Ext.util.Renderable", {
    requires: ["Ext.dom.Element"],
    frameCls: Ext.baseCSSPrefix + "frame",
    frameIdRegex: /[\-]frame\d+[TMB][LCR]$/,
    frameElementCls: {
        tl: [],
        tc: [],
        tr: [],
        ml: [],
        mc: [],
        mr: [],
        bl: [],
        bc: [],
        br: []
    },
    frameElNames: ["TL", "TC", "TR", "ML", "MC", "MR", "BL", "BC", "BR"],
    frameTpl: ["{%this.renderDockedItems(out,values,0);%}", '<tpl if="top">', '<tpl if="left"><div id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>" style="background-position: {tl}; padding-left: {frameWidth}px" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>" style="background-position: {tr}; padding-right: {frameWidth}px" role="presentation"></tpl>', '<div id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>" style="background-position: {tc}; height: {frameWidth}px" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', "</tpl>", '<tpl if="left"><div id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>" style="background-position: {ml}; padding-left: {frameWidth}px" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>" style="background-position: {mr}; padding-right: {frameWidth}px" role="presentation"></tpl>', '<div id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>" role="presentation">', "{%this.applyRenderTpl(out, values)%}", "</div>", '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', '<tpl if="bottom">', '<tpl if="left"><div id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>" style="background-position: {bl}; padding-left: {frameWidth}px" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>" style="background-position: {br}; padding-right: {frameWidth}px" role="presentation"></tpl>', '<div id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>" style="background-position: {bc}; height: {frameWidth}px" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', "</tpl>", "{%this.renderDockedItems(out,values,1);%}"],
    frameTableTpl: ["{%this.renderDockedItems(out,values,0);%}", "<table><tbody>", '<tpl if="top">', "<tr>", '<tpl if="left"><td id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>" style="background-position: {tl}; padding-left:{frameWidth}px" role="presentation"></td></tpl>', '<td id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>" style="background-position: {tc}; height: {frameWidth}px" role="presentation"></td>', '<tpl if="right"><td id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>" style="background-position: {tr}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', "</tr>", "</tpl>", "<tr>", '<tpl if="left"><td id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>" style="background-position: {ml}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', '<td id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>" style="background-position: 0 0;" role="presentation">', "{%this.applyRenderTpl(out, values)%}", "</td>", '<tpl if="right"><td id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>" style="background-position: {mr}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', "</tr>", '<tpl if="bottom">', "<tr>", '<tpl if="left"><td id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>" style="background-position: {bl}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', '<td id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>" style="background-position: {bc}; height: {frameWidth}px" role="presentation"></td>', '<tpl if="right"><td id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>" style="background-position: {br}; padding-left: {frameWidth}px" role="presentation"></td></tpl>', "</tr>", "</tpl>", "</tbody></table>", "{%this.renderDockedItems(out,values,1);%}"],
    afterRender: function() {
        var c = this,
            d = {},
            g = c.protoEl,
            e = c.getTargetEl(),
            a;
        c.finishRenderChildren();
        if (c.styleHtmlContent) {
            e.addCls(c.styleHtmlCls)
        }
        g.writeTo(d);
        a = d.removed;
        if (a) {
            e.removeCls(a)
        }
        a = d.cls;
        if (a.length) {
            e.addCls(a)
        }
        a = d.style;
        if (d.style) {
            e.setStyle(a)
        }
        c.protoEl = null;
        if (!c.ownerCt) {
            c.updateLayout()
        }
    },
    afterFirstLayout: function(e, a) {
        var g = this,
            d = Ext.isDefined(g.x),
            c = Ext.isDefined(g.y),
            j, i;
        if (g.floating && (!d || !c)) {
            if (g.floatParent) {
                j = g.floatParent.getTargetEl().getViewRegion();
                i = g.el.getAlignToXY(g.floatParent.getTargetEl(), "c-c");
                j.left = i[0] - j.left;
                j.top = i[1] - j.top
            } else {
                i = g.el.getAlignToXY(g.container, "c-c");
                j = g.container.translatePoints(i[0], i[1])
            }
            g.x = d ? g.x : j.left;
            g.y = c ? g.y : j.top;
            d = c = true
        }
        if (d || c) {
            g.setPosition(g.x, g.y)
        }
        g.onBoxReady(e, a);
        if (g.hasListeners.boxready) {
            g.fireEvent("boxready", g, e, a)
        }
    },
    onBoxReady: Ext.emptyFn,
    applyRenderSelectors: function() {
        var e = this,
            c = e.renderSelectors,
            d = e.el,
            g = d.dom,
            a;
        e.applyChildEls(d);
        if (c) {
            for (a in c) {
                if (c.hasOwnProperty(a) && c[a]) {
                    e[a] = Ext.get(Ext.DomQuery.selectNode(c[a], g))
                }
            }
        }
    },
    beforeRender: function() {
        var c = this,
            d = c.getTargetEl(),
            a = c.getComponentLayout();
        c.frame = c.frame || c.alwaysFramed;
        if (!a.initialized) {
            a.initLayout()
        }
        if (d) {
            d.setStyle(c.getOverflowStyle());
            c.overflowStyleSet = true
        }
        c.setUI(c.ui);
        if (c.disabled) {
            c.disable(true)
        }
    },
    doApplyRenderTpl: function(d, a) {
        var e = a.$comp,
            c;
        if (!e.rendered) {
            c = e.initRenderTpl();
            c.applyOut(a.renderData, d)
        }
    },
    doAutoRender: function() {
        var a = this;
        if (!a.rendered) {
            if (a.floating) {
                a.render(document.body)
            } else {
                a.render(Ext.isBoolean(a.autoRender) ? Ext.getBody() : a.autoRender)
            }
        }
    },
    doRenderContent: function(a, d) {
        var c = d.$comp;
        if (c.html) {
            Ext.DomHelper.generateMarkup(c.html, a);
            delete c.html
        }
        if (c.tpl) {
            if (!c.tpl.isTemplate) {
                c.tpl = new Ext.XTemplate(c.tpl)
            }
            if (c.data) {
                c.tpl.applyOut(c.data, a);
                delete c.data
            }
        }
    },
    doRenderFramingDockedItems: function(a, d, e) {
        var c = d.$comp;
        if (!c.rendered && c.doRenderDockedItems) {
            d.renderData.$skipDockedItems = true;
            c.doRenderDockedItems.call(this, a, d, e)
        }
    },
    finishRender: function(a) {
        var i = this,
            c, j, g, e, k, d;
        if (!i.el || i.$pid) {
            if (i.container) {
                e = i.container.getById(i.id, true)
            } else {
                e = Ext.getDom(i.id)
            }
            if (!i.el) {
                i.wrapPrimaryEl(e)
            } else {
                delete i.$pid;
                if (!i.el.dom) {
                    i.wrapPrimaryEl(i.el)
                }
                e.parentNode.insertBefore(i.el.dom, e);
                Ext.removeNode(e)
            }
        } else {
            if (!i.rendering) {
                c = i.initRenderTpl();
                if (c) {
                    j = i.initRenderData();
                    c.insertFirst(i.getTargetEl(), j)
                }
            }
        }
        if (!i.container) {
            i.container = Ext.get(i.el.dom.parentNode)
        }
        if (i.ctCls) {
            i.container.addCls(i.ctCls)
        }
        i.onRender(i.container, a);
        if (!i.overflowStyleSet) {
            i.getTargetEl().setStyle(i.getOverflowStyle())
        }
        i.el.setVisibilityMode(Ext.Element[i.hideMode.toUpperCase()]);
        if (i.overCls) {
            i.el.hover(i.addOverCls, i.removeOverCls, i)
        }
        if (i.hasListeners.render) {
            i.fireEvent("render", i)
        }
        if (i.contentEl) {
            k = Ext.baseCSSPrefix;
            d = k + "hide-";
            g = Ext.get(i.contentEl);
            g.removeCls([k + "hidden", d + "display", d + "offsets", d + "nosize"]);
            i.getTargetEl().appendChild(g.dom)
        }
        i.afterRender();
        if (i.hasListeners.afterrender) {
            i.fireEvent("afterrender", i)
        }
        i.initEvents();
        if (i.hidden) {
            i.el.hide()
        }
    },
    finishRenderChildren: function() {
        var a = this.getComponentLayout();
        a.finishRender()
    },
    getElConfig: function() {
        var k = this,
            l = k.autoEl,
            g = k.getFrameInfo(),
            a = {
                tag: "div",
                tpl: g ? k.initFramingTpl(g.table) : k.initRenderTpl()
            },
            c, e, j, m, d;
        k.initStyles(k.protoEl);
        k.protoEl.writeTo(a);
        k.protoEl.flush();
        if (Ext.isString(l)) {
            a.tag = l
        } else {
            Ext.apply(a, l)
        }
        a.id = k.id;
        if (a.tpl) {
            if (g) {
                e = k.frameElNames;
                j = e.length;
                d = k.id + "-frame1";
                k.frameGenId = 1;
                a.tplData = Ext.apply({}, {
                    $comp: k,
                    fgid: d,
                    ui: k.ui,
                    uiCls: k.uiCls,
                    frameCls: k.frameCls,
                    baseCls: k.baseCls,
                    frameWidth: g.maxWidth,
                    top: !!g.top,
                    left: !!g.left,
                    right: !!g.right,
                    bottom: !!g.bottom,
                    renderData: k.initRenderData()
                }, k.getFramePositions(g));
                for (c = 0; c < j; c++) {
                    m = e[c];
                    k.addChildEls({
                        name: "frame" + m,
                        id: d + m
                    })
                }
                k.addChildEls({
                    name: "frameBody",
                    id: d + "MC"
                })
            } else {
                a.tplData = k.initRenderData()
            }
        }
        return a
    },
    initFramingTpl: function(c) {
        var a = c ? this.getTpl("frameTableTpl") : this.getTpl("frameTpl");
        if (a && !a.applyRenderTpl) {
            this.setupFramingTpl(a)
        }
        return a
    },
    setupFramingTpl: function(a) {
        a.applyRenderTpl = this.doApplyRenderTpl;
        a.renderDockedItems = this.doRenderFramingDockedItems
    },
    getInsertPosition: function(a) {
        if (a !== undefined) {
            if (Ext.isNumber(a)) {
                a = this.container.dom.childNodes[a]
            } else {
                a = Ext.getDom(a)
            }
        }
        return a
    },
    getRenderTree: function() {
        var a = this;
        if (!a.hasListeners.beforerender || a.fireEvent("beforerender", a) !== false) {
            a.beforeRender();
            a.rendering = true;
            if (a.el) {
                return {
                    tag: "div",
                    id: (a.$pid = Ext.id())
                }
            }
            return a.getElConfig()
        }
        return null
    },
    initContainer: function(a) {
        var c = this;
        if (!a && c.el) {
            a = c.el.dom.parentNode;
            c.allowDomMove = false
        }
        c.container = a.dom ? a : Ext.get(a);
        return c.container
    },
    initRenderData: function() {
        var a = this;
        return Ext.apply({
            $comp: a,
            id: a.id,
            ui: a.ui,
            uiCls: a.uiCls,
            baseCls: a.baseCls,
            componentCls: a.componentCls,
            frame: a.frame
        }, a.renderData)
    },
    initRenderTpl: function() {
        var a = this.getTpl("renderTpl");
        if (a && !a.renderContent) {
            this.setupRenderTpl(a)
        }
        return a
    },
    onRender: function(e, g) {
        var j = this,
            l = j.x,
            k = j.y,
            d, a, m, c = j.el,
            i = Ext.getBody().dom;
        if (Ext.scopeResetCSS && !j.ownerCt) {
            if (c.dom === i) {
                c.parent().addCls(Ext.resetCls)
            } else {
                if (j.floating && j.el.dom.parentNode === i) {
                    Ext.resetElement.appendChild(j.el)
                } else {
                    j.resetEl = c.wrap(Ext.resetElementSpec, false, Ext.supports.CSS3LinearGradient ? undefined : "*")
                }
            }
        }
        j.applyRenderSelectors();
        delete j.rendering;
        j.rendered = true;
        d = null;
        if (l !== undefined) {
            d = d || {};
            d.x = l
        }
        if (k !== undefined) {
            d = d || {};
            d.y = k
        }
        if (!j.getFrameInfo() && Ext.isBorderBox) {
            a = j.width;
            m = j.height;
            if (typeof a == "number") {
                d = d || {};
                d.width = a
            }
            if (typeof m == "number") {
                d = d || {};
                d.height = m
            }
        }
        j.lastBox = j.el.lastBox = d
    },
    render: function(d, c) {
        var g = this,
            e = g.el && (g.el = Ext.get(g.el)),
            j, a, i;
        Ext.suspendLayouts();
        d = g.initContainer(d);
        i = g.getInsertPosition(c);
        if (!e) {
            a = g.getRenderTree();
            if (g.ownerLayout && g.ownerLayout.transformItemRenderTree) {
                a = g.ownerLayout.transformItemRenderTree(a)
            }
            if (a) {
                if (i) {
                    e = Ext.DomHelper.insertBefore(i, a)
                } else {
                    e = Ext.DomHelper.append(d, a)
                }
                g.wrapPrimaryEl(e)
            }
        } else {
            if (!g.hasListeners.beforerender || g.fireEvent("beforerender", g) !== false) {
                g.initStyles(e);
                if (g.allowDomMove !== false) {
                    if (i) {
                        d.dom.insertBefore(e.dom, i)
                    } else {
                        d.dom.appendChild(e.dom)
                    }
                }
            } else {
                j = true
            }
        }
        if (e && !j) {
            g.finishRender(c)
        }
        Ext.resumeLayouts(!d.isDetachedBody)
    },
    ensureAttachedToBody: function(d) {
        var c = this,
            a;
        while (c.ownerCt) {
            c = c.ownerCt
        }
        if (c.container.isDetachedBody) {
            c.container = a = Ext.resetElement;
            a.appendChild(c.el.dom);
            if (d) {
                c.updateLayout()
            }
            if (typeof c.x == "number" || typeof c.y == "number") {
                c.setPosition(c.x, c.y)
            }
        }
    },
    setupRenderTpl: function(a) {
        a.renderBody = a.renderContent = this.doRenderContent
    },
    wrapPrimaryEl: function(a) {
        this.el = Ext.get(a, true)
    },
    initFrame: function() {
        if (Ext.supports.CSS3BorderRadius || !this.frame) {
            return
        }
        var k = this,
            g = k.getFrameInfo(),
            l, a, d, c, e = k.frameElNames,
            j = e.length,
            m;
        if (g) {
            l = g.maxWidth;
            a = k.getFrameTpl(g.table);
            k.frameGenId = d = (k.frameGenId || 0) + 1;
            d = k.id + "-frame" + d;
            a.insertFirst(k.el, Ext.apply({
                $comp: k,
                fgid: d,
                ui: k.ui,
                uiCls: k.uiCls,
                frameCls: k.frameCls,
                baseCls: k.baseCls,
                frameWidth: l,
                top: !!g.top,
                left: !!g.left,
                right: !!g.right,
                bottom: !!g.bottom
            }, k.getFramePositions(g)));
            k.frameBody = k.el.down("." + k.frameCls + "-mc");
            k.removeChildEls(function(i) {
                return i.id && k.frameIdRegex.test(i.id)
            });
            for (c = 0; c < j; c++) {
                m = e[c];
                k["frame" + m] = k.el.getById(d + m)
            }
        }
    },
    updateFrame: function() {
        if (Ext.supports.CSS3BorderRadius || !this.frame) {
            return
        }
        var g = this,
            j = this.frameSize && this.frameSize.table,
            i = this.frameTL,
            e = this.frameBL,
            d = this.frameML,
            a = this.frameMC,
            c;
        this.initFrame();
        if (a) {
            if (g.frame) {
                c = this.frameMC.dom.className;
                a.insertAfter(this.frameMC);
                this.frameMC.remove();
                this.frameBody = this.frameMC = a;
                a.dom.className = c;
                if (j) {
                    g.el.query("> table")[1].remove()
                } else {
                    if (i) {
                        i.remove()
                    }
                    if (e) {
                        e.remove()
                    }
                    if (d) {
                        d.remove()
                    }
                }
            }
        } else {
            if (g.frame) {
                this.applyRenderSelectors()
            }
        }
    },
    getFrameInfo: function() {
        if (Ext.supports.CSS3BorderRadius || !this.frame) {
            return false
        }
        var i = this,
            k = i.frameInfoCache,
            a = i.el || i.protoEl,
            l = a.dom ? a.dom.className : a.classList.join(" "),
            e = k[l],
            g, d, j, c;
        if (e == null) {
            g = Ext.fly(i.getStyleProxy(l), "frame-style-el");
            d = g.getStyle("background-position-x");
            j = g.getStyle("background-position-y");
            if (!d && !j) {
                c = g.getStyle("background-position").split(" ");
                d = c[0];
                j = c[1]
            }
            e = i.calculateFrame(d, j);
            if (e) {
                a.setStyle("background-image", "none")
            }
            k[l] = e
        }
        i.frame = !!e;
        i.frameSize = e;
        return e
    },
    calculateFrame: function(j, i) {
        if (!(parseInt(j, 10) >= 1000000 && parseInt(i, 10) >= 1000000)) {
            return false
        }
        var a = Math.max,
            c = parseInt(j.substr(3, 2), 10),
            g = parseInt(j.substr(5, 2), 10),
            d = parseInt(i.substr(3, 2), 10),
            k = parseInt(i.substr(5, 2), 10),
            e = {
                table: j.substr(0, 3) == "110",
                vertical: i.substr(0, 3) == "110",
                top: a(c, g),
                right: a(g, d),
                bottom: a(k, d),
                left: a(c, k)
            };
        e.maxWidth = a(e.top, e.right, e.bottom, e.left);
        e.width = e.left + e.right;
        e.height = e.top + e.bottom;
        return e
    },
    getStyleProxy: function(c) {
        var a = this.styleProxyEl || (Ext.AbstractComponent.prototype.styleProxyEl = Ext.resetElement.createChild({
            style: {
                position: "absolute",
                top: "-10000px"
            }
        }, null, true));
        a.className = c;
        return a
    },
    getFramePositions: function(g) {
        var j = this,
            k = g.maxWidth,
            l = j.dock,
            e, c, i, d, a;
        if (g.vertical) {
            c = "0 -" + (k * 0) + "px";
            i = "0 -" + (k * 1) + "px";
            if (l && l == "right") {
                c = "right -" + (k * 0) + "px";
                i = "right -" + (k * 1) + "px"
            }
            e = {
                tl: "0 -" + (k * 0) + "px",
                tr: "0 -" + (k * 1) + "px",
                bl: "0 -" + (k * 2) + "px",
                br: "0 -" + (k * 3) + "px",
                ml: "-" + (k * 1) + "px 0",
                mr: "right 0",
                tc: c,
                bc: i
            }
        } else {
            d = "-" + (k * 0) + "px 0";
            a = "right 0";
            if (l && l == "bottom") {
                d = "left bottom";
                a = "right bottom"
            }
            e = {
                tl: "0 -" + (k * 2) + "px",
                tr: "right -" + (k * 3) + "px",
                bl: "0 -" + (k * 4) + "px",
                br: "right -" + (k * 5) + "px",
                ml: d,
                mr: a,
                tc: "0 -" + (k * 0) + "px",
                bc: "0 -" + (k * 1) + "px"
            }
        }
        return e
    },
    getFrameTpl: function(a) {
        return this.getTpl(a ? "frameTableTpl" : "frameTpl")
    },
    frameInfoCache: {}
});
Ext.define("Ext.state.Provider", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    prefix: "ext-",
    constructor: function(a) {
        a = a || {};
        var c = this;
        Ext.apply(c, a);
        c.addEvents("statechange");
        c.state = {};
        c.mixins.observable.constructor.call(c)
    },
    get: function(c, a) {
        return typeof this.state[c] == "undefined" ? a : this.state[c]
    },
    clear: function(a) {
        var c = this;
        delete c.state[a];
        c.fireEvent("statechange", c, a, null)
    },
    set: function(a, d) {
        var c = this;
        c.state[a] = d;
        c.fireEvent("statechange", c, a, d)
    },
    decodeValue: function(i) {
        var d = this,
            m = /^(a|n|d|b|s|o|e)\:(.*)$/,
            c = m.exec(unescape(i)),
            j, e, a, l, g, k;
        if (!c || !c[1]) {
            return
        }
        e = c[1];
        i = c[2];
        switch (e) {
            case "e":
                return null;
            case "n":
                return parseFloat(i);
            case "d":
                return new Date(Date.parse(i));
            case "b":
                return (i == "1");
            case "a":
                j = [];
                if (i != "") {
                    l = i.split("^");
                    g = l.length;
                    for (k = 0; k < g; k++) {
                        i = l[k];
                        j.push(d.decodeValue(i))
                    }
                }
                return j;
            case "o":
                j = {};
                if (i != "") {
                    l = i.split("^");
                    g = l.length;
                    for (k = 0; k < g; k++) {
                        i = l[k];
                        a = i.split("=");
                        j[a[0]] = d.decodeValue(a[1])
                    }
                }
                return j;
            default:
                return i
        }
    },
    encodeValue: function(g) {
        var j = "",
            e = 0,
            c, a, d;
        if (g == null) {
            return "e:1"
        } else {
            if (typeof g == "number") {
                c = "n:" + g
            } else {
                if (typeof g == "boolean") {
                    c = "b:" + (g ? "1" : "0")
                } else {
                    if (Ext.isDate(g)) {
                        c = "d:" + g.toGMTString()
                    } else {
                        if (Ext.isArray(g)) {
                            for (a = g.length; e < a; e++) {
                                j += this.encodeValue(g[e]);
                                if (e != a - 1) {
                                    j += "^"
                                }
                            }
                            c = "a:" + j
                        } else {
                            if (typeof g == "object") {
                                for (d in g) {
                                    if (typeof g[d] != "function" && g[d] !== undefined) {
                                        j += d + "=" + this.encodeValue(g[d]) + "^"
                                    }
                                }
                                c = "o:" + j.substring(0, j.length - 1)
                            } else {
                                c = "s:" + g
                            }
                        }
                    }
                }
            }
        }
        return escape(c)
    }
});
Ext.define("Ext.state.Manager", {
    singleton: true,
    requires: ["Ext.state.Provider"],
    constructor: function() {
        this.provider = new Ext.state.Provider()
    },
    setProvider: function(a) {
        this.provider = a
    },
    get: function(c, a) {
        return this.provider.get(c, a)
    },
    set: function(a, c) {
        this.provider.set(a, c)
    },
    clear: function(a) {
        this.provider.clear(a)
    },
    getProvider: function() {
        return this.provider
    }
});
Ext.define("Ext.state.Stateful", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.state.Manager"],
    stateful: false,
    saveDelay: 100,
    constructor: function(a) {
        var c = this;
        a = a || {};
        if (a.stateful !== undefined) {
            c.stateful = a.stateful
        }
        if (a.saveDelay !== undefined) {
            c.saveDelay = a.saveDelay
        }
        c.stateId = c.stateId || a.stateId;
        if (!c.stateEvents) {
            c.stateEvents = []
        }
        if (a.stateEvents) {
            c.stateEvents.concat(a.stateEvents)
        }
        this.addEvents("beforestaterestore", "staterestore", "beforestatesave", "statesave");
        c.mixins.observable.constructor.call(c);
        if (c.stateful !== false) {
            c.addStateEvents(c.stateEvents);
            c.initState()
        }
    },
    addStateEvents: function(d) {
        var g = this,
            c, e, a;
        if (g.stateful && g.getStateId()) {
            if (typeof d == "string") {
                d = Array.prototype.slice.call(arguments, 0)
            }
            a = g.stateEventsByName || (g.stateEventsByName = {});
            for (c = d.length; c--;) {
                e = d[c];
                if (!a[e]) {
                    a[e] = 1;
                    g.on(e, g.onStateChange, g)
                }
            }
        }
    },
    onStateChange: function() {
        var d = this,
            a = d.saveDelay,
            e, c;
        if (!d.stateful) {
            return
        }
        if (a) {
            if (!d.stateTask) {
                e = Ext.state.Stateful;
                c = e.runner || (e.runner = new Ext.util.TaskRunner());
                d.stateTask = c.newTask({
                    run: d.saveState,
                    scope: d,
                    interval: a,
                    repeat: 1
                })
            }
            d.stateTask.start()
        } else {
            d.saveState()
        }
    },
    saveState: function() {
        var c = this,
            e = c.stateful && c.getStateId(),
            a = c.hasListeners,
            d;
        if (e) {
            d = c.getState() || {};
            if (!a.beforestatesave || c.fireEvent("beforestatesave", c, d) !== false) {
                Ext.state.Manager.set(e, d);
                if (a.statesave) {
                    c.fireEvent("statesave", c, d)
                }
            }
        }
    },
    getState: function() {
        return null
    },
    applyState: function(a) {
        if (a) {
            Ext.apply(this, a)
        }
    },
    getStateId: function() {
        var a = this;
        return a.stateId || (a.autoGenId ? null : a.id)
    },
    initState: function() {
        var c = this,
            e = c.stateful && c.getStateId(),
            a = c.hasListeners,
            d;
        if (e) {
            d = Ext.state.Manager.get(e);
            if (d) {
                d = Ext.apply({}, d);
                if (!a.beforestaterestore || c.fireEvent("beforestaterestore", c, d) !== false) {
                    c.applyState(d);
                    if (a.staterestore) {
                        c.fireEvent("staterestore", c, d)
                    }
                }
            }
        }
    },
    savePropToState: function(i, g, e) {
        var c = this,
            d = c[i],
            a = c.initialConfig;
        if (c.hasOwnProperty(i)) {
            if (!a || a[i] !== d) {
                if (g) {
                    g[e || i] = d
                }
                return true
            }
        }
        return false
    },
    savePropsToState: function(g, d) {
        var c = this,
            a, e;
        if (typeof g == "string") {
            c.savePropToState(g, d)
        } else {
            for (a = 0, e = g.length; a < e; ++a) {
                c.savePropToState(g[a], d)
            }
        }
        return d
    },
    destroy: function() {
        var c = this,
            a = c.stateTask;
        if (a) {
            a.destroy();
            c.stateTask = null
        }
        c.clearListeners()
    }
});
Ext.define("Ext.AbstractComponent", {
    requires: ["Ext.ComponentQuery", "Ext.ComponentManager", "Ext.util.ProtoElement"],
    mixins: {
        observable: "Ext.util.Observable",
        animate: "Ext.util.Animate",
        elementCt: "Ext.util.ElementContainer",
        renderable: "Ext.util.Renderable",
        state: "Ext.state.Stateful"
    },
    uses: ["Ext.PluginManager", "Ext.Element", "Ext.DomHelper", "Ext.XTemplate", "Ext.ComponentQuery", "Ext.ComponentLoader", "Ext.EventManager", "Ext.layout.Context", "Ext.layout.Layout", "Ext.layout.component.Auto", "Ext.LoadMask", "Ext.ZIndexManager"],
    statics: {
        AUTO_ID: 1000,
        pendingLayouts: null,
        layoutSuspendCount: 0,
        cancelLayout: function(a, d) {
            var c = this.runningLayoutContext || this.pendingLayouts;
            if (c) {
                c.cancelComponent(a, false, d)
            }
        },
        flushLayouts: function() {
            var c = this,
                a = c.pendingLayouts;
            if (a && a.invalidQueue.length) {
                c.pendingLayouts = null;
                c.runningLayoutContext = a;
                Ext.override(a, {
                    runComplete: function() {
                        c.runningLayoutContext = null;
                        return this.callParent()
                    }
                });
                a.run()
            }
        },
        resumeLayouts: function(a) {
            if (this.layoutSuspendCount && !--this.layoutSuspendCount) {
                if (a) {
                    this.flushLayouts()
                }
            }
        },
        suspendLayouts: function() {
            ++this.layoutSuspendCount
        },
        updateLayout: function(c, g) {
            var d = this,
                a = d.runningLayoutContext,
                e;
            if (a) {
                a.queueInvalidate(c)
            } else {
                e = d.pendingLayouts || (d.pendingLayouts = new Ext.layout.Context());
                e.queueInvalidate(c);
                if (!g && !d.layoutSuspendCount && !c.isLayoutSuspended()) {
                    d.flushLayouts()
                }
            }
        }
    },
    isComponent: true,
    getAutoId: function() {
        this.autoGenId = true;
        return ++Ext.AbstractComponent.AUTO_ID
    },
    deferLayouts: false,
    autoGenId: false,
    renderTpl: "{%this.renderContent(out,values)%}",
    frameSize: {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: 0,
        height: 0
    },
    tplWriteMode: "overwrite",
    baseCls: Ext.baseCSSPrefix + "component",
    disabledCls: Ext.baseCSSPrefix + "item-disabled",
    ui: "default",
    uiCls: [],
    hidden: false,
    disabled: false,
    draggable: false,
    floating: false,
    hideMode: "display",
    styleHtmlContent: false,
    styleHtmlCls: Ext.baseCSSPrefix + "html",
    autoShow: false,
    autoRender: false,
    allowDomMove: true,
    rendered: false,
    componentLayoutCounter: 0,
    shrinkWrap: 2,
    weight: 0,
    maskOnDisable: true,
    _isLayoutRoot: false,
    constructor: function(d) {
        var g = this,
            e, a, c;
        if (d) {
            Ext.apply(g, d);
            c = g.xhooks;
            if (c) {
                delete g.xhooks;
                Ext.override(g, c)
            }
        } else {
            d = {}
        }
        g.initialConfig = d;
        g.mixins.elementCt.constructor.call(g);
        g.addEvents("beforeactivate", "activate", "beforedeactivate", "deactivate", "added", "disable", "enable", "beforeshow", "show", "beforehide", "hide", "removed", "beforerender", "render", "afterrender", "boxready", "beforedestroy", "destroy", "resize", "move", "focus", "blur");
        g.getId();
        g.setupProtoEl();
        if (g.cls) {
            g.initialCls = g.cls;
            g.protoEl.addCls(g.cls)
        }
        if (g.style) {
            g.initialStyle = g.style;
            g.protoEl.setStyle(g.style)
        }
        g.mons = [];
        g.renderData = g.renderData || {};
        g.renderSelectors = g.renderSelectors || {};
        if (g.plugins) {
            g.plugins = g.constructPlugins()
        }
        if (!g.hasListeners) {
            g.hasListeners = new g.HasListeners()
        }
        g.initComponent();
        Ext.ComponentManager.register(g);
        g.mixins.observable.constructor.call(g);
        g.mixins.state.constructor.call(g, d);
        this.addStateEvents("resize");
        if (g.plugins) {
            for (e = 0, a = g.plugins.length; e < a; e++) {
                g.plugins[e] = g.initPlugin(g.plugins[e])
            }
        }
        g.loader = g.getLoader();
        if (g.renderTo) {
            g.render(g.renderTo)
        }
        if (g.autoShow && !g.isContained) {
            g.show()
        }
    },
    initComponent: function() {
        this.plugins = this.constructPlugins();
        this.setSize(this.width, this.height)
    },
    getState: function() {
        var c = this,
            d = null,
            a = c.getSizeModel();
        if (a.width.configured) {
            d = c.addPropertyToState(d, "width")
        }
        if (a.height.configured) {
            d = c.addPropertyToState(d, "height")
        }
        return d
    },
    addPropertyToState: function(g, e, d) {
        var c = this,
            a = arguments.length;
        if (a == 3 || c.hasOwnProperty(e)) {
            if (a < 3) {
                d = c[e]
            }
            if (d !== c.initialConfig[e]) {
                (g || (g = {}))[e] = d
            }
        }
        return g
    },
    show: Ext.emptyFn,
    animate: function(c) {
        var l = this,
            g, i, e, q, p, n, m, k, o, j, d, a;
        c = c || {};
        p = c.to || {};
        if (Ext.fx.Manager.hasFxBlock(l.id)) {
            return l
        }
        g = Ext.isDefined(p.width);
        if (g) {
            q = Ext.Number.constrain(p.width, l.minWidth, l.maxWidth)
        }
        i = Ext.isDefined(p.height);
        if (i) {
            e = Ext.Number.constrain(p.height, l.minHeight, l.maxHeight)
        }
        if (!c.dynamic && (g || i)) {
            k = (c.from ? c.from.width : undefined) || l.getWidth();
            o = k;
            j = (c.from ? c.from.height : undefined) || l.getHeight();
            d = j;
            a = false;
            if (i && e > j) {
                d = e;
                a = true
            }
            if (g && q > k) {
                o = q;
                a = true
            }
            if (a) {
                n = !Ext.isNumber(l.width);
                m = !Ext.isNumber(l.height);
                l.setSize(o, d);
                l.el.setSize(k, j);
                if (n) {
                    delete l.width
                }
                if (m) {
                    delete l.height
                }
            }
            if (g) {
                p.width = q
            }
            if (i) {
                p.height = e
            }
        }
        return l.mixins.animate.animate.apply(l, arguments)
    },
    onHide: function() {
        this.updateLayout({
            isRoot: false
        })
    },
    onShow: function() {
        this.updateLayout({
            isRoot: false
        })
    },
    constructPlugin: function(a) {
        if (a.ptype && typeof a.init != "function") {
            a.cmp = this;
            a = Ext.PluginManager.create(a)
        } else {
            if (typeof a == "string") {
                a = Ext.PluginManager.create({
                    ptype: a,
                    cmp: this
                })
            }
        }
        return a
    },
    constructPlugins: function() {
        var g = this,
            d, c = [],
            e, a;
        if (g.plugins) {
            d = Ext.isArray(g.plugins) ? g.plugins : [g.plugins];
            for (e = 0, a = d.length; e < a; e++) {
                c[e] = g.constructPlugin(d[e])
            }
            return c
        }
    },
    initPlugin: function(a) {
        a.init(this);
        return a
    },
    updateAria: Ext.emptyFn,
    registerFloatingItem: function(c) {
        var a = this;
        if (!a.floatingDescendants) {
            a.floatingDescendants = new Ext.ZIndexManager(a)
        }
        a.floatingDescendants.register(c)
    },
    unregisterFloatingItem: function(c) {
        var a = this;
        if (a.floatingDescendants) {
            a.floatingDescendants.unregister(c)
        }
    },
    layoutSuspendCount: 0,
    suspendLayouts: function() {
        var a = this;
        if (!a.rendered) {
            return
        }
        if (++a.layoutSuspendCount == 1) {
            a.suspendLayout = true
        }
    },
    resumeLayouts: function(c) {
        var a = this;
        if (!a.rendered) {
            return
        }
        if (!--a.layoutSuspendCount) {
            a.suspendLayout = false;
            if (c && !a.isLayoutSuspended()) {
                a.updateLayout(c)
            }
        }
    },
    setupProtoEl: function() {
        var c = this,
            a = [c.baseCls, c.getComponentLayout().targetCls];
        if (Ext.isDefined(c.cmpCls)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn("Ext.Component: cmpCls has been deprecated. Please use componentCls.")
            }
            c.componentCls = c.cmpCls;
            delete c.cmpCls
        }
        if (c.componentCls) {
            a.push(c.componentCls)
        } else {
            c.componentCls = c.baseCls
        }
        c.protoEl = new Ext.util.ProtoElement({
            cls: a.join(" ")
        })
    },
    setUI: function(j) {
        var g = this,
            c = Ext.Array.clone(g.uiCls),
            k = [],
            e = [],
            a, d;
        for (d = 0; d < c.length; d++) {
            a = c[d];
            e = e.concat(g.removeClsWithUI(a, true));
            k.push(a)
        }
        if (e.length) {
            g.removeCls(e)
        }
        g.removeUIFromElement();
        g.ui = j;
        g.addUIToElement();
        e = [];
        for (d = 0; d < k.length; d++) {
            a = k[d];
            e = e.concat(g.addClsWithUI(a, true))
        }
        if (e.length) {
            g.addCls(e)
        }
        if (g.rendered) {
            g.updateLayout()
        }
    },
    addClsWithUI: function(d, k) {
        var j = this,
            g = [],
            e, c = 0,
            a;
        if (typeof d === "string") {
            d = (d.indexOf(" ") < 0) ? [d] : Ext.String.splitWords(d)
        }
        e = d.length;
        j.uiCls = Ext.Array.clone(j.uiCls);
        for (; c < e; c++) {
            a = d[c];
            if (a && !j.hasUICls(a)) {
                j.uiCls.push(a);
                g = g.concat(j.addUIClsToElement(a))
            }
        }
        if (k !== true) {
            j.addCls(g)
        }
        return g
    },
    removeClsWithUI: function(d, k) {
        var j = this,
            g = [],
            c = 0,
            e, a;
        if (typeof d === "string") {
            d = (d.indexOf(" ") < 0) ? [d] : Ext.String.splitWords(d)
        }
        e = d.length;
        for (c = 0; c < e; c++) {
            a = d[c];
            if (a && j.hasUICls(a)) {
                j.uiCls = Ext.Array.remove(j.uiCls, a);
                g = g.concat(j.removeUIClsFromElement(a))
            }
        }
        if (k !== true) {
            j.removeCls(g)
        }
        return g
    },
    hasUICls: function(a) {
        var c = this,
            d = c.uiCls || [];
        return Ext.Array.contains(d, a)
    },
    frameElementsArray: ["tl", "tc", "tr", "ml", "mc", "mr", "bl", "bc", "br"],
    addUIClsToElement: function(o) {
        var m = this,
            d = m.baseCls + "-" + m.ui + "-" + o,
            p = [Ext.baseCSSPrefix + o, m.baseCls + "-" + o, d],
            n = m.frameElementCls,
            k, j, g, a, e, l;
        if (m.frame && !Ext.supports.CSS3BorderRadius) {
            k = m.frameElementsArray;
            j = k.length;
            g = 0;
            for (; g < j; g++) {
                e = k[g];
                a = m["frame" + e.toUpperCase()];
                l = d + "-" + e;
                if (a && a.dom) {
                    a.addCls(l)
                } else {
                    if (Ext.Array.indexOf(n[e], l) == -1) {
                        n[e].push(l)
                    }
                }
            }
        }
        m.frameElementCls = n;
        return p
    },
    removeUIClsFromElement: function(o) {
        var m = this,
            d = m.baseCls + "-" + m.ui + "-" + o,
            p = [Ext.baseCSSPrefix + o, m.baseCls + "-" + o, d],
            n = m.frameElementCls,
            k, j, g, a, e, l;
        if (m.frame && !Ext.supports.CSS3BorderRadius) {
            k = m.frameElementsArray;
            j = k.length;
            g = 0;
            for (; g < j; g++) {
                e = k[g];
                a = m["frame" + e.toUpperCase()];
                l = d + "-" + e;
                if (a && a.dom) {
                    a.addCls(l)
                } else {
                    Ext.Array.remove(n[e], l)
                }
            }
        }
        m.frameElementCls = n;
        return p
    },
    addUIToElement: function() {
        var l = this,
            m = l.baseCls + "-" + l.ui,
            n = l.frameElementCls,
            j, g, e, a, d, k;
        l.addCls(m);
        if (l.frame && !Ext.supports.CSS3BorderRadius) {
            j = l.frameElementsArray;
            g = j.length;
            e = 0;
            for (; e < g; e++) {
                d = j[e];
                a = l["frame" + d.toUpperCase()];
                k = m + "-" + d;
                if (a) {
                    a.addCls(k)
                } else {
                    if (!Ext.Array.contains(n[d], k)) {
                        n[d].push(k)
                    }
                }
            }
        }
    },
    removeUIFromElement: function() {
        var l = this,
            m = l.baseCls + "-" + l.ui,
            n = l.frameElementCls,
            j, g, e, a, d, k;
        l.removeCls(m);
        if (l.frame && !Ext.supports.CSS3BorderRadius) {
            j = l.frameElementsArray;
            g = j.length;
            e = 0;
            for (; e < g; e++) {
                d = j[e];
                a = l["frame" + d.toUpperCase()];
                k = m + "-" + d;
                if (a) {
                    a.removeCls(k)
                } else {
                    Ext.Array.remove(n[d], k)
                }
            }
        }
    },
    getTpl: function(a) {
        return Ext.XTemplate.getTpl(this, a)
    },
    initStyles: function(l) {
        var e = this,
            c = Ext.Element,
            i = e.padding,
            d = e.margin,
            j = e.x,
            g = e.y,
            a, k;
        if (i !== undefined) {
            l.setStyle("padding", c.unitizeBox((i === true) ? 5 : i))
        }
        if (d !== undefined) {
            l.setStyle("margin", c.unitizeBox((d === true) ? 5 : d))
        }
        if (e.border !== undefined) {
            e.setBorder(e.border, l)
        }
        if (e.cls && e.cls != e.initialCls) {
            l.addCls(e.cls);
            delete e.cls;
            delete e.initialCls
        }
        if (e.style && e.style != e.initialStyle) {
            l.setStyle(e.style);
            delete e.style;
            delete e.initialStyle
        }
        if (j !== undefined) {
            l.setStyle("left", (typeof j == "number") ? (j + "px") : j)
        }
        if (g !== undefined) {
            l.setStyle("top", (typeof g == "number") ? (g + "px") : g)
        }
        if (!e.getFrameInfo()) {
            a = e.width;
            k = e.height;
            if (a !== undefined) {
                if (typeof a === "number") {
                    if (Ext.isBorderBox) {
                        l.setStyle("width", a + "px")
                    }
                } else {
                    l.setStyle("width", a)
                }
            }
            if (k !== undefined) {
                if (typeof k === "number") {
                    if (Ext.isBorderBox) {
                        l.setStyle("height", k + "px")
                    }
                } else {
                    l.setStyle("height", k)
                }
            }
        }
    },
    initEvents: function() {
        var d = this,
            g = d.afterRenderEvents,
            c, e, a = function(i) {
                d.mon(c, i)
            };
        if (g) {
            for (e in g) {
                if (g.hasOwnProperty(e)) {
                    c = d[e];
                    if (c && c.on) {
                        Ext.each(g[e], a)
                    }
                }
            }
        }
        d.addFocusListener()
    },
    addFocusListener: function() {
        var d = this,
            c = d.getFocusEl(),
            a;
        if (c) {
            if (c.isComponent) {
                return c.addFocusListener()
            }
            a = c.needsTabIndex();
            if (!d.focusListenerAdded && (!a || Ext.FocusManager.enabled)) {
                if (a) {
                    c.dom.tabIndex = -1
                }
                c.on({
                    focus: d.onFocus,
                    blur: d.onBlur,
                    scope: d
                });
                d.focusListenerAdded = true
            }
        }
    },
    getFocusEl: Ext.emptyFn,
    isFocusable: function(e) {
        var d = this,
            a;
        if ((d.focusable !== false) && (a = d.getFocusEl()) && d.rendered && !d.destroying && !d.isDestroyed && !d.disabled && d.isVisible(true)) {
            if (a.isComponent) {
                return a.isFocusable()
            }
            return a && a.dom && a.isVisible()
        }
    },
    preFocus: Ext.emptyFn,
    onFocus: function(g) {
        var d = this,
            c = d.focusCls,
            a = d.getFocusEl();
        if (!d.disabled) {
            d.preFocus(g);
            if (c && a) {
                a.addCls(d.addClsWithUI(c, true))
            }
            if (!d.hasFocus) {
                d.hasFocus = true;
                d.fireEvent("focus", d, g)
            }
        }
    },
    beforeBlur: Ext.emptyFn,
    onBlur: function(g) {
        var d = this,
            c = d.focusCls,
            a = d.getFocusEl();
        if (d.destroying) {
            return
        }
        d.beforeBlur(g);
        if (c && a) {
            a.removeCls(d.removeClsWithUI(c, true))
        }
        if (d.validateOnBlur) {
            d.validate()
        }
        d.hasFocus = false;
        d.fireEvent("blur", d, g);
        d.postBlur(g)
    },
    postBlur: Ext.emptyFn,
    is: function(a) {
        return Ext.ComponentQuery.is(this, a)
    },
    up: function(c) {
        var a = this.getBubbleTarget();
        if (c) {
            for (; a; a = a.getBubbleTarget()) {
                if (Ext.ComponentQuery.is(a, c)) {
                    return a
                }
            }
        }
        return a
    },
    nextSibling: function(d) {
        var i = this.ownerCt,
            e, g, a, j;
        if (i) {
            e = i.items;
            a = e.indexOf(this) + 1;
            if (a) {
                if (d) {
                    for (g = e.getCount(); a < g; a++) {
                        if ((j = e.getAt(a)).is(d)) {
                            return j
                        }
                    }
                } else {
                    if (a < e.getCount()) {
                        return e.getAt(a)
                    }
                }
            }
        }
        return null
    },
    previousSibling: function(d) {
        var g = this.ownerCt,
            e, a, i;
        if (g) {
            e = g.items;
            a = e.indexOf(this);
            if (a != -1) {
                if (d) {
                    for (--a; a >= 0; a--) {
                        if ((i = e.getAt(a)).is(d)) {
                            return i
                        }
                    }
                } else {
                    if (a) {
                        return e.getAt(--a)
                    }
                }
            }
        }
        return null
    },
    previousNode: function(c, e) {
        var l = this,
            k = l.ownerCt,
            a, j, g, d;
        if (e && l.is(c)) {
            return l
        }
        if (k) {
            for (j = k.items.items, g = Ext.Array.indexOf(j, l) - 1; g > -1; g--) {
                d = j[g];
                if (d.query) {
                    a = d.query(c);
                    a = a[a.length - 1];
                    if (a) {
                        return a
                    }
                }
                if (d.is(c)) {
                    return d
                }
            }
            return k.previousNode(c, true)
        }
        return null
    },
    nextNode: function(e, l) {
        var c = this,
            d = c.ownerCt,
            m, g, k, j, a;
        if (l && c.is(e)) {
            return c
        }
        if (d) {
            for (g = d.items.items, j = Ext.Array.indexOf(g, c) + 1, k = g.length; j < k; j++) {
                a = g[j];
                if (a.is(e)) {
                    return a
                }
                if (a.down) {
                    m = a.down(e);
                    if (m) {
                        return m
                    }
                }
            }
            return d.nextNode(e)
        }
        return null
    },
    getId: function() {
        return this.id || (this.id = "ext-comp-" + (this.getAutoId()))
    },
    getItemId: function() {
        return this.itemId || this.id
    },
    getEl: function() {
        return this.el
    },
    getTargetEl: function() {
        return this.frameBody || this.el
    },
    getOverflowStyle: function() {
        var c = this,
            a = null;
        if (typeof c.autoScroll == "boolean") {
            a = {
                overflow: c.autoScroll ? "auto" : ""
            }
        } else {
            if (c.overflowX !== undefined || c.overflowY !== undefined) {
                a = {
                    "overflow-x": (c.overflowX || ""),
                    "overflow-y": (c.overflowY || "")
                }
            }
        }
        if (a && (Ext.isIE6 || Ext.isIE7)) {
            a.position = "relative"
        }
        return a
    },
    isXType: function(c, a) {
        if (a) {
            return this.xtype === c
        } else {
            return this.xtypesMap[c]
        }
    },
    getXTypes: function() {
        var d = this.self,
            e, c, a;
        if (!d.xtypes) {
            e = [];
            c = this;
            while (c) {
                a = c.xtypes;
                if (a !== undefined) {
                    e.unshift.apply(e, a)
                }
                c = c.superclass
            }
            d.xtypeChain = e;
            d.xtypes = e.join("/")
        }
        return d.xtypes
    },
    update: function(c, d, a) {
        var e = this;
        if (e.tpl && !Ext.isString(c)) {
            e.data = c;
            if (e.rendered) {
                e.tpl[e.tplWriteMode](e.getTargetEl(), c || {})
            }
        } else {
            e.html = Ext.isObject(c) ? Ext.DomHelper.markup(c) : c;
            if (e.rendered) {
                e.getTargetEl().update(e.html, d, a)
            }
        }
        if (e.rendered) {
            e.updateLayout()
        }
    },
    setVisible: function(a) {
        return this[a ? "show" : "hide"]()
    },
    isVisible: function(a) {
        var d = this,
            g = d,
            e = d.rendered && !d.hidden,
            c = d.ownerCt;
        d.hiddenAncestor = false;
        if (d.destroyed) {
            return false
        }
        if (a && e && c) {
            while (c) {
                if (c.hidden || (c.collapsed && !(c.getDockedItems && Ext.Array.contains(c.getDockedItems(), g)))) {
                    d.hiddenAncestor = c;
                    e = false;
                    break
                }
                g = c;
                c = c.ownerCt
            }
        }
        return e
    },
    onBoxReady: function() {
        var a = this;
        if (a.disableOnBoxReady) {
            a.onDisable()
        } else {
            if (a.enableOnBoxReady) {
                a.onEnable()
            }
        }
        if (a.resizable) {
            a.initResizable(a.resizable)
        }
        if (a.draggable) {
            a.initDraggable()
        }
    },
    enable: function(a) {
        var c = this;
        delete c.disableOnBoxReady;
        c.removeCls(c.disabledCls);
        if (c.rendered) {
            c.onEnable()
        } else {
            c.enableOnBoxReady = true
        }
        c.disabled = false;
        delete c.resetDisable;
        if (a !== true) {
            c.fireEvent("enable", c)
        }
        return c
    },
    disable: function(a) {
        var c = this;
        delete c.enableOnBoxReady;
        c.addCls(c.disabledCls);
        if (c.rendered) {
            c.onDisable()
        } else {
            c.disableOnBoxReady = true
        }
        c.disabled = true;
        if (a !== true) {
            delete c.resetDisable;
            c.fireEvent("disable", c)
        }
        return c
    },
    onEnable: function() {
        if (this.maskOnDisable) {
            this.el.dom.disabled = false;
            this.unmask()
        }
    },
    onDisable: function() {
        var d = this,
            c = d.focusCls,
            a = d.getFocusEl();
        if (c && a) {
            a.removeCls(d.removeClsWithUI(c, true))
        }
        if (d.maskOnDisable) {
            d.el.dom.disabled = true;
            d.mask()
        }
    },
    mask: function() {
        var c = this.lastBox,
            d = this.getMaskTarget(),
            a = [];
        if (c) {
            a[2] = c.height
        }
        d.mask.apply(d, a)
    },
    unmask: function() {
        this.getMaskTarget().unmask()
    },
    getMaskTarget: function() {
        return this.el
    },
    isDisabled: function() {
        return this.disabled
    },
    setDisabled: function(a) {
        return this[a ? "disable" : "enable"]()
    },
    isHidden: function() {
        return this.hidden
    },
    addCls: function(a) {
        var d = this,
            c = d.rendered ? d.el : d.protoEl;
        c.addCls.apply(c, arguments);
        return d
    },
    addClass: function() {
        return this.addCls.apply(this, arguments)
    },
    hasCls: function(a) {
        var d = this,
            c = d.rendered ? d.el : d.protoEl;
        return c.hasCls.apply(c, arguments)
    },
    removeCls: function(a) {
        var d = this,
            c = d.rendered ? d.el : d.protoEl;
        c.removeCls.apply(c, arguments);
        return d
    },
    addOverCls: function() {
        var a = this;
        if (!a.disabled) {
            a.el.addCls(a.overCls)
        }
    },
    removeOverCls: function() {
        this.el.removeCls(this.overCls)
    },
    addListener: function(c, i, g, a) {
        var j = this,
            e, d;
        if (Ext.isString(c) && (Ext.isObject(i) || a && a.element)) {
            if (a.element) {
                e = i;
                i = {};
                i[c] = e;
                c = a.element;
                if (g) {
                    i.scope = g
                }
                for (d in a) {
                    if (a.hasOwnProperty(d)) {
                        if (j.eventOptionsRe.test(d)) {
                            i[d] = a[d]
                        }
                    }
                }
            }
            if (j[c] && j[c].on) {
                j.mon(j[c], i)
            } else {
                j.afterRenderEvents = j.afterRenderEvents || {};
                if (!j.afterRenderEvents[c]) {
                    j.afterRenderEvents[c] = []
                }
                j.afterRenderEvents[c].push(i)
            }
        }
        return j.mixins.observable.addListener.apply(j, arguments)
    },
    removeManagedListenerItem: function(c, a, k, e, i, g) {
        var j = this,
            d = a.options ? a.options.element : null;
        if (d) {
            d = j[d];
            if (d && d.un) {
                if (c || (a.item === k && a.ename === e && (!i || a.fn === i) && (!g || a.scope === g))) {
                    d.un(a.ename, a.fn, a.scope);
                    if (!c) {
                        Ext.Array.remove(j.managedListeners, a)
                    }
                }
            }
        } else {
            return j.mixins.observable.removeManagedListenerItem.apply(j, arguments)
        }
    },
    getBubbleTarget: function() {
        return this.ownerCt
    },
    isFloating: function() {
        return this.floating
    },
    isDraggable: function() {
        return !!this.draggable
    },
    isDroppable: function() {
        return !!this.droppable
    },
    onAdded: function(a, d) {
        var c = this;
        c.ownerCt = a;
        if (c.hasListeners.added) {
            c.fireEvent("added", c, a, d)
        }
    },
    onRemoved: function(c) {
        var a = this;
        if (a.hasListeners.removed) {
            a.fireEvent("removed", a, a.ownerCt)
        }
        delete a.ownerCt;
        delete a.ownerLayout
    },
    beforeDestroy: Ext.emptyFn,
    onResize: Ext.emptyFn,
    setSize: function(c, a) {
        var d = this;
        if (c && typeof c == "object") {
            a = c.height;
            c = c.width
        }
        if (typeof c == "number") {
            d.width = Ext.Number.constrain(c, d.minWidth, d.maxWidth)
        } else {
            if (c === null) {
                delete d.width
            }
        }
        if (typeof a == "number") {
            d.height = Ext.Number.constrain(a, d.minHeight, d.maxHeight)
        } else {
            if (a === null) {
                delete d.height
            }
        }
        if (d.rendered && d.isVisible()) {
            d.updateLayout({
                isRoot: false
            })
        }
        return d
    },
    isLayoutRoot: function() {
        var a = this,
            c = a.ownerLayout;
        if (!c || a._isLayoutRoot || a.floating) {
            return true
        }
        return c.isItemLayoutRoot(a)
    },
    isLayoutSuspended: function() {
        var a = this,
            c;
        while (a) {
            if (a.layoutSuspendCount || a.suspendLayout) {
                return true
            }
            c = a.ownerLayout;
            if (!c) {
                break
            }
            a = c.owner
        }
        return false
    },
    updateLayout: function(c) {
        var d = this,
            e, a = c && c.isRoot;
        if (!d.rendered || d.layoutSuspendCount || d.suspendLayout) {
            return
        }
        if (d.hidden) {
            Ext.AbstractComponent.cancelLayout(d)
        } else {
            if (typeof a != "boolean") {
                a = d.isLayoutRoot()
            }
        }
        if (a || !d.ownerLayout || !d.ownerLayout.onContentChange(d)) {
            if (!d.isLayoutSuspended()) {
                e = (c && c.hasOwnProperty("defer")) ? c.defer : d.deferLayouts;
                Ext.AbstractComponent.updateLayout(d, e)
            }
        }
    },
    getSizeModel: function(l) {
        var p = this,
            a = Ext.layout.SizeModel,
            e = p.componentLayout.ownerContext,
            c = p.width,
            r = p.height,
            s, d, i, g, j, q, n, o, m, k;
        if (e) {
            k = e.widthModel;
            j = e.heightModel
        }
        if (!k || !j) {
            i = ((s = typeof c) == "number");
            g = ((d = typeof r) == "number");
            m = p.floating || !(q = p.ownerLayout);
            if (m) {
                n = Ext.layout.Layout.prototype.autoSizePolicy;
                o = p.floating ? 3 : p.shrinkWrap;
                if (i) {
                    k = a.configured
                }
                if (g) {
                    j = a.configured
                }
            } else {
                n = q.getItemSizePolicy(p, l);
                o = q.isItemShrinkWrap(p)
            }
            o = (o === true) ? 3 : (o || 0);
            if (m && o) {
                if (c && s == "string") {
                    o &= 2
                }
                if (r && d == "string") {
                    o &= 1
                }
            }
            if (o !== 3) {
                if (!l) {
                    l = p.ownerCt && p.ownerCt.getSizeModel()
                }
                if (l) {
                    o |= (l.width.shrinkWrap ? 1 : 0) | (l.height.shrinkWrap ? 2 : 0)
                }
            }
            if (!k) {
                if (!n.setsWidth) {
                    if (i) {
                        k = a.configured
                    } else {
                        k = (o & 1) ? a.shrinkWrap : a.natural
                    }
                } else {
                    if (n.readsWidth) {
                        if (i) {
                            k = a.calculatedFromConfigured
                        } else {
                            k = (o & 1) ? a.calculatedFromShrinkWrap : a.calculatedFromNatural
                        }
                    } else {
                        k = a.calculated
                    }
                }
            }
            if (!j) {
                if (!n.setsHeight) {
                    if (g) {
                        j = a.configured
                    } else {
                        j = (o & 2) ? a.shrinkWrap : a.natural
                    }
                } else {
                    if (n.readsHeight) {
                        if (g) {
                            j = a.calculatedFromConfigured
                        } else {
                            j = (o & 2) ? a.calculatedFromShrinkWrap : a.calculatedFromNatural
                        }
                    } else {
                        j = a.calculated
                    }
                }
            }
        }
        return k.pairsByHeightOrdinal[j.ordinal]
    },
    isDescendant: function(a) {
        if (a.isContainer) {
            for (var d = this.ownerCt; d; d = d.ownerCt) {
                if (d === a) {
                    return true
                }
            }
        }
        return false
    },
    doComponentLayout: function() {
        this.updateLayout();
        return this
    },
    forceComponentLayout: function() {
        this.updateLayout()
    },
    setComponentLayout: function(c) {
        var a = this.componentLayout;
        if (a && a.isLayout && a != c) {
            a.setOwner(null)
        }
        this.componentLayout = c;
        c.setOwner(this)
    },
    getComponentLayout: function() {
        var a = this;
        if (!a.componentLayout || !a.componentLayout.isLayout) {
            a.setComponentLayout(Ext.layout.Layout.create(a.componentLayout, "autocomponent"))
        }
        return a.componentLayout
    },
    afterComponentLayout: function(a, m, c, l) {
        var j = this,
            k, e, d, g;
        if (++j.componentLayoutCounter === 1) {
            j.afterFirstLayout(a, m)
        }
        if (j.floatingItems) {
            k = j.floatingItems.items;
            e = k.length;
            for (d = 0; d < e; d++) {
                g = k[d];
                if (!g.rendered && g.autoShow) {
                    g.show()
                }
            }
        }
        if (j.hasListeners.resize && (a !== c || m !== l)) {
            j.fireEvent("resize", j, a, m, c, l)
        }
    },
    beforeComponentLayout: function(c, a) {
        return true
    },
    setPosition: function(a, g, c) {
        var d = this,
            e = d.beforeSetPosition.apply(d, arguments);
        if (e && d.rendered) {
            e = d.convertPosition(e);
            if (e.left !== d.el.getLeft() || e.top !== d.el.getTop()) {
                if (c) {
                    d.stopAnimation();
                    d.animate(Ext.apply({
                        duration: 1000,
                        listeners: {
                            afteranimate: Ext.Function.bind(d.afterSetPosition, d, [e.left, e.top])
                        },
                        to: e
                    }, c))
                } else {
                    if (e.left !== undefined && e.top !== undefined) {
                        d.el.setLeftTop(e.left, e.top)
                    } else {
                        if (e.left !== undefined) {
                            d.el.setLeft(e.left)
                        } else {
                            if (e.top !== undefined) {
                                d.el.setTop(e.top)
                            }
                        }
                    }
                    d.afterSetPosition(e.left, e.top)
                }
            }
        }
        return d
    },
    beforeSetPosition: function(a, g, c) {
        var e, d;
        if (!a || Ext.isNumber(a)) {
            e = {
                x: a,
                y: g,
                anim: c
            }
        } else {
            if (Ext.isNumber(d = a[0])) {
                e = {
                    x: d,
                    y: a[1],
                    anim: g
                }
            } else {
                e = {
                    x: a.x,
                    y: a.y,
                    anim: g
                }
            }
        }
        e.hasX = Ext.isNumber(e.x);
        e.hasY = Ext.isNumber(e.y);
        this.x = e.x;
        this.y = e.y;
        return (e.hasX || e.hasY) ? e : null
    },
    afterSetPosition: function(a, d) {
        var c = this;
        c.onPosition(a, d);
        if (c.hasListeners.move) {
            c.fireEvent("move", c, a, d)
        }
    },
    convertPosition: function(e, c) {
        var a = {},
            d = Ext.Element;
        if (e.hasX) {
            a.left = c ? d.addUnits(e.x) : e.x
        }
        if (e.hasY) {
            a.top = c ? d.addUnits(e.y) : e.y
        }
        return a
    },
    onPosition: Ext.emptyFn,
    setWidth: function(a) {
        return this.setSize(a)
    },
    setHeight: function(a) {
        return this.setSize(undefined, a)
    },
    getSize: function() {
        return this.el.getSize()
    },
    getWidth: function() {
        return this.el.getWidth()
    },
    getHeight: function() {
        return this.el.getHeight()
    },
    getLoader: function() {
        var d = this,
            c = d.autoLoad ? (Ext.isObject(d.autoLoad) ? d.autoLoad : {
                url: d.autoLoad
            }) : null,
            a = d.loader || c;
        if (a) {
            if (!a.isLoader) {
                d.loader = new Ext.ComponentLoader(Ext.apply({
                    target: d,
                    autoLoad: c
                }, a))
            } else {
                a.setTarget(d)
            }
            return d.loader
        }
        return null
    },
    setDocked: function(c, d) {
        var a = this;
        a.dock = c;
        if (d && a.ownerCt && a.rendered) {
            a.ownerCt.updateLayout()
        }
        return a
    },
    setBorder: function(c, e) {
        var d = this,
            a = !!e;
        if (d.rendered || a) {
            if (!a) {
                e = d.el
            }
            if (!c) {
                c = 0
            } else {
                c = Ext.Element.unitizeBox((c === true) ? 1 : c)
            }
            e.setStyle("border-width", c);
            if (!a) {
                d.updateLayout()
            }
        }
        d.border = c
    },
    onDestroy: function() {
        var a = this;
        if (a.monitorResize && Ext.EventManager.resizeEvent) {
            Ext.EventManager.resizeEvent.removeListener(a.setSize, a)
        }
        Ext.destroy(a.componentLayout, a.loadMask, a.floatingDescendants)
    },
    destroy: function() {
        var e = this,
            c = e.renderSelectors,
            a, d;
        if (!e.isDestroyed) {
            if (!e.hasListeners.beforedestroy || e.fireEvent("beforedestroy", e) !== false) {
                e.destroying = true;
                e.beforeDestroy();
                if (e.floating) {
                    delete e.floatParent;
                    if (e.zIndexManager) {
                        e.zIndexManager.unregister(e)
                    }
                } else {
                    if (e.ownerCt && e.ownerCt.remove) {
                        e.ownerCt.remove(e, false)
                    }
                }
                e.onDestroy();
                Ext.destroy(e.plugins);
                if (e.hasListeners.destroy) {
                    e.fireEvent("destroy", e)
                }
                Ext.ComponentManager.unregister(e);
                e.mixins.state.destroy.call(e);
                e.clearListeners();
                if (e.rendered) {
                    if (!e.preserveElOnDestroy) {
                        e.el.remove()
                    }
                    e.mixins.elementCt.destroy.call(e);
                    if (c) {
                        for (a in c) {
                            if (c.hasOwnProperty(a)) {
                                d = e[a];
                                if (d) {
                                    delete e[a];
                                    d.remove()
                                }
                            }
                        }
                    }
                    delete e.el;
                    delete e.frameBody;
                    delete e.rendered
                }
                e.destroying = false;
                e.isDestroyed = true
            }
        }
    },
    getPlugin: function(c) {
        var d = 0,
            a = this.plugins,
            e = a.length;
        for (; d < e; d++) {
            if (a[d].pluginId === c) {
                return a[d]
            }
        }
    },
    isDescendantOf: function(a) {
        return !!this.findParentBy(function(c) {
            return c === a
        })
    }
}, function() {
    var a = this;
    a.createAlias({
        on: "addListener",
        prev: "previousSibling",
        next: "nextSibling"
    });
    Ext.resumeLayouts = function(c) {
        a.resumeLayouts(c)
    };
    Ext.suspendLayouts = function() {
        a.suspendLayouts()
    };
    Ext.batchLayouts = function(d, c) {
        a.suspendLayouts();
        d.call(c);
        a.resumeLayouts(true)
    }
});
Ext.define("Ext.util.Floating", {
    uses: ["Ext.Layer", "Ext.window.Window"],
    focusOnToFront: true,
    shadow: "sides",
    constructor: function(c) {
        var a = this;
        a.el = new Ext.Layer(Ext.apply({
            hideMode: a.hideMode,
            hidden: a.hidden,
            shadow: (typeof a.shadow != "undefined") ? a.shadow : "sides",
            shadowOffset: a.shadowOffset,
            constrain: false,
            shim: (a.shim === false) ? false : undefined
        }, a.floating), c);
        a.floating = true;
        a.registerWithOwnerCt()
    },
    registerWithOwnerCt: function() {
        var a = this;
        if (a.zIndexParent) {
            a.zIndexParent.unregisterFloatingItem(a)
        }
        a.zIndexParent = a.up("[floating]");
        a.setFloatParent(a.ownerCt);
        delete a.ownerCt;
        if (a.zIndexParent) {
            a.zIndexParent.registerFloatingItem(a)
        } else {
            Ext.WindowManager.register(a)
        }
    },
    setFloatParent: function(c) {
        var a = this;
        if (a.floatParent) {
            a.mun(a.floatParent, {
                hide: a.onFloatParentHide,
                show: a.onFloatParentShow,
                scope: a
            })
        }
        a.floatParent = c;
        if (c) {
            a.mon(a.floatParent, {
                hide: a.onFloatParentHide,
                show: a.onFloatParentShow,
                scope: a
            })
        }
        if ((a.constrain || a.constrainHeader) && !a.constrainTo) {
            a.constrainTo = c ? c.getTargetEl() : a.container
        }
    },
    onAfterFloatLayout: function() {
        this.syncShadow()
    },
    onFloatParentHide: function() {
        var a = this;
        if (a.hideOnParentHide !== false && a.isVisible()) {
            a.hide();
            a.showOnParentShow = true
        }
    },
    onFloatParentShow: function() {
        if (this.showOnParentShow) {
            delete this.showOnParentShow;
            this.show()
        }
    },
    setZIndex: function(a) {
        var c = this;
        c.el.setZIndex(a);
        a += 10;
        if (c.floatingDescendants) {
            a = Math.floor(c.floatingDescendants.setBase(a) / 100) * 100 + 10000
        }
        return a
    },
    doConstrain: function(c) {
        var d = this,
            a = d.getConstrainVector(c),
            e;
        if (a) {
            e = d.getPosition(!!d.floatParent);
            e[0] += a[0];
            e[1] += a[1];
            d.setPosition(e)
        }
    },
    getConstrainVector: function(a) {
        var c = this;
        if (c.constrain || c.constrainHeader) {
            a = a || (c.floatParent && c.floatParent.getTargetEl()) || c.container || c.el.getScopeParent();
            return (c.constrainHeader ? c.header.el : c.el).getConstrainVector(a)
        }
    },
    alignTo: function(c, a, d) {
        this.setPagePosition(this.el.getAlignToXY(c.el || c, a, d));
        return this
    },
    toFront: function(c) {
        var a = this;
        if (a.zIndexParent && a.bringParentToFront !== false) {
            a.zIndexParent.toFront(true)
        }
        if (!Ext.isDefined(c)) {
            c = !a.focusOnToFront
        }
        if (c) {
            a.preventFocusOnActivate = true
        }
        if (a.zIndexManager.bringToFront(a)) {
            if (!c) {
                a.focus(false, true)
            }
        }
        delete a.preventFocusOnActivate;
        return a
    },
    setActive: function(c, d) {
        var a = this;
        if (c) {
            if (a.el.shadow && !a.maximized) {
                a.el.enableShadow(true)
            }
            if (a.modal && !a.preventFocusOnActivate) {
                a.focus(false, true)
            }
            a.fireEvent("activate", a)
        } else {
            if (a.isWindow && (d && d.isWindow)) {
                a.el.disableShadow()
            }
            a.fireEvent("deactivate", a)
        }
    },
    toBack: function() {
        this.zIndexManager.sendToBack(this);
        return this
    },
    center: function() {
        var a = this,
            c;
        if (a.isVisible()) {
            c = a.el.getAlignToXY(a.container, "c-c");
            a.setPagePosition(c)
        } else {
            a.needsCenter = true
        }
        return a
    },
    onFloatShow: function() {
        if (this.needsCenter) {
            this.center()
        }
        delete this.needsCenter
    },
    syncShadow: function() {
        if (this.floating) {
            this.el.sync(true)
        }
    },
    fitContainer: function() {
        var d = this,
            c = d.floatParent,
            a = c ? c.getTargetEl() : d.container;
        d.setSize(a.getViewSize(false));
        d.setPosition.apply(d, c ? [0, 0] : a.getXY())
    }
});
Ext.define("Ext.Component", {
    alias: ["widget.component", "widget.box"],
    extend: "Ext.AbstractComponent",
    requires: ["Ext.util.DelayedTask"],
    uses: ["Ext.Layer", "Ext.resizer.Resizer", "Ext.util.ComponentDragger"],
    mixins: {
        floating: "Ext.util.Floating"
    },
    statics: {
        DIRECTION_TOP: "top",
        DIRECTION_RIGHT: "right",
        DIRECTION_BOTTOM: "bottom",
        DIRECTION_LEFT: "left",
        VERTICAL_DIRECTION_Re: /^(?:top|bottom)$/,
        INVALID_ID_CHARS_Re: /[\.,\s]/g
    },
    resizeHandles: "all",
    floating: false,
    toFrontOnShow: true,
    hideMode: "display",
    bubbleEvents: [],
    monPropRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate)$/,
    defaultComponentLayoutType: "autocomponent",
    constructor: function(a) {
        var c = this;
        a = a || {};
        if (a.initialConfig) {
            if (a.isAction) {
                c.baseAction = a
            }
            a = a.initialConfig
        } else {
            if (a.tagName || a.dom || Ext.isString(a)) {
                a = {
                    applyTo: a,
                    id: a.id || a
                }
            }
        }
        c.callParent([a]);
        if (c.baseAction) {
            c.baseAction.addComponent(c)
        }
    },
    initComponent: function() {
        var a = this;
        a.callParent();
        if (a.listeners) {
            a.on(a.listeners);
            a.listeners = null
        }
        a.enableBubble(a.bubbleEvents);
        a.mons = []
    },
    afterRender: function() {
        var a = this;
        a.callParent();
        if (!(a.x && a.y) && (a.pageX || a.pageY)) {
            a.setPagePosition(a.pageX, a.pageY)
        }
    },
    setAutoScroll: function(a) {
        var c = this;
        c.autoScroll = !!a;
        if (c.rendered) {
            c.getTargetEl().setStyle(c.getOverflowStyle())
        }
        c.updateLayout();
        return c
    },
    setOverflowXY: function(c, a) {
        var d = this,
            e = arguments.length;
        if (e) {
            d.overflowX = c || "";
            if (e > 1) {
                d.overflowY = a || ""
            }
        }
        if (d.rendered) {
            d.getTargetEl().setStyle(d.getOverflowStyle())
        }
        d.updateLayout();
        return d
    },
    beforeRender: function() {
        var c = this,
            d = c.floating,
            a;
        if (d) {
            c.addCls(Ext.baseCSSPrefix + "layer");
            a = d.cls;
            if (a) {
                c.addCls(a)
            }
        }
        return c.callParent()
    },
    afterComponentLayout: function() {
        this.callParent(arguments);
        if (this.floating) {
            this.onAfterFloatLayout()
        }
    },
    makeFloating: function(a) {
        this.mixins.floating.constructor.call(this, a)
    },
    wrapPrimaryEl: function(a) {
        if (this.floating) {
            this.makeFloating(a)
        } else {
            this.callParent(arguments)
        }
    },
    initResizable: function(a) {
        var c = this;
        a = Ext.apply({
            target: c,
            dynamic: false,
            constrainTo: c.constrainTo || (c.floatParent ? c.floatParent.getTargetEl() : null),
            handles: c.resizeHandles
        }, a);
        a.target = c;
        c.resizer = new Ext.resizer.Resizer(a)
    },
    getDragEl: function() {
        return this.el
    },
    initDraggable: function() {
        var d = this,
            a = (d.resizer && d.resizer.el !== d.el) ? d.resizerComponent = new Ext.Component({
                el: d.resizer.el,
                rendered: true,
                container: d.container
            }) : d,
            c = Ext.applyIf({
                el: a.getDragEl(),
                constrainTo: d.constrain ? (d.constrainTo || (d.floatParent ? d.floatParent.getTargetEl() : d.el.getScopeParent())) : undefined
            }, d.draggable);
        if (d.constrain || d.constrainDelegate) {
            c.constrain = d.constrain;
            c.constrainDelegate = d.constrainDelegate
        }
        d.dd = new Ext.util.ComponentDragger(a, c)
    },
    scrollBy: function(c, a, d) {
        var e;
        if ((e = this.getTargetEl()) && e.dom) {
            e.scrollBy.apply(e, arguments)
        }
    },
    setLoading: function(d, e) {
        var c = this,
            a;
        if (c.rendered) {
            Ext.destroy(c.loadMask);
            c.loadMask = null;
            if (d !== false && !c.collapsed) {
                if (Ext.isObject(d)) {
                    a = Ext.apply({}, d)
                } else {
                    if (Ext.isString(d)) {
                        a = {
                            msg: d
                        }
                    } else {
                        a = {}
                    }
                }
                if (e) {
                    Ext.applyIf(a, {
                        useTargetEl: true
                    })
                }
                c.loadMask = new Ext.LoadMask(c, a);
                c.loadMask.show()
            }
        }
        return c.loadMask
    },
    beforeSetPosition: function() {
        var c = this,
            d = c.callParent(arguments),
            a;
        if (d) {
            a = c.adjustPosition(d.x, d.y);
            d.x = a.x;
            d.y = a.y
        }
        return d || null
    },
    afterSetPosition: function(c, a) {
        this.onPosition(c, a);
        this.fireEvent("move", this, c, a)
    },
    showAt: function(a, e, c) {
        var d = this;
        if (!d.rendered && (d.autoRender || d.floating)) {
            d.doAutoRender();
            d.hidden = true
        }
        if (d.floating) {
            d.setPosition(a, e, c)
        } else {
            d.setPagePosition(a, e, c)
        }
        d.show()
    },
    setPagePosition: function(a, i, c) {
        var d = this,
            e, g;
        if (Ext.isArray(a)) {
            i = a[1];
            a = a[0]
        }
        d.pageX = a;
        d.pageY = i;
        if (d.floating) {
            if (d.isContainedFloater()) {
                g = d.floatParent.getTargetEl().getViewRegion();
                if (Ext.isNumber(a) && Ext.isNumber(g.left)) {
                    a -= g.left
                }
                if (Ext.isNumber(i) && Ext.isNumber(g.top)) {
                    i -= g.top
                }
            } else {
                e = d.el.translatePoints(a, i);
                a = e.left;
                i = e.top
            }
            d.setPosition(a, i, c)
        } else {
            e = d.el.translatePoints(a, i);
            d.setPosition(e.left, e.top, c)
        }
        return d
    },
    isContainedFloater: function() {
        return (this.floating && this.floatParent)
    },
    getBox: function(c) {
        var d = c ? this.getPosition(c) : this.el.getXY(),
            a = this.getSize();
        a.x = d[0];
        a.y = d[1];
        return a
    },
    updateBox: function(a) {
        this.setSize(a.width, a.height);
        this.setPagePosition(a.x, a.y);
        return this
    },
    getOuterSize: function() {
        var a = this.el;
        return {
            width: a.getWidth() + a.getMargin("lr"),
            height: a.getHeight() + a.getMargin("tb")
        }
    },
    adjustPosition: function(a, e) {
        var c = this,
            d;
        if (c.isContainedFloater()) {
            d = c.floatParent.getTargetEl().getViewRegion();
            a += d.left;
            e += d.top
        }
        return {
            x: a,
            y: e
        }
    },
    getPosition: function(a) {
        var d = this,
            c = d.el,
            g, e = d.isContainedFloater(),
            i;
        if ((a === true) && !e) {
            return [c.getLocalX(), c.getLocalY()]
        }
        g = d.el.getXY();
        if ((a === true) && e) {
            i = d.floatParent.getTargetEl().getViewRegion();
            g[0] -= i.left;
            g[1] -= i.top
        }
        return g
    },
    getId: function() {
        var a = this,
            c;
        if (!a.id) {
            c = a.getXType();
            if (c) {
                c = c.replace(Ext.Component.INVALID_ID_CHARS_Re, "-")
            } else {
                c = Ext.name.toLowerCase() + "-comp"
            }
            a.id = c + "-" + a.getAutoId()
        }
        return a.id
    },
    show: function(e, a, c) {
        var d = this,
            g = d.rendered;
        if (g && d.isVisible()) {
            if (d.toFrontOnShow && d.floating) {
                d.toFront()
            }
        } else {
            if (d.fireEvent("beforeshow", d) !== false) {
                d.hidden = false;
                if (!g && (d.autoRender || d.floating)) {
                    d.doAutoRender();
                    g = d.rendered
                }
                if (g) {
                    d.beforeShow();
                    d.onShow.apply(d, arguments);
                    d.afterShow.apply(d, arguments)
                }
            } else {
                d.onShowVeto()
            }
        }
        return d
    },
    onShowVeto: Ext.emptyFn,
    beforeShow: Ext.emptyFn,
    onShow: function() {
        var a = this;
        a.el.show();
        a.callParent(arguments);
        if (a.floating) {
            if (a.maximized) {
                a.fitContainer()
            } else {
                if (a.constrain) {
                    a.doConstrain()
                }
            }
        }
    },
    afterShow: function(j, c, g) {
        var i = this,
            a, d, e;
        j = j || i.animateTarget;
        if (!i.ghost) {
            j = null
        }
        if (j) {
            j = j.el ? j.el : Ext.get(j);
            d = i.el.getBox();
            a = j.getBox();
            i.el.addCls(Ext.baseCSSPrefix + "hide-offsets");
            e = i.ghost();
            e.el.stopAnimation();
            e.el.setX(-10000);
            e.el.animate({
                from: a,
                to: d,
                listeners: {
                    afteranimate: function() {
                        delete e.componentLayout.lastComponentSize;
                        i.unghost();
                        i.el.removeCls(Ext.baseCSSPrefix + "hide-offsets");
                        i.onShowComplete(c, g)
                    }
                }
            })
        } else {
            i.onShowComplete(c, g)
        }
    },
    onShowComplete: function(a, c) {
        var d = this;
        if (d.floating) {
            d.toFront();
            d.onFloatShow()
        }
        Ext.callback(a, c || d);
        d.fireEvent("show", d);
        delete d.hiddenByLayout
    },
    hide: function() {
        var a = this;
        a.showOnParentShow = false;
        if (!(a.rendered && !a.isVisible()) && a.fireEvent("beforehide", a) !== false) {
            a.hidden = true;
            if (a.rendered) {
                a.onHide.apply(a, arguments)
            }
        }
        return a
    },
    onHide: function(i, a, e) {
        var g = this,
            d, c;
        i = i || g.animateTarget;
        if (!g.ghost) {
            i = null
        }
        if (i) {
            i = i.el ? i.el : Ext.get(i);
            d = g.ghost();
            d.el.stopAnimation();
            c = i.getBox();
            c.width += "px";
            c.height += "px";
            d.el.animate({
                to: c,
                listeners: {
                    afteranimate: function() {
                        delete d.componentLayout.lastComponentSize;
                        d.el.hide();
                        g.afterHide(a, e)
                    }
                }
            })
        }
        g.el.hide();
        if (!i) {
            g.afterHide(a, e)
        }
    },
    afterHide: function(a, c) {
        var d = this;
        delete d.hiddenByLayout;
        Ext.AbstractComponent.prototype.onHide.call(this);
        Ext.callback(a, c || d);
        d.fireEvent("hide", d)
    },
    onDestroy: function() {
        var a = this;
        if (a.rendered) {
            Ext.destroy(a.proxy, a.proxyWrap, a.resizer, a.resizerComponent)
        }
        delete a.focusTask;
        a.callParent()
    },
    deleteMembers: function() {
        var c = arguments,
            a = c.length,
            d = 0;
        for (; d < a; ++d) {
            delete this[c[d]]
        }
    },
    focus: function(g, d) {
        var e = this,
            a, i, c;
        if (d) {
            if (!e.focusTask) {
                e.focusTask = new Ext.util.DelayedTask(e.focus)
            }
            e.focusTask.delay(Ext.isNumber(d) ? d : 10, null, e, [g, false]);
            return e
        }
        if (e.rendered && !e.isDestroyed && e.isVisible(true) && (a = e.getFocusEl())) {
            if (a.isComponent) {
                return a.focus(g, d)
            }
            if ((i = a.dom)) {
                if (a.needsTabIndex()) {
                    i.tabIndex = -1
                }
                if (e.floating) {
                    c = e.container.dom.scrollTop
                }
                a.focus();
                if (g === true) {
                    i.select()
                }
            }
            if (e.floating) {
                e.toFront(true);
                if (c !== undefined) {
                    e.container.dom.scrollTop = c
                }
            }
        }
        return e
    },
    cancelFocus: function() {
        var a = this.focusTask;
        if (a) {
            a.cancel()
        }
    },
    blur: function() {
        var a;
        if (this.rendered && (a = this.getFocusEl())) {
            a.blur()
        }
        return this
    },
    getEl: function() {
        return this.el
    },
    getResizeEl: function() {
        return this.el
    },
    getPositionEl: function() {
        return this.el
    },
    getActionEl: function() {
        return this.el
    },
    getVisibilityEl: function() {
        return this.el
    },
    onResize: Ext.emptyFn,
    getBubbleTarget: function() {
        return this.ownerCt || this.floatParent
    },
    getContentTarget: function() {
        return this.el
    },
    cloneConfig: function(d) {
        d = d || {};
        var e = d.id || Ext.id(),
            a = Ext.applyIf(d, this.initialConfig),
            c;
        a.id = e;
        c = Ext.getClass(this);
        return new c(a)
    },
    getXType: function() {
        return this.self.xtype
    },
    findParentBy: function(a) {
        var c;
        for (c = this.getBubbleTarget(); c && !a(c, this); c = c.getBubbleTarget()) {}
        return c || null
    },
    findParentByType: function(a) {
        return Ext.isFunction(a) ? this.findParentBy(function(c) {
            return c.constructor === a
        }) : this.up(a)
    },
    bubble: function(d, c, a) {
        var e = this;
        while (e) {
            if (d.apply(c || e, a || [e]) === false) {
                break
            }
            e = e.getBubbleTarget()
        }
        return this
    },
    getProxy: function() {
        var a = this,
            c;
        if (!a.proxy) {
            c = Ext.getBody();
            if (Ext.scopeResetCSS) {
                a.proxyWrap = c = Ext.getBody().createChild({
                    cls: Ext.resetCls
                })
            }
            a.proxy = a.el.createProxy(Ext.baseCSSPrefix + "proxy-el", c, true)
        }
        return a.proxy
    }
});
Ext.define("Ext.resizer.Splitter", {
    extend: "Ext.Component",
    requires: ["Ext.XTemplate"],
    uses: ["Ext.resizer.SplitterTracker"],
    alias: "widget.splitter",
    childEls: ["collapseEl"],
    renderTpl: ['<tpl if="collapsible===true">', '<div id="{id}-collapseEl" class="', Ext.baseCSSPrefix, "collapse-el ", Ext.baseCSSPrefix, 'layout-split-{collapseDir}">&#160;</div>', "</tpl>"],
    baseCls: Ext.baseCSSPrefix + "splitter",
    collapsedClsInternal: Ext.baseCSSPrefix + "splitter-collapsed",
    canResize: true,
    collapsible: false,
    collapseOnDblClick: true,
    defaultSplitMin: 40,
    defaultSplitMax: 1000,
    collapseTarget: "next",
    horizontal: false,
    vertical: false,
    getTrackerConfig: function() {
        return {
            xclass: "Ext.resizer.SplitterTracker",
            el: this.el,
            splitter: this
        }
    },
    beforeRender: function() {
        var e = this,
            g = e.getCollapseTarget(),
            i = e.getCollapseDirection(),
            d = e.vertical,
            c = d ? "width" : "height",
            j = d ? "height" : "width",
            a;
        e.callParent();
        if (!e.hasOwnProperty(j)) {
            e[j] = "100%"
        }
        if (!e.hasOwnProperty(c)) {
            e[c] = 5
        }
        if (g.collapsed) {
            e.addCls(e.collapsedClsInternal)
        }
        a = e.baseCls + "-" + e.orientation;
        e.addCls(a);
        if (!e.canResize) {
            e.addCls(a + "-noresize")
        }
        Ext.applyIf(e.renderData, {
            collapseDir: i,
            collapsible: e.collapsible || g.collapsible
        })
    },
    onRender: function() {
        var a = this;
        a.callParent(arguments);
        if (a.performCollapse !== false) {
            if (a.renderData.collapsible) {
                a.mon(a.collapseEl, "click", a.toggleTargetCmp, a)
            }
            if (a.collapseOnDblClick) {
                a.mon(a.el, "dblclick", a.toggleTargetCmp, a)
            }
        }
        a.mon(a.getCollapseTarget(), {
            collapse: a.onTargetCollapse,
            expand: a.onTargetExpand,
            scope: a
        });
        a.el.unselectable();
        if (a.canResize) {
            a.tracker = Ext.create(a.getTrackerConfig());
            a.relayEvents(a.tracker, ["beforedragstart", "dragstart", "dragend"])
        }
    },
    getCollapseDirection: function() {
        var i = this,
            d = i.collapseDirection,
            g, a, c, e;
        if (!d) {
            g = i.collapseTarget;
            if (g.isComponent) {
                d = g.collapseDirection
            }
            if (!d) {
                e = i.ownerCt.layout.type;
                if (g.isComponent) {
                    c = i.ownerCt.items;
                    a = Number(c.indexOf(g) == c.indexOf(i) - 1) << 1 | Number(e == "hbox")
                } else {
                    a = Number(i.collapseTarget == "prev") << 1 | Number(e == "hbox")
                }
                d = ["bottom", "right", "top", "left"][a]
            }
            i.collapseDirection = d
        }
        i.orientation = (d == "top" || d == "bottom") ? "horizontal" : "vertical";
        i[i.orientation] = true;
        return d
    },
    getCollapseTarget: function() {
        var a = this;
        return a.collapseTarget.isComponent ? a.collapseTarget : a.collapseTarget == "prev" ? a.previousSibling() : a.nextSibling()
    },
    onTargetCollapse: function(a) {
        this.el.addCls([this.collapsedClsInternal, this.collapsedCls])
    },
    onTargetExpand: function(a) {
        this.el.removeCls([this.collapsedClsInternal, this.collapsedCls])
    },
    toggleTargetCmp: function(g, c) {
        var d = this.getCollapseTarget(),
            i = d.placeholder,
            a;
        if (i && !i.hidden) {
            a = true
        } else {
            a = !d.hidden
        }
        if (a) {
            if (d.collapsed) {
                d.expand()
            } else {
                if (d.collapseDirection) {
                    d.collapse()
                } else {
                    d.collapse(this.renderData.collapseDir)
                }
            }
        }
    },
    setSize: function() {
        var a = this;
        a.callParent(arguments);
        if (Ext.isIE && a.el) {
            a.el.repaint()
        }
    },
    beforeDestroy: function() {
        Ext.destroy(this.tracker);
        this.callParent()
    }
});
Ext.define("Ext.resizer.BorderSplitter", {
    extend: "Ext.resizer.Splitter",
    uses: ["Ext.resizer.BorderSplitterTracker"],
    alias: "widget.bordersplitter",
    collapseTarget: null,
    getTrackerConfig: function() {
        var a = this.callParent();
        a.xclass = "Ext.resizer.BorderSplitterTracker";
        return a
    }
});
Ext.define("Ext.fx.target.Target", {
    isAnimTarget: true,
    constructor: function(a) {
        this.target = a;
        this.id = this.getId()
    },
    getId: function() {
        return this.target.id
    }
});
Ext.define("Ext.fx.target.Element", {
    extend: "Ext.fx.target.Target",
    type: "element",
    getElVal: function(c, a, d) {
        if (d == undefined) {
            if (a === "x") {
                d = c.getX()
            } else {
                if (a === "y") {
                    d = c.getY()
                } else {
                    if (a === "scrollTop") {
                        d = c.getScroll().top
                    } else {
                        if (a === "scrollLeft") {
                            d = c.getScroll().left
                        } else {
                            if (a === "height") {
                                d = c.getHeight()
                            } else {
                                if (a === "width") {
                                    d = c.getWidth()
                                } else {
                                    d = c.getStyle(a)
                                }
                            }
                        }
                    }
                }
            }
        }
        return d
    },
    getAttr: function(a, d) {
        var c = this.target;
        return [
            [c, this.getElVal(c, a, d)]
        ]
    },
    setAttr: function(n) {
        var k = this.target,
            m = n.length,
            q, l, c, g, d, a, e, p;
        for (g = 0; g < m; g++) {
            q = n[g].attrs;
            for (l in q) {
                if (q.hasOwnProperty(l)) {
                    a = q[l].length;
                    for (d = 0; d < a; d++) {
                        c = q[l][d];
                        e = c[0];
                        p = c[1];
                        if (l === "x") {
                            e.setX(p)
                        } else {
                            if (l === "y") {
                                e.setY(p)
                            } else {
                                if (l === "scrollTop") {
                                    e.scrollTo("top", p)
                                } else {
                                    if (l === "scrollLeft") {
                                        e.scrollTo("left", p)
                                    } else {
                                        if (l === "width") {
                                            e.setWidth(p)
                                        } else {
                                            if (l === "height") {
                                                e.setHeight(p)
                                            } else {
                                                e.setStyle(l, p)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
});
Ext.define("Ext.fx.target.ElementCSS", {
    extend: "Ext.fx.target.Element",
    setAttr: function(q, g) {
        var s = {
                attrs: [],
                duration: [],
                easing: []
            },
            p = q.length,
            k, r, m, n, d, c, l, e, a;
        for (l = 0; l < p; l++) {
            r = q[l];
            d = r.duration;
            n = r.easing;
            r = r.attrs;
            for (m in r) {
                if (Ext.Array.indexOf(s.attrs, m) == -1) {
                    s.attrs.push(m.replace(/[A-Z]/g, function(i) {
                        return "-" + i.toLowerCase()
                    }));
                    s.duration.push(d + "ms");
                    s.easing.push(n)
                }
            }
        }
        k = s.attrs.join(",");
        d = s.duration.join(",");
        n = s.easing.join(", ");
        for (l = 0; l < p; l++) {
            r = q[l].attrs;
            for (m in r) {
                a = r[m].length;
                for (e = 0; e < a; e++) {
                    c = r[m][e];
                    c[0].setStyle(Ext.supports.CSS3Prefix + "TransitionProperty", g ? "" : k);
                    c[0].setStyle(Ext.supports.CSS3Prefix + "TransitionDuration", g ? "" : d);
                    c[0].setStyle(Ext.supports.CSS3Prefix + "TransitionTimingFunction", g ? "" : n);
                    c[0].setStyle(m, c[1]);
                    if (g) {
                        c = c[0].dom.offsetWidth
                    } else {
                        c[0].on(Ext.supports.CSS3TransitionEnd, function() {
                            this.setStyle(Ext.supports.CSS3Prefix + "TransitionProperty", null);
                            this.setStyle(Ext.supports.CSS3Prefix + "TransitionDuration", null);
                            this.setStyle(Ext.supports.CSS3Prefix + "TransitionTimingFunction", null)
                        }, c[0], {
                            single: true
                        })
                    }
                }
            }
        }
    }
});
Ext.define("Ext.fx.target.CompositeElement", {
    extend: "Ext.fx.target.Element",
    isComposite: true,
    constructor: function(a) {
        a.id = a.id || Ext.id(null, "ext-composite-");
        this.callParent([a])
    },
    getAttr: function(a, k) {
        var c = [],
            j = this.target.elements,
            g = j.length,
            d, e;
        for (d = 0; d < g; d++) {
            e = j[d];
            if (e) {
                e = this.target.getElement(e);
                c.push([e, this.getElVal(e, a, k)])
            }
        }
        return c
    }
});
Ext.define("Ext.fx.target.CompositeElementCSS", {
    extend: "Ext.fx.target.CompositeElement",
    requires: ["Ext.fx.target.ElementCSS"],
    setAttr: function() {
        return Ext.fx.target.ElementCSS.prototype.setAttr.apply(this, arguments)
    }
});
Ext.define("Ext.fx.target.Sprite", {
    extend: "Ext.fx.target.Target",
    type: "draw",
    getFromPrim: function(c, a) {
        var d;
        switch (a) {
            case "rotate":
            case "rotation":
                d = c.attr.rotation;
                return {
                    x: d.x || 0,
                    y: d.y || 0,
                    degrees: d.degrees || 0
                };
            case "scale":
            case "scaling":
                d = c.attr.scaling;
                return {
                    x: d.x || 1,
                    y: d.y || 1,
                    cx: d.cx || 0,
                    cy: d.cy || 0
                };
            case "translate":
            case "translation":
                d = c.attr.translation;
                return {
                    x: d.x || 0,
                    y: d.y || 0
                };
            default:
                return c.attr[a]
        }
    },
    getAttr: function(a, c) {
        return [
            [this.target, c != undefined ? c : this.getFromPrim(this.target, a)]
        ]
    },
    setAttr: function(o) {
        var k = o.length,
            m = [],
            c, g, r, t, s, q, p, e, d, n, l, a;
        for (e = 0; e < k; e++) {
            c = o[e].attrs;
            for (g in c) {
                r = c[g];
                a = r.length;
                for (d = 0; d < a; d++) {
                    s = r[d][0];
                    t = r[d][1];
                    if (g === "translate" || g === "translation") {
                        p = {
                            x: t.x,
                            y: t.y
                        }
                    } else {
                        if (g === "rotate" || g === "rotation") {
                            n = t.x;
                            if (isNaN(n)) {
                                n = null
                            }
                            l = t.y;
                            if (isNaN(l)) {
                                l = null
                            }
                            p = {
                                degrees: t.degrees,
                                x: n,
                                y: l
                            }
                        } else {
                            if (g === "scale" || g === "scaling") {
                                n = t.x;
                                if (isNaN(n)) {
                                    n = null
                                }
                                l = t.y;
                                if (isNaN(l)) {
                                    l = null
                                }
                                p = {
                                    x: n,
                                    y: l,
                                    cx: t.cx,
                                    cy: t.cy
                                }
                            } else {
                                if (g === "width" || g === "height" || g === "x" || g === "y") {
                                    p = parseFloat(t)
                                } else {
                                    p = t
                                }
                            }
                        }
                    }
                    q = Ext.Array.indexOf(m, s);
                    if (q == -1) {
                        m.push([s, {}]);
                        q = m.length - 1
                    }
                    m[q][1][g] = p
                }
            }
        }
        k = m.length;
        for (e = 0; e < k; e++) {
            m[e][0].setAttributes(m[e][1])
        }
        this.target.redraw()
    }
});
Ext.define("Ext.fx.target.CompositeSprite", {
    extend: "Ext.fx.target.Sprite",
    getAttr: function(a, k) {
        var c = [],
            j = [].concat(this.target.items),
            g = j.length,
            e, d;
        for (e = 0; e < g; e++) {
            d = j[e];
            c.push([d, k != undefined ? k : this.getFromPrim(d, a)])
        }
        return c
    }
});
Ext.define("Ext.fx.target.Component", {
    extend: "Ext.fx.target.Target",
    type: "component",
    getPropMethod: {
        top: function() {
            return this.getPosition(true)[1]
        },
        left: function() {
            return this.getPosition(true)[0]
        },
        x: function() {
            return this.getPosition()[0]
        },
        y: function() {
            return this.getPosition()[1]
        },
        height: function() {
            return this.getHeight()
        },
        width: function() {
            return this.getWidth()
        },
        opacity: function() {
            return this.el.getStyle("opacity")
        }
    },
    compMethod: {
        top: "setPosition",
        left: "setPosition",
        x: "setPagePosition",
        y: "setPagePosition",
        height: "setSize",
        width: "setSize",
        opacity: "setOpacity"
    },
    getAttr: function(a, c) {
        return [
            [this.target, c !== undefined ? c : this.getPropMethod[a].call(this.target)]
        ]
    },
    setAttr: function(u, g, c) {
        var s = this,
            n = s.target,
            r = u.length,
            x, p, a, k, e, q, m, d, t, v, l;
        for (k = 0; k < r; k++) {
            x = u[k].attrs;
            for (p in x) {
                m = x[p].length;
                q = {
                    setPosition: {},
                    setPagePosition: {},
                    setSize: {},
                    setOpacity: {}
                };
                for (e = 0; e < m; e++) {
                    a = x[p][e];
                    q[s.compMethod[p]].target = a[0];
                    q[s.compMethod[p]][p] = a[1]
                }
                if (q.setPosition.target) {
                    a = q.setPosition;
                    d = (a.left === undefined) ? undefined : parseFloat(a.left);
                    t = (a.top === undefined) ? undefined : parseFloat(a.top);
                    a.target.setPosition(d, t)
                }
                if (q.setPagePosition.target) {
                    a = q.setPagePosition;
                    a.target.setPagePosition(a.x, a.y)
                }
                if (q.setSize.target) {
                    a = q.setSize;
                    v = (a.width === undefined) ? a.target.getWidth() : parseFloat(a.width);
                    l = (a.height === undefined) ? a.target.getHeight() : parseFloat(a.height);
                    if (c || s.dynamic) {
                        a.target.setSize(v, l)
                    } else {
                        a.target.el.setSize(v, l)
                    }
                }
                if (q.setOpacity.target) {
                    a = q.setOpacity;
                    a.target.el.setStyle("opacity", a.opacity)
                }
            }
        }
    }
});
Ext.define("Ext.fx.Queue", {
    requires: ["Ext.util.HashMap"],
    constructor: function() {
        this.targets = new Ext.util.HashMap();
        this.fxQueue = {}
    },
    getFxDefaults: function(a) {
        var c = this.targets.get(a);
        if (c) {
            return c.fxDefaults
        }
        return {}
    },
    setFxDefaults: function(a, d) {
        var c = this.targets.get(a);
        if (c) {
            c.fxDefaults = Ext.apply(c.fxDefaults || {}, d)
        }
    },
    stopAnimation: function(c) {
        var e = this,
            a = e.getFxQueue(c),
            d = a.length;
        while (d) {
            a[d - 1].end();
            d--
        }
    },
    getActiveAnimation: function(c) {
        var a = this.getFxQueue(c);
        return (a && !!a.length) ? a[0] : false
    },
    hasFxBlock: function(c) {
        var a = this.getFxQueue(c);
        return a && a[0] && a[0].block
    },
    getFxQueue: function(c) {
        if (!c) {
            return false
        }
        var d = this,
            a = d.fxQueue[c],
            e = d.targets.get(c);
        if (!e) {
            return false
        }
        if (!a) {
            d.fxQueue[c] = [];
            if (e.type != "element") {
                e.target.on("destroy", function() {
                    d.fxQueue[c] = []
                })
            }
        }
        return d.fxQueue[c]
    },
    queueFx: function(e) {
        var d = this,
            g = e.target,
            a, c;
        if (!g) {
            return
        }
        a = d.getFxQueue(g.getId());
        c = a.length;
        if (c) {
            if (e.concurrent) {
                e.paused = false
            } else {
                a[c - 1].on("afteranimate", function() {
                    e.paused = false
                })
            }
        } else {
            e.paused = false
        }
        e.on("afteranimate", function() {
            Ext.Array.remove(a, e);
            if (e.remove) {
                if (g.type == "element") {
                    var i = Ext.get(g.id);
                    if (i) {
                        i.remove()
                    }
                }
            }
        }, this);
        a.push(e)
    }
});
Ext.define("Ext.fx.Manager", {
    singleton: true,
    requires: ["Ext.util.MixedCollection", "Ext.fx.target.Element", "Ext.fx.target.ElementCSS", "Ext.fx.target.CompositeElement", "Ext.fx.target.CompositeElementCSS", "Ext.fx.target.Sprite", "Ext.fx.target.CompositeSprite", "Ext.fx.target.Component"],
    mixins: {
        queue: "Ext.fx.Queue"
    },
    constructor: function() {
        this.items = new Ext.util.MixedCollection();
        this.mixins.queue.constructor.call(this)
    },
    interval: 16,
    forceJS: true,
    createTarget: function(e) {
        var c = this,
            d = !c.forceJS && Ext.supports.Transitions,
            a;
        c.useCSS3 = d;
        if (e) {
            if (e.tagName || Ext.isString(e) || e.isFly) {
                e = Ext.get(e);
                a = new Ext.fx.target["Element" + (d ? "CSS" : "")](e)
            } else {
                if (e.dom) {
                    a = new Ext.fx.target["Element" + (d ? "CSS" : "")](e)
                } else {
                    if (e.isComposite) {
                        a = new Ext.fx.target["CompositeElement" + (d ? "CSS" : "")](e)
                    } else {
                        if (e.isSprite) {
                            a = new Ext.fx.target.Sprite(e)
                        } else {
                            if (e.isCompositeSprite) {
                                a = new Ext.fx.target.CompositeSprite(e)
                            } else {
                                if (e.isComponent) {
                                    a = new Ext.fx.target.Component(e)
                                } else {
                                    if (e.isAnimTarget) {
                                        return e
                                    } else {
                                        return null
                                    }
                                }
                            }
                        }
                    }
                }
            }
            c.targets.add(a);
            return a
        } else {
            return null
        }
    },
    addAnim: function(d) {
        var c = this.items,
            a = this.task;
        c.add(d.id, d);
        if (!a && c.length) {
            a = this.task = {
                run: this.runner,
                interval: this.interval,
                scope: this
            };
            Ext.TaskManager.start(a)
        }
    },
    removeAnim: function(e) {
        var d = this,
            c = d.items,
            a = d.task;
        c.removeAtKey(e.id);
        if (a && !c.length) {
            Ext.TaskManager.stop(a);
            delete d.task
        }
    },
    runner: function() {
        var e = this,
            c = e.items.getRange(),
            d = 0,
            a = c.length,
            g;
        e.targetArr = {};
        e.timestamp = new Date();
        for (; d < a; d++) {
            g = c[d];
            if (g.isReady()) {
                e.startAnim(g)
            }
        }
        for (d = 0; d < a; d++) {
            g = c[d];
            if (g.isRunning()) {
                e.runAnim(g)
            }
        }
        e.applyPendingAttrs()
    },
    startAnim: function(a) {
        a.start(this.timestamp)
    },
    runAnim: function(g) {
        if (!g) {
            return
        }
        var e = this,
            c = g.target.getId(),
            j = e.useCSS3 && g.target.type == "element",
            a = e.timestamp - g.startTime,
            d = (a >= g.duration),
            i, k;
        i = this.collectTargetData(g, a, j, d);
        if (j) {
            g.target.setAttr(i.anims[g.id].attributes, true);
            e.collectTargetData(g, g.duration, j, d);
            g.paused = true;
            i = g.target.target;
            if (g.target.isComposite) {
                i = g.target.target.last()
            }
            k = {};
            k[Ext.supports.CSS3TransitionEnd] = g.lastFrame;
            k.scope = g;
            k.single = true;
            i.on(k)
        }
    },
    collectTargetData: function(d, a, g, i) {
        var c = d.target.getId(),
            e = this.targetArr[c];
        if (!e) {
            e = this.targetArr[c] = {
                id: c,
                el: d.target,
                anims: {}
            }
        }
        e.anims[d.id] = {
            id: d.id,
            anim: d,
            elapsed: a,
            isLastFrame: i,
            attributes: [{
                duration: d.duration,
                easing: (g && d.reverse) ? d.easingFn.reverse().toCSS3() : d.easing,
                attrs: d.runAnim(a)
            }]
        };
        return e
    },
    applyPendingAttrs: function() {
        var g = this.targetArr,
            i, d, c, e, a;
        for (d in g) {
            if (g.hasOwnProperty(d)) {
                i = g[d];
                for (a in i.anims) {
                    if (i.anims.hasOwnProperty(a)) {
                        c = i.anims[a];
                        e = c.anim;
                        if (c.attributes && e.isRunning()) {
                            i.el.setAttr(c.attributes, false, c.isLastFrame);
                            if (c.isLastFrame) {
                                e.lastFrame()
                            }
                        }
                    }
                }
            }
        }
    }
});
Ext.define("Ext.fx.Animator", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.fx.Manager"],
    isAnimator: true,
    duration: 250,
    delay: 0,
    delayStart: 0,
    dynamic: false,
    easing: "ease",
    running: false,
    paused: false,
    damper: 1,
    iterations: 1,
    currentIteration: 0,
    keyframeStep: 0,
    animKeyFramesRE: /^(from|to|\d+%?)$/,
    constructor: function(a) {
        var c = this;
        a = Ext.apply(c, a || {});
        c.config = a;
        c.id = Ext.id(null, "ext-animator-");
        c.addEvents("beforeanimate", "keyframe", "afteranimate");
        c.mixins.observable.constructor.call(c, a);
        c.timeline = [];
        c.createTimeline(c.keyframes);
        if (c.target) {
            c.applyAnimator(c.target);
            Ext.fx.Manager.addAnim(c)
        }
    },
    sorter: function(d, c) {
        return d.pct - c.pct
    },
    createTimeline: function(j) {
        var m = this,
            p = [],
            n = m.to || {},
            d = m.duration,
            q, a, g, l, o, c, e, k;
        for (o in j) {
            if (j.hasOwnProperty(o) && m.animKeyFramesRE.test(o)) {
                k = {
                    attrs: Ext.apply(j[o], n)
                };
                if (o == "from") {
                    o = 0
                } else {
                    if (o == "to") {
                        o = 100
                    }
                }
                k.pct = parseInt(o, 10);
                p.push(k)
            }
        }
        Ext.Array.sort(p, m.sorter);
        l = p.length;
        for (g = 0; g < l; g++) {
            q = (p[g - 1]) ? d * (p[g - 1].pct / 100) : 0;
            a = d * (p[g].pct / 100);
            m.timeline.push({
                duration: a - q,
                attrs: p[g].attrs
            })
        }
    },
    applyAnimator: function(g) {
        var m = this,
            n = [],
            q = m.timeline,
            j = m.reverse,
            l = q.length,
            c, k, a, e, p, o, d;
        if (m.fireEvent("beforeanimate", m) !== false) {
            for (d = 0; d < l; d++) {
                c = q[d];
                p = c.attrs;
                k = p.easing || m.easing;
                a = p.damper || m.damper;
                delete p.easing;
                delete p.damper;
                c = new Ext.fx.Anim({
                    target: g,
                    easing: k,
                    damper: a,
                    duration: c.duration,
                    paused: true,
                    to: p
                });
                n.push(c)
            }
            m.animations = n;
            m.target = c.target;
            for (d = 0; d < l - 1; d++) {
                c = n[d];
                c.nextAnim = n[d + 1];
                c.on("afteranimate", function() {
                    this.nextAnim.paused = false
                });
                c.on("afteranimate", function() {
                    this.fireEvent("keyframe", this, ++this.keyframeStep)
                }, m)
            }
            n[l - 1].on("afteranimate", function() {
                this.lastFrame()
            }, m)
        }
    },
    start: function(e) {
        var g = this,
            d = g.delay,
            c = g.delayStart,
            a;
        if (d) {
            if (!c) {
                g.delayStart = e;
                return
            } else {
                a = e - c;
                if (a < d) {
                    return
                } else {
                    e = new Date(c.getTime() + d)
                }
            }
        }
        if (g.fireEvent("beforeanimate", g) !== false) {
            g.startTime = e;
            g.running = true;
            g.animations[g.keyframeStep].paused = false
        }
    },
    lastFrame: function() {
        var d = this,
            a = d.iterations,
            c = d.currentIteration;
        c++;
        if (c < a) {
            d.startTime = new Date();
            d.currentIteration = c;
            d.keyframeStep = 0;
            d.applyAnimator(d.target);
            d.animations[d.keyframeStep].paused = false
        } else {
            d.currentIteration = 0;
            d.end()
        }
    },
    end: function() {
        var a = this;
        a.fireEvent("afteranimate", a, a.startTime, new Date() - a.startTime)
    },
    isReady: function() {
        return this.paused === false && this.running === false && this.iterations > 0
    },
    isRunning: function() {
        return false
    }
});
Ext.define("Ext.fx.CubicBezier", {
    singleton: true,
    cubicBezierAtTime: function(q, e, c, p, o, k) {
        var l = 3 * e,
            n = 3 * (p - e) - l,
            a = 1 - l - n,
            j = 3 * c,
            m = 3 * (o - c) - j,
            r = 1 - j - m;

        function i(s) {
            return ((a * s + n) * s + l) * s
        }

        function d(s, v) {
            var u = g(s, v);
            return ((r * u + m) * u + j) * u
        }

        function g(s, B) {
            var A, z, v, t, y, u;
            for (v = s, u = 0; u < 8; u++) {
                t = i(v) - s;
                if (Math.abs(t) < B) {
                    return v
                }
                y = (3 * a * v + 2 * n) * v + l;
                if (Math.abs(y) < 0.000001) {
                    break
                }
                v = v - t / y
            }
            A = 0;
            z = 1;
            v = s;
            if (v < A) {
                return A
            }
            if (v > z) {
                return z
            }
            while (A < z) {
                t = i(v);
                if (Math.abs(t - s) < B) {
                    return v
                }
                if (s > t) {
                    A = v
                } else {
                    z = v
                }
                v = (z - A) / 2 + A
            }
            return v
        }
        return d(q, 1 / (200 * k))
    },
    cubicBezier: function(c, g, a, d) {
        var e = function(i) {
            return Ext.fx.CubicBezier.cubicBezierAtTime(i, c, g, a, d, 1)
        };
        e.toCSS3 = function() {
            return "cubic-bezier(" + [c, g, a, d].join(",") + ")"
        };
        e.reverse = function() {
            return Ext.fx.CubicBezier.cubicBezier(1 - a, 1 - d, 1 - c, 1 - g)
        };
        return e
    }
});
Ext.ns("Ext.fx");
Ext.require("Ext.fx.CubicBezier", function() {
    var g = Math,
        j = g.PI,
        e = g.pow,
        c = g.sin,
        i = g.sqrt,
        a = g.abs,
        d = 1.70158;
    Ext.fx.Easing = {};
    Ext.apply(Ext.fx.Easing, {
        linear: function(k) {
            return k
        },
        ease: function(o) {
            var k = 0.07813 - o / 2,
                p = -0.25,
                r = i(0.0066 + k * k),
                u = r - k,
                m = e(a(u), 1 / 3) * (u < 0 ? -1 : 1),
                s = -r - k,
                l = e(a(s), 1 / 3) * (s < 0 ? -1 : 1),
                v = m + l + 0.25;
            return e(1 - v, 2) * 3 * v * 0.1 + (1 - v) * 3 * v * v + v * v * v
        },
        easeIn: function(k) {
            return e(k, 1.7)
        },
        easeOut: function(k) {
            return e(k, 0.48)
        },
        easeInOut: function(u) {
            var o = 0.48 - u / 1.04,
                m = i(0.1734 + o * o),
                k = m - o,
                s = e(a(k), 1 / 3) * (k < 0 ? -1 : 1),
                r = -m - o,
                p = e(a(r), 1 / 3) * (r < 0 ? -1 : 1),
                l = s + p + 0.5;
            return (1 - l) * 3 * l * l + l * l * l
        },
        backIn: function(k) {
            return k * k * ((d + 1) * k - d)
        },
        backOut: function(k) {
            k = k - 1;
            return k * k * ((d + 1) * k + d) + 1
        },
        elasticIn: function(m) {
            if (m === 0 || m === 1) {
                return m
            }
            var l = 0.3,
                k = l / 4;
            return e(2, -10 * m) * c((m - k) * (2 * j) / l) + 1
        },
        elasticOut: function(k) {
            return 1 - Ext.fx.Easing.elasticIn(1 - k)
        },
        bounceIn: function(k) {
            return 1 - Ext.fx.Easing.bounceOut(1 - k)
        },
        bounceOut: function(q) {
            var m = 7.5625,
                o = 2.75,
                k;
            if (q < (1 / o)) {
                k = m * q * q
            } else {
                if (q < (2 / o)) {
                    q -= (1.5 / o);
                    k = m * q * q + 0.75
                } else {
                    if (q < (2.5 / o)) {
                        q -= (2.25 / o);
                        k = m * q * q + 0.9375
                    } else {
                        q -= (2.625 / o);
                        k = m * q * q + 0.984375
                    }
                }
            }
            return k
        }
    });
    Ext.apply(Ext.fx.Easing, {
        "back-in": Ext.fx.Easing.backIn,
        "back-out": Ext.fx.Easing.backOut,
        "ease-in": Ext.fx.Easing.easeIn,
        "ease-out": Ext.fx.Easing.easeOut,
        "elastic-in": Ext.fx.Easing.elasticIn,
        "elastic-out": Ext.fx.Easing.elasticIn,
        "bounce-in": Ext.fx.Easing.bounceIn,
        "bounce-out": Ext.fx.Easing.bounceOut,
        "ease-in-out": Ext.fx.Easing.easeInOut
    })
});
Ext.define("Ext.draw.Color", {
    colorToHexRe: /(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/,
    rgbRe: /\s*rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)\s*/,
    hexRe: /\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/,
    lightnessFactor: 0.2,
    constructor: function(e, d, a) {
        var c = this,
            g = Ext.Number.constrain;
        c.r = g(e, 0, 255);
        c.g = g(d, 0, 255);
        c.b = g(a, 0, 255)
    },
    getRed: function() {
        return this.r
    },
    getGreen: function() {
        return this.g
    },
    getBlue: function() {
        return this.b
    },
    getRGB: function() {
        var a = this;
        return [a.r, a.g, a.b]
    },
    getHSL: function() {
        var j = this,
            a = j.r / 255,
            i = j.g / 255,
            k = j.b / 255,
            m = Math.max(a, i, k),
            d = Math.min(a, i, k),
            n = m - d,
            e, o = 0,
            c = 0.5 * (m + d);
        if (d != m) {
            o = (c < 0.5) ? n / (m + d) : n / (2 - m - d);
            if (a == m) {
                e = 60 * (i - k) / n
            } else {
                if (i == m) {
                    e = 120 + 60 * (k - a) / n
                } else {
                    e = 240 + 60 * (a - i) / n
                }
            }
            if (e < 0) {
                e += 360
            }
            if (e >= 360) {
                e -= 360
            }
        }
        return [e, o, c]
    },
    getLighter: function(c) {
        var a = this.getHSL();
        c = c || this.lightnessFactor;
        a[2] = Ext.Number.constrain(a[2] + c, 0, 1);
        return this.fromHSL(a[0], a[1], a[2])
    },
    getDarker: function(a) {
        a = a || this.lightnessFactor;
        return this.getLighter(-a)
    },
    toString: function() {
        var i = this,
            c = Math.round,
            e = c(i.r).toString(16),
            d = c(i.g).toString(16),
            a = c(i.b).toString(16);
        e = (e.length == 1) ? "0" + e : e;
        d = (d.length == 1) ? "0" + d : d;
        a = (a.length == 1) ? "0" + a : a;
        return ["#", e, d, a].join("")
    },
    toHex: function(c) {
        if (Ext.isArray(c)) {
            c = c[0]
        }
        if (!Ext.isString(c)) {
            return ""
        }
        if (c.substr(0, 1) === "#") {
            return c
        }
        var g = this.colorToHexRe.exec(c),
            i, e, a, d;
        if (Ext.isArray(g)) {
            i = parseInt(g[2], 10);
            e = parseInt(g[3], 10);
            a = parseInt(g[4], 10);
            d = a | (e << 8) | (i << 16);
            return g[1] + "#" + ("000000" + d.toString(16)).slice(-6)
        } else {
            return c
        }
    },
    fromString: function(j) {
        var c, e, d, a, i = parseInt;
        if ((j.length == 4 || j.length == 7) && j.substr(0, 1) === "#") {
            c = j.match(this.hexRe);
            if (c) {
                e = i(c[1], 16) >> 0;
                d = i(c[2], 16) >> 0;
                a = i(c[3], 16) >> 0;
                if (j.length == 4) {
                    e += (e * 16);
                    d += (d * 16);
                    a += (a * 16)
                }
            }
        } else {
            c = j.match(this.rgbRe);
            if (c) {
                e = c[1];
                d = c[2];
                a = c[3]
            }
        }
        return (typeof e == "undefined") ? undefined : new Ext.draw.Color(e, d, a)
    },
    getGrayscale: function() {
        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11
    },
    fromHSL: function(j, p, e) {
        var a, c, d, g, n = [],
            o = Math.abs,
            k = Math.floor;
        if (p == 0 || j == null) {
            n = [e, e, e]
        } else {
            j /= 60;
            a = p * (1 - o(2 * e - 1));
            c = a * (1 - o(j - 2 * k(j / 2) - 1));
            d = e - a / 2;
            switch (k(j)) {
                case 0:
                    n = [a, c, 0];
                    break;
                case 1:
                    n = [c, a, 0];
                    break;
                case 2:
                    n = [0, a, c];
                    break;
                case 3:
                    n = [0, c, a];
                    break;
                case 4:
                    n = [c, 0, a];
                    break;
                case 5:
                    n = [a, 0, c];
                    break
            }
            n = [n[0] + d, n[1] + d, n[2] + d]
        }
        return new Ext.draw.Color(n[0] * 255, n[1] * 255, n[2] * 255)
    }
}, function() {
    var a = this.prototype;
    this.addStatics({
        fromHSL: function() {
            return a.fromHSL.apply(a, arguments)
        },
        fromString: function() {
            return a.fromString.apply(a, arguments)
        },
        toHex: function() {
            return a.toHex.apply(a, arguments)
        }
    })
});
Ext.define("Ext.draw.Draw", {
    singleton: true,
    requires: ["Ext.draw.Color"],
    pathToStringRE: /,?([achlmqrstvxz]),?/gi,
    pathCommandRE: /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
    pathValuesRE: /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
    stopsRE: /^(\d+%?)$/,
    radian: Math.PI / 180,
    availableAnimAttrs: {
        along: "along",
        blur: null,
        "clip-rect": "csv",
        cx: null,
        cy: null,
        fill: "color",
        "fill-opacity": null,
        "font-size": null,
        height: null,
        opacity: null,
        path: "path",
        r: null,
        rotation: "csv",
        rx: null,
        ry: null,
        scale: "csv",
        stroke: "color",
        "stroke-opacity": null,
        "stroke-width": null,
        translation: "csv",
        width: null,
        x: null,
        y: null
    },
    is: function(c, a) {
        a = String(a).toLowerCase();
        return (a == "object" && c === Object(c)) || (a == "undefined" && typeof c == a) || (a == "null" && c === null) || (a == "array" && Array.isArray && Array.isArray(c)) || (Object.prototype.toString.call(c).toLowerCase().slice(8, -1)) == a
    },
    ellipsePath: function(c) {
        var a = c.attr;
        return Ext.String.format("M{0},{1}A{2},{3},0,1,1,{0},{4}A{2},{3},0,1,1,{0},{1}z", a.x, a.y - a.ry, a.rx, a.ry, a.y + a.ry)
    },
    rectPath: function(c) {
        var a = c.attr;
        if (a.radius) {
            return Ext.String.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", a.x + a.radius, a.y, a.width - a.radius * 2, a.radius, -a.radius, a.height - a.radius * 2, a.radius * 2 - a.width, a.radius * 2 - a.height)
        } else {
            return Ext.String.format("M{0},{1}L{2},{1},{2},{3},{0},{3}z", a.x, a.y, a.width + a.x, a.height + a.y)
        }
    },
    path2string: function() {
        return this.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1")
    },
    pathToString: function(a) {
        return a.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1")
    },
    parsePathString: function(a) {
        if (!a) {
            return null
        }
        var e = {
                a: 7,
                c: 6,
                h: 1,
                l: 2,
                m: 2,
                q: 4,
                s: 4,
                t: 2,
                v: 1,
                z: 0
            },
            d = [],
            c = this;
        if (c.is(a, "array") && c.is(a[0], "array")) {
            d = c.pathClone(a)
        }
        if (!d.length) {
            String(a).replace(c.pathCommandRE, function(i, g, l) {
                var k = [],
                    j = g.toLowerCase();
                l.replace(c.pathValuesRE, function(n, m) {
                    m && k.push(+m)
                });
                if (j == "m" && k.length > 2) {
                    d.push([g].concat(Ext.Array.splice(k, 0, 2)));
                    j = "l";
                    g = (g == "m") ? "l" : "L"
                }
                while (k.length >= e[j]) {
                    d.push([g].concat(Ext.Array.splice(k, 0, e[j])));
                    if (!e[j]) {
                        break
                    }
                }
            })
        }
        d.toString = c.path2string;
        return d
    },
    mapPath: function(n, k) {
        if (!k) {
            return n
        }
        var l, g, d, m, a, e, c;
        n = this.path2curve(n);
        for (d = 0, m = n.length; d < m; d++) {
            c = n[d];
            for (a = 1, e = c.length; a < e - 1; a += 2) {
                l = k.x(c[a], c[a + 1]);
                g = k.y(c[a], c[a + 1]);
                c[a] = l;
                c[a + 1] = g
            }
        }
        return n
    },
    pathClone: function(k) {
        var d = [],
            a, g, c, e;
        if (!this.is(k, "array") || !this.is(k && k[0], "array")) {
            k = this.parsePathString(k)
        }
        for (c = 0, e = k.length; c < e; c++) {
            d[c] = [];
            for (a = 0, g = k[c].length; a < g; a++) {
                d[c][a] = k[c][a]
            }
        }
        d.toString = this.path2string;
        return d
    },
    pathToAbsolute: function(d) {
        if (!this.is(d, "array") || !this.is(d && d[0], "array")) {
            d = this.parsePathString(d)
        }
        var m = [],
            o = 0,
            n = 0,
            q = 0,
            p = 0,
            k = 0,
            l = d.length,
            c, e, g, a;
        if (l && d[0][0] == "M") {
            o = +d[0][1];
            n = +d[0][2];
            q = o;
            p = n;
            k++;
            m[0] = ["M", o, n]
        }
        for (; k < l; k++) {
            c = m[k] = [];
            e = d[k];
            if (e[0] != e[0].toUpperCase()) {
                c[0] = e[0].toUpperCase();
                switch (c[0]) {
                    case "A":
                        c[1] = e[1];
                        c[2] = e[2];
                        c[3] = e[3];
                        c[4] = e[4];
                        c[5] = e[5];
                        c[6] = +(e[6] + o);
                        c[7] = +(e[7] + n);
                        break;
                    case "V":
                        c[1] = +e[1] + n;
                        break;
                    case "H":
                        c[1] = +e[1] + o;
                        break;
                    case "M":
                        q = +e[1] + o;
                        p = +e[2] + n;
                    default:
                        g = 1;
                        a = e.length;
                        for (; g < a; g++) {
                            c[g] = +e[g] + ((g % 2) ? o : n)
                        }
                }
            } else {
                g = 0;
                a = e.length;
                for (; g < a; g++) {
                    m[k][g] = e[g]
                }
            }
            switch (c[0]) {
                case "Z":
                    o = q;
                    n = p;
                    break;
                case "H":
                    o = c[1];
                    break;
                case "V":
                    n = c[1];
                    break;
                case "M":
                    e = m[k];
                    a = e.length;
                    q = e[a - 2];
                    p = e[a - 1];
                default:
                    e = m[k];
                    a = e.length;
                    o = e[a - 2];
                    n = e[a - 1]
            }
        }
        m.toString = this.path2string;
        return m
    },
    pathToRelative: function(e) {
        if (!this.is(e, "array") || !this.is(e && e[0], "array")) {
            e = this.parsePathString(e)
        }
        var p = [],
            s = 0,
            q = 0,
            v = 0,
            u = 0,
            d = 0,
            a, t, m, l, g, o, z, n, c;
        if (e[0][0] == "M") {
            s = e[0][1];
            q = e[0][2];
            v = s;
            u = q;
            d++;
            p.push(["M", s, q])
        }
        for (m = d, z = e.length; m < z; m++) {
            a = p[m] = [];
            t = e[m];
            if (t[0] != t[0].toLowerCase()) {
                a[0] = t[0].toLowerCase();
                switch (a[0]) {
                    case "a":
                        a[1] = t[1];
                        a[2] = t[2];
                        a[3] = t[3];
                        a[4] = t[4];
                        a[5] = t[5];
                        a[6] = +(t[6] - s).toFixed(3);
                        a[7] = +(t[7] - q).toFixed(3);
                        break;
                    case "v":
                        a[1] = +(t[1] - q).toFixed(3);
                        break;
                    case "m":
                        v = t[1];
                        u = t[2];
                    default:
                        for (l = 1, n = t.length; l < n; l++) {
                            a[l] = +(t[l] - ((l % 2) ? s : q)).toFixed(3)
                        }
                }
            } else {
                a = p[m] = [];
                if (t[0] == "m") {
                    v = t[1] + s;
                    u = t[2] + q
                }
                for (g = 0, c = t.length; g < c; g++) {
                    p[m][g] = t[g]
                }
            }
            o = p[m].length;
            switch (p[m][0]) {
                case "z":
                    s = v;
                    q = u;
                    break;
                case "h":
                    s += +p[m][o - 1];
                    break;
                case "v":
                    q += +p[m][o - 1];
                    break;
                default:
                    s += +p[m][o - 2];
                    q += +p[m][o - 1]
            }
        }
        p.toString = this.path2string;
        return p
    },
    path2curve: function(m) {
        var e = this,
            k = e.pathToAbsolute(m),
            d = k.length,
            l = {
                x: 0,
                y: 0,
                bx: 0,
                by: 0,
                X: 0,
                Y: 0,
                qx: null,
                qy: null
            },
            c, a, j, g;
        for (c = 0; c < d; c++) {
            k[c] = e.command2curve(k[c], l);
            if (k[c].length > 7) {
                k[c].shift();
                g = k[c];
                while (g.length) {
                    Ext.Array.splice(k, c++, 0, ["C"].concat(Ext.Array.splice(g, 0, 6)))
                }
                Ext.Array.erase(k, c, 1);
                d = k.length;
                c--
            }
            a = k[c];
            j = a.length;
            l.x = a[j - 2];
            l.y = a[j - 1];
            l.bx = parseFloat(a[j - 4]) || l.x;
            l.by = parseFloat(a[j - 3]) || l.y
        }
        return k
    },
    interpolatePaths: function(t, n) {
        var l = this,
            e = l.pathToAbsolute(t),
            o = l.pathToAbsolute(n),
            q = {
                x: 0,
                y: 0,
                bx: 0,
                by: 0,
                X: 0,
                Y: 0,
                qx: null,
                qy: null
            },
            a = {
                x: 0,
                y: 0,
                bx: 0,
                by: 0,
                X: 0,
                Y: 0,
                qx: null,
                qy: null
            },
            c = function(p, u) {
                if (p[u].length > 7) {
                    p[u].shift();
                    var v = p[u];
                    while (v.length) {
                        Ext.Array.splice(p, u++, 0, ["C"].concat(Ext.Array.splice(v, 0, 6)))
                    }
                    Ext.Array.erase(p, u, 1);
                    r = Math.max(e.length, o.length || 0)
                }
            },
            d = function(y, x, u, p, v) {
                if (y && x && y[v][0] == "M" && x[v][0] != "M") {
                    Ext.Array.splice(x, v, 0, ["M", p.x, p.y]);
                    u.bx = 0;
                    u.by = 0;
                    u.x = y[v][1];
                    u.y = y[v][2];
                    r = Math.max(e.length, o.length || 0)
                }
            },
            k, r, j, s, g, m;
        for (k = 0, r = Math.max(e.length, o.length || 0); k < r; k++) {
            e[k] = l.command2curve(e[k], q);
            c(e, k);
            (o[k] = l.command2curve(o[k], a));
            c(o, k);
            d(e, o, q, a, k);
            d(o, e, a, q, k);
            j = e[k];
            s = o[k];
            g = j.length;
            m = s.length;
            q.x = j[g - 2];
            q.y = j[g - 1];
            q.bx = parseFloat(j[g - 4]) || q.x;
            q.by = parseFloat(j[g - 3]) || q.y;
            a.bx = (parseFloat(s[m - 4]) || a.x);
            a.by = (parseFloat(s[m - 3]) || a.y);
            a.x = s[m - 2];
            a.y = s[m - 1]
        }
        return [e, o]
    },
    command2curve: function(e, c) {
        var a = this;
        if (!e) {
            return ["C", c.x, c.y, c.x, c.y, c.x, c.y]
        }
        if (e[0] != "T" && e[0] != "Q") {
            c.qx = c.qy = null
        }
        switch (e[0]) {
            case "M":
                c.X = e[1];
                c.Y = e[2];
                break;
            case "A":
                e = ["C"].concat(a.arc2curve.apply(a, [c.x, c.y].concat(e.slice(1))));
                break;
            case "S":
                e = ["C", c.x + (c.x - (c.bx || c.x)), c.y + (c.y - (c.by || c.y))].concat(e.slice(1));
                break;
            case "T":
                c.qx = c.x + (c.x - (c.qx || c.x));
                c.qy = c.y + (c.y - (c.qy || c.y));
                e = ["C"].concat(a.quadratic2curve(c.x, c.y, c.qx, c.qy, e[1], e[2]));
                break;
            case "Q":
                c.qx = e[1];
                c.qy = e[2];
                e = ["C"].concat(a.quadratic2curve(c.x, c.y, e[1], e[2], e[3], e[4]));
                break;
            case "L":
                e = ["C"].concat(c.x, c.y, e[1], e[2], e[1], e[2]);
                break;
            case "H":
                e = ["C"].concat(c.x, c.y, e[1], c.y, e[1], c.y);
                break;
            case "V":
                e = ["C"].concat(c.x, c.y, c.x, e[1], c.x, e[1]);
                break;
            case "Z":
                e = ["C"].concat(c.x, c.y, c.X, c.Y, c.X, c.Y);
                break
        }
        return e
    },
    quadratic2curve: function(c, e, j, g, a, d) {
        var i = 1 / 3,
            k = 2 / 3;
        return [i * c + k * j, i * e + k * g, i * a + k * j, i * d + k * g, a, d]
    },
    rotate: function(c, j, a) {
        var e = Math.cos(a),
            d = Math.sin(a),
            i = c * e - j * d,
            g = c * d + j * e;
        return {
            x: i,
            y: g
        }
    },
    arc2curve: function(z, aj, L, J, D, p, l, v, ai, E) {
        var B = this,
            g = Math.PI,
            C = B.radian,
            I = g * 120 / 180,
            c = C * (+D || 0),
            Q = [],
            N = Math,
            X = N.cos,
            a = N.sin,
            Z = N.sqrt,
            A = N.abs,
            q = N.asin,
            M, d, s, S, R, ae, e, V, Y, G, F, o, n, u, m, ah, j, ag, T, W, U, af, ad, ac, aa, P, ab, O, H, K, r;
        if (!E) {
            M = B.rotate(z, aj, -c);
            z = M.x;
            aj = M.y;
            M = B.rotate(v, ai, -c);
            v = M.x;
            ai = M.y;
            d = X(C * D);
            s = a(C * D);
            S = (z - v) / 2;
            R = (aj - ai) / 2;
            ae = (S * S) / (L * L) + (R * R) / (J * J);
            if (ae > 1) {
                ae = Z(ae);
                L = ae * L;
                J = ae * J
            }
            e = L * L;
            V = J * J;
            Y = (p == l ? -1 : 1) * Z(A((e * V - e * R * R - V * S * S) / (e * R * R + V * S * S)));
            G = Y * L * R / J + (z + v) / 2;
            F = Y * -J * S / L + (aj + ai) / 2;
            o = q(((aj - F) / J).toFixed(7));
            n = q(((ai - F) / J).toFixed(7));
            o = z < G ? g - o : o;
            n = v < G ? g - n : n;
            if (o < 0) {
                o = g * 2 + o
            }
            if (n < 0) {
                n = g * 2 + n
            }
            if (l && o > n) {
                o = o - g * 2
            }
            if (!l && n > o) {
                n = n - g * 2
            }
        } else {
            o = E[0];
            n = E[1];
            G = E[2];
            F = E[3]
        }
        u = n - o;
        if (A(u) > I) {
            H = n;
            K = v;
            r = ai;
            n = o + I * (l && n > o ? 1 : -1);
            v = G + L * X(n);
            ai = F + J * a(n);
            Q = B.arc2curve(v, ai, L, J, D, 0, l, K, r, [n, H, G, F])
        }
        u = n - o;
        m = X(o);
        ah = a(o);
        j = X(n);
        ag = a(n);
        T = N.tan(u / 4);
        W = 4 / 3 * L * T;
        U = 4 / 3 * J * T;
        af = [z, aj];
        ad = [z + W * ah, aj - U * m];
        ac = [v + W * ag, ai - U * j];
        aa = [v, ai];
        ad[0] = 2 * af[0] - ad[0];
        ad[1] = 2 * af[1] - ad[1];
        if (E) {
            return [ad, ac, aa].concat(Q)
        } else {
            Q = [ad, ac, aa].concat(Q).join().split(",");
            P = [];
            O = Q.length;
            for (ab = 0; ab < O; ab++) {
                P[ab] = ab % 2 ? B.rotate(Q[ab - 1], Q[ab], c).y : B.rotate(Q[ab], Q[ab + 1], c).x
            }
            return P
        }
    },
    rotateAndTranslatePath: function(m) {
        var d = m.rotation.degrees,
            e = m.rotation.x,
            c = m.rotation.y,
            r = m.translation.x,
            n = m.translation.y,
            q, k, a, o, g, l = [];
        if (!d && !r && !n) {
            return this.pathToAbsolute(m.attr.path)
        }
        r = r || 0;
        n = n || 0;
        q = this.pathToAbsolute(m.attr.path);
        for (k = q.length; k--;) {
            a = l[k] = q[k].slice();
            if (a[0] == "A") {
                o = this.rotatePoint(a[6], a[7], d, e, c);
                a[6] = o.x + r;
                a[7] = o.y + n
            } else {
                g = 1;
                while (a[g + 1] != null) {
                    o = this.rotatePoint(a[g], a[g + 1], d, e, c);
                    a[g] = o.x + r;
                    a[g + 1] = o.y + n;
                    g += 2
                }
            }
        }
        return l
    },
    rotatePoint: function(c, j, g, a, i) {
        if (!g) {
            return {
                x: c,
                y: j
            }
        }
        a = a || 0;
        i = i || 0;
        c = c - a;
        j = j - i;
        g = g * this.radian;
        var e = Math.cos(g),
            d = Math.sin(g);
        return {
            x: c * e - j * d + a,
            y: c * d + j * e + i
        }
    },
    pathDimensions: function(o) {
        if (!o || !(o + "")) {
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        }
        o = this.path2curve(o);
        var m = 0,
            l = 0,
            e = [],
            c = [],
            g = 0,
            k = o.length,
            d, a, n, j;
        for (; g < k; g++) {
            d = o[g];
            if (d[0] == "M") {
                m = d[1];
                l = d[2];
                e.push(m);
                c.push(l)
            } else {
                j = this.curveDim(m, l, d[1], d[2], d[3], d[4], d[5], d[6]);
                e = e.concat(j.min.x, j.max.x);
                c = c.concat(j.min.y, j.max.y);
                m = d[5];
                l = d[6]
            }
        }
        a = Math.min.apply(0, e);
        n = Math.min.apply(0, c);
        return {
            x: a,
            y: n,
            path: o,
            width: Math.max.apply(0, e) - a,
            height: Math.max.apply(0, c) - n
        }
    },
    intersectInside: function(c, d, a) {
        return (a[0] - d[0]) * (c[1] - d[1]) > (a[1] - d[1]) * (c[0] - d[0])
    },
    intersectIntersection: function(q, o, i, g) {
        var d = [],
            c = i[0] - g[0],
            a = i[1] - g[1],
            m = q[0] - o[0],
            k = q[1] - o[1],
            n = i[0] * g[1] - i[1] * g[0],
            l = q[0] * o[1] - q[1] * o[0],
            j = 1 / (c * k - a * m);
        d[0] = (n * m - l * c) * j;
        d[1] = (n * k - l * a) * j;
        return d
    },
    intersect: function(q, d) {
        var p = this,
            m = 0,
            o = d.length,
            l = d[o - 1],
            t = q,
            k, u, n, r, a, c, g;
        for (; m < o; ++m) {
            k = d[m];
            c = t;
            t = [];
            u = c[c.length - 1];
            g = 0;
            a = c.length;
            for (; g < a; g++) {
                n = c[g];
                if (p.intersectInside(n, l, k)) {
                    if (!p.intersectInside(u, l, k)) {
                        t.push(p.intersectIntersection(u, n, l, k))
                    }
                    t.push(n)
                } else {
                    if (p.intersectInside(u, l, k)) {
                        t.push(p.intersectIntersection(u, n, l, k))
                    }
                }
                u = n
            }
            l = k
        }
        return t
    },
    bezier: function(i, g, n, m, e) {
        if (e === 0) {
            return i
        } else {
            if (e === 1) {
                return m
            }
        }
        var k = 1 - e,
            j = k * k * k,
            l = e / k;
        return j * (i + l * (3 * g + l * (3 * n + m * l)))
    },
    bezierDim: function(u, t, o, n) {
        var x = [],
            g, k, q, j, v, e, y, l, p, m;
        if (u + 3 * o == n + 3 * t) {
            g = u - t;
            g /= 2 * (u - t - t + o);
            if (g < 1 && g > 0) {
                x.push(g)
            }
        } else {
            k = u - 3 * t + 3 * o - n;
            q = 2 * (u - t - t + o);
            j = u - t;
            v = q * q - 4 * k * j;
            e = k + k;
            if (v === 0) {
                g = q / e;
                if (g < 1 && g > 0) {
                    x.push(g)
                }
            } else {
                if (v > 0) {
                    y = Math.sqrt(v);
                    g = (y + q) / e;
                    if (g < 1 && g > 0) {
                        x.push(g)
                    }
                    g = (q - y) / e;
                    if (g < 1 && g > 0) {
                        x.push(g)
                    }
                }
            }
        }
        l = Math.min(u, n);
        p = Math.max(u, n);
        for (m = 0; m < x.length; m++) {
            l = Math.min(l, this.bezier(u, t, o, n, x[m]));
            p = Math.max(p, this.bezier(u, t, o, n, x[m]))
        }
        return [l, p]
    },
    curveDim: function(c, a, e, d, m, l, j, g) {
        var k = this.bezierDim(c, e, m, j),
            i = this.bezierDim(a, d, l, g);
        return {
            min: {
                x: k[0],
                y: i[0]
            },
            max: {
                x: k[1],
                y: i[1]
            }
        }
    },
    getAnchors: function(g, e, m, l, y, x, s) {
        s = s || 4;
        var k = Math,
            r = k.PI,
            t = r / 2,
            o = k.abs,
            a = k.sin,
            c = k.cos,
            i = k.atan,
            v, u, j, n, q, p, A, z, d;
        v = (m - g) / s;
        u = (y - m) / s;
        if ((l >= e && l >= x) || (l <= e && l <= x)) {
            j = n = t
        } else {
            j = i((m - g) / o(l - e));
            if (e < l) {
                j = r - j
            }
            n = i((y - m) / o(l - x));
            if (x < l) {
                n = r - n
            }
        }
        d = t - ((j + n) % (r * 2)) / 2;
        if (d > t) {
            d -= r
        }
        j += d;
        n += d;
        q = m - v * a(j);
        p = l + v * c(j);
        A = m + u * a(n);
        z = l + u * c(n);
        if ((l > e && p < e) || (l < e && p > e)) {
            q += o(e - p) * (q - m) / (p - l);
            p = e
        }
        if ((l > x && z < x) || (l < x && z > x)) {
            A -= o(x - z) * (A - m) / (z - l);
            z = x
        }
        return {
            x1: q,
            y1: p,
            x2: A,
            y2: z
        }
    },
    smooth: function(a, t) {
        var s = this.path2curve(a),
            g = [s[0]],
            m = s[0][1],
            l = s[0][2],
            u, z, A = 1,
            n = s.length,
            k = 1,
            p = m,
            o = l,
            d = 0,
            c = 0,
            D, C, B, q, v, r, e;
        for (; A < n; A++) {
            D = s[A];
            C = D.length;
            B = s[A - 1];
            q = B.length;
            v = s[A + 1];
            r = v && v.length;
            if (D[0] == "M") {
                p = D[1];
                o = D[2];
                u = A + 1;
                while (s[u][0] != "C") {
                    u++
                }
                d = s[u][5];
                c = s[u][6];
                g.push(["M", p, o]);
                k = g.length;
                m = p;
                l = o;
                continue
            }
            if (D[C - 2] == p && D[C - 1] == o && (!v || v[0] == "M")) {
                e = g[k].length;
                z = this.getAnchors(B[q - 2], B[q - 1], p, o, g[k][e - 2], g[k][e - 1], t);
                g[k][1] = z.x2;
                g[k][2] = z.y2
            } else {
                if (!v || v[0] == "M") {
                    z = {
                        x1: D[C - 2],
                        y1: D[C - 1]
                    }
                } else {
                    z = this.getAnchors(B[q - 2], B[q - 1], D[C - 2], D[C - 1], v[r - 2], v[r - 1], t)
                }
            }
            g.push(["C", m, l, z.x1, z.y1, D[C - 2], D[C - 1]]);
            m = z.x2;
            l = z.y2
        }
        return g
    },
    findDotAtSegment: function(c, a, e, d, l, k, j, i, m) {
        var g = 1 - m;
        return {
            x: Math.pow(g, 3) * c + Math.pow(g, 2) * 3 * m * e + g * 3 * m * m * l + Math.pow(m, 3) * j,
            y: Math.pow(g, 3) * a + Math.pow(g, 2) * 3 * m * d + g * 3 * m * m * k + Math.pow(m, 3) * i
        }
    },
    snapEnds: function(t, u, e, p) {
        if (Ext.isDate(t)) {
            return this.snapEndsByDate(t, u, e)
        }
        var d = (u - t) / e,
            a = Math.floor(Math.log(d) / Math.LN10) + 1,
            g = Math.pow(10, a),
            v, r = Math.round((d % g) * Math.pow(10, 2 - a)),
            c = [
                [0, 15],
                [20, 4],
                [30, 2],
                [40, 4],
                [50, 9],
                [60, 4],
                [70, 2],
                [80, 4],
                [100, 15]
            ],
            k = 0,
            s, n, l, j, o = 1000000000,
            q = c.length;
        v = t = Math.floor(t / g) * g;
        if (p) {
            for (l = 0; l < q; l++) {
                s = c[l][0];
                n = (s - r) < 0 ? 1000000 : (s - r) / c[l][1];
                if (n < o) {
                    j = s;
                    o = n
                }
            }
            d = Math.floor(d * Math.pow(10, -a)) * Math.pow(10, a) + j * Math.pow(10, a - 2);
            while (v < u) {
                v += d;
                k++
            }
            u = +v.toFixed(10)
        } else {
            k = e
        }
        return {
            from: t,
            to: u,
            power: a,
            step: d,
            steps: k
        }
    },
    snapEndsByDate: function(m, n, c, o) {
        var g = false,
            k = [
                [Ext.Date.MILLI, [1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500]],
                [Ext.Date.SECOND, [1, 2, 3, 5, 10, 15, 30]],
                [Ext.Date.MINUTE, [1, 2, 3, 5, 10, 20, 30]],
                [Ext.Date.HOUR, [1, 2, 3, 4, 6, 12]],
                [Ext.Date.DAY, [1, 2, 3, 7, 14]],
                [Ext.Date.MONTH, [1, 2, 3, 4, 6]]
            ],
            i = k.length,
            l = false,
            d, e, a, p;
        for (p = 0; p < i; p++) {
            d = k[p];
            if (!l) {
                for (e = 0; e < d[1].length; e++) {
                    if (n < Ext.Date.add(m, d[0], d[1][e] * c)) {
                        g = [d[0], d[1][e]];
                        l = true;
                        break
                    }
                }
            }
        }
        if (!g) {
            a = this.snapEnds(m.getFullYear(), n.getFullYear() + 1, c, o);
            g = [Date.YEAR, Math.round(a.step)]
        }
        return this.snapEndsByDateAndStep(m, n, g, o)
    },
    snapEndsByDateAndStep: function(k, j, g, a) {
        var e = [k.getFullYear(), k.getMonth(), k.getDate(), k.getHours(), k.getMinutes(), k.getSeconds(), k.getMilliseconds()],
            c = 0,
            i, d;
        if (a) {
            i = k
        } else {
            switch (g[0]) {
                case Ext.Date.MILLI:
                    i = new Date(e[0], e[1], e[2], e[3], e[4], e[5], Math.floor(e[6] / g[1]) * g[1]);
                    break;
                case Ext.Date.SECOND:
                    i = new Date(e[0], e[1], e[2], e[3], e[4], Math.floor(e[5] / g[1]) * g[1], 0);
                    break;
                case Ext.Date.MINUTE:
                    i = new Date(e[0], e[1], e[2], e[3], Math.floor(e[4] / g[1]) * g[1], 0, 0);
                    break;
                case Ext.Date.HOUR:
                    i = new Date(e[0], e[1], e[2], Math.floor(e[3] / g[1]) * g[1], 0, 0, 0);
                    break;
                case Ext.Date.DAY:
                    i = new Date(e[0], e[1], Math.floor(e[2] - 1 / g[1]) * g[1] + 1, 0, 0, 0, 0);
                    break;
                case Ext.Date.MONTH:
                    i = new Date(e[0], Math.floor(e[1] / g[1]) * g[1], 1, 0, 0, 0, 0);
                    break;
                default:
                    i = new Date(Math.floor(e[0] / g[1]) * g[1], 0, 1, 0, 0, 0, 0);
                    break
            }
        }
        d = i;
        while (d < j) {
            d = Ext.Date.add(d, g[0], g[1]);
            c++
        }
        if (a) {
            d = j
        }
        return {
            from: +i,
            to: +d,
            step: (d - i) / c,
            steps: c
        }
    },
    sorter: function(d, c) {
        return d.offset - c.offset
    },
    rad: function(a) {
        return a % 360 * Math.PI / 180
    },
    degrees: function(a) {
        return a * 180 / Math.PI % 360
    },
    withinBox: function(a, d, c) {
        c = c || {};
        return (a >= c.x && a <= (c.x + c.width) && d >= c.y && d <= (c.y + c.height))
    },
    parseGradient: function(m) {
        var g = this,
            i = m.type || "linear",
            d = m.angle || 0,
            k = g.radian,
            n = m.stops,
            a = [],
            l, c, j, e;
        if (i == "linear") {
            c = [0, 0, Math.cos(d * k), Math.sin(d * k)];
            j = 1 / (Math.max(Math.abs(c[2]), Math.abs(c[3])) || 1);
            c[2] *= j;
            c[3] *= j;
            if (c[2] < 0) {
                c[0] = -c[2];
                c[2] = 0
            }
            if (c[3] < 0) {
                c[1] = -c[3];
                c[3] = 0
            }
        }
        for (l in n) {
            if (n.hasOwnProperty(l) && g.stopsRE.test(l)) {
                e = {
                    offset: parseInt(l, 10),
                    color: Ext.draw.Color.toHex(n[l].color) || "#ffffff",
                    opacity: n[l].opacity || 1
                };
                a.push(e)
            }
        }
        Ext.Array.sort(a, g.sorter);
        if (i == "linear") {
            return {
                id: m.id,
                type: i,
                vector: c,
                stops: a
            }
        } else {
            return {
                id: m.id,
                type: i,
                centerX: m.centerX,
                centerY: m.centerY,
                focalX: m.focalX,
                focalY: m.focalY,
                radius: m.radius,
                vector: c,
                stops: a
            }
        }
    }
});
Ext.define("Ext.fx.PropertyHandler", {
    requires: ["Ext.draw.Draw"],
    statics: {
        defaultHandler: {
            pixelDefaultsRE: /width|height|top$|bottom$|left$|right$/i,
            unitRE: /^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/,
            scrollRE: /^scroll/i,
            computeDelta: function(l, d, a, i, k) {
                a = (typeof a == "number") ? a : 1;
                var j = this.unitRE,
                    e = j.exec(l),
                    c, g;
                if (e) {
                    l = e[1];
                    g = e[2];
                    if (!this.scrollRE.test(k) && !g && this.pixelDefaultsRE.test(k)) {
                        g = "px"
                    }
                }
                l = +l || 0;
                e = j.exec(d);
                if (e) {
                    d = e[1];
                    g = e[2] || g
                }
                d = +d || 0;
                c = (i != null) ? i : l;
                return {
                    from: l,
                    delta: (d - c) * a,
                    units: g
                }
            },
            get: function(q, c, a, p, m) {
                var o = q.length,
                    e = [],
                    g, l, n, d, k;
                for (g = 0; g < o; g++) {
                    if (p) {
                        l = p[g][1].from
                    }
                    if (Ext.isArray(q[g][1]) && Ext.isArray(c)) {
                        n = [];
                        d = 0;
                        k = q[g][1].length;
                        for (; d < k; d++) {
                            n.push(this.computeDelta(q[g][1][d], c[d], a, l, m))
                        }
                        e.push([q[g][0], n])
                    } else {
                        e.push([q[g][0], this.computeDelta(q[g][1], c, a, l, m)])
                    }
                }
                return e
            },
            set: function(n, k) {
                var l = n.length,
                    d = [],
                    e, a, m, g, c;
                for (e = 0; e < l; e++) {
                    a = n[e][1];
                    if (Ext.isArray(a)) {
                        m = [];
                        c = 0;
                        g = a.length;
                        for (; c < g; c++) {
                            m.push(a[c].from + a[c].delta * k + (a[c].units || 0))
                        }
                        d.push([n[e][0], m])
                    } else {
                        d.push([n[e][0], a.from + a.delta * k + (a.units || 0)])
                    }
                }
                return d
            }
        },
        stringHandler: {
            computeDelta: function(g, c, e, d, a) {
                return {
                    from: g,
                    delta: c
                }
            },
            get: function(q, c, a, p, m) {
                var o = q.length,
                    e = [],
                    g, l, n, d, k;
                for (g = 0; g < o; g++) {
                    e.push([q[g][0], this.computeDelta(q[g][1], c, a, l, m)])
                }
                return e
            },
            set: function(n, k) {
                var l = n.length,
                    d = [],
                    e, a, m, g, c;
                for (e = 0; e < l; e++) {
                    a = n[e][1];
                    d.push([n[e][0], a.delta])
                }
                return d
            }
        },
        color: {
            rgbRE: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,
            hexRE: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,
            hex3RE: /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i,
            parseColor: function(g, a) {
                a = (typeof a == "number") ? a : 1;
                var j = false,
                    d = [this.hexRE, this.rgbRE, this.hex3RE],
                    e = d.length,
                    l, c, m, k;
                for (k = 0; k < e; k++) {
                    m = d[k];
                    c = (k % 2 === 0) ? 16 : 10;
                    l = m.exec(g);
                    if (l && l.length === 4) {
                        if (k === 2) {
                            l[1] += l[1];
                            l[2] += l[2];
                            l[3] += l[3]
                        }
                        j = {
                            red: parseInt(l[1], c),
                            green: parseInt(l[2], c),
                            blue: parseInt(l[3], c)
                        };
                        break
                    }
                }
                return j || g
            },
            computeDelta: function(j, a, g, d) {
                j = this.parseColor(j);
                a = this.parseColor(a, g);
                var i = d ? d : j,
                    c = typeof i,
                    e = typeof a;
                if (c == "string" || c == "undefined" || e == "string" || e == "undefined") {
                    return a || i
                }
                return {
                    from: j,
                    delta: {
                        red: Math.round((a.red - i.red) * g),
                        green: Math.round((a.green - i.green) * g),
                        blue: Math.round((a.blue - i.blue) * g)
                    }
                }
            },
            get: function(l, a, j, e) {
                var k = l.length,
                    d = [],
                    g, c;
                for (g = 0; g < k; g++) {
                    if (e) {
                        c = e[g][1].from
                    }
                    d.push([l[g][0], this.computeDelta(l[g][1], a, j, c)])
                }
                return d
            },
            set: function(m, g) {
                var j = m.length,
                    d = [],
                    e, c, a, k, l;
                for (e = 0; e < j; e++) {
                    c = m[e][1];
                    if (c) {
                        k = c.from;
                        l = c.delta;
                        c = (typeof c == "object" && "red" in c) ? "rgb(" + c.red + ", " + c.green + ", " + c.blue + ")" : c;
                        c = (typeof c == "object" && c.length) ? c[0] : c;
                        if (typeof c == "undefined") {
                            return []
                        }
                        a = typeof c == "string" ? c : "rgb(" + [(k.red + Math.round(l.red * g)) % 256, (k.green + Math.round(l.green * g)) % 256, (k.blue + Math.round(l.blue * g)) % 256].join(",") + ")";
                        d.push([m[e][0], a])
                    }
                }
                return d
            }
        },
        object: {
            interpolate: function(e, c) {
                c = (typeof c == "number") ? c : 1;
                var a = {},
                    d;
                for (d in e) {
                    a[d] = parseFloat(e[d]) * c
                }
                return a
            },
            computeDelta: function(j, a, d, c) {
                j = this.interpolate(j);
                a = this.interpolate(a, d);
                var i = c ? c : j,
                    g = {},
                    e;
                for (e in a) {
                    g[e] = a[e] - i[e]
                }
                return {
                    from: j,
                    delta: g
                }
            },
            get: function(l, a, j, e) {
                var k = l.length,
                    d = [],
                    g, c;
                for (g = 0; g < k; g++) {
                    if (e) {
                        c = e[g][1].from
                    }
                    d.push([l[g][0], this.computeDelta(l[g][1], a, j, c)])
                }
                return d
            },
            set: function(n, j) {
                var k = n.length,
                    d = [],
                    g = {},
                    e, l, m, c, a;
                for (e = 0; e < k; e++) {
                    c = n[e][1];
                    l = c.from;
                    m = c.delta;
                    for (a in l) {
                        g[a] = l[a] + m[a] * j
                    }
                    d.push([n[e][0], g])
                }
                return d
            }
        },
        path: {
            computeDelta: function(g, a, d, c) {
                d = (typeof d == "number") ? d : 1;
                var e;
                g = +g || 0;
                a = +a || 0;
                e = (c != null) ? c : g;
                return {
                    from: g,
                    delta: (a - e) * d
                }
            },
            forcePath: function(a) {
                if (!Ext.isArray(a) && !Ext.isArray(a[0])) {
                    a = Ext.draw.Draw.parsePathString(a)
                }
                return a
            },
            get: function(c, n, a, s) {
                var d = this.forcePath(n),
                    p = [],
                    u = c.length,
                    e, m, q, l, r, o, g, v, t;
                for (q = 0; q < u; q++) {
                    t = this.forcePath(c[q][1]);
                    l = Ext.draw.Draw.interpolatePaths(t, d);
                    t = l[0];
                    d = l[1];
                    e = t.length;
                    v = [];
                    for (o = 0; o < e; o++) {
                        l = [t[o][0]];
                        m = t[o].length;
                        for (g = 1; g < m; g++) {
                            r = s && s[0][1][o][g].from;
                            l.push(this.computeDelta(t[o][g], d[o][g], a, r))
                        }
                        v.push(l)
                    }
                    p.push([c[q][0], v])
                }
                return p
            },
            set: function(r, p) {
                var q = r.length,
                    g = [],
                    m, l, e, n, o, d, a, c;
                for (m = 0; m < q; m++) {
                    d = r[m][1];
                    n = [];
                    a = d.length;
                    for (l = 0; l < a; l++) {
                        o = [d[l][0]];
                        c = d[l].length;
                        for (e = 1; e < c; e++) {
                            o.push(d[l][e].from + d[l][e].delta * p)
                        }
                        n.push(o.join(","))
                    }
                    g.push([r[m][0], n.join(",")])
                }
                return g
            }
        }
    }
}, function() {
    var c = ["outlineColor", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "fill", "stroke"],
        d = c.length,
        a = 0,
        e;
    for (; a < d; a++) {
        e = c[a];
        this[e] = this.color
    }
    c = ["cursor"];
    d = c.length;
    a = 0;
    for (; a < d; a++) {
        e = c[a];
        this[e] = this.stringHandler
    }
});
Ext.define("Ext.fx.Anim", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.fx.Manager", "Ext.fx.Animator", "Ext.fx.Easing", "Ext.fx.CubicBezier", "Ext.fx.PropertyHandler"],
    isAnimation: true,
    duration: 250,
    delay: 0,
    delayStart: 0,
    dynamic: false,
    easing: "ease",
    damper: 1,
    bezierRE: /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
    reverse: false,
    running: false,
    paused: false,
    iterations: 1,
    alternate: false,
    currentIteration: 0,
    startTime: 0,
    frameCount: 0,
    constructor: function(a) {
        var c = this,
            d;
        a = a || {};
        if (a.keyframes) {
            return new Ext.fx.Animator(a)
        }
        Ext.apply(c, a);
        if (c.from === undefined) {
            c.from = {}
        }
        c.propHandlers = {};
        c.config = a;
        c.target = Ext.fx.Manager.createTarget(c.target);
        c.easingFn = Ext.fx.Easing[c.easing];
        c.target.dynamic = c.dynamic;
        if (!c.easingFn) {
            c.easingFn = String(c.easing).match(c.bezierRE);
            if (c.easingFn && c.easingFn.length == 5) {
                d = c.easingFn;
                c.easingFn = Ext.fx.CubicBezier.cubicBezier(+d[1], +d[2], +d[3], +d[4])
            }
        }
        c.id = Ext.id(null, "ext-anim-");
        c.addEvents("beforeanimate", "afteranimate", "lastframe");
        c.mixins.observable.constructor.call(c);
        Ext.fx.Manager.addAnim(c)
    },
    setAttr: function(a, c) {
        return Ext.fx.Manager.items.get(this.id).setAttr(this.target, a, c)
    },
    initAttrs: function() {
        var g = this,
            j = g.from,
            k = g.to,
            i = g.initialFrom || {},
            d = {},
            a, c, l, e;
        for (e in k) {
            if (k.hasOwnProperty(e)) {
                a = g.target.getAttr(e, j[e]);
                c = k[e];
                if (!Ext.fx.PropertyHandler[e]) {
                    if (Ext.isObject(c)) {
                        l = g.propHandlers[e] = Ext.fx.PropertyHandler.object
                    } else {
                        l = g.propHandlers[e] = Ext.fx.PropertyHandler.defaultHandler
                    }
                } else {
                    l = g.propHandlers[e] = Ext.fx.PropertyHandler[e]
                }
                d[e] = l.get(a, c, g.damper, i[e], e)
            }
        }
        g.currentAttrs = d
    },
    start: function(e) {
        var g = this,
            d = g.delay,
            c = g.delayStart,
            a;
        if (d) {
            if (!c) {
                g.delayStart = e;
                return
            } else {
                a = e - c;
                if (a < d) {
                    return
                } else {
                    e = new Date(c.getTime() + d)
                }
            }
        }
        if (g.fireEvent("beforeanimate", g) !== false) {
            g.startTime = e;
            if (!g.paused && !g.currentAttrs) {
                g.initAttrs()
            }
            g.running = true;
            g.frameCount = 0
        }
    },
    runAnim: function(n) {
        var k = this,
            m = k.currentAttrs,
            e = k.duration,
            d = k.easingFn,
            c = k.propHandlers,
            i = {},
            j, l, g, a;
        if (n >= e) {
            n = e;
            a = true
        }
        if (k.reverse) {
            n = e - n
        }
        for (g in m) {
            if (m.hasOwnProperty(g)) {
                l = m[g];
                j = a ? 1 : d(n / e);
                i[g] = c[g].set(l, j)
            }
        }
        k.frameCount++;
        return i
    },
    lastFrame: function() {
        var d = this,
            a = d.iterations,
            c = d.currentIteration;
        c++;
        if (c < a) {
            if (d.alternate) {
                d.reverse = !d.reverse
            }
            d.startTime = new Date();
            d.currentIteration = c;
            d.paused = false
        } else {
            d.currentIteration = 0;
            d.end();
            d.fireEvent("lastframe", d, d.startTime)
        }
    },
    endWasCalled: 0,
    end: function() {
        if (this.endWasCalled++) {
            return
        }
        var a = this;
        a.startTime = 0;
        a.paused = false;
        a.running = false;
        Ext.fx.Manager.removeAnim(a);
        a.fireEvent("afteranimate", a, a.startTime);
        Ext.callback(a.callback, a.scope, [a, a.startTime])
    },
    isReady: function() {
        return this.paused === false && this.running === false && this.iterations > 0
    },
    isRunning: function() {
        return this.paused === false && this.running === true && this.isAnimator !== true
    }
});
Ext.enableFx = true;
Ext.define("Ext.layout.container.Border", {
    alias: "layout.border",
    extend: "Ext.layout.container.Container",
    requires: ["Ext.resizer.BorderSplitter", "Ext.Component", "Ext.fx.Anim"],
    alternateClassName: "Ext.layout.BorderLayout",
    targetCls: Ext.baseCSSPrefix + "border-layout-ct",
    itemCls: [Ext.baseCSSPrefix + "border-item", Ext.baseCSSPrefix + "box-item"],
    type: "border",
    padding: undefined,
    percentageRe: /(\d+)%/,
    axisProps: {
        horz: {
            borderBegin: "west",
            borderEnd: "east",
            horizontal: true,
            posProp: "x",
            sizeProp: "width",
            sizePropCap: "Width"
        },
        vert: {
            borderBegin: "north",
            borderEnd: "south",
            horizontal: false,
            posProp: "y",
            sizeProp: "height",
            sizePropCap: "Height"
        }
    },
    centerRegion: null,
    collapseDirections: {
        north: "top",
        south: "bottom",
        east: "right",
        west: "left"
    },
    manageMargins: true,
    panelCollapseAnimate: true,
    panelCollapseMode: "placeholder",
    regionWeights: {
        north: 20,
        south: 10,
        center: 0,
        west: -10,
        east: -20
    },
    beginAxis: function(o, c, z) {
        var x = this,
            d = x.axisProps[z],
            t = !d.horizontal,
            n = d.sizeProp,
            r = 0,
            a = o.childItems,
            j = a.length,
            v, s, q, k, u, g, m, p, e, y, l;
        for (s = 0; s < j; ++s) {
            q = a[s];
            u = q.target;
            q.layoutPos = {};
            if (u.region) {
                q.region = g = u.region;
                q.isCenter = u.isCenter;
                q.isHorz = u.isHorz;
                q.isVert = u.isVert;
                q.weight = u.weight || x.regionWeights[g] || 0;
                c[u.id] = q;
                if (u.isCenter) {
                    v = q;
                    k = u.flex;
                    o.centerRegion = v;
                    continue
                }
                if (t !== q.isVert) {
                    continue
                }
                q.reverseWeighting = (g == d.borderEnd);
                p = u[n];
                e = typeof p;
                if (!u.collapsed) {
                    if (e == "string" && (m = x.percentageRe.exec(p))) {
                        q.percentage = parseInt(m[1], 10)
                    } else {
                        if (u.flex) {
                            r += q.flex = u.flex
                        }
                    }
                }
            }
        }
        if (v) {
            y = v.target;
            if (l = y.placeholderFor) {
                if (!k && t === l.collapsedVertical()) {
                    k = 0;
                    v.collapseAxis = z
                }
            } else {
                if (y.collapsed && (t === y.collapsedVertical())) {
                    k = 0;
                    v.collapseAxis = z
                }
            }
        }
        if (k == null) {
            k = 1
        }
        r += k;
        return Ext.apply({
            before: t ? "top" : "left",
            totalFlex: r
        }, d)
    },
    beginLayout: function(e) {
        var n = this,
            m = n.getLayoutItems(),
            g = n.padding,
            o = typeof g,
            r = false,
            s, q, c, k, j, a, d, l, p;
        if (g) {
            if (o == "string" || o == "number") {
                g = Ext.util.Format.parseBox(g)
            }
        } else {
            g = e.getEl("getTargetEl").getPaddingInfo();
            r = true
        }
        e.outerPad = g;
        e.padOnContainer = r;
        for (k = 0, c = m.length; k < c; ++k) {
            q = m[k];
            a = n.getSplitterTarget(q);
            if (a) {
                l = !!q.hidden;
                if (!a.split) {
                    if (a.isCollapsingOrExpanding) {
                        d = !!a.collapsed
                    }
                } else {
                    if (l !== a.hidden) {
                        d = !a.hidden
                    }
                }
                if (d === true) {
                    q.show()
                } else {
                    if (d === false) {
                        q.hide()
                    }
                }
            }
        }
        n.callParent(arguments);
        m = e.childItems;
        c = m.length;
        j = {};
        e.borderAxisHorz = n.beginAxis(e, j, "horz");
        e.borderAxisVert = n.beginAxis(e, j, "vert");
        for (k = 0; k < c; ++k) {
            s = m[k];
            a = n.getSplitterTarget(s.target);
            if (a) {
                p = j[a.id];
                if (!p) {
                    p = e.getEl(a.el, n);
                    p.region = a.region
                }
                s.collapseTarget = a = p;
                s.weight = a.weight;
                s.reverseWeighting = a.reverseWeighting;
                a.splitter = s;
                s.isHorz = a.isHorz;
                s.isVert = a.isVert
            }
        }
        n.sortWeightedItems(m, "reverseWeighting");
        n.setupSplitterNeighbors(m)
    },
    calculate: function(e) {
        var o = this,
            a = o.getContainerSize(e),
            l = e.childItems,
            d = l.length,
            c = e.borderAxisHorz,
            m = e.borderAxisVert,
            g = e.outerPad,
            q = e.padOnContainer,
            k, s, n, r, p, j;
        c.begin = g.left;
        m.begin = g.top;
        p = c.end = c.flexSpace = a.width + (q ? g.left : -g.right);
        j = m.end = m.flexSpace = a.height + (q ? g.top : -g.bottom);
        for (k = 0; k < d; ++k) {
            s = l[k];
            n = s.getMarginInfo();
            if (s.isHorz || s.isCenter) {
                c.addUnflexed(n.width);
                p -= n.width
            }
            if (s.isVert || s.isCenter) {
                m.addUnflexed(n.height);
                j -= n.height
            }
            if (!s.flex && !s.percentage) {
                if (s.isHorz || (s.isCenter && s.collapseAxis === "horz")) {
                    r = s.getProp("width");
                    c.addUnflexed(r);
                    if (s.collapseTarget) {
                        p -= r
                    }
                } else {
                    if (s.isVert || (s.isCenter && s.collapseAxis === "vert")) {
                        r = s.getProp("height");
                        m.addUnflexed(r);
                        if (s.collapseTarget) {
                            j -= r
                        }
                    }
                }
            }
        }
        for (k = 0; k < d; ++k) {
            s = l[k];
            n = s.getMarginInfo();
            if (s.percentage) {
                if (s.isHorz) {
                    r = Math.ceil(p * s.percentage / 100);
                    r = s.setWidth(r);
                    c.addUnflexed(r)
                } else {
                    if (s.isVert) {
                        r = Math.ceil(j * s.percentage / 100);
                        r = s.setHeight(r);
                        m.addUnflexed(r)
                    }
                }
            }
        }
        for (k = 0; k < d; ++k) {
            s = l[k];
            if (!s.isCenter) {
                o.calculateChildAxis(s, c);
                o.calculateChildAxis(s, m)
            }
        }
        if (o.finishAxis(e, m) + o.finishAxis(e, c) < 2) {
            o.done = false
        } else {
            o.finishPositions(l)
        }
    },
    calculateChildAxis: function(n, d) {
        var a = n.collapseTarget,
            j = "set" + d.sizePropCap,
            g = d.sizeProp,
            e = n.getMarginInfo()[g],
            l, c, i, k, m;
        if (a) {
            l = a.region
        } else {
            l = n.region;
            i = n.flex
        }
        c = l == d.borderBegin;
        if (!c && l != d.borderEnd) {
            n[j](d.end - d.begin - e);
            k = d.begin
        } else {
            if (i) {
                m = Math.ceil(d.flexSpace * (i / d.totalFlex));
                m = n[j](m)
            } else {
                if (n.percentage) {
                    m = n.peek(g)
                } else {
                    m = n.getProp(g)
                }
            }
            m += e;
            if (c) {
                k = d.begin;
                d.begin += m
            } else {
                d.end = k = d.end - m
            }
        }
        n.layoutPos[d.posProp] = k
    },
    finishAxis: function(e, d) {
        var c = d.end - d.begin,
            a = e.centerRegion;
        if (a) {
            a["set" + d.sizePropCap](c - a.getMarginInfo()[d.sizeProp]);
            a.layoutPos[d.posProp] = d.begin
        }
        return Ext.isNumber(c) ? 1 : 0
    },
    finishPositions: function(e) {
        var d = e.length,
            c, a;
        for (c = 0; c < d; ++c) {
            a = e[c];
            a.setProp("x", a.layoutPos.x + a.marginInfo.left);
            a.setProp("y", a.layoutPos.y + a.marginInfo.top)
        }
    },
    getPlaceholder: function(a) {
        return a.getPlaceholder && a.getPlaceholder()
    },
    getSplitterTarget: function(c) {
        var a = c.collapseTarget;
        if (a && a.collapsed) {
            return a.placeholder || a
        }
        return a
    },
    isItemBoxParent: function(a) {
        return true
    },
    isItemShrinkWrap: function(a) {
        return true
    },
    insertSplitter: function(d, c, g) {
        var i = d.region,
            e = {
                xtype: "bordersplitter",
                collapseTarget: d,
                id: d.id + "-splitter",
                hidden: g,
                canResize: d.splitterResize !== false
            },
            a = c + ((i == "south" || i == "east") ? 0 : 1);
        if (d.isHorz) {
            e.height = null
        } else {
            e.width = null
        }
        if (d.collapseMode == "mini") {
            e.collapsedCls = d.collapsedCls
        }
        d.splitter = this.owner.add(a, e)
    },
    onAdd: function(e, a) {
        var d = this,
            j = e.placeholderFor,
            i = e.region,
            c, g;
        d.callParent(arguments);
        if (i) {
            Ext.apply(e, d.regionFlags[i]);
            if (i == "center") {
                d.centerRegion = e
            } else {
                e.collapseDirection = this.collapseDirections[i];
                c = e.split;
                g = !!e.hidden;
                if ((e.isHorz || e.isVert) && (c || e.collapseMode == "mini")) {
                    d.insertSplitter(e, a, g || !c)
                }
            }
            if (!e.hasOwnProperty("collapseMode")) {
                e.collapseMode = d.panelCollapseMode
            }
            if (!e.hasOwnProperty("animCollapse")) {
                if (e.collapseMode != "placeholder") {
                    e.animCollapse = false
                } else {
                    e.animCollapse = d.panelCollapseAnimate
                }
            }
        } else {
            if (j) {
                Ext.apply(e, d.regionFlags[j.region]);
                e.region = j.region;
                e.weight = j.weight
            }
        }
    },
    onDestroy: function() {
        this.centerRegion = null;
        this.callParent()
    },
    onRemove: function(c) {
        var a = this,
            e = c.region,
            d = c.splitter;
        if (e) {
            if (c.isCenter) {
                a.centerRegion = null
            }
            delete c.isCenter;
            delete c.isHorz;
            delete c.isVert;
            if (d) {
                a.owner.doRemove(d, true);
                delete c.splitter
            }
        }
        a.callParent(arguments)
    },
    regionFlags: {
        center: {
            isCenter: true,
            isHorz: false,
            isVert: false
        },
        north: {
            isCenter: false,
            isHorz: false,
            isVert: true
        },
        south: {
            isCenter: false,
            isHorz: false,
            isVert: true
        },
        west: {
            isCenter: false,
            isHorz: true,
            isVert: false
        },
        east: {
            isCenter: false,
            isHorz: true,
            isVert: false
        }
    },
    setupSplitterNeighbors: function(o) {
        var r = {},
            g = o.length,
            q = this.touchedRegions,
            l, k, a, n, e, m, p, c, d;
        for (l = 0; l < g; ++l) {
            m = o[l].target;
            p = m.region;
            if (m.isCenter) {
                a = m
            } else {
                if (p) {
                    d = q[p];
                    for (k = 0, n = d.length; k < n; ++k) {
                        e = r[d[k]];
                        if (e) {
                            e.neighbors.push(m)
                        }
                    }
                    if (m.placeholderFor) {
                        c = m.placeholderFor.splitter
                    } else {
                        c = m.splitter
                    }
                    if (c) {
                        c.neighbors = []
                    }
                    r[p] = c
                }
            }
        }
        if (a) {
            d = q.center;
            for (k = 0, n = d.length; k < n; ++k) {
                e = r[d[k]];
                if (e) {
                    e.neighbors.push(a)
                }
            }
        }
    },
    touchedRegions: {
        center: ["north", "south", "east", "west"],
        north: ["north", "east", "west"],
        south: ["south", "east", "west"],
        east: ["east", "north", "south"],
        west: ["west", "north", "south"]
    },
    sizePolicies: {
        vert: {
            setsWidth: 1,
            setsHeight: 0
        },
        horz: {
            setsWidth: 0,
            setsHeight: 1
        },
        flexAll: {
            setsWidth: 1,
            setsHeight: 1
        }
    },
    getItemSizePolicy: function(g) {
        var e = this,
            a = this.sizePolicies,
            d, c, i, j;
        if (g.isCenter) {
            j = g.placeholderFor;
            if (j) {
                if (j.collapsedVertical()) {
                    return a.vert
                }
                return a.horz
            }
            if (g.collapsed) {
                if (g.collapsedVertical()) {
                    return a.vert
                }
                return a.horz
            }
            return a.flexAll
        }
        d = g.collapseTarget;
        if (d) {
            return d.isVert ? a.vert : a.horz
        }
        if (g.region) {
            if (g.isVert) {
                c = g.height;
                i = a.vert
            } else {
                c = g.width;
                i = a.horz
            }
            if (g.flex || (typeof c == "string" && e.percentageRe.test(c))) {
                return a.flexAll
            }
            return i
        }
        return e.autoSizePolicy
    }
}, function() {
    var a = {
            addUnflexed: function(d) {
                this.flexSpace = Math.max(this.flexSpace - d, 0)
            }
        },
        c = this.prototype.axisProps;
    Ext.apply(c.horz, a);
    Ext.apply(c.vert, a)
});
Ext.define("Ext.layout.component.Dock", {
    extend: "Ext.layout.component.Component",
    alias: "layout.dock",
    alternateClassName: "Ext.layout.component.AbstractDock",
    type: "dock",
    initializedBorders: -1,
    horizontalCollapsePolicy: {
        width: true,
        x: true
    },
    verticalCollapsePolicy: {
        height: true,
        y: true
    },
    finishRender: function() {
        var c = this,
            d, a;
        c.callParent();
        d = c.getRenderTarget();
        a = c.getDockedItems();
        c.finishRenderItems(d, a)
    },
    isItemBoxParent: function(a) {
        return true
    },
    isItemShrinkWrap: function(a) {
        return true
    },
    dockOpposites: {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right"
    },
    handleItemBorders: function() {
        var o = this,
            a = o.owner,
            n, r, g = o.borders,
            k = o.dockOpposites,
            c = a.dockedItems.generation,
            j, m, q, p, l, d, e = o.collapsed;
        if (o.initializedBorders == c || (a.border && !a.manageBodyBorders)) {
            return
        }
        o.initializedBorders = c;
        o.collapsed = false;
        r = o.getLayoutItems();
        o.collapsed = e;
        n = {
            top: [],
            right: [],
            bottom: [],
            left: []
        };
        for (j = 0, m = r.length; j < m; j++) {
            q = r[j];
            p = q.dock;
            if (q.ignoreBorderManagement) {
                continue
            }
            if (!n[p].satisfied) {
                n[p].push(q);
                n[p].satisfied = true
            }
            if (!n.top.satisfied && k[p] !== "top") {
                n.top.push(q)
            }
            if (!n.right.satisfied && k[p] !== "right") {
                n.right.push(q)
            }
            if (!n.bottom.satisfied && k[p] !== "bottom") {
                n.bottom.push(q)
            }
            if (!n.left.satisfied && k[p] !== "left") {
                n.left.push(q)
            }
        }
        if (g) {
            for (l in g) {
                if (g.hasOwnProperty(l)) {
                    m = g[l].length;
                    if (!a.manageBodyBorders) {
                        for (j = 0; j < m; j++) {
                            d = g[l][j];
                            if (!d.isDestroyed) {
                                d.removeCls(Ext.baseCSSPrefix + "docked-noborder-" + l)
                            }
                        }
                        if (!g[l].satisfied && !a.bodyBorder) {
                            a.removeBodyCls(Ext.baseCSSPrefix + "docked-noborder-" + l)
                        }
                    } else {
                        if (g[l].satisfied) {
                            a.setBodyStyle("border-" + l + "-width", "")
                        }
                    }
                }
            }
        }
        for (l in n) {
            if (n.hasOwnProperty(l)) {
                m = n[l].length;
                if (!a.manageBodyBorders) {
                    for (j = 0; j < m; j++) {
                        n[l][j].addCls(Ext.baseCSSPrefix + "docked-noborder-" + l)
                    }
                    if ((!n[l].satisfied && !a.bodyBorder) || a.bodyBorder === false) {
                        a.addBodyCls(Ext.baseCSSPrefix + "docked-noborder-" + l)
                    }
                } else {
                    if (n[l].satisfied) {
                        a.setBodyStyle("border-" + l + "-width", "1px")
                    }
                }
            }
        }
        o.borders = n
    },
    beforeLayoutCycle: function(g) {
        var d = this,
            c = d.owner,
            i = d.sizeModels.shrinkWrap,
            e, a;
        if (c.collapsed) {
            if (c.collapsedVertical()) {
                a = true;
                g.measureDimensions = 1
            } else {
                e = true;
                g.measureDimensions = 2
            }
        }
        g.collapsedVert = a;
        g.collapsedHorz = e;
        if (a) {
            g.heightModel = i
        } else {
            if (e) {
                g.widthModel = i
            }
        }
    },
    beginLayout: function(e) {
        var m = this,
            d = m.owner,
            p = m.getLayoutItems(),
            c = e.context,
            j = p.length,
            n, l, o, a, g, k;
        m.callParent(arguments);
        m.handleItemBorders();
        k = d.getCollapsed();
        if (k !== m.lastCollapsedState && Ext.isDefined(m.lastCollapsedState)) {
            if (m.owner.collapsed) {
                e.isCollapsingOrExpanding = 1;
                d.addClsWithUI(d.collapsedCls)
            } else {
                e.isCollapsingOrExpanding = 2;
                d.removeClsWithUI(d.collapsedCls);
                e.lastCollapsedState = m.lastCollapsedState
            }
        }
        m.lastCollapsedState = k;
        e.dockedItems = n = [];
        for (l = 0; l < j; l++) {
            o = p[l];
            if (o.rendered) {
                a = c.getCmp(o);
                a.dockedAt = {
                    x: 0,
                    y: 0
                };
                a.offsets = g = Ext.Element.parseBox(o.offsets || {});
                g.width = g.left + g.right;
                g.height = g.top + g.bottom;
                n.push(a)
            }
        }
        e.bodyContext = e.getEl("body")
    },
    beginLayoutCycle: function(c) {
        var g = this,
            n = c.dockedItems,
            e = n.length,
            a = g.owner,
            j = a.frameBody,
            m = g.lastHeightModel,
            d, l, k;
        g.callParent(arguments);
        if (m && m.shrinkWrap && !c.heightModel.shrinkWrap && !g.owner.manageHeight) {
            a.body.dom.style.marginBottom = ""
        }
        if (c.widthModel.auto) {
            if (c.widthModel.shrinkWrap) {
                a.el.setWidth(null)
            }
            a.body.setWidth(null);
            if (j) {
                j.setWidth(null)
            }
        }
        if (c.heightModel.auto) {
            a.body.setHeight(null);
            if (j) {
                j.setHeight(null)
            }
        }
        if (c.collapsedVert) {
            c.setContentHeight(0)
        } else {
            if (c.collapsedHorz) {
                c.setContentWidth(0)
            }
        }
        for (d = 0; d < e; d++) {
            l = n[d].target;
            k = l.dock;
            if (k == "right") {
                l.el.setLeft(0)
            } else {
                if (k != "left") {
                    continue
                }
            }
        }
    },
    calculate: function(e) {
        var m = this,
            d = m.measureAutoDimensions(e, e.measureDimensions),
            c = e.state,
            l = c.horzDone,
            g = c.vertDone,
            i = e.bodyContext,
            a, k, j, n;
        e.borderInfo || e.getBorderInfo();
        e.paddingInfo || e.getPaddingInfo();
        e.framingInfo || e.getFraming();
        i.borderInfo || i.getBorderInfo();
        i.paddingInfo || i.getPaddingInfo();
        a = !l && m.createAxis(e, d.contentWidth, e.widthModel, "left", "right", "x", "width", "Width", e.collapsedHorz);
        k = !g && m.createAxis(e, d.contentHeight, e.heightModel, "top", "bottom", "y", "height", "Height", e.collapsedVert);
        for (j = 0, n = e.dockedItems.length; n--; ++j) {
            if (a) {
                m.dockChild(e, a, n, j)
            }
            if (k) {
                m.dockChild(e, k, n, j)
            }
        }
        if (a && m.finishAxis(e, a)) {
            c.horzDone = l = a
        }
        if (k && m.finishAxis(e, k)) {
            c.vertDone = g = k
        }
        if (l && g && m.finishConstraints(e, l, g)) {
            m.finishPositions(e, l, g)
        } else {
            m.done = false
        }
    },
    createAxis: function(q, l, g, p, k, u, o, m, e) {
        var x = 0,
            c = this.owner,
            i = c["max" + m],
            d = c["min" + m] || 0,
            n = i != null,
            v = "set" + m,
            s, a, t, r, j;
        if (g.shrinkWrap) {
            if (e) {
                j = 0
            } else {
                a = q.bodyContext;
                j = l + a.borderInfo[o]
            }
        } else {
            s = q.borderInfo;
            t = q.framingInfo;
            r = q.paddingInfo;
            j = q.getProp(o);
            j -= s[k] + r[k] + t[k];
            x = s[p] + r[p] + t[p]
        }
        return {
            shrinkWrap: g.shrinkWrap,
            sizeModel: g,
            begin: x,
            end: j,
            collapsed: e,
            horizontal: u == "x",
            ignoreFrameBegin: false,
            ignoreFrameEnd: false,
            initialSize: j - x,
            hasMinMaxConstraints: (d || n) && g.shrinkWrap,
            minSize: d,
            maxSize: n ? i : 1000000000,
            bodyPosProp: this.owner.manageHeight ? u : ("margin-" + p),
            dockBegin: p,
            dockEnd: k,
            posProp: u,
            sizeProp: o,
            sizePropCap: m,
            setSize: v,
            dockedPixelsEnd: 0
        }
    },
    dockChild: function(c, d, l, e) {
        var g = this,
            a = c.dockedItems[d.shrinkWrap ? l : e],
            j = a.target,
            k = j.dock,
            i;
        if (j.ignoreParentFrame && c.isCollapsingOrExpanding) {
            a.clearMarginCache()
        }
        if (k == d.dockBegin) {
            if (d.shrinkWrap) {
                i = g.dockOutwardBegin(c, a, j, d)
            } else {
                i = g.dockInwardBegin(c, a, j, d)
            }
        } else {
            if (k == d.dockEnd) {
                if (d.shrinkWrap) {
                    i = g.dockOutwardEnd(c, a, j, d)
                } else {
                    i = g.dockInwardEnd(c, a, j, d)
                }
            } else {
                i = g.dockStretch(c, a, j, d)
            }
        }
        a.dockedAt[d.posProp] = i
    },
    dockInwardBegin: function(i, g, e, c) {
        var k = c.begin,
            j = c.sizeProp,
            a, d;
        if (e.ignoreParentFrame) {
            d = e.dock;
            k -= i.borderInfo[d] + i.paddingInfo[d] + i.framingInfo[d]
        }
        if (!e.overlay) {
            a = g.getProp(j) + g.getMarginInfo()[j];
            c.begin += a
        }
        return k
    },
    dockInwardEnd: function(g, e, d, c) {
        var j = c.sizeProp,
            a = e.getProp(j) + e.getMarginInfo()[j],
            i = c.end - a;
        if (!d.overlay) {
            c.end = i
        }
        if (d.ignoreParentFrame) {
            i += g.borderInfo[d.dock] + g.paddingInfo[d.dock] + g.framingInfo[d.dock]
        }
        return i
    },
    dockOutwardBegin: function(i, g, e, c) {
        var k = c.begin,
            j = c.sizeProp,
            d, a;
        if (c.collapsed) {
            c.ignoreFrameBegin = c.ignoreFrameEnd = true
        } else {
            if (e.ignoreParentFrame) {
                d = e.dock;
                k -= i.borderInfo[d] + i.paddingInfo[d] + i.framingInfo[d];
                c.ignoreFrameBegin = true
            }
        }
        if (!e.overlay) {
            a = g.getProp(j) + g.getMarginInfo()[j];
            k -= a;
            c.begin = k
        }
        return k
    },
    dockOutwardEnd: function(i, g, e, c) {
        var k = c.end,
            j = c.sizeProp,
            d, a;
        a = g.getProp(j) + g.getMarginInfo()[j];
        if (c.collapsed) {
            c.ignoreFrameBegin = c.ignoreFrameEnd = true
        } else {
            if (e.ignoreParentFrame) {
                d = e.dock;
                k += i.borderInfo[d] + i.paddingInfo[d] + i.framingInfo[d];
                c.ignoreFrameEnd = true
            }
        }
        if (!e.overlay) {
            c.end = k + a;
            c.dockedPixelsEnd += a
        }
        return k
    },
    dockStretch: function(d, c, p, e) {
        var q = p.dock,
            l = e.sizeProp,
            a = q == "top" || q == "bottom",
            g = c.offsets,
            k = d.borderInfo,
            o = d.paddingInfo,
            j = a ? "right" : "bottom",
            s = a ? "left" : "top",
            n = e.begin + g[s],
            i, r, m;
        if (p.stretch !== false) {
            r = e.end - n - g[j];
            if (p.ignoreParentFrame) {
                m = d.framingInfo;
                n -= k[s] + o[s] + m[s];
                r += k[l] + o[l] + m[l]
            }
            i = c.getMarginInfo();
            r -= i[l];
            c[e.setSize](r)
        }
        return n
    },
    finishAxis: function(d, g) {
        var q = g.end - g.begin,
            n = g.setSize,
            e = g.dockBegin,
            k = g.dockEnd,
            l = d.borderInfo,
            o = d.paddingInfo,
            m = d.framingInfo,
            j = o[e] + l[e] + m[e],
            i = d.bodyContext,
            p, a, c;
        if (g.shrinkWrap) {
            g.delta = -g.begin;
            a = g.initialSize;
            if (g.ignoreFrameBegin) {
                g.delta -= l[e];
                p = -g.begin - j
            } else {
                q += j;
                g.delta += o[e] + m[e];
                p = -g.begin
            }
            if (!g.ignoreFrameEnd) {
                q += o[k] + l[k] + m[k]
            }
            g.size = q;
            if (!g.horizontal && !this.owner.manageHeight) {
                c = false
            }
        } else {
            g.delta = -l[g.dockBegin];
            a = q;
            p = g.begin - j
        }
        i[n](a, c);
        i.setProp(g.bodyPosProp, p);
        return !isNaN(q)
    },
    finishConstraints: function(g, a, j) {
        var l = this.sizeModels,
            n = a.shrinkWrap,
            c = j.shrinkWrap,
            d, m, e, i, k, o;
        if (n) {
            o = a.size;
            if (o < a.minSize) {
                k = l.constrainedMin;
                e = a.minSize
            } else {
                if (o > a.maxSize) {
                    k = l.constrainedMax;
                    e = a.maxSize
                } else {
                    e = o
                }
            }
        }
        if (c) {
            o = j.size;
            if (o < j.minSize) {
                i = l.constrainedMin;
                m = j.minSize
            } else {
                if (o > j.maxSize) {
                    i = l.constrainedMax;
                    m = j.maxSize
                } else {
                    if (!g.collapsedVert && !this.owner.manageHeight) {
                        d = false;
                        g.bodyContext.setProp("margin-bottom", j.dockedPixelsEnd)
                    }
                    m = o
                }
            }
        }
        if (k || i) {
            if (k && i && k.constrainedMax && i.constrainedMin) {
                g.invalidate({
                    widthModel: k
                });
                return false
            }
            if (!g.widthModel.calculatedFromShrinkWrap && !g.heightModel.calculatedFromShrinkWrap) {
                g.invalidate({
                    widthModel: k,
                    heightModel: i
                });
                return false
            }
        }
        if (n) {
            g.setWidth(e);
            if (k) {
                g.widthModel = k
            }
        }
        if (c) {
            g.setHeight(m, d);
            if (i) {
                g.heightModel = i
            }
        }
        return true
    },
    finishPositions: function(e, a, j) {
        var l = e.dockedItems,
            d = l.length,
            i = a.delta,
            g = j.delta,
            k, c;
        for (k = 0; k < d; ++k) {
            c = l[k];
            c.setProp("x", i + c.dockedAt.x);
            c.setProp("y", g + c.dockedAt.y)
        }
    },
    finishedLayout: function(c) {
        var a = this,
            d = c.target;
        a.callParent(arguments);
        if (!c.animatePolicy) {
            if (c.isCollapsingOrExpanding === 1) {
                d.afterCollapse(false)
            } else {
                if (c.isCollapsingOrExpanding === 2) {
                    d.afterExpand(false)
                }
            }
        }
    },
    getAnimatePolicy: function(d) {
        var c = this,
            a, e;
        if (d.isCollapsingOrExpanding == 1) {
            a = c.lastCollapsedState
        } else {
            if (d.isCollapsingOrExpanding == 2) {
                a = d.lastCollapsedState
            }
        }
        if (a == "left" || a == "right") {
            e = c.horizontalCollapsePolicy
        } else {
            if (a == "top" || a == "bottom") {
                e = c.verticalCollapsePolicy
            }
        }
        return e
    },
    getDockedItems: function(d, p) {
        var l = this,
            g = (d === "visual"),
            m = g ? Ext.ComponentQuery.query("[rendered]", l.owner.dockedItems.items) : l.owner.dockedItems.items,
            k = m && m.length && d !== false,
            c, o, n, j, e, a;
        if (p == null) {
            n = k && !g ? m.slice() : m
        } else {
            n = [];
            for (j = 0, a = m.length; j < a; ++j) {
                o = m[j].dock;
                e = (o == "top" || o == "left");
                if (p ? e : !e) {
                    n.push(m[j])
                }
            }
            k = k && n.length
        }
        if (k) {
            c = (d = d || "render") == "render";
            Ext.Array.sort(n, function(q, i) {
                var r, s;
                if (c && ((r = l.owner.dockOrder[q.dock]) !== (s = l.owner.dockOrder[i.dock]))) {
                    if (!(r + s)) {
                        return r - s
                    }
                }
                r = l.getItemWeight(q, d);
                s = l.getItemWeight(i, d);
                if ((r !== undefined) && (s !== undefined)) {
                    return r - s
                }
                return 0
            })
        }
        return n || []
    },
    getItemWeight: function(c, a) {
        var d = c.weight || this.owner.defaultDockWeights[c.dock];
        return d[a] || d
    },
    getLayoutItems: function() {
        var g = this,
            c, j, e, d, a;
        if (g.owner.collapsed) {
            a = g.owner.getCollapsedDockedItems()
        } else {
            c = g.getDockedItems("visual");
            j = c.length;
            a = [];
            for (d = 0; d < j; d++) {
                e = c[d];
                if (!e.hidden) {
                    a.push(e)
                }
            }
        }
        return a
    },
    measureContentWidth: function(a) {
        var c = a.bodyContext;
        return c.el.getWidth() - c.getBorderInfo().width
    },
    measureContentHeight: function(a) {
        var c = a.bodyContext;
        return c.el.getHeight() - c.getBorderInfo().height
    },
    redoLayout: function(d) {
        var c = this,
            a = c.owner;
        if (d.isCollapsingOrExpanding == 1) {
            if (a.reExpander) {
                a.reExpander.el.show()
            }
            a.addClsWithUI(a.collapsedCls);
            d.redo(true)
        } else {
            if (d.isCollapsingOrExpanding == 2) {
                a.removeClsWithUI(a.collapsedCls);
                d.bodyContext.redo()
            }
        }
    },
    renderChildren: function() {
        var c = this,
            a = c.getDockedItems(),
            d = c.getRenderTarget();
        c.renderItems(a, d)
    },
    renderItems: function(m, l) {
        var n = this,
            d = m.length,
            a = 0,
            c = 0,
            r = 0,
            o = n.getRenderTarget().dom.childNodes,
            p = o.length,
            k, e, g, q;
        for (k = 0, e = 0; k < p; k++) {
            g = o[k];
            if (Ext.fly(g).hasCls("x-resizable-handle")) {
                break
            }
            for (e = 0; e < d; e++) {
                q = m[e];
                if (q.rendered && q.el.dom === g) {
                    break
                }
            }
            if (e === d) {
                r++
            }
        }
        for (; a < d; a++, c++) {
            q = m[a];
            if (a === c && (q.dock === "right" || q.dock === "bottom")) {
                c += r
            }
            if (q && !q.rendered) {
                n.renderItem(q, l, c)
            } else {
                if (!n.isValidParent(q, l, c)) {
                    n.moveItem(q, l, c)
                }
            }
        }
    },
    undoLayout: function(d) {
        var c = this,
            a = c.owner;
        if (d.isCollapsingOrExpanding == 1) {
            if (a.reExpander) {
                a.reExpander.el.hide()
            }
            a.removeClsWithUI(a.collapsedCls);
            d.undo(true)
        } else {
            if (d.isCollapsingOrExpanding == 2) {
                a.addClsWithUI(a.collapsedCls);
                d.bodyContext.undo()
            }
        }
    },
    sizePolicy: {
        nostretch: {
            setsWidth: 0,
            setsHeight: 0
        },
        stretchH: {
            setsWidth: 1,
            setsHeight: 0
        },
        stretchV: {
            setsWidth: 0,
            setsHeight: 1
        },
        autoStretchH: {
            readsWidth: 1,
            setsWidth: 1,
            setsHeight: 0
        },
        autoStretchV: {
            readsHeight: 1,
            setsWidth: 0,
            setsHeight: 1
        }
    },
    getItemSizePolicy: function(d) {
        var e = this.sizePolicy,
            c, a;
        if (d.stretch === false) {
            return e.nostretch
        }
        c = d.dock;
        a = (c == "left" || c == "right");
        if (a) {
            return e.stretchV
        }
        return e.stretchH
    },
    configureItem: function(a, c) {
        this.callParent(arguments);
        a.addCls(Ext.baseCSSPrefix + "docked");
        a.addClsWithUI("docked-" + a.dock)
    },
    afterRemove: function(a) {
        this.callParent(arguments);
        if (this.itemCls) {
            a.el.removeCls(this.itemCls + "-" + a.dock)
        }
        var c = a.el.dom;
        if (!a.destroying && c) {
            c.parentNode.removeChild(c)
        }
        this.childrenChanged = true
    }
});
Ext.define("Ext.layout.container.Auto", {
    alias: ["layout.auto", "layout.autocontainer"],
    extend: "Ext.layout.container.Container",
    type: "autocontainer",
    childEls: ["clearEl"],
    renderTpl: ["{%this.renderBody(out,values)%}", '<div id="{ownerId}-clearEl" class="', Ext.baseCSSPrefix, 'clear" role="presentation"></div>'],
    calculate: function(c) {
        var a = this,
            d;
        if (!c.hasDomProp("containerChildrenDone")) {
            a.done = false
        } else {
            d = a.getContainerSize(c);
            if (!d.gotAll) {
                a.done = false
            }
            a.calculateContentSize(c)
        }
    }
});
Ext.define("Ext.ZIndexManager", {
    alternateClassName: "Ext.WindowGroup",
    statics: {
        zBase: 9000
    },
    constructor: function(a) {
        var c = this;
        c.list = {};
        c.zIndexStack = [];
        c.front = null;
        if (a) {
            if (a.isContainer) {
                a.on("resize", c._onContainerResize, c);
                c.zseed = Ext.Number.from(c.rendered ? a.getEl().getStyle("zIndex") : undefined, c.getNextZSeed());
                c.targetEl = a.getTargetEl();
                c.container = a
            } else {
                Ext.EventManager.onWindowResize(c._onContainerResize, c);
                c.zseed = c.getNextZSeed();
                c.targetEl = Ext.get(a)
            }
        } else {
            Ext.EventManager.onWindowResize(c._onContainerResize, c);
            c.zseed = c.getNextZSeed();
            Ext.onDocumentReady(function() {
                c.targetEl = Ext.getBody()
            })
        }
    },
    getNextZSeed: function() {
        return (Ext.ZIndexManager.zBase += 10000)
    },
    setBase: function(c) {
        this.zseed = c;
        var a = this.assignZIndices();
        this._activateLast();
        return a
    },
    assignZIndices: function() {
        var d = this.zIndexStack,
            c = d.length,
            g = 0,
            j = this.zseed,
            e;
        for (; g < c; g++) {
            e = d[g];
            if (e && !e.hidden) {
                j = e.setZIndex(j)
            }
        }
        this._activateLast();
        return j
    },
    _setActiveChild: function(c, a) {
        var d = this.front;
        if (c !== d) {
            if (d && !d.destroying) {
                d.setActive(false, c)
            }
            this.front = c;
            if (c && c != a) {
                c.setActive(true);
                if (c.modal) {
                    this._showModalMask(c)
                }
            }
        }
    },
    onComponentHide: function(a) {
        a.setActive(false);
        this._activateLast()
    },
    _activateLast: function() {
        var g = this,
            a = g.zIndexStack,
            e = a.length - 1,
            d = g.front,
            c;
        g.front = undefined;
        for (; e >= 0 && a[e].hidden; --e) {}
        if ((c = a[e])) {
            g._setActiveChild(c, d);
            if (c.modal) {
                return
            }
        }
        for (; e >= 0; --e) {
            c = a[e];
            if (c.isVisible() && c.modal) {
                g._showModalMask(c);
                return
            }
        }
        g._hideModalMask()
    },
    _showModalMask: function(a) {
        var d = this,
            g = a.el.getStyle("zIndex") - 4,
            c = a.floatParent ? a.floatParent.getTargetEl() : a.container,
            e = c.getBox();
        if (c.dom === document.body) {
            e.height = Math.max(document.body.scrollHeight, Ext.dom.Element.getDocumentHeight());
            e.width = Math.max(document.body.scrollWidth, e.width)
        }
        if (!d.mask) {
            d.mask = Ext.getBody().createChild({
                cls: Ext.baseCSSPrefix + "mask"
            });
            d.mask.setVisibilityMode(Ext.Element.DISPLAY);
            d.mask.on("click", d._onMaskClick, d)
        }
        d.mask.maskTarget = c;
        c.addCls(Ext.baseCSSPrefix + "body-masked");
        d.mask.setStyle("zIndex", g);
        d.mask.show();
        d.mask.setBox(e)
    },
    _hideModalMask: function() {
        var a = this.mask;
        if (a && a.isVisible()) {
            a.maskTarget.removeCls(Ext.baseCSSPrefix + "body-masked");
            a.maskTarget = undefined;
            a.hide()
        }
    },
    _onMaskClick: function() {
        if (this.front) {
            this.front.focus()
        }
    },
    _onContainerResize: function() {
        var a = this.mask,
            c, d;
        if (a && a.isVisible()) {
            a.hide();
            c = a.maskTarget;
            if (c.dom === document.body) {
                d = {
                    height: Math.max(document.body.scrollHeight, Ext.dom.Element.getDocumentHeight()),
                    width: Math.max(document.body.scrollWidth, document.documentElement.clientWidth)
                }
            } else {
                d = c.getViewSize(true)
            }
            a.setSize(d);
            a.show()
        }
    },
    register: function(a) {
        var c = this;
        if (a.zIndexManager) {
            a.zIndexManager.unregister(a)
        }
        a.zIndexManager = c;
        c.list[a.id] = a;
        c.zIndexStack.push(a);
        a.on("hide", c.onComponentHide, c)
    },
    unregister: function(a) {
        var c = this,
            d = c.list;
        delete a.zIndexManager;
        if (d && d[a.id]) {
            delete d[a.id];
            a.un("hide", c.onComponentHide);
            Ext.Array.remove(c.zIndexStack, a);
            c._activateLast()
        }
    },
    get: function(a) {
        return a.isComponent ? a : this.list[a]
    },
    bringToFront: function(c) {
        var d = this,
            a = false,
            e = d.zIndexStack;
        c = d.get(c);
        if (c !== d.front) {
            Ext.Array.remove(e, c);
            if (c.preventBringToFront) {
                e.unshift(c)
            } else {
                e.push(c)
            }
            d.assignZIndices();
            a = true;
            this.front = c
        }
        if (a && c.modal) {
            d._showModalMask(c)
        }
        return a
    },
    sendToBack: function(a) {
        var c = this;
        a = c.get(a);
        Ext.Array.remove(c.zIndexStack, a);
        c.zIndexStack.unshift(a);
        c.assignZIndices();
        this._activateLast();
        return a
    },
    hideAll: function() {
        var c = this.list,
            a, d;
        for (d in c) {
            if (c.hasOwnProperty(d)) {
                a = c[d];
                if (a.isComponent && a.isVisible()) {
                    a.hide()
                }
            }
        }
    },
    hide: function() {
        var j = this,
            d = j.mask,
            g = 0,
            c = j.zIndexStack,
            a = c.length,
            e;
        j.tempHidden = j.tempHidden || [];
        for (; g < a; g++) {
            e = c[g];
            if (e.isVisible()) {
                j.tempHidden.push(e);
                e.el.hide()
            }
        }
        if (d) {
            d.hide()
        }
    },
    show: function() {
        var g = this,
            c = g.mask,
            e = 0,
            j = g.tempHidden,
            a = j ? j.length : 0,
            d;
        for (; e < a; e++) {
            d = j[e];
            d.el.show();
            d.setPosition(d.x, d.y)
        }
        g.tempHidden.length = 0;
        if (c) {
            c.show();
            c.alignTo(c.maskTarget, "tl-tl")
        }
    },
    getActive: function() {
        return this.front
    },
    getBy: function(j, g) {
        var k = [],
            e = 0,
            c = this.zIndexStack,
            a = c.length,
            d;
        for (; e < a; e++) {
            d = c[e];
            if (j.call(g || d, d) !== false) {
                k.push(d)
            }
        }
        return k
    },
    each: function(d, c) {
        var e = this.list,
            g, a;
        for (g in e) {
            if (e.hasOwnProperty(g)) {
                a = e[g];
                if (a.isComponent && d.call(c || a, a) === false) {
                    return
                }
            }
        }
    },
    eachBottomUp: function(j, g) {
        var c = this.zIndexStack,
            e = 0,
            a = c.length,
            d;
        for (; e < a; e++) {
            d = c[e];
            if (d.isComponent && j.call(g || d, d) === false) {
                return
            }
        }
    },
    eachTopDown: function(g, e) {
        var a = this.zIndexStack,
            d = a.length,
            c;
        for (; d-- > 0;) {
            c = a[d];
            if (c.isComponent && g.call(e || c, c) === false) {
                return
            }
        }
    },
    destroy: function() {
        var c = this,
            d = c.list,
            a, e;
        for (e in d) {
            if (d.hasOwnProperty(e)) {
                a = d[e];
                if (a.isComponent) {
                    a.destroy()
                }
            }
        }
        delete c.zIndexStack;
        delete c.list;
        delete c.container;
        delete c.targetEl
    }
}, function() {
    Ext.WindowManager = Ext.WindowMgr = new this()
});
Ext.define("Ext.container.AbstractContainer", {
    extend: "Ext.Component",
    requires: ["Ext.util.MixedCollection", "Ext.layout.container.Auto", "Ext.ZIndexManager"],
    renderTpl: "{%this.renderContainer(out,values)%}",
    suspendLayout: false,
    autoDestroy: true,
    defaultType: "panel",
    detachOnRemove: true,
    isContainer: true,
    layoutCounter: 0,
    baseCls: Ext.baseCSSPrefix + "container",
    bubbleEvents: ["add", "remove"],
    defaultLayoutType: "auto",
    initComponent: function() {
        var a = this;
        a.addEvents("afterlayout", "beforeadd", "beforeremove", "add", "remove");
        a.callParent();
        a.getLayout();
        a.initItems()
    },
    initItems: function() {
        var c = this,
            a = c.items;
        c.items = new Ext.util.AbstractMixedCollection(false, c.getComponentId);
        if (a) {
            if (!Ext.isArray(a)) {
                a = [a]
            }
            c.add(a)
        }
    },
    getFocusEl: function() {
        return this.getTargetEl()
    },
    finishRenderChildren: function() {
        this.callParent();
        var a = this.getLayout();
        if (a) {
            a.finishRender()
        }
    },
    beforeRender: function() {
        var c = this,
            a = c.getLayout();
        c.callParent();
        if (!a.initialized) {
            a.initLayout()
        }
    },
    setupRenderTpl: function(c) {
        var a = this.getLayout();
        this.callParent(arguments);
        a.setupRenderTpl(c)
    },
    setLayout: function(c) {
        var a = this.layout;
        if (a && a.isLayout && a != c) {
            a.setOwner(null)
        }
        this.layout = c;
        c.setOwner(this)
    },
    getLayout: function() {
        var a = this;
        if (!a.layout || !a.layout.isLayout) {
            a.setLayout(Ext.layout.Layout.create(a.layout, a.self.prototype.layout || "autocontainer"))
        }
        return a.layout
    },
    doLayout: function() {
        this.updateLayout();
        return this
    },
    afterLayout: function(c) {
        var a = this;
        ++a.layoutCounter;
        if (a.hasListeners.afterlayout) {
            a.fireEvent("afterlayout", a, c)
        }
    },
    prepareItems: function(c, e) {
        if (Ext.isArray(c)) {
            c = c.slice()
        } else {
            c = [c]
        }
        var j = this,
            d = 0,
            a = c.length,
            g;
        for (; d < a; d++) {
            g = c[d];
            if (g == null) {
                Ext.Array.erase(c, d, 1);
                --d;
                --a
            } else {
                if (e) {
                    g = this.applyDefaults(g)
                }
                g.isContained = j;
                c[d] = j.lookupComponent(g);
                delete g.isContained
            }
        }
        return c
    },
    applyDefaults: function(a) {
        var c = this.defaults;
        if (c) {
            if (Ext.isFunction(c)) {
                c = c.call(this, a)
            }
            if (Ext.isString(a)) {
                a = Ext.ComponentManager.get(a)
            }
            Ext.applyIf(a, c)
        }
        return a
    },
    lookupComponent: function(a) {
        return (typeof a == "string") ? Ext.ComponentManager.get(a) : Ext.ComponentManager.create(a, this.defaultType)
    },
    getComponentId: function(a) {
        return a.getItemId()
    },
    add: function() {
        var l = this,
            j = Ext.Array.slice(arguments),
            e = (typeof j[0] == "number") ? j.shift() : -1,
            d = l.getLayout(),
            n, k, c, a, o, m, g;
        if (j.length == 1 && Ext.isArray(j[0])) {
            k = j[0];
            n = true
        } else {
            k = j
        }
        g = k = l.prepareItems(k, true);
        a = k.length;
        if (l.rendered) {
            Ext.suspendLayouts()
        }
        if (!n && a == 1) {
            g = k[0]
        }
        for (c = 0; c < a; c++) {
            o = k[c];
            m = (e < 0) ? l.items.length : (e + c);
            if (o.floating) {
                l.floatingItems = l.floatingItems || new Ext.util.MixedCollection();
                l.floatingItems.add(o);
                o.onAdded(l, m)
            } else {
                if ((!l.hasListeners.beforeadd || l.fireEvent("beforeadd", l, o, m) !== false) && l.onBeforeAdd(o) !== false) {
                    l.items.insert(m, o);
                    o.onAdded(l, m);
                    l.onAdd(o, m);
                    d.onAdd(o, m);
                    if (l.hasListeners.add) {
                        l.fireEvent("add", l, o, m)
                    }
                }
            }
        }
        l.updateLayout();
        if (l.rendered) {
            Ext.resumeLayouts(true)
        }
        return g
    },
    onAdd: Ext.emptyFn,
    onRemove: Ext.emptyFn,
    insert: function(c, a) {
        return this.add(c, a)
    },
    move: function(c, e) {
        var a = this.items,
            d;
        d = a.removeAt(c);
        if (d === false) {
            return false
        }
        a.insert(e, d);
        this.doLayout();
        return d
    },
    onBeforeAdd: function(d) {
        var c = this,
            a = d.border;
        if (d.ownerCt && d.ownerCt !== c) {
            d.ownerCt.remove(d, false)
        }
        if (c.border === false || c.border === 0) {
            d.border = Ext.isDefined(a) && a !== false && a !== 0
        }
    },
    remove: function(a, d) {
        var e = this,
            g = e.getComponent(a);
        if (g && (!e.hasListeners.beforeremove || e.fireEvent("beforeremove", e, g) !== false)) {
            e.doRemove(g, d);
            if (e.hasListeners.remove) {
                e.fireEvent("remove", e, g)
            }
            if (!e.destroying) {
                e.doLayout()
            }
        }
        return g
    },
    doRemove: function(d, c) {
        var g = this,
            e = g.layout,
            a = e && g.rendered,
            i = c === true || (c !== false && g.autoDestroy);
        c = c === true || (c !== false && g.autoDestroy);
        g.items.remove(d);
        if (a) {
            if (e.running) {
                Ext.AbstractComponent.cancelLayout(d, i)
            }
            e.onRemove(d, i)
        }
        d.onRemoved(i);
        g.onRemove(d, i);
        if (i) {
            d.destroy()
        } else {
            if (a) {
                e.afterRemove(d)
            }
            if (g.detachOnRemove && d.rendered) {
                Ext.getDetachedBody().appendChild(d.getEl())
            }
        }
    },
    removeAll: function(d) {
        var k = this,
            g = k.items.items.slice(),
            c = [],
            e = 0,
            a = g.length,
            j;
        k.suspendLayouts();
        for (; e < a; e++) {
            j = g[e];
            k.remove(j, d);
            if (j.ownerCt !== k) {
                c.push(j)
            }
        }
        k.resumeLayouts(!!a);
        return c
    },
    getRefItems: function(d) {
        var k = this,
            e = k.items.items,
            c = e.length,
            g = 0,
            j, a = [];
        for (; g < c; g++) {
            j = e[g];
            a.push(j);
            if (d && j.getRefItems) {
                a.push.apply(a, j.getRefItems(true))
            }
        }
        if (k.floatingItems) {
            a.push.apply(a, k.floatingItems.items)
        }
        return a
    },
    cascade: function(n, o, a) {
        var m = this,
            g = m.items ? m.items.items : [],
            j = g.length,
            e = 0,
            l, k = a ? a.concat(m) : [m],
            d = k.length - 1;
        if (n.apply(o || m, k) !== false) {
            for (; e < j; e++) {
                l = g[e];
                if (l.cascade) {
                    l.cascade(n, o, a)
                } else {
                    k[d] = l;
                    n.apply(o || g, k)
                }
            }
        }
        return this
    },
    isAncestor: function(a) {
        while (a) {
            if (a.ownerCt === this) {
                return true
            }
            a = a.ownerCt
        }
    },
    getComponent: function(a) {
        if (Ext.isObject(a)) {
            a = a.getItemId()
        }
        return this.items.get(a)
    },
    query: function(a) {
        a = a || "*";
        return Ext.ComponentQuery.query(a, this)
    },
    queryBy: function(j, g) {
        var d = [],
            c = this.getRefItems(true),
            e = 0,
            a = c.length,
            k;
        for (; e < a; ++e) {
            k = c[e];
            if (j.call(g || k, k) !== false) {
                d.push(k)
            }
        }
        return d
    },
    queryById: function(a) {
        return this.down("#" + a)
    },
    child: function(a) {
        a = a || "";
        return this.query("> " + a)[0] || null
    },
    nextChild: function(g, c) {
        var d = this,
            a, e = d.items.indexOf(g);
        if (e !== -1) {
            a = c ? Ext.ComponentQuery(c, d.items.items.slice(e + 1)) : d.items.getAt(e + 1);
            if (!a && d.ownerCt) {
                a = d.ownerCt.nextChild(d, c)
            }
        }
        return a
    },
    prevChild: function(g, c) {
        var d = this,
            a, e = d.items.indexOf(g);
        if (e !== -1) {
            a = c ? Ext.ComponentQuery(c, d.items.items.slice(e + 1)) : d.items.getAt(e + 1);
            if (!a && d.ownerCt) {
                a = d.ownerCt.nextChild(d, c)
            }
        }
        return a
    },
    down: function(a) {
        return this.query(a)[0] || null
    },
    enable: function() {
        this.callParent(arguments);
        var e = this.getChildItemsToDisable(),
            d = e.length,
            c, a;
        for (a = 0; a < d; a++) {
            c = e[a];
            if (c.resetDisable) {
                c.enable()
            }
        }
        return this
    },
    disable: function() {
        this.callParent(arguments);
        var e = this.getChildItemsToDisable(),
            d = e.length,
            c, a;
        for (a = 0; a < d; a++) {
            c = e[a];
            if (c.resetDisable !== false && !c.disabled) {
                c.disable();
                c.resetDisable = true
            }
        }
        return this
    },
    getChildItemsToDisable: function() {
        return this.query("[isFormField],button")
    },
    beforeLayout: function() {
        return true
    },
    beforeDestroy: function() {
        var d = this,
            a = d.items,
            e;
        if (a) {
            while ((e = a.first())) {
                d.doRemove(e, true)
            }
        }
        Ext.destroy(d.layout);
        d.callParent()
    }
});
Ext.define("Ext.container.Container", {
    extend: "Ext.container.AbstractContainer",
    alias: "widget.container",
    alternateClassName: "Ext.Container",
    fireHierarchyEvent: function(a) {
        this.hierarchyEventSource.fireEvent(a, this)
    },
    afterHide: function() {
        this.callParent(arguments);
        this.fireHierarchyEvent("hide")
    },
    afterShow: function() {
        this.callParent(arguments);
        this.fireHierarchyEvent("show")
    },
    onAdded: function() {
        this.callParent(arguments);
        if (this.hierarchyEventSource.hasListeners.added) {
            this.fireHierarchyEvent("added")
        }
    },
    getChildByElement: function(g, a) {
        var k, d, c = 0,
            e = this.getRefItems(),
            j = e.length;
        g = Ext.getDom(g);
        for (; c < j; c++) {
            k = e[c];
            d = k.getEl();
            if (d && ((d.dom === g) || d.contains(g))) {
                return (a && k.getChildByElement) ? k.getChildByElement(g, a) : k
            }
        }
        return null
    }
}, function() {
    this.hierarchyEventSource = this.prototype.hierarchyEventSource = new Ext.util.Observable({
        events: {
            hide: true,
            show: true,
            collapse: true,
            expand: true,
            added: true
        }
    })
});
Ext.define("Ext.container.Viewport", {
    extend: "Ext.container.Container",
    alias: "widget.viewport",
    requires: ["Ext.EventManager"],
    alternateClassName: "Ext.Viewport",
    isViewport: true,
    ariaRole: "application",
    preserveElOnDestroy: true,
    initComponent: function() {
        var d = this,
            a = document.body.parentNode,
            c;
        Ext.getScrollbarSize();
        d.width = d.height = undefined;
        d.callParent(arguments);
        Ext.fly(a).addCls(Ext.baseCSSPrefix + "viewport");
        if (d.autoScroll) {
            delete d.autoScroll;
            Ext.fly(a).setStyle("overflow", "auto")
        }
        d.el = c = Ext.getBody();
        c.setHeight = Ext.emptyFn;
        c.setWidth = Ext.emptyFn;
        c.setSize = Ext.emptyFn;
        c.dom.scroll = "no";
        d.allowDomMove = false;
        d.renderTo = d.el
    },
    onRender: function() {
        var a = this;
        a.callParent(arguments);
        a.width = Ext.Element.getViewportWidth();
        a.height = Ext.Element.getViewportHeight()
    },
    afterFirstLayout: function() {
        var a = this;
        a.callParent(arguments);
        setTimeout(function() {
            Ext.EventManager.onWindowResize(a.fireResize, a)
        }, 1)
    },
    fireResize: function(c, a) {
        if (c != this.width || a != this.height) {
            this.setSize(c, a)
        }
    }
});
Ext.define("Ext.layout.container.boxOverflow.None", {
    alternateClassName: "Ext.layout.boxOverflow.None",
    constructor: function(c, a) {
        this.layout = c;
        Ext.apply(this, a)
    },
    handleOverflow: Ext.emptyFn,
    clearOverflow: Ext.emptyFn,
    beginLayout: Ext.emptyFn,
    beginLayoutCycle: Ext.emptyFn,
    finishedLayout: Ext.emptyFn,
    completeLayout: function(c) {
        var a = this,
            d = c.state.boxPlan,
            e;
        if (d && d.tooNarrow) {
            e = a.handleOverflow(c);
            if (e) {
                if (e.reservedSpace) {
                    a.layout.publishInnerCtSize(c, e.reservedSpace)
                }
            }
        } else {
            a.clearOverflow()
        }
    },
    onRemove: Ext.emptyFn,
    getItem: function(a) {
        return this.layout.owner.getComponent(a)
    },
    getOwnerType: function(a) {
        var c;
        if (a.isToolbar) {
            c = "toolbar"
        } else {
            if (a.isTabBar) {
                c = "tabbar"
            } else {
                if (a.isMenu) {
                    c = "menu"
                } else {
                    c = a.getXType()
                }
            }
        }
        return c
    },
    getPrefixConfig: Ext.emptyFn,
    getSuffixConfig: Ext.emptyFn,
    getOverflowCls: function() {
        return ""
    }
});
Ext.define("Ext.toolbar.Item", {
    extend: "Ext.Component",
    alias: "widget.tbitem",
    alternateClassName: "Ext.Toolbar.Item",
    enable: Ext.emptyFn,
    disable: Ext.emptyFn,
    focus: Ext.emptyFn
});
Ext.define("Ext.toolbar.Separator", {
    extend: "Ext.toolbar.Item",
    alias: "widget.tbseparator",
    alternateClassName: "Ext.Toolbar.Separator",
    baseCls: Ext.baseCSSPrefix + "toolbar-separator",
    focusable: false,
    border: true
});
Ext.define("Ext.layout.component.Button", {
    alias: ["layout.button"],
    extend: "Ext.layout.component.Auto",
    type: "button",
    cellClsRE: /-btn-(tl|br)\b/,
    htmlRE: /<.*>/,
    constructor: function() {
        this.callParent(arguments);
        this.hackWidth = Ext.isIE && (!Ext.isStrict || Ext.isIE6 || Ext.isIE7 || Ext.isIE8);
        this.heightIncludesPadding = Ext.isIE6 && Ext.isStrict
    },
    beginLayout: function(a) {
        this.callParent(arguments);
        this.cacheTargetInfo(a)
    },
    beginLayoutCycle: function(g) {
        var d = this,
            e = "",
            a = d.owner,
            c = a.btnEl,
            k = a.btnInnerEl,
            i = a.text,
            j;
        d.callParent(arguments);
        k.setStyle("overflow", e);
        if (!g.widthModel.natural) {
            a.el.setStyle("width", e)
        }
        j = g.heightModel.shrinkWrap && i && d.htmlRE.test(i);
        c.setStyle("width", e);
        c.setStyle("height", j ? "auto" : e);
        k.setStyle("width", e);
        k.setStyle("height", j ? "auto" : e);
        k.setStyle("line-height", j ? "normal" : e);
        k.setStyle("padding-top", e);
        a.btnIconEl.setStyle("width", e)
    },
    calculateOwnerHeightFromContentHeight: function(c, a) {
        return a
    },
    calculateOwnerWidthFromContentWidth: function(c, a) {
        return a
    },
    measureContentWidth: function(d) {
        var k = this,
            c = k.owner,
            i = c.btnEl,
            e = c.btnInnerEl,
            n = c.text,
            o, l, j, a, m, g;
        if (c.text && k.hackWidth && i) {
            o = k.btnFrameWidth;
            if (n.indexOf(">") === -1) {
                n = n.replace(/</g, "&lt;")
            }
            l = Ext.util.TextMetrics.measure(e, n);
            a = l.width + o + k.adjWidth;
            m = d.getEl("btnEl");
            g = d.getEl("btnInnerEl");
            j = (c.icon || c.iconCls) && (c.iconAlign == "top" || c.iconAlign == "bottom");
            d.setWidth(a);
            m.setWidth(l.width + o);
            g.setWidth(l.width + o);
            if (j) {
                c.btnIconEl.setWidth(l.width + o)
            }
        } else {
            a = d.el.getWidth()
        }
        return a
    },
    measureContentHeight: function(e) {
        var l = this,
            c = l.owner,
            g = c.btnInnerEl,
            k = e.getEl("btnEl"),
            i = e.getEl("btnInnerEl"),
            d = l.minTextHeight,
            j = l.adjHeight,
            o = c.getText(),
            n, m, a;
        if (c.vertical) {
            n = Ext.util.TextMetrics.measure(g, c.text).width;
            n += l.btnFrameHeight + j;
            e.setHeight(n, true, true)
        } else {
            if (o && l.htmlRE.test(o)) {
                m = g.getHeight();
                if (m < d) {
                    a = Math.floor((d - m) / 2);
                    i.setHeight(d - (l.heightIncludesPadding ? a : 0));
                    i.setProp("padding-top", a);
                    m = d
                }
                n = m + j
            } else {
                n = e.el.getHeight()
            }
        }
        k.setHeight(n - j);
        return n
    },
    publishInnerHeight: function(d, o) {
        var l = this,
            a = l.owner,
            i = Ext.isNumber,
            k = d.getEl("btnEl"),
            e = a.btnInnerEl,
            j = d.getEl("btnInnerEl"),
            g = i(o) ? o - l.adjHeight : o,
            c = l.btnFrameHeight,
            n = a.getText(),
            m, p;
        k.setHeight(g);
        j.setHeight(g);
        if (!a.vertical && g >= 0) {
            j.setProp("line-height", g - c + "px")
        }
        if (n && l.htmlRE.test(n)) {
            j.setProp("line-height", "normal");
            e.setStyle("line-height", "normal");
            m = Ext.util.TextMetrics.measure(e, n).height;
            p = Math.floor(Math.max(g - c - m, 0) / 2);
            j.setProp("padding-top", l.btnFrameTop + p);
            j.setHeight(g - (l.heightIncludesPadding ? p : 0))
        }
    },
    publishInnerWidth: function(i, d) {
        var g = this,
            j = Ext.isNumber,
            a = i.getEl("btnEl"),
            c = i.getEl("btnInnerEl"),
            e = j(d) ? d - g.adjWidth : d;
        a.setWidth(e);
        c.setWidth(e)
    },
    clearTargetCache: function() {
        delete this.adjWidth
    },
    cacheTargetInfo: function(c) {
        var i = this,
            a = i.owner,
            e = a.scale,
            k, g, l, d, j;
        if (!("adjWidth" in i) || i.lastScale !== e) {
            if (i.lastScale) {
                a.btnInnerEl.setStyle("line-height", "")
            }
            i.lastScale = e;
            k = c.getPaddingInfo();
            g = c.getFrameInfo();
            l = c.getEl("btnWrap").getPaddingInfo();
            d = c.getEl("btnInnerEl");
            j = d.getPaddingInfo();
            Ext.apply(i, {
                adjWidth: l.width + g.width + k.width,
                adjHeight: l.height + g.height + k.height,
                btnFrameWidth: j.width,
                btnFrameHeight: j.height,
                btnFrameTop: j.top,
                minTextHeight: parseInt(d.getStyle("line-height"), 10)
            })
        }
        i.callParent(arguments)
    },
    finishedLayout: function() {
        var a = this.owner;
        this.callParent(arguments);
        if (Ext.isWebKit) {
            a.el.dom.offsetWidth
        }
    }
});
Ext.define("Ext.util.KeyMap", {
    alternateClassName: "Ext.KeyMap",
    eventName: "keydown",
    constructor: function(a) {
        var c = this;
        if ((arguments.length !== 1) || (typeof a === "string") || a.dom || a.tagName || a === document || a.isComponent) {
            c.legacyConstructor.apply(c, arguments);
            return
        }
        Ext.apply(c, a);
        c.bindings = [];
        if (!c.target.isComponent) {
            c.target = Ext.get(c.target)
        }
        if (c.binding) {
            c.addBinding(c.binding)
        } else {
            if (a.key) {
                c.addBinding(a)
            }
        }
        c.enable()
    },
    legacyConstructor: function(c, e, a) {
        var d = this;
        Ext.apply(d, {
            target: Ext.get(c),
            eventName: a || d.eventName,
            bindings: []
        });
        if (e) {
            d.addBinding(e)
        }
        d.enable()
    },
    addBinding: function(k) {
        var j = k.key,
            l = false,
            e, g, c, d, a;
        if (Ext.isArray(k)) {
            for (d = 0, a = k.length; d < a; d++) {
                this.addBinding(k[d])
            }
            return
        }
        if (Ext.isString(j)) {
            g = [];
            c = j.toUpperCase();
            for (d = 0, a = c.length; d < a; ++d) {
                g.push(c.charCodeAt(d))
            }
            j = g;
            l = true
        }
        if (!Ext.isArray(j)) {
            j = [j]
        }
        if (!l) {
            for (d = 0, a = j.length; d < a; ++d) {
                e = j[d];
                if (Ext.isString(e)) {
                    j[d] = e.toUpperCase().charCodeAt(0)
                }
            }
        }
        this.bindings.push(Ext.apply({
            keyCode: j
        }, k))
    },
    handleTargetEvent: (function() {
        var a = /input|textarea/i;
        return function(j) {
            var g = this,
                l, d, c, k, e;
            if (this.enabled) {
                l = this.bindings;
                d = 0;
                c = l.length;
                j = g.processEvent.apply(g || g.processEventScope, arguments);
                if (g.ignoreInputFields) {
                    k = j.target;
                    e = k.contentEditable;
                    if (a.test(k.tagName) || (e === "" || e === "true")) {
                        return
                    }
                }
                if (!j.getKey) {
                    return j
                }
                for (; d < c; ++d) {
                    this.processBinding(l[d], j)
                }
            }
        }
    }()),
    processEvent: function(a) {
        return a
    },
    processBinding: function(j, a) {
        if (this.checkModifiers(j, a)) {
            var k = a.getKey(),
                m = j.fn || j.handler,
                n = j.scope || this,
                l = j.keyCode,
                c = j.defaultEventAction,
                d, g, e = new Ext.EventObjectImpl(a);
            for (d = 0, g = l.length; d < g; ++d) {
                if (k === l[d]) {
                    if (m.call(n, k, a) !== true && c) {
                        e[c]()
                    }
                    break
                }
            }
        }
    },
    checkModifiers: function(l, j) {
        var g = ["shift", "ctrl", "alt"],
            d = 0,
            a = g.length,
            k, c;
        for (; d < a; ++d) {
            c = g[d];
            k = l[c];
            if (!(k === undefined || (k === j[c + "Key"]))) {
                return false
            }
        }
        return true
    },
    on: function(c, e, d) {
        var j, a, g, i;
        if (Ext.isObject(c) && !Ext.isArray(c)) {
            j = c.key;
            a = c.shift;
            g = c.ctrl;
            i = c.alt
        } else {
            j = c
        }
        this.addBinding({
            key: j,
            shift: a,
            ctrl: g,
            alt: i,
            fn: e,
            scope: d
        })
    },
    isEnabled: function() {
        return this.enabled
    },
    enable: function() {
        var a = this;
        if (!a.enabled) {
            a.target.on(a.eventName, a.handleTargetEvent, a);
            a.enabled = true
        }
    },
    disable: function() {
        var a = this;
        if (a.enabled) {
            a.target.removeListener(a.eventName, a.handleTargetEvent, a);
            a.enabled = false
        }
    },
    setDisabled: function(a) {
        if (a) {
            this.disable()
        } else {
            this.enable()
        }
    },
    destroy: function(d) {
        var a = this,
            c = a.target;
        a.bindings = [];
        a.disable();
        if (d === true) {
            if (c.isComponent) {
                c.destroy()
            } else {
                c.remove()
            }
        }
        delete a.target
    }
});
Ext.define("Ext.menu.Manager", {
    singleton: true,
    requires: ["Ext.util.MixedCollection", "Ext.util.KeyMap"],
    alternateClassName: "Ext.menu.MenuMgr",
    uses: ["Ext.menu.Menu"],
    menus: {},
    groups: {},
    attached: false,
    lastShow: new Date(),
    init: function() {
        var a = this;
        a.active = new Ext.util.MixedCollection();
        Ext.getDoc().addKeyListener(27, function() {
            if (a.active.length > 0) {
                a.hideAll()
            }
        }, a)
    },
    hideAll: function() {
        var d = this.active,
            g, c, a, e;
        if (d && d.length > 0) {
            g = d.clone();
            c = g.items;
            e = c.length;
            for (a = 0; a < e; a++) {
                c[a].hide()
            }
            return true
        }
        return false
    },
    onHide: function(a) {
        var c = this,
            d = c.active;
        d.remove(a);
        if (d.length < 1) {
            Ext.getDoc().un("mousedown", c.onMouseDown, c);
            c.attached = false
        }
    },
    onShow: function(a) {
        var g = this,
            i = g.active,
            e = i.last(),
            d = g.attached,
            c = a.getEl(),
            j;
        g.lastShow = new Date();
        i.add(a);
        if (!d) {
            Ext.getDoc().on("mousedown", g.onMouseDown, g, {
                buffer: Ext.isIE ? 10 : undefined
            });
            g.attached = true
        }
        a.toFront()
    },
    onBeforeHide: function(a) {
        if (a.activeChild) {
            a.activeChild.hide()
        }
        if (a.autoHideTimer) {
            clearTimeout(a.autoHideTimer);
            delete a.autoHideTimer
        }
    },
    onBeforeShow: function(a) {
        var d = this.active,
            c = a.parentMenu;
        d.remove(a);
        if (!c && !a.allowOtherMenus) {
            this.hideAll()
        } else {
            if (c && c.activeChild && a != c.activeChild) {
                c.activeChild.hide()
            }
        }
    },
    onMouseDown: function(g) {
        var c = this,
            d = c.active,
            a = c.lastShow;
        if (Ext.Date.getElapsed(a) > 50 && d.length > 0 && !g.getTarget("." + Ext.baseCSSPrefix + "menu")) {
            c.hideAll()
        }
    },
    register: function(c) {
        var a = this;
        if (!a.active) {
            a.init()
        }
        if (c.floating) {
            a.menus[c.id] = c;
            c.on({
                beforehide: a.onBeforeHide,
                hide: a.onHide,
                beforeshow: a.onBeforeShow,
                show: a.onShow,
                scope: a
            })
        }
    },
    get: function(c) {
        var a = this.menus;
        if (typeof c == "string") {
            if (!a) {
                return null
            }
            return a[c]
        } else {
            if (c.isMenu) {
                return c
            } else {
                if (Ext.isArray(c)) {
                    return new Ext.menu.Menu({
                        items: c
                    })
                } else {
                    return Ext.ComponentManager.create(c, "menu")
                }
            }
        }
    },
    unregister: function(e) {
        var a = this,
            c = a.menus,
            d = a.active;
        delete c[e.id];
        d.remove(e);
        e.un({
            beforehide: a.onBeforeHide,
            hide: a.onHide,
            beforeshow: a.onBeforeShow,
            show: a.onShow,
            scope: a
        })
    },
    registerCheckable: function(d) {
        var a = this.groups,
            c = d.group;
        if (c) {
            if (!a[c]) {
                a[c] = []
            }
            a[c].push(d)
        }
    },
    unregisterCheckable: function(d) {
        var a = this.groups,
            c = d.group;
        if (c) {
            Ext.Array.remove(a[c], d)
        }
    },
    onCheckChange: function(e, j) {
        var a = this.groups,
            d = e.group,
            c = 0,
            l, g, k;
        if (d && j) {
            l = a[d];
            g = l.length;
            for (; c < g; c++) {
                k = l[c];
                if (k != e) {
                    k.setChecked(false)
                }
            }
        }
    }
});
Ext.define("Ext.util.ClickRepeater", {
    extend: "Ext.util.Observable",
    constructor: function(c, a) {
        var d = this;
        d.el = Ext.get(c);
        d.el.unselectable();
        Ext.apply(d, a);
        d.callParent();
        d.addEvents("mousedown", "click", "mouseup");
        if (!d.disabled) {
            d.disabled = true;
            d.enable()
        }
        if (d.handler) {
            d.on("click", d.handler, d.scope || d)
        }
    },
    interval: 20,
    delay: 250,
    preventDefault: true,
    stopDefault: false,
    timer: 0,
    enable: function() {
        if (this.disabled) {
            this.el.on("mousedown", this.handleMouseDown, this);
            if (Ext.isIE && !(Ext.isStrict && Ext.isIE9)) {
                this.el.on("dblclick", this.handleDblClick, this)
            }
            if (this.preventDefault || this.stopDefault) {
                this.el.on("click", this.eventOptions, this)
            }
        }
        this.disabled = false
    },
    disable: function(a) {
        if (a || !this.disabled) {
            clearTimeout(this.timer);
            if (this.pressedCls) {
                this.el.removeCls(this.pressedCls)
            }
            Ext.getDoc().un("mouseup", this.handleMouseUp, this);
            this.el.removeAllListeners()
        }
        this.disabled = true
    },
    setDisabled: function(a) {
        this[a ? "disable" : "enable"]()
    },
    eventOptions: function(a) {
        if (this.preventDefault) {
            a.preventDefault()
        }
        if (this.stopDefault) {
            a.stopEvent()
        }
    },
    destroy: function() {
        this.disable(true);
        Ext.destroy(this.el);
        this.clearListeners()
    },
    handleDblClick: function(a) {
        clearTimeout(this.timer);
        this.el.blur();
        this.fireEvent("mousedown", this, a);
        this.fireEvent("click", this, a)
    },
    handleMouseDown: function(a) {
        clearTimeout(this.timer);
        this.el.blur();
        if (this.pressedCls) {
            this.el.addCls(this.pressedCls)
        }
        this.mousedownTime = new Date();
        Ext.getDoc().on("mouseup", this.handleMouseUp, this);
        this.el.on("mouseout", this.handleMouseOut, this);
        this.fireEvent("mousedown", this, a);
        this.fireEvent("click", this, a);
        if (this.accelerate) {
            this.delay = 400
        }
        a = new Ext.EventObjectImpl(a);
        this.timer = Ext.defer(this.click, this.delay || this.interval, this, [a])
    },
    click: function(a) {
        this.fireEvent("click", this, a);
        this.timer = Ext.defer(this.click, this.accelerate ? this.easeOutExpo(Ext.Date.getElapsed(this.mousedownTime), 400, -390, 12000) : this.interval, this, [a])
    },
    easeOutExpo: function(e, a, i, g) {
        return (e == g) ? a + i : i * (-Math.pow(2, -10 * e / g) + 1) + a
    },
    handleMouseOut: function() {
        clearTimeout(this.timer);
        if (this.pressedCls) {
            this.el.removeCls(this.pressedCls)
        }
        this.el.on("mouseover", this.handleMouseReturn, this)
    },
    handleMouseReturn: function() {
        this.el.un("mouseover", this.handleMouseReturn, this);
        if (this.pressedCls) {
            this.el.addCls(this.pressedCls)
        }
        this.click()
    },
    handleMouseUp: function(a) {
        clearTimeout(this.timer);
        this.el.un("mouseover", this.handleMouseReturn, this);
        this.el.un("mouseout", this.handleMouseOut, this);
        Ext.getDoc().un("mouseup", this.handleMouseUp, this);
        if (this.pressedCls) {
            this.el.removeCls(this.pressedCls)
        }
        this.fireEvent("mouseup", this, a)
    }
});
Ext.define("Ext.util.TextMetrics", {
    statics: {
        shared: null,
        measure: function(a, e, g) {
            var c = this,
                d = c.shared;
            if (!d) {
                d = c.shared = new c(a, g)
            }
            d.bind(a);
            d.setFixedWidth(g || "auto");
            return d.getSize(e)
        },
        destroy: function() {
            var a = this;
            Ext.destroy(a.shared);
            a.shared = null
        }
    },
    constructor: function(a, d) {
        var c = this.measure = Ext.getBody().createChild({
            cls: Ext.baseCSSPrefix + "textmetrics"
        });
        this.el = Ext.get(a);
        c.position("absolute");
        c.setLeftTop(-1000, -1000);
        c.hide();
        if (d) {
            c.setWidth(d)
        }
    },
    getSize: function(d) {
        var c = this.measure,
            a;
        c.update(d);
        a = c.getSize();
        c.update("");
        return a
    },
    bind: function(a) {
        var c = this;
        c.el = Ext.get(a);
        c.measure.setStyle(c.el.getStyles("font-size", "font-style", "font-weight", "font-family", "line-height", "text-transform", "letter-spacing"))
    },
    setFixedWidth: function(a) {
        this.measure.setWidth(a)
    },
    getWidth: function(a) {
        this.measure.dom.style.width = "auto";
        return this.getSize(a).width
    },
    getHeight: function(a) {
        return this.getSize(a).height
    },
    destroy: function() {
        var a = this;
        a.measure.remove();
        delete a.el;
        delete a.measure
    }
}, function() {
    Ext.Element.addMethods({
        getTextWidth: function(d, c, a) {
            return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.value(d, this.dom.innerHTML, true)).width, c || 0, a || 1000000)
        }
    })
});
Ext.define("Ext.button.Button", {
    alias: "widget.button",
    extend: "Ext.Component",
    requires: ["Ext.menu.Manager", "Ext.util.ClickRepeater", "Ext.layout.component.Button", "Ext.util.TextMetrics", "Ext.util.KeyMap"],
    alternateClassName: "Ext.Button",
    isButton: true,
    componentLayout: "button",
    hidden: false,
    disabled: false,
    pressed: false,
    enableToggle: false,
    menuAlign: "tl-bl?",
    textAlign: "center",
    type: "button",
    clickEvent: "click",
    preventDefault: true,
    handleMouseEvents: true,
    tooltipType: "qtip",
    baseCls: Ext.baseCSSPrefix + "btn",
    pressedCls: "pressed",
    overCls: "over",
    focusCls: "focus",
    menuActiveCls: "menu-active",
    hrefTarget: "_blank",
    border: true,
    childEls: ["btnEl", "btnWrap", "btnInnerEl", "btnIconEl"],
    renderTpl: ['<em id="{id}-btnWrap"<tpl if="splitCls"> class="{splitCls}"</tpl>>', '<tpl if="href">', '<a id="{id}-btnEl" href="{href}" class="{btnCls}" target="{hrefTarget}"', '<tpl if="tabIndex"> tabIndex="{tabIndex}"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', ' role="link">', '<span id="{id}-btnInnerEl" class="{baseCls}-inner">', "{text}", "</span>", '<span id="{id}-btnIconEl" class="{baseCls}-icon {iconCls}"<tpl if="iconUrl"> style="background-image:url({iconUrl})"</tpl>></span>', "</a>", "<tpl else>", '<button id="{id}-btnEl" type="{type}" class="{btnCls}" hidefocus="true"', '<tpl if="tabIndex"> tabIndex="{tabIndex}"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', ' role="button" autocomplete="off">', '<span id="{id}-btnInnerEl" class="{baseCls}-inner" style="{innerSpanStyle}">', "{text}", "</span>", '<span id="{id}-btnIconEl" class="{baseCls}-icon {iconCls}"<tpl if="iconUrl"> style="background-image:url({iconUrl})"</tpl>></span>', "</button>", "</tpl>", "</em>", '<tpl if="closable">', '<a id="{id}-closeEl" href="#" class="{baseCls}-close-btn" title="{closeText}"></a>', "</tpl>"],
    scale: "small",
    allowedScales: ["small", "medium", "large"],
    iconAlign: "left",
    arrowAlign: "right",
    arrowCls: "arrow",
    maskOnDisable: false,
    persistentPadding: undefined,
    shrinkWrap: 3,
    frame: true,
    initComponent: function() {
        var a = this;
        a.callParent(arguments);
        a.addEvents("click", "toggle", "mouseover", "mouseout", "menushow", "menuhide", "menutriggerover", "menutriggerout");
        if (a.menu) {
            a.split = true;
            a.menu = Ext.menu.Manager.get(a.menu);
            a.menu.ownerButton = a
        }
        if (a.url) {
            a.href = a.url
        }
        if (a.href && !a.hasOwnProperty("preventDefault")) {
            a.preventDefault = false
        }
        if (Ext.isString(a.toggleGroup) && a.toggleGroup !== "") {
            a.enableToggle = true
        }
        if (a.html && !a.text) {
            a.text = a.html;
            delete a.html
        }
    },
    getActionEl: function() {
        return this.btnEl
    },
    getFocusEl: function() {
        return this.useElForFocus ? this.el : this.btnEl
    },
    onFocus: function(c) {
        var a = this;
        a.useElForFocus = true;
        a.callParent(arguments);
        a.useElForFocus = false
    },
    onBlur: function(a) {
        this.useElForFocus = true;
        this.callParent(arguments);
        this.useElForFocus = false
    },
    onDisable: function() {
        this.useElForFocus = true;
        this.callParent(arguments);
        this.useElForFocus = false
    },
    setComponentCls: function() {
        var c = this,
            a = c.getComponentCls();
        if (!Ext.isEmpty(c.oldCls)) {
            c.removeClsWithUI(c.oldCls);
            c.removeClsWithUI(c.pressedCls)
        }
        c.oldCls = a;
        c.addClsWithUI(a)
    },
    getComponentCls: function() {
        var c = this,
            a = [];
        if (c.iconCls || c.icon) {
            if (c.text) {
                a.push("icon-text-" + c.iconAlign)
            } else {
                a.push("icon")
            }
        } else {
            if (c.text) {
                a.push("noicon")
            }
        }
        if (c.pressed) {
            a.push(c.pressedCls)
        }
        return a
    },
    beforeRender: function() {
        var a = this;
        a.callParent();
        a.oldCls = a.getComponentCls();
        a.addClsWithUI(a.oldCls);
        Ext.applyIf(a.renderData, a.getTemplateArgs());
        if (a.scale) {
            a.setScale(a.scale)
        }
    },
    onRender: function() {
        var d = this,
            e, a, c;
        d.doc = Ext.getDoc();
        d.callParent(arguments);
        if (d.split && d.arrowTooltip) {
            d.arrowEl.dom.setAttribute(d.getTipAttr(), d.arrowTooltip)
        }
        a = d.el;
        if (d.tooltip) {
            d.setTooltip(d.tooltip, true)
        }
        if (d.handleMouseEvents) {
            c = {
                scope: d,
                mouseover: d.onMouseOver,
                mouseout: d.onMouseOut,
                mousedown: d.onMouseDown
            };
            if (d.split) {
                c.mousemove = d.onMouseMove
            }
        } else {
            c = {
                scope: d
            }
        }
        if (d.menu) {
            d.mon(d.menu, {
                scope: d,
                show: d.onMenuShow,
                hide: d.onMenuHide
            });
            d.keyMap = new Ext.util.KeyMap({
                target: d.el,
                key: Ext.EventObject.DOWN,
                handler: d.onDownKey,
                scope: d
            })
        }
        if (d.repeat) {
            d.mon(new Ext.util.ClickRepeater(a, Ext.isObject(d.repeat) ? d.repeat : {}), "click", d.onRepeatClick, d)
        } else {
            if (c[d.clickEvent]) {
                e = true
            } else {
                c[d.clickEvent] = d.onClick
            }
        }
        d.mon(a, c);
        if (e) {
            d.mon(a, d.clickEvent, d.onClick, d)
        }
        Ext.ButtonToggleManager.register(d)
    },
    getTemplateArgs: function() {
        var d = this,
            c = d.getPersistentPadding(),
            a = "";
        if (Math.max.apply(Math, c) > 0) {
            a = "margin:" + Ext.Array.map(c, function(e) {
                return -e + "px"
            }).join(" ")
        }
        return {
            href: d.getHref(),
            disabled: d.disabled,
            hrefTarget: d.hrefTarget,
            type: d.type,
            btnCls: d.getBtnCls(),
            splitCls: d.getSplitCls(),
            iconUrl: d.icon,
            iconCls: d.iconCls,
            text: d.text || "&#160;",
            tabIndex: d.tabIndex,
            innerSpanStyle: a
        }
    },
    getHref: function() {
        var a = this,
            c = Ext.apply({}, a.baseParams);
        c = Ext.apply(c, a.params);
        return a.href ? Ext.urlAppend(a.href, Ext.Object.toQueryString(c)) : false
    },
    setParams: function(a) {
        this.params = a;
        this.btnEl.dom.href = this.getHref()
    },
    getSplitCls: function() {
        var a = this;
        return a.split ? (a.baseCls + "-" + a.arrowCls) + " " + (a.baseCls + "-" + a.arrowCls + "-" + a.arrowAlign) : ""
    },
    getBtnCls: function() {
        return this.textAlign ? this.baseCls + "-" + this.textAlign : ""
    },
    setIconCls: function(c) {
        var e = this,
            a = e.btnIconEl,
            d = e.iconCls;
        e.iconCls = c;
        if (a) {
            a.removeCls(d);
            a.addCls(c || "");
            e.setComponentCls();
            if (e.didIconStateChange(d, c)) {
                e.updateLayout()
            }
        }
        return e
    },
    setTooltip: function(d, a) {
        var c = this;
        if (c.rendered) {
            if (!a) {
                c.clearTip()
            }
            if (Ext.isObject(d)) {
                Ext.tip.QuickTipManager.register(Ext.apply({
                    target: c.btnEl.id
                }, d));
                c.tooltip = d
            } else {
                c.btnEl.dom.setAttribute(c.getTipAttr(), d)
            }
        } else {
            c.tooltip = d
        }
        return c
    },
    setTextAlign: function(d) {
        var c = this,
            a = c.btnEl;
        if (a) {
            a.removeCls(c.baseCls + "-" + c.textAlign);
            a.addCls(c.baseCls + "-" + d)
        }
        c.textAlign = d;
        return c
    },
    getTipAttr: function() {
        return this.tooltipType == "qtip" ? "data-qtip" : "title"
    },
    getRefItems: function(a) {
        var d = this.menu,
            c;
        if (d) {
            c = d.getRefItems(a);
            c.unshift(d)
        }
        return c || []
    },
    clearTip: function() {
        if (Ext.isObject(this.tooltip)) {
            Ext.tip.QuickTipManager.unregister(this.btnEl)
        }
    },
    beforeDestroy: function() {
        var a = this;
        if (a.rendered) {
            a.clearTip()
        }
        if (a.menu && a.destroyMenu !== false) {
            Ext.destroy(a.menu)
        }
        Ext.destroy(a.btnInnerEl, a.repeater);
        a.callParent()
    },
    onDestroy: function() {
        var a = this;
        if (a.rendered) {
            a.doc.un("mouseover", a.monitorMouseOver, a);
            a.doc.un("mouseup", a.onMouseUp, a);
            delete a.doc;
            Ext.ButtonToggleManager.unregister(a);
            Ext.destroy(a.keyMap);
            delete a.keyMap
        }
        a.callParent()
    },
    setHandler: function(c, a) {
        this.handler = c;
        this.scope = a;
        return this
    },
    setText: function(c) {
        var a = this;
        a.text = c;
        if (a.rendered) {
            a.btnInnerEl.update(c || "&#160;");
            a.setComponentCls();
            if (Ext.isStrict && Ext.isIE8) {
                a.el.repaint()
            }
            a.updateLayout()
        }
        return a
    },
    setIcon: function(c) {
        var d = this,
            a = d.btnIconEl,
            e = d.icon;
        d.icon = c;
        if (a) {
            a.setStyle("background-image", c ? "url(" + c + ")" : "");
            d.setComponentCls();
            if (d.didIconStateChange(e, c)) {
                d.updateLayout()
            }
        }
        return d
    },
    didIconStateChange: function(a, d) {
        var c = Ext.isEmpty(d);
        return Ext.isEmpty(a) ? !c : c
    },
    getText: function() {
        return this.text
    },
    toggle: function(d, a) {
        var c = this;
        d = d === undefined ? !c.pressed : !!d;
        if (d !== c.pressed) {
            if (c.rendered) {
                c[d ? "addClsWithUI" : "removeClsWithUI"](c.pressedCls)
            }
            c.pressed = d;
            if (!a) {
                c.fireEvent("toggle", c, d);
                Ext.callback(c.toggleHandler, c.scope || c, [c, d])
            }
        }
        return c
    },
    maybeShowMenu: function() {
        var a = this;
        if (a.menu && !a.hasVisibleMenu() && !a.ignoreNextClick) {
            a.showMenu()
        }
    },
    showMenu: function() {
        var a = this;
        if (a.rendered && a.menu) {
            if (a.tooltip && a.getTipAttr() != "title") {
                Ext.tip.QuickTipManager.getQuickTip().cancelShow(a.btnEl)
            }
            if (a.menu.isVisible()) {
                a.menu.hide()
            }
            a.menu.showBy(a.el, a.menuAlign, ((!Ext.isStrict && Ext.isIE) || Ext.isIE6) ? [-2, -2] : undefined)
        }
        return a
    },
    hideMenu: function() {
        if (this.hasVisibleMenu()) {
            this.menu.hide()
        }
        return this
    },
    hasVisibleMenu: function() {
        var a = this.menu;
        return a && a.rendered && a.isVisible()
    },
    onRepeatClick: function(a, c) {
        this.onClick(c)
    },
    onClick: function(c) {
        var a = this;
        if (a.preventDefault || (a.disabled && a.getHref()) && c) {
            c.preventDefault()
        }
        if (c.button !== 0) {
            return
        }
        if (!a.disabled) {
            a.doToggle();
            a.maybeShowMenu();
            a.fireHandler(c)
        }
    },
    fireHandler: function(d) {
        var c = this,
            a = c.handler;
        if (c.fireEvent("click", c, d) !== false) {
            if (a) {
                a.call(c.scope || c, c, d)
            }
            c.blur()
        }
    },
    doToggle: function() {
        var a = this;
        if (a.enableToggle && (a.allowDepress !== false || !a.pressed)) {
            a.toggle()
        }
    },
    onMouseOver: function(c) {
        var a = this;
        if (!a.disabled && !c.within(a.el, true, true)) {
            a.onMouseEnter(c)
        }
    },
    onMouseOut: function(c) {
        var a = this;
        if (!c.within(a.el, true, true)) {
            if (a.overMenuTrigger) {
                a.onMenuTriggerOut(c)
            }
            a.onMouseLeave(c)
        }
    },
    onMouseMove: function(j) {
        var g = this,
            d = g.el,
            i = g.overMenuTrigger,
            c, a;
        if (g.split) {
            if (g.arrowAlign === "right") {
                c = j.getX() - d.getX();
                a = d.getWidth()
            } else {
                c = j.getY() - d.getY();
                a = d.getHeight()
            }
            if (c > (a - g.getTriggerSize())) {
                if (!i) {
                    g.onMenuTriggerOver(j)
                }
            } else {
                if (i) {
                    g.onMenuTriggerOut(j)
                }
            }
        }
    },
    getTriggerSize: function() {
        var g = this,
            d = g.triggerSize,
            c, a, e;
        if (d === e) {
            c = g.arrowAlign;
            a = c.charAt(0);
            d = g.triggerSize = g.el.getFrameWidth(a) + g.btnWrap.getFrameWidth(a) + g.frameSize[c]
        }
        return d
    },
    onMouseEnter: function(c) {
        var a = this;
        a.addClsWithUI(a.overCls);
        a.fireEvent("mouseover", a, c)
    },
    onMouseLeave: function(c) {
        var a = this;
        a.removeClsWithUI(a.overCls);
        a.fireEvent("mouseout", a, c)
    },
    onMenuTriggerOver: function(c) {
        var a = this;
        a.overMenuTrigger = true;
        a.fireEvent("menutriggerover", a, a.menu, c)
    },
    onMenuTriggerOut: function(c) {
        var a = this;
        delete a.overMenuTrigger;
        a.fireEvent("menutriggerout", a, a.menu, c)
    },
    enable: function(a) {
        var c = this;
        c.callParent(arguments);
        if (c.btnEl) {
            c.btnEl.dom.disabled = false
        }
        c.removeClsWithUI("disabled");
        return c
    },
    disable: function(a) {
        var c = this;
        c.callParent(arguments);
        if (c.btnEl) {
            c.btnEl.dom.disabled = true
        }
        c.addClsWithUI("disabled");
        c.removeClsWithUI(c.overCls);
        if (c.btnInnerEl && (Ext.isIE6 || Ext.isIE7)) {
            c.btnInnerEl.repaint()
        }
        return c
    },
    setScale: function(d) {
        var a = this,
            c = a.ui.replace("-" + a.scale, "");
        if (!Ext.Array.contains(a.allowedScales, d)) {
            throw ("#setScale: scale must be an allowed scale (" + a.allowedScales.join(", ") + ")")
        }
        a.scale = d;
        a.setUI(c)
    },
    setUI: function(c) {
        var a = this;
        if (a.scale && !c.match(a.scale)) {
            c = c + "-" + a.scale
        }
        a.callParent([c])
    },
    onMouseDown: function(c) {
        var a = this;
        if (!a.disabled && c.button === 0) {
            a.addClsWithUI(a.pressedCls);
            a.doc.on("mouseup", a.onMouseUp, a)
        }
    },
    onMouseUp: function(c) {
        var a = this;
        if (c.button === 0) {
            if (!a.pressed) {
                a.removeClsWithUI(a.pressedCls)
            }
            a.doc.un("mouseup", a.onMouseUp, a)
        }
    },
    onMenuShow: function(c) {
        var a = this;
        a.ignoreNextClick = 0;
        a.addClsWithUI(a.menuActiveCls);
        a.fireEvent("menushow", a, a.menu)
    },
    onMenuHide: function(c) {
        var a = this;
        a.removeClsWithUI(a.menuActiveCls);
        a.ignoreNextClick = Ext.defer(a.restoreClick, 250, a);
        a.fireEvent("menuhide", a, a.menu)
    },
    restoreClick: function() {
        this.ignoreNextClick = 0
    },
    onDownKey: function() {
        var a = this;
        if (!a.disabled) {
            if (a.menu) {
                a.showMenu()
            }
        }
    },
    getPersistentPadding: function() {
        var i = this,
            g = Ext.scopeResetCSS,
            j = i.persistentPadding,
            c, a, e, k, d;
        if (!j) {
            j = i.self.prototype.persistentPadding = [0, 0, 0, 0];
            if (!Ext.isIE) {
                c = new Ext.button.Button({
                    text: "test",
                    style: "position:absolute;top:-999px;"
                });
                c.el = Ext.DomHelper.append(Ext.resetElement, c.getRenderTree(), true);
                c.applyChildEls(c.el);
                e = c.btnEl;
                k = c.btnInnerEl;
                e.setSize(null, null);
                a = k.getOffsetsTo(e);
                j[0] = a[1];
                j[1] = e.getWidth() - k.getWidth() - a[0];
                j[2] = e.getHeight() - k.getHeight() - a[1];
                j[3] = a[0];
                c.destroy();
                c.el.remove()
            }
        }
        return j
    }
}, function() {
    var a = {},
        c = function(e, l) {
            if (l) {
                var k = a[e.toggleGroup],
                    j = k.length,
                    d;
                for (d = 0; d < j; d++) {
                    if (k[d] !== e) {
                        k[d].toggle(false)
                    }
                }
            }
        };
    Ext.ButtonToggleManager = {
        register: function(d) {
            if (!d.toggleGroup) {
                return
            }
            var e = a[d.toggleGroup];
            if (!e) {
                e = a[d.toggleGroup] = []
            }
            e.push(d);
            d.on("toggle", c)
        },
        unregister: function(d) {
            if (!d.toggleGroup) {
                return
            }
            var e = a[d.toggleGroup];
            if (e) {
                Ext.Array.remove(e, d);
                d.un("toggle", c)
            }
        },
        getPressed: function(k) {
            var j = a[k],
                e = 0,
                d;
            if (j) {
                for (d = j.length; e < d; e++) {
                    if (j[e].pressed === true) {
                        return j[e]
                    }
                }
            }
            return null
        }
    }
});
Ext.define("Ext.layout.container.boxOverflow.Menu", {
    extend: "Ext.layout.container.boxOverflow.None",
    requires: ["Ext.toolbar.Separator", "Ext.button.Button"],
    alternateClassName: "Ext.layout.boxOverflow.Menu",
    noItemsMenuText: '<div class="' + Ext.baseCSSPrefix + 'toolbar-no-items">(None)</div>',
    constructor: function(c) {
        var a = this;
        a.callParent(arguments);
        a.triggerButtonCls = a.triggerButtonCls || Ext.baseCSSPrefix + "box-menu-" + c.getNames().right;
        a.menuItems = []
    },
    beginLayout: function(a) {
        this.callParent(arguments);
        this.clearOverflow(a)
    },
    beginLayoutCycle: function(c, a) {
        this.callParent(arguments);
        if (!a) {
            this.clearOverflow(c);
            this.layout.cacheChildItems(c)
        }
    },
    onRemove: function(a) {
        Ext.Array.remove(this.menuItems, a)
    },
    getSuffixConfig: function() {
        var d = this,
            c = d.layout,
            a = c.owner.id;
        d.menu = new Ext.menu.Menu({
            listeners: {
                scope: d,
                beforeshow: d.beforeMenuShow
            }
        });
        d.menuTrigger = new Ext.button.Button({
            id: a + "-menu-trigger",
            cls: Ext.layout.container.Box.prototype.innerCls + " " + d.triggerButtonCls,
            hidden: true,
            ownerCt: c.owner,
            ownerLayout: c,
            iconCls: Ext.baseCSSPrefix + d.getOwnerType(c.owner) + "-more-icon",
            ui: c.owner instanceof Ext.toolbar.Toolbar ? "default-toolbar" : "default",
            menu: d.menu,
            getSplitCls: function() {
                return ""
            }
        });
        return d.menuTrigger.getRenderTree()
    },
    getOverflowCls: function() {
        return Ext.baseCSSPrefix + this.layout.direction + "-box-overflow-body"
    },
    handleOverflow: function(e) {
        var d = this,
            c = d.layout,
            i = c.getNames(),
            g = e.state.boxPlan,
            a = [null, null];
        d.showTrigger(e);
        a[i.heightIndex] = (g.maxSize - d.menuTrigger[i.getHeight]()) / 2;
        d.menuTrigger.setPosition.apply(d.menuTrigger, a);
        return {
            reservedSpace: d.menuTrigger[i.getWidth]()
        }
    },
    captureChildElements: function() {
        var a = this.menuTrigger;
        if (a.rendering) {
            a.finishRender()
        }
    },
    _asLayoutRoot: {
        isRoot: true
    },
    clearOverflow: function(k) {
        var j = this,
            c = j.menuItems,
            g, d = 0,
            e = c.length,
            a = j.layout.owner,
            l = j._asLayoutRoot;
        a.suspendLayouts();
        j.captureChildElements();
        j.hideTrigger();
        a.resumeLayouts();
        for (; d < e; d++) {
            g = c[d];
            g.suspendLayouts();
            g.show();
            g.resumeLayouts(l)
        }
        c.length = 0
    },
    showTrigger: function(d) {
        var q = this,
            m = q.layout,
            a = m.owner,
            p = m.getNames(),
            t = p.x,
            g = p.width,
            r = d.state.boxPlan,
            c = r.targetSize[g],
            k = d.childItems,
            n = k.length,
            j = q.menuTrigger,
            s, l, e, o;
        j.suspendLayouts();
        j.show();
        j.resumeLayouts(q._asLayoutRoot);
        c -= q.menuTrigger.getWidth();
        a.suspendLayouts();
        q.menuItems.length = 0;
        for (e = 0; e < n; e++) {
            s = k[e];
            o = s.props;
            if (o[t] + o[g] > c) {
                l = s.target;
                q.menuItems.push(l);
                l.hide()
            }
        }
        a.resumeLayouts()
    },
    hideTrigger: function() {
        var a = this.menuTrigger;
        if (a) {
            a.hide()
        }
    },
    beforeMenuShow: function(l) {
        var k = this,
            c = k.menuItems,
            e = 0,
            a = c.length,
            j, g, d = function(m, i) {
                return m.isXType("buttongroup") && !(i instanceof Ext.toolbar.Separator)
            };
        l.suspendLayouts();
        k.clearMenu();
        l.removeAll();
        for (; e < a; e++) {
            j = c[e];
            if (!e && (j instanceof Ext.toolbar.Separator)) {
                continue
            }
            if (g && (d(j, g) || d(g, j))) {
                l.add("-")
            }
            k.addComponentToMenu(l, j);
            g = j
        }
        if (l.items.length < 1) {
            l.add(k.noItemsMenuText)
        }
        l.resumeLayouts()
    },
    createMenuConfig: function(d, a) {
        var c = Ext.apply({}, d.initialConfig),
            e = d.toggleGroup;
        Ext.copyTo(c, d, ["iconCls", "icon", "itemId", "disabled", "handler", "scope", "menu"]);
        Ext.apply(c, {
            text: d.overflowText || d.text,
            hideOnClick: a,
            destroyMenu: false
        });
        if (d.isFormField) {
            c.value = d.getValue();
            if (!c.listeners) {
                c.listeners = {}
            }
            c.listeners.change = function(j, i, g) {
                d.setValue(i)
            }
        } else {
            if (e || d.enableToggle) {
                Ext.apply(c, {
                    iconAlign: "right",
                    hideOnClick: false,
                    group: e,
                    checked: d.pressed,
                    listeners: {
                        checkchange: function(i, g) {
                            d.toggle(g)
                        }
                    }
                })
            }
        }
        delete c.ownerCt;
        delete c.xtype;
        delete c.id;
        return c
    },
    addComponentToMenu: function(j, d) {
        var g = this,
            e, c, a;
        if (d instanceof Ext.toolbar.Separator) {
            j.add("-")
        } else {
            if (d.isComponent) {
                if (d.isXType("splitbutton")) {
                    j.add(g.createMenuConfig(d, true))
                } else {
                    if (d.isXType("button")) {
                        j.add(g.createMenuConfig(d, !d.menu))
                    } else {
                        if (d.isXType("buttongroup")) {
                            c = d.items.items;
                            a = c.length;
                            for (e = 0; e < a; e++) {
                                g.addComponentToMenu(j, c[e])
                            }
                        } else {
                            j.add(Ext.create(Ext.getClassName(d), g.createMenuConfig(d)))
                        }
                    }
                }
            }
        }
    },
    clearMenu: function() {
        var g = this.menu,
            c, d, a, e;
        if (g && g.items) {
            c = g.items.items;
            a = c.length;
            for (d = 0; d < a; d++) {
                e = c[d];
                if (e.setMenu) {
                    e.setMenu(null)
                }
            }
        }
    },
    destroy: function() {
        var a = this.menuTrigger;
        if (a && !this.layout.owner.items.contains(a)) {
            delete a.ownerCt
        }
        Ext.destroy(this.menu, a)
    }
});
Ext.define("Ext.layout.container.boxOverflow.Scroller", {
    extend: "Ext.layout.container.boxOverflow.None",
    requires: ["Ext.util.ClickRepeater", "Ext.Element"],
    alternateClassName: "Ext.layout.boxOverflow.Scroller",
    mixins: {
        observable: "Ext.util.Observable"
    },
    animateScroll: false,
    scrollIncrement: 20,
    wheelIncrement: 10,
    scrollRepeatInterval: 60,
    scrollDuration: 400,
    scrollerCls: Ext.baseCSSPrefix + "box-scroller",
    constructor: function(d, a) {
        var c = this;
        c.layout = d;
        Ext.apply(c, a || {});
        c.mixins.observable.constructor.call(c);
        c.addEvents("scroll");
        c.scrollPosition = 0;
        c.scrollSize = 0
    },
    getPrefixConfig: function() {
        var a = this;
        a.initCSSClasses();
        return {
            cls: Ext.layout.container.Box.prototype.innerCls + " " + a.beforeCtCls,
            cn: {
                id: a.layout.owner.id + "-before-scroller",
                cls: a.scrollerCls + " " + a.beforeScrollerCls,
                style: "display:none"
            }
        }
    },
    getSuffixConfig: function() {
        var a = this;
        return {
            cls: Ext.layout.container.Box.prototype.innerCls + " " + a.afterCtCls,
            cn: {
                id: a.layout.owner.id + "-after-scroller",
                cls: a.scrollerCls + " " + a.afterScrollerCls,
                style: "display:none"
            }
        }
    },
    getOverflowCls: function() {
        return Ext.baseCSSPrefix + this.layout.direction + "-box-overflow-body"
    },
    initCSSClasses: function() {
        var e = this,
            g = Ext.baseCSSPrefix,
            d = e.layout,
            i = d.getNames(),
            a = i.left,
            j = i.right,
            c = e.getOwnerType(d.owner);
        e.beforeCtCls = e.beforeCtCls || g + "box-scroller-" + a;
        e.afterCtCls = e.afterCtCls || g + "box-scroller-" + j;
        e.beforeScrollerCls = e.beforeScrollerCls || g + c + "-scroll-" + a;
        e.afterScrollerCls = e.afterScrollerCls || g + c + "-scroll-" + j
    },
    beginLayout: function(c) {
        var a = this.layout,
            d = a.getNames();
        c.innerCtScrollPos = a.innerCt.dom["scroll" + d.leftCap];
        this.callParent(arguments)
    },
    completeLayout: function(a) {
        this.scrollSize = a.props["content" + this.layout.getNames().widthCap];
        this.callParent(arguments)
    },
    finishedLayout: function(d) {
        var c = this,
            a = c.layout,
            e = a.getNames(),
            g = Math.min(c.getMaxScrollPosition(), d.innerCtScrollPos);
        a.innerCt.dom["scroll" + e.leftCap] = g
    },
    handleOverflow: function(e) {
        var d = this,
            c = d.layout,
            g = c.getNames(),
            a = "get" + g.widthCap;
        d.captureChildElements();
        d.showScrollers();
        return {
            reservedSpace: d.beforeCt[a]() + d.afterCt[a]()
        }
    },
    captureChildElements: function() {
        var c = this,
            a = c.layout.owner.el,
            d, e;
        if (!c.beforeCt) {
            d = c.beforeScroller = a.getById(c.layout.owner.id + "-before-scroller");
            e = c.afterScroller = a.getById(c.layout.owner.id + "-after-scroller");
            c.beforeCt = d.up("");
            c.afterCt = e.up("");
            c.createWheelListener();
            d.addClsOnOver(c.beforeScrollerCls + "-hover");
            e.addClsOnOver(c.afterScrollerCls + "-hover");
            d.setVisibilityMode(Ext.Element.DISPLAY);
            e.setVisibilityMode(Ext.Element.DISPLAY);
            c.beforeRepeater = new Ext.util.ClickRepeater(d, {
                interval: c.scrollRepeatInterval,
                handler: c.scrollLeft,
                scope: c
            });
            c.afterRepeater = new Ext.util.ClickRepeater(e, {
                interval: c.scrollRepeatInterval,
                handler: c.scrollRight,
                scope: c
            })
        }
    },
    createWheelListener: function() {
        this.layout.innerCt.on({
            mousewheel: function(a) {
                this.scrollBy(a.getWheelDelta() * this.wheelIncrement * -1, false)
            },
            stopEvent: true,
            scope: this
        })
    },
    clearOverflow: function() {
        var a = this.layout;
        this.hideScrollers()
    },
    showScrollers: function() {
        var a = this;
        a.captureChildElements();
        a.beforeScroller.show();
        a.afterScroller.show();
        a.updateScrollButtons();
        a.layout.owner.addClsWithUI("scroller")
    },
    hideScrollers: function() {
        var a = this;
        if (a.beforeScroller !== undefined) {
            a.beforeScroller.hide();
            a.afterScroller.hide();
            a.layout.owner.removeClsWithUI("scroller")
        }
    },
    destroy: function() {
        var a = this;
        Ext.destroy(a.beforeRepeater, a.afterRepeater, a.beforeScroller, a.afterScroller, a.beforeCt, a.afterCt)
    },
    scrollBy: function(c, a) {
        this.scrollTo(this.getScrollPosition() + c, a)
    },
    getScrollAnim: function() {
        return {
            duration: this.scrollDuration,
            callback: this.updateScrollButtons,
            scope: this
        }
    },
    updateScrollButtons: function() {
        var e = this,
            g, d, a, c;
        if (e.beforeScroller === undefined || e.afterScroller === undefined) {
            return
        }
        g = e.atExtremeBefore() ? "addCls" : "removeCls";
        d = e.atExtremeAfter() ? "addCls" : "removeCls";
        a = e.beforeScrollerCls + "-disabled";
        c = e.afterScrollerCls + "-disabled";
        e.beforeScroller[g](a);
        e.afterScroller[d](c);
        e.scrolling = false
    },
    atExtremeBefore: function() {
        return !this.getScrollPosition()
    },
    scrollLeft: function() {
        this.scrollBy(-this.scrollIncrement, false)
    },
    scrollRight: function() {
        this.scrollBy(this.scrollIncrement, false)
    },
    getScrollPosition: function() {
        var d = this,
            c = d.layout,
            a;
        if (d.hasOwnProperty("scrollPosition")) {
            a = d.scrollPosition
        } else {
            a = parseInt(c.innerCt.dom["scroll" + c.getNames().leftCap], 10) || 0
        }
        return a
    },
    getMaxScrollPosition: function() {
        var c = this,
            a = c.layout,
            d = a.getNames(),
            e = c.scrollSize - a.innerCt["get" + d.widthCap]();
        return (e < 0) ? 0 : e
    },
    atExtremeAfter: function() {
        return this.getScrollPosition() >= this.getMaxScrollPosition()
    },
    scrollTo: function(a, c) {
        var i = this,
            g = i.layout,
            j = g.getNames(),
            e = i.getScrollPosition(),
            d = Ext.Number.constrain(a, 0, i.getMaxScrollPosition());
        if (d != e && !i.scrolling) {
            delete i.scrollPosition;
            if (c === undefined) {
                c = i.animateScroll
            }
            g.innerCt.scrollTo(j.left, d, c ? i.getScrollAnim() : false);
            if (c) {
                i.scrolling = true
            } else {
                i.updateScrollButtons()
            }
            i.fireEvent("scroll", i, d, c ? i.getScrollAnim() : false)
        }
    },
    scrollToItem: function(j, c) {
        var i = this,
            g = i.layout,
            k = g.getNames(),
            a, e, d;
        j = i.getItem(j);
        if (j !== undefined) {
            a = i.getItemVisibility(j);
            if (!a.fullyVisible) {
                e = j.getBox(true, true);
                d = e[k.x];
                if (a.hiddenEnd) {
                    d -= (i.layout.innerCt["get" + k.widthCap]() - e[k.width])
                }
                i.scrollTo(d, c)
            }
        }
    },
    getItemVisibility: function(l) {
        var j = this,
            c = j.getItem(l).getBox(true, true),
            d = j.layout,
            i = d.getNames(),
            g = c[i.x],
            e = g + c[i.width],
            a = j.getScrollPosition(),
            k = a + d.innerCt["get" + i.widthCap]();
        return {
            hiddenStart: g < a,
            hiddenEnd: e > k,
            fullyVisible: g > a && e < k
        }
    }
});
Ext.define("Ext.util.Offset", {
    statics: {
        fromObject: function(a) {
            return new this(a.x, a.y)
        }
    },
    constructor: function(a, c) {
        this.x = (a != null && !isNaN(a)) ? a : 0;
        this.y = (c != null && !isNaN(c)) ? c : 0;
        return this
    },
    copy: function() {
        return new Ext.util.Offset(this.x, this.y)
    },
    copyFrom: function(a) {
        this.x = a.x;
        this.y = a.y
    },
    toString: function() {
        return "Offset[" + this.x + "," + this.y + "]"
    },
    equals: function(a) {
        return (this.x == a.x && this.y == a.y)
    },
    round: function(c) {
        if (!isNaN(c)) {
            var a = Math.pow(10, c);
            this.x = Math.round(this.x * a) / a;
            this.y = Math.round(this.y * a) / a
        } else {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y)
        }
    },
    isZero: function() {
        return this.x == 0 && this.y == 0
    }
});
Ext.define("Ext.util.Region", {
    requires: ["Ext.util.Offset"],
    statics: {
        getRegion: function(a) {
            return Ext.fly(a).getPageBox(true)
        },
        from: function(a) {
            return new this(a.top, a.right, a.bottom, a.left)
        }
    },
    constructor: function(d, g, a, c) {
        var e = this;
        e.y = e.top = e[1] = d;
        e.right = g;
        e.bottom = a;
        e.x = e.left = e[0] = c
    },
    contains: function(c) {
        var a = this;
        return (c.x >= a.x && c.right <= a.right && c.y >= a.y && c.bottom <= a.bottom)
    },
    intersect: function(i) {
        var g = this,
            d = Math.max(g.y, i.y),
            e = Math.min(g.right, i.right),
            a = Math.min(g.bottom, i.bottom),
            c = Math.max(g.x, i.x);
        if (a > d && e > c) {
            return new this.self(d, e, a, c)
        } else {
            return false
        }
    },
    union: function(i) {
        var g = this,
            d = Math.min(g.y, i.y),
            e = Math.max(g.right, i.right),
            a = Math.max(g.bottom, i.bottom),
            c = Math.min(g.x, i.x);
        return new this.self(d, e, a, c)
    },
    constrainTo: function(c) {
        var a = this,
            d = Ext.Number.constrain;
        a.top = a.y = d(a.top, c.y, c.bottom);
        a.bottom = d(a.bottom, c.y, c.bottom);
        a.left = a.x = d(a.left, c.x, c.right);
        a.right = d(a.right, c.x, c.right);
        return a
    },
    adjust: function(d, g, a, c) {
        var e = this;
        e.top = e.y += d;
        e.left = e.x += c;
        e.right += g;
        e.bottom += a;
        return e
    },
    getOutOfBoundOffset: function(a, c) {
        if (!Ext.isObject(a)) {
            if (a == "x") {
                return this.getOutOfBoundOffsetX(c)
            } else {
                return this.getOutOfBoundOffsetY(c)
            }
        } else {
            c = a;
            var e = new Ext.util.Offset();
            e.x = this.getOutOfBoundOffsetX(c.x);
            e.y = this.getOutOfBoundOffsetY(c.y);
            return e
        }
    },
    getOutOfBoundOffsetX: function(a) {
        if (a <= this.x) {
            return this.x - a
        } else {
            if (a >= this.right) {
                return this.right - a
            }
        }
        return 0
    },
    getOutOfBoundOffsetY: function(a) {
        if (a <= this.y) {
            return this.y - a
        } else {
            if (a >= this.bottom) {
                return this.bottom - a
            }
        }
        return 0
    },
    isOutOfBound: function(a, c) {
        if (!Ext.isObject(a)) {
            if (a == "x") {
                return this.isOutOfBoundX(c)
            } else {
                return this.isOutOfBoundY(c)
            }
        } else {
            c = a;
            return (this.isOutOfBoundX(c.x) || this.isOutOfBoundY(c.y))
        }
    },
    isOutOfBoundX: function(a) {
        return (a < this.x || a > this.right)
    },
    isOutOfBoundY: function(a) {
        return (a < this.y || a > this.bottom)
    },
    restrict: function(c, e, a) {
        if (Ext.isObject(c)) {
            var d;
            a = e;
            e = c;
            if (e.copy) {
                d = e.copy()
            } else {
                d = {
                    x: e.x,
                    y: e.y
                }
            }
            d.x = this.restrictX(e.x, a);
            d.y = this.restrictY(e.y, a);
            return d
        } else {
            if (c == "x") {
                return this.restrictX(e, a)
            } else {
                return this.restrictY(e, a)
            }
        }
    },
    restrictX: function(c, a) {
        if (!a) {
            a = 1
        }
        if (c <= this.x) {
            c -= (c - this.x) * a
        } else {
            if (c >= this.right) {
                c -= (c - this.right) * a
            }
        }
        return c
    },
    restrictY: function(c, a) {
        if (!a) {
            a = 1
        }
        if (c <= this.y) {
            c -= (c - this.y) * a
        } else {
            if (c >= this.bottom) {
                c -= (c - this.bottom) * a
            }
        }
        return c
    },
    getSize: function() {
        return {
            width: this.right - this.x,
            height: this.bottom - this.y
        }
    },
    copy: function() {
        return new this.self(this.y, this.right, this.bottom, this.x)
    },
    copyFrom: function(c) {
        var a = this;
        a.top = a.y = a[1] = c.y;
        a.right = c.right;
        a.bottom = c.bottom;
        a.left = a.x = a[0] = c.x;
        return this
    },
    toString: function() {
        return "Region[" + this.top + "," + this.right + "," + this.bottom + "," + this.left + "]"
    },
    translateBy: function(a, d) {
        if (arguments.length == 1) {
            d = a.y;
            a = a.x
        }
        var c = this;
        c.top = c.y += d;
        c.right += a;
        c.bottom += d;
        c.left = c.x += a;
        return c
    },
    round: function() {
        var a = this;
        a.top = a.y = Math.round(a.y);
        a.right = Math.round(a.right);
        a.bottom = Math.round(a.bottom);
        a.left = a.x = Math.round(a.x);
        return a
    },
    equals: function(a) {
        return (this.top == a.top && this.right == a.right && this.bottom == a.bottom && this.left == a.left)
    }
});
Ext.define("Ext.dd.DragDropManager", {
    singleton: true,
    requires: ["Ext.util.Region"],
    uses: ["Ext.tip.QuickTipManager"],
    alternateClassName: ["Ext.dd.DragDropMgr", "Ext.dd.DDM"],
    ids: {},
    handleIds: {},
    dragCurrent: null,
    dragOvers: {},
    deltaX: 0,
    deltaY: 0,
    preventDefault: true,
    stopPropagation: true,
    initialized: false,
    locked: false,
    init: function() {
        this.initialized = true
    },
    POINT: 0,
    INTERSECT: 1,
    mode: 0,
    notifyOccluded: false,
    _execOnAll: function(d, c) {
        var e, a, g;
        for (e in this.ids) {
            for (a in this.ids[e]) {
                g = this.ids[e][a];
                if (!this.isTypeOfDD(g)) {
                    continue
                }
                g[d].apply(g, c)
            }
        }
    },
    _onLoad: function() {
        this.init();
        var a = Ext.EventManager;
        a.on(document, "mouseup", this.handleMouseUp, this, true);
        a.on(document, "mousemove", this.handleMouseMove, this, true);
        a.on(window, "unload", this._onUnload, this, true);
        a.on(window, "resize", this._onResize, this, true)
    },
    _onResize: function(a) {
        this._execOnAll("resetConstraints", [])
    },
    lock: function() {
        this.locked = true
    },
    unlock: function() {
        this.locked = false
    },
    isLocked: function() {
        return this.locked
    },
    locationCache: {},
    useCache: true,
    clickPixelThresh: 3,
    clickTimeThresh: 350,
    dragThreshMet: false,
    clickTimeout: null,
    startX: 0,
    startY: 0,
    regDragDrop: function(c, a) {
        if (!this.initialized) {
            this.init()
        }
        if (!this.ids[a]) {
            this.ids[a] = {}
        }
        this.ids[a][c.id] = c
    },
    removeDDFromGroup: function(d, a) {
        if (!this.ids[a]) {
            this.ids[a] = {}
        }
        var c = this.ids[a];
        if (c && c[d.id]) {
            delete c[d.id]
        }
    },
    _remove: function(c) {
        for (var a in c.groups) {
            if (a && this.ids[a] && this.ids[a][c.id]) {
                delete this.ids[a][c.id]
            }
        }
        delete this.handleIds[c.id]
    },
    regHandle: function(c, a) {
        if (!this.handleIds[c]) {
            this.handleIds[c] = {}
        }
        this.handleIds[c][a] = a
    },
    isDragDrop: function(a) {
        return (this.getDDById(a)) ? true : false
    },
    getRelated: function(k, c) {
        var g = [],
            e, d, a;
        for (e in k.groups) {
            for (d in this.ids[e]) {
                a = this.ids[e][d];
                if (!this.isTypeOfDD(a)) {
                    continue
                }
                if (!c || a.isTarget) {
                    g[g.length] = a
                }
            }
        }
        return g
    },
    isLegalTarget: function(g, e) {
        var c = this.getRelated(g, true),
            d, a;
        for (d = 0, a = c.length; d < a; ++d) {
            if (c[d].id == e.id) {
                return true
            }
        }
        return false
    },
    isTypeOfDD: function(a) {
        return (a && a.__ygDragDrop)
    },
    isHandle: function(c, a) {
        return (this.handleIds[c] && this.handleIds[c][a])
    },
    getDDById: function(e) {
        var d = this,
            c, a;
        for (c in this.ids) {
            a = this.ids[c][e];
            if (a instanceof Ext.dd.DDTarget) {
                return a
            }
        }
        return null
    },
    handleMouseDown: function(d, c) {
        if (Ext.tip.QuickTipManager) {
            Ext.tip.QuickTipManager.ddDisable()
        }
        if (this.dragCurrent) {
            this.handleMouseUp(d)
        }
        this.currentTarget = d.getTarget();
        this.dragCurrent = c;
        var a = c.getEl();
        if (Ext.isIE && a.setCapture) {
            a.setCapture()
        }
        this.startX = d.getPageX();
        this.startY = d.getPageY();
        this.deltaX = this.startX - a.offsetLeft;
        this.deltaY = this.startY - a.offsetTop;
        this.dragThreshMet = false;
        this.clickTimeout = setTimeout(function() {
            var e = Ext.dd.DragDropManager;
            e.startDrag(e.startX, e.startY)
        }, this.clickTimeThresh)
    },
    startDrag: function(a, c) {
        clearTimeout(this.clickTimeout);
        if (this.dragCurrent) {
            this.dragCurrent.b4StartDrag(a, c);
            this.dragCurrent.startDrag(a, c)
        }
        this.dragThreshMet = true
    },
    handleMouseUp: function(c) {
        var a = this.dragCurrent;
        if (Ext.tip && Ext.tip.QuickTipManager) {
            Ext.tip.QuickTipManager.ddEnable()
        }
        if (!a) {
            return
        }
        if (Ext.isIE && document.releaseCapture) {
            document.releaseCapture()
        }
        clearTimeout(this.clickTimeout);
        if (this.dragThreshMet) {
            this.fireEvents(c, true)
        }
        this.stopDrag(c);
        this.stopEvent(c)
    },
    stopEvent: function(a) {
        if (this.stopPropagation) {
            a.stopPropagation()
        }
        if (this.preventDefault) {
            a.preventDefault()
        }
    },
    stopDrag: function(a) {
        if (this.dragCurrent) {
            if (this.dragThreshMet) {
                this.dragCurrent.b4EndDrag(a);
                this.dragCurrent.endDrag(a)
            }
            this.dragCurrent.onMouseUp(a)
        }
        this.dragCurrent = null;
        this.dragOvers = {}
    },
    handleMouseMove: function(g) {
        var d = this,
            c, a;
        if (!d.dragCurrent) {
            return true
        }
        if (!d.dragThreshMet) {
            c = Math.abs(d.startX - g.getPageX());
            a = Math.abs(d.startY - g.getPageY());
            if (c > d.clickPixelThresh || a > d.clickPixelThresh) {
                d.startDrag(d.startX, d.startY)
            }
        }
        if (d.dragThreshMet) {
            d.dragCurrent.b4Drag(g);
            d.dragCurrent.onDrag(g);
            if (!d.dragCurrent.moveOnly) {
                d.fireEvents(g, false)
            }
        }
        d.stopEvent(g);
        return true
    },
    fireEvents: function(p, s) {
        var r = this,
            m = r.dragCurrent,
            t = p.getPoint(),
            c, v, g = [],
            a = [],
            j = [],
            n = [],
            l = [],
            d = [],
            q, k, o, u;
        if (!m || m.isLocked()) {
            return
        }
        for (k in r.dragOvers) {
            c = r.dragOvers[k];
            if (!r.isTypeOfDD(c)) {
                continue
            }
            if (!this.isOverTarget(t, c, r.mode)) {
                j.push(c)
            }
            a[k] = true;
            delete r.dragOvers[k]
        }
        for (u in m.groups) {
            if ("string" != typeof u) {
                continue
            }
            for (k in r.ids[u]) {
                c = r.ids[u][k];
                if (r.isTypeOfDD(c) && (v = c.getEl()) && (c.isTarget) && (!c.isLocked()) && (Ext.fly(v).isVisible(true)) && ((c != m) || (m.ignoreSelf === false))) {
                    if ((c.zIndex = r.getZIndex(v)) !== -1) {
                        q = true
                    }
                    g.push(c)
                }
            }
        }
        if (q) {
            Ext.Array.sort(g, r.byZIndex)
        }
        for (k = 0, o = g.length; k < o; k++) {
            c = g[k];
            if (r.isOverTarget(t, c, r.mode)) {
                if (s) {
                    l.push(c)
                } else {
                    if (!a[c.id]) {
                        d.push(c)
                    } else {
                        n.push(c)
                    }
                    r.dragOvers[c.id] = c
                }
                if (!r.notifyOccluded) {
                    break
                }
            }
        }
        if (r.mode) {
            if (j.length) {
                m.b4DragOut(p, j);
                m.onDragOut(p, j)
            }
            if (d.length) {
                m.onDragEnter(p, d)
            }
            if (n.length) {
                m.b4DragOver(p, n);
                m.onDragOver(p, n)
            }
            if (l.length) {
                m.b4DragDrop(p, l);
                m.onDragDrop(p, l)
            }
        } else {
            for (k = 0, o = j.length; k < o; ++k) {
                m.b4DragOut(p, j[k].id);
                m.onDragOut(p, j[k].id)
            }
            for (k = 0, o = d.length; k < o; ++k) {
                m.onDragEnter(p, d[k].id)
            }
            for (k = 0, o = n.length; k < o; ++k) {
                m.b4DragOver(p, n[k].id);
                m.onDragOver(p, n[k].id)
            }
            for (k = 0, o = l.length; k < o; ++k) {
                m.b4DragDrop(p, l[k].id);
                m.onDragDrop(p, l[k].id)
            }
        }
        if (s && !l.length) {
            m.onInvalidDrop(p)
        }
    },
    getZIndex: function(c) {
        var a = document.body,
            d, e = -1;
        c = Ext.getDom(c);
        while (c !== a) {
            if (!isNaN(d = Number(Ext.fly(c).getStyle("zIndex")))) {
                e = d
            }
            c = c.parentNode
        }
        return e
    },
    byZIndex: function(c, a) {
        return c.zIndex < a.zIndex
    },
    getBestMatch: function(d) {
        var g = null,
            c = d.length,
            e, a;
        if (c == 1) {
            g = d[0]
        } else {
            for (e = 0; e < c; ++e) {
                a = d[e];
                if (a.cursorIsOver) {
                    g = a;
                    break
                } else {
                    if (!g || g.overlap.getArea() < a.overlap.getArea()) {
                        g = a
                    }
                }
            }
        }
        return g
    },
    refreshCache: function(c) {
        var a, d, e, g;
        for (a in c) {
            if ("string" != typeof a) {
                continue
            }
            for (d in this.ids[a]) {
                e = this.ids[a][d];
                if (this.isTypeOfDD(e)) {
                    g = this.getLocation(e);
                    if (g) {
                        this.locationCache[e.id] = g
                    } else {
                        delete this.locationCache[e.id]
                    }
                }
            }
        }
    },
    verifyEl: function(c) {
        if (c) {
            var a;
            if (Ext.isIE) {
                try {
                    a = c.offsetParent
                } catch (d) {}
            } else {
                a = c.offsetParent
            }
            if (a) {
                return true
            }
        }
        return false
    },
    getLocation: function(j) {
        if (!this.isTypeOfDD(j)) {
            return null
        }
        if (j.getRegion) {
            return j.getRegion()
        }
        var g = j.getEl(),
            n, d, c, p, o, q, a, m, i;
        try {
            n = Ext.Element.getXY(g)
        } catch (k) {}
        if (!n) {
            return null
        }
        d = n[0];
        c = d + g.offsetWidth;
        p = n[1];
        o = p + g.offsetHeight;
        q = p - j.padding[0];
        a = c + j.padding[1];
        m = o + j.padding[2];
        i = d - j.padding[3];
        return new Ext.util.Region(q, a, m, i)
    },
    isOverTarget: function(l, a, d) {
        var g = this.locationCache[a.id],
            k, i, c, e, j;
        if (!g || !this.useCache) {
            g = this.getLocation(a);
            this.locationCache[a.id] = g
        }
        if (!g) {
            return false
        }
        a.cursorIsOver = g.contains(l);
        k = this.dragCurrent;
        if (!k || !k.getTargetCoord || (!d && !k.constrainX && !k.constrainY)) {
            return a.cursorIsOver
        }
        a.overlap = null;
        i = k.getTargetCoord(l.x, l.y);
        c = k.getDragEl();
        e = new Ext.util.Region(i.y, i.x + c.offsetWidth, i.y + c.offsetHeight, i.x);
        j = e.intersect(g);
        if (j) {
            a.overlap = j;
            return (d) ? true : a.cursorIsOver
        } else {
            return false
        }
    },
    _onUnload: function(c, a) {
        Ext.dd.DragDropManager.unregAll()
    },
    unregAll: function() {
        if (this.dragCurrent) {
            this.stopDrag();
            this.dragCurrent = null
        }
        this._execOnAll("unreg", []);
        for (var a in this.elementCache) {
            delete this.elementCache[a]
        }
        this.elementCache = {};
        this.ids = {}
    },
    elementCache: {},
    getElWrapper: function(c) {
        var a = this.elementCache[c];
        if (!a || !a.el) {
            a = this.elementCache[c] = new this.ElementWrapper(Ext.getDom(c))
        }
        return a
    },
    getElement: function(a) {
        return Ext.getDom(a)
    },
    getCss: function(c) {
        var a = Ext.getDom(c);
        return (a) ? a.style : null
    },
    ElementWrapper: function(a) {
        this.el = a || null;
        this.id = this.el && a.id;
        this.css = this.el && a.style
    },
    getPosX: function(a) {
        return Ext.Element.getX(a)
    },
    getPosY: function(a) {
        return Ext.Element.getY(a)
    },
    swapNode: function(d, a) {
        if (d.swapNode) {
            d.swapNode(a)
        } else {
            var e = a.parentNode,
                c = a.nextSibling;
            if (c == d) {
                e.insertBefore(d, a)
            } else {
                if (a == d.nextSibling) {
                    e.insertBefore(a, d)
                } else {
                    d.parentNode.replaceChild(a, d);
                    e.insertBefore(d, c)
                }
            }
        }
    },
    getScroll: function() {
        var e = window.document,
            g = e.documentElement,
            a = e.body,
            d = 0,
            c = 0;
        if (Ext.isGecko4) {
            d = window.scrollYOffset;
            c = window.scrollXOffset
        } else {
            if (g && (g.scrollTop || g.scrollLeft)) {
                d = g.scrollTop;
                c = g.scrollLeft
            } else {
                if (a) {
                    d = a.scrollTop;
                    c = a.scrollLeft
                }
            }
        }
        return {
            top: d,
            left: c
        }
    },
    getStyle: function(c, a) {
        return Ext.fly(c).getStyle(a)
    },
    getScrollTop: function() {
        return this.getScroll().top
    },
    getScrollLeft: function() {
        return this.getScroll().left
    },
    moveToEl: function(a, d) {
        var c = Ext.Element.getXY(d);
        Ext.Element.setXY(a, c)
    },
    numericSort: function(d, c) {
        return (d - c)
    },
    _timeoutCount: 0,
    _addListeners: function() {
        if (document) {
            this._onLoad()
        } else {
            if (this._timeoutCount <= 2000) {
                setTimeout(this._addListeners, 10);
                if (document && document.body) {
                    this._timeoutCount += 1
                }
            }
        }
    },
    handleWasClicked: function(a, d) {
        if (this.isHandle(d, a.id)) {
            return true
        } else {
            var c = a.parentNode;
            while (c) {
                if (this.isHandle(d, c.id)) {
                    return true
                } else {
                    c = c.parentNode
                }
            }
        }
        return false
    }
}, function() {
    this._addListeners()
});
Ext.define("Ext.layout.container.Box", {
    alias: ["layout.box"],
    extend: "Ext.layout.container.Container",
    alternateClassName: "Ext.layout.BoxLayout",
    requires: ["Ext.layout.container.boxOverflow.None", "Ext.layout.container.boxOverflow.Menu", "Ext.layout.container.boxOverflow.Scroller", "Ext.util.Format", "Ext.dd.DragDropManager"],
    defaultMargins: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    },
    padding: 0,
    pack: "start",
    flex: undefined,
    stretchMaxPartner: undefined,
    type: "box",
    scrollOffset: 0,
    itemCls: Ext.baseCSSPrefix + "box-item",
    targetCls: Ext.baseCSSPrefix + "box-layout-ct",
    innerCls: Ext.baseCSSPrefix + "box-inner",
    availableSpaceOffset: 0,
    reserveOffset: true,
    manageMargins: true,
    childEls: ["innerCt", "targetEl"],
    renderTpl: ["{%var oc,l=values.$comp.layout,oh=l.overflowHandler;", "if (oh.getPrefixConfig!==Ext.emptyFn) {", "if(oc=oh.getPrefixConfig())dh.generateMarkup(oc, out)", "}%}", '<div id="{ownerId}-innerCt" class="{[l.innerCls]} {[oh.getOverflowCls()]}" role="presentation">', '<div id="{ownerId}-targetEl" style="position:absolute;', "width:20000px;", "left:0px;top:0px;", 'height:1px">', "{%this.renderBody(out, values)%}", "</div>", "</div>", "{%if (oh.getSuffixConfig!==Ext.emptyFn) {", "if(oc=oh.getSuffixConfig())dh.generateMarkup(oc, out)", "}%}", {
        disableFormats: true,
        definitions: "var dh=Ext.DomHelper;"
    }],
    constructor: function(a) {
        var d = this,
            c;
        d.callParent(arguments);
        d.flexSortFn = Ext.Function.bind(d.flexSort, d);
        d.initOverflowHandler();
        c = typeof d.padding;
        if (c == "string" || c == "number") {
            d.padding = Ext.util.Format.parseBox(d.padding);
            d.padding.height = d.padding.top + d.padding.bottom;
            d.padding.width = d.padding.left + d.padding.right
        }
    },
    getNames: function() {
        return this.names
    },
    _percentageRe: /^\s*(\d+(?:\.\d*)?)\s*[%]\s*$/,
    getItemSizePolicy: function(o, p) {
        var l = this,
            j = l.sizePolicy,
            i = l.align,
            g = o.flex,
            m = i,
            k = l.names,
            a = o[k.width],
            n = o[k.height],
            d = l._percentageRe,
            c = d.test(a),
            e = (i == "stretch");
        if ((e || g || c) && !p) {
            p = l.owner.getSizeModel()
        }
        if (e) {
            if (!d.test(n) && p[k.height].shrinkWrap) {
                m = "stretchmax"
            }
        } else {
            if (i != "stretchmax") {
                if (d.test(n)) {
                    m = "stretch"
                } else {
                    m = ""
                }
            }
        }
        if (g || c) {
            if (!p[k.width].shrinkWrap) {
                j = j.flex
            }
        }
        return j[m]
    },
    flexSort: function(d, c) {
        var e = this.getNames().maxWidth,
            g = Infinity;
        d = d.target[e] || g;
        c = c.target[e] || g;
        if (!isFinite(d) && !isFinite(c)) {
            return 0
        }
        return d - c
    },
    isItemBoxParent: function(a) {
        return true
    },
    isItemShrinkWrap: function(a) {
        return true
    },
    minSizeSortFn: function(d, c) {
        return c.available - d.available
    },
    roundFlex: function(a) {
        return Math.ceil(a)
    },
    beginCollapse: function(c) {
        var a = this;
        if (a.direction === "vertical" && c.collapsedVertical()) {
            c.collapseMemento.capture(["flex"]);
            delete c.flex
        } else {
            if (a.direction === "horizontal" && c.collapsedHorizontal()) {
                c.collapseMemento.capture(["flex"]);
                delete c.flex
            }
        }
    },
    beginExpand: function(a) {
        a.collapseMemento.restore(["flex"])
    },
    beginLayout: function(d) {
        var c = this,
            g = c.owner.stretchMaxPartner,
            a = c.innerCt.dom.style,
            e = c.getNames();
        d.boxNames = e;
        c.overflowHandler.beginLayout(d);
        if (typeof g === "string") {
            g = Ext.getCmp(g) || c.owner.query(g)[0]
        }
        d.stretchMaxPartner = g && d.context.getCmp(g);
        c.callParent(arguments);
        d.innerCtContext = d.getEl("innerCt", c);
        c.scrollParallel = !!(c.owner.autoScroll || c.owner[e.overflowX]);
        c.scrollPerpendicular = !!(c.owner.autoScroll || c.owner[e.overflowY]);
        if (c.scrollParallel) {
            c.scrollPos = c.owner.getTargetEl().dom[e.scrollLeft]
        }
        a.width = "";
        a.height = ""
    },
    beginLayoutCycle: function(g, a) {
        var e = this,
            j = e.align,
            i = g.boxNames,
            c = e.pack,
            d = i.heightModel;
        e.overflowHandler.beginLayoutCycle(g, a);
        e.callParent(arguments);
        g.parallelSizeModel = g[i.widthModel];
        g.perpendicularSizeModel = g[d];
        g.boxOptions = {
            align: j = {
                stretch: j == "stretch",
                stretchmax: j == "stretchmax",
                center: j == i.center
            },
            pack: c = {
                center: c == "center",
                end: c == "end"
            }
        };
        if (j.stretch && g.perpendicularSizeModel.shrinkWrap) {
            j.stretchmax = true;
            j.stretch = false
        }
        j.nostretch = !(j.stretch || j.stretchmax);
        if (g.parallelSizeModel.shrinkWrap) {
            c.center = c.end = false
        }
        e.cacheFlexes(g);
        if (Ext.isWebKit) {
            e.targetEl.setWidth(20000)
        }
    },
    cacheFlexes: function(m) {
        var x = this,
            n = m.boxNames,
            a = n.widthModel,
            e = n.heightModel,
            d = m.boxOptions.align.nostretch,
            q = 0,
            c = m.childItems,
            s = c.length,
            u = [],
            o = 0,
            l = n.minWidth,
            j = x._percentageRe,
            t = 0,
            v = 0,
            g, p, r, k;
        while (s--) {
            p = c[s];
            g = p.target;
            if (p[a].calculated) {
                p.flex = r = g.flex;
                if (r) {
                    q += r;
                    u.push(p);
                    o += g[l] || 0
                } else {
                    k = j.exec(g[n.width]);
                    p.percentageParallel = parseFloat(k[1]) / 100;
                    ++t
                }
            }
            if (d && p[e].calculated) {
                k = j.exec(g[n.height]);
                p.percentagePerpendicular = parseFloat(k[1]) / 100;
                ++v
            }
        }
        m.flexedItems = u;
        m.flexedMinSize = o;
        m.totalFlex = q;
        m.percentageWidths = t;
        m.percentageHeights = v;
        Ext.Array.sort(u, x.flexSortFn)
    },
    calculate: function(e) {
        var c = this,
            a = c.getContainerSize(e),
            i = e.boxNames,
            d = e.state,
            g = d.boxPlan || (d.boxPlan = {});
        g.targetSize = a;
        if (!e.parallelSizeModel.shrinkWrap && !a[i.gotWidth]) {
            c.done = false;
            return
        }
        if (!d.parallelDone) {
            d.parallelDone = c.calculateParallel(e, i, g)
        }
        if (!d.perpendicularDone) {
            d.perpendicularDone = c.calculatePerpendicular(e, i, g)
        }
        if (d.parallelDone && d.perpendicularDone) {
            if (c.owner.dock && (Ext.isIE6 || Ext.isIE7 || Ext.isIEQuirks) && !c.owner.width && !c.horizontal) {
                g.isIEVerticalDock = true;
                g.calculatedWidth = g.maxSize + e.getPaddingInfo().width + e.getFrameInfo().width
            }
            c.publishInnerCtSize(e, c.reserveOffset ? c.availableSpaceOffset : 0);
            if (c.done && e.childItems.length > 1 && e.boxOptions.align.stretchmax && !d.stretchMaxDone) {
                c.calculateStretchMax(e, i, g);
                d.stretchMaxDone = true
            }
        } else {
            c.done = false
        }
    },
    calculateParallel: function(m, p, c) {
        var I = this,
            C = p.width,
            a = m.childItems,
            e = p.left,
            t = p.right,
            s = p.setWidth,
            D = a.length,
            A = m.flexedItems,
            u = A.length,
            y = m.boxOptions.pack,
            o = I.padding,
            k = c.targetSize[C],
            E = 0,
            g = o[e],
            H = g + o[t] + I.scrollOffset + (I.reserveOffset ? I.availableSpaceOffset : 0),
            z = Ext.getScrollbarSize()[p.width],
            x, n, j, B, q, v, G, r, F, d, l;
        if (z && I.scrollPerpendicular && m.parallelSizeModel.shrinkWrap && !m.boxOptions.align.stretch && !m.perpendicularSizeModel.shrinkWrap) {
            if (!m.state.perpendicularDone) {
                return false
            }
            F = true
        }
        for (x = 0; x < D; ++x) {
            q = a[x];
            n = q.marginInfo || q.getMarginInfo();
            E += n[C];
            if (!q[p.widthModel].calculated) {
                d = q.getProp(C);
                H += d;
                if (isNaN(H)) {
                    return false
                }
            }
        }
        H += E;
        if (m.percentageWidths) {
            l = k - E;
            if (isNaN(l)) {
                return false
            }
            for (x = 0; x < D; ++x) {
                q = a[x];
                if (q.percentageParallel) {
                    d = Math.ceil(l * q.percentageParallel);
                    d = q.setWidth(d);
                    H += d
                }
            }
        }
        if (m.parallelSizeModel.shrinkWrap) {
            c.availableSpace = 0;
            c.tooNarrow = false
        } else {
            c.availableSpace = k - H;
            c.tooNarrow = c.availableSpace < m.flexedMinSize;
            if (c.tooNarrow && Ext.getScrollbarSize()[p.height] && I.scrollParallel && m.state.perpendicularDone) {
                m.state.perpendicularDone = false;
                for (x = 0; x < D; ++x) {
                    a[x].invalidate()
                }
            }
        }
        r = H;
        j = c.availableSpace;
        B = m.totalFlex;
        for (x = 0; x < u; x++) {
            q = A[x];
            v = q.flex;
            G = I.roundFlex((v / B) * j);
            G = q[s](G);
            r += G;
            j = Math.max(0, j - G);
            B -= v
        }
        if (y.center) {
            g += j / 2;
            if (g < 0) {
                g = 0
            }
        } else {
            if (y.end) {
                g += j
            }
        }
        for (x = 0; x < D; ++x) {
            q = a[x];
            n = q.marginInfo;
            g += n[e];
            q.setProp(p.x, g);
            g += n[t] + q.props[C]
        }
        r += m.targetContext.getPaddingInfo()[C];
        m.state.contentWidth = r;
        if (F && (m.peek(p.contentHeight) > c.targetSize[p.height])) {
            r += z;
            m[p.hasOverflowY] = true;
            m.target.componentLayout[p.setWidthInDom] = true;
            m[p.invalidateScrollY] = (Ext.isStrict && Ext.isIE8)
        }
        m[p.setContentWidth](r);
        return true
    },
    calculatePerpendicular: function(t, y, d) {
        var J = this,
            a = t.perpendicularSizeModel.shrinkWrap,
            e = d.targetSize,
            c = t.childItems,
            H = c.length,
            M = Math.max,
            K = y.height,
            o = y.setHeight,
            r = y.top,
            I = y.y,
            x = J.padding,
            z = x[r],
            k = e[K] - z - x[y.bottom],
            E = t.boxOptions.align,
            q = E.stretch,
            C = E.stretchmax,
            p = E.center,
            D = 0,
            j = 0,
            n = Ext.getScrollbarSize().height,
            L, F, g, v, u, B, A, m, l, s, G;
        if (q || (p && !a)) {
            if (isNaN(k)) {
                return false
            }
        }
        if (J.scrollParallel && d.tooNarrow) {
            if (a) {
                s = true
            } else {
                k -= n;
                d.targetSize[K] -= n
            }
        }
        if (q) {
            B = k
        } else {
            for (F = 0; F < H; F++) {
                A = c[F];
                v = (A.marginInfo || A.getMarginInfo())[K];
                if (!(G = A.percentagePerpendicular)) {
                    g = A.getProp(K)
                } else {
                    ++j;
                    if (a) {
                        continue
                    } else {
                        g = G * k - v;
                        g = A[y.setHeight](g)
                    }
                }
                if (isNaN(D = M(D, g + v, A.target[y.minHeight] || 0))) {
                    return false
                }
            }
            if (s) {
                D += n;
                t[y.hasOverflowX] = true;
                t.target.componentLayout[y.setHeightInDom] = true;
                t[y.invalidateScrollX] = (Ext.isStrict && Ext.isIE8)
            }
            m = t.stretchMaxPartner;
            if (m) {
                t.setProp("maxChildHeight", D);
                l = m.childItems;
                if (l && l.length) {
                    D = M(D, m.getProp("maxChildHeight"));
                    if (isNaN(D)) {
                        return false
                    }
                }
            }
            t[y.setContentHeight](D + J.padding[K] + t.targetContext.getPaddingInfo()[K]);
            if (s) {
                D -= n
            }
            d.maxSize = D;
            if (C) {
                B = D
            } else {
                if (p || j) {
                    B = a ? D : M(k, D);
                    B -= t.innerCtContext.getBorderInfo()[K]
                }
            }
        }
        for (F = 0; F < H; F++) {
            A = c[F];
            v = A.marginInfo || A.getMarginInfo();
            L = z + v[r];
            if (q) {
                A[o](B - v[K])
            } else {
                G = A.percentagePerpendicular;
                if (a && G) {
                    v = A.marginInfo || A.getMarginInfo();
                    g = G * B - v[K];
                    g = A.setHeight(g)
                }
                if (p) {
                    u = B - A.props[K];
                    if (u > 0) {
                        L = z + Math.round(u / 2)
                    }
                }
            }
            A.setProp(I, L)
        }
        return true
    },
    calculateStretchMax: function(e, m, o) {
        var n = this,
            k = m.height,
            p = m.width,
            j = e.childItems,
            c = j.length,
            q = o.maxSize,
            a = n.onBeforeInvalidateChild,
            s = n.onAfterInvalidateChild,
            r, l, g, d;
        for (g = 0; g < c; ++g) {
            r = j[g];
            l = r.props;
            d = q - r.getMarginInfo()[k];
            if (d != l[k] || r[m.heightModel].constrained) {
                r.invalidate({
                    before: a,
                    after: s,
                    layout: n,
                    childWidth: l[p],
                    childHeight: d,
                    childX: l.x,
                    childY: l.y,
                    names: m
                })
            }
        }
    },
    completeLayout: function(c) {
        var l = this,
            k = c.boxNames,
            j = c.invalidateScrollX,
            i = c.invalidateScrollY,
            e, a, g, d, m;
        l.overflowHandler.completeLayout(c);
        if (j || i) {
            a = l.getTarget();
            e = a.dom;
            m = e.style;
            if (j) {
                g = a.getStyle("overflowX");
                if (g == "auto") {
                    g = m.overflowX;
                    m.overflowX = "scroll"
                } else {
                    j = false
                }
            }
            if (i) {
                d = a.getStyle("overflowY");
                if (d == "auto") {
                    d = m.overflowY;
                    m.overflowY = "scroll"
                } else {
                    i = false
                }
            }
            if (j || i) {
                e.scrollWidth;
                if (j) {
                    m.overflowX = g
                }
                if (i) {
                    m.overflowY = d
                }
            }
        }
        if (l.scrollParallel) {
            l.owner.getTargetEl().dom[k.scrollLeft] = l.scrollPos
        }
    },
    finishedLayout: function(a) {
        this.overflowHandler.finishedLayout(a);
        this.callParent(arguments);
        if (Ext.isWebKit) {
            this.targetEl.setWidth(a.innerCtContext.props.width)
        }
    },
    onBeforeInvalidateChild: function(c, a) {
        var d = a.names.heightModel;
        if (!c[d].constrainedMax) {
            c[d] = Ext.layout.SizeModel.calculated
        }
    },
    onAfterInvalidateChild: function(e, d) {
        var i = d.names,
            g = Ext.getScrollbarSize(),
            a = d.childHeight,
            c = d.childWidth;
        e.setProp("x", d.childX);
        e.setProp("y", d.childY);
        if (e[i.heightModel].calculated) {
            e[i.setHeight](a)
        }
        if (e[i.widthModel].calculated) {
            e[i.setWidth](c)
        }
    },
    publishInnerCtSize: function(a, e) {
        var k = this,
            j = a.boxNames,
            i = j.height,
            m = j.width,
            g = a.boxOptions.align,
            q = k.owner.dock,
            n = k.padding,
            l = a.state.boxPlan,
            d = l.targetSize,
            p = d[i],
            r = a.innerCtContext,
            c = (a.parallelSizeModel.shrinkWrap || (l.tooNarrow && k.scrollParallel) ? a.state.contentWidth : d[m]) - (e || 0),
            o;
        if (g.stretch) {
            o = p
        } else {
            o = l.maxSize + n[j.top] + n[j.bottom] + r.getBorderInfo()[i];
            if (!a.perpendicularSizeModel.shrinkWrap && g.center) {
                o = Math.max(p, o)
            }
        }
        r[j.setWidth](c);
        r[j.setHeight](o);
        if (isNaN(c + o)) {
            k.done = false
        }
        if (l.calculatedWidth && (q == "left" || q == "right")) {
            a.setWidth(l.calculatedWidth, true, true)
        }
    },
    onRemove: function(a) {
        var c = this;
        c.callParent(arguments);
        if (c.overflowHandler) {
            c.overflowHandler.onRemove(a)
        }
        if (a.layoutMarginCap == c.id) {
            delete a.layoutMarginCap
        }
    },
    initOverflowHandler: function() {
        var e = this,
            d = e.overflowHandler,
            c, a;
        if (typeof d == "string") {
            d = {
                type: d
            }
        }
        c = "None";
        if (d && d.type !== undefined) {
            c = d.type
        }
        a = Ext.layout.container.boxOverflow[c];
        if (a[e.type]) {
            a = a[e.type]
        }
        e.overflowHandler = Ext.create("Ext.layout.container.boxOverflow." + c, e, d)
    },
    getRenderTarget: function() {
        return this.targetEl
    },
    getElementTarget: function() {
        return this.innerCt
    },
    destroy: function() {
        Ext.destroy(this.innerCt, this.overflowHandler);
        this.callParent(arguments)
    }
});
Ext.define("Ext.layout.container.VBox", {
    alias: ["layout.vbox"],
    extend: "Ext.layout.container.Box",
    alternateClassName: "Ext.layout.VBoxLayout",
    align: "left",
    type: "vbox",
    direction: "vertical",
    horizontal: false,
    names: {
        lr: "tb",
        left: "top",
        leftCap: "Top",
        right: "bottom",
        position: "top",
        width: "height",
        contentWidth: "contentHeight",
        minWidth: "minHeight",
        maxWidth: "maxHeight",
        widthCap: "Height",
        widthModel: "heightModel",
        widthIndex: 1,
        x: "y",
        scrollLeft: "scrollTop",
        overflowX: "overflowY",
        hasOverflowX: "hasOverflowY",
        invalidateScrollX: "invalidateScrollY",
        center: "center",
        top: "left",
        topPosition: "left",
        bottom: "right",
        height: "width",
        contentHeight: "contentWidth",
        minHeight: "minWidth",
        maxHeight: "maxWidth",
        heightCap: "Width",
        heightModel: "widthModel",
        heightIndex: 0,
        y: "x",
        scrollTop: "scrollLeft",
        overflowY: "overflowX",
        hasOverflowY: "hasOverflowX",
        invalidateScrollY: "invalidateScrollX",
        getWidth: "getHeight",
        getHeight: "getWidth",
        setWidth: "setHeight",
        setHeight: "setWidth",
        gotWidth: "gotHeight",
        gotHeight: "gotWidth",
        setContentWidth: "setContentHeight",
        setContentHeight: "setContentWidth",
        setWidthInDom: "setHeightInDom",
        setHeightInDom: "setWidthInDom"
    },
    sizePolicy: {
        flex: {
            "": {
                setsWidth: 0,
                setsHeight: 1
            },
            stretch: {
                setsWidth: 1,
                setsHeight: 1
            },
            stretchmax: {
                readsWidth: 1,
                setsWidth: 1,
                setsHeight: 1
            }
        },
        "": {
            setsWidth: 0,
            setsHeight: 0
        },
        stretch: {
            setsWidth: 1,
            setsHeight: 0
        },
        stretchmax: {
            readsWidth: 1,
            setsWidth: 1,
            setsHeight: 0
        }
    }
});
Ext.define("Ext.layout.container.HBox", {
    alias: ["layout.hbox"],
    extend: "Ext.layout.container.Box",
    alternateClassName: "Ext.layout.HBoxLayout",
    align: "top",
    type: "hbox",
    direction: "horizontal",
    horizontal: true,
    names: {
        lr: "lr",
        left: "left",
        leftCap: "Left",
        right: "right",
        position: "left",
        width: "width",
        contentWidth: "contentWidth",
        minWidth: "minWidth",
        maxWidth: "maxWidth",
        widthCap: "Width",
        widthModel: "widthModel",
        widthIndex: 0,
        x: "x",
        scrollLeft: "scrollLeft",
        overflowX: "overflowX",
        hasOverflowX: "hasOverflowX",
        invalidateScrollX: "invalidateScrollX",
        center: "middle",
        top: "top",
        topPosition: "top",
        bottom: "bottom",
        height: "height",
        contentHeight: "contentHeight",
        minHeight: "minHeight",
        maxHeight: "maxHeight",
        heightCap: "Height",
        heightModel: "heightModel",
        heightIndex: 1,
        y: "y",
        scrollTop: "scrollTop",
        overflowY: "overflowY",
        hasOverflowY: "hasOverflowY",
        invalidateScrollY: "invalidateScrollY",
        getWidth: "getWidth",
        getHeight: "getHeight",
        setWidth: "setWidth",
        setHeight: "setHeight",
        gotWidth: "gotWidth",
        gotHeight: "gotHeight",
        setContentWidth: "setContentWidth",
        setContentHeight: "setContentHeight",
        setWidthInDom: "setWidthInDom",
        setHeightInDom: "setHeightInDom"
    },
    sizePolicy: {
        flex: {
            "": {
                setsWidth: 1,
                setsHeight: 0
            },
            stretch: {
                setsWidth: 1,
                setsHeight: 1
            },
            stretchmax: {
                readsHeight: 1,
                setsWidth: 1,
                setsHeight: 1
            }
        },
        "": {
            setsWidth: 0,
            setsHeight: 0
        },
        stretch: {
            setsWidth: 0,
            setsHeight: 1
        },
        stretchmax: {
            readsHeight: 1,
            setsWidth: 0,
            setsHeight: 1
        }
    }
});
Ext.define("Ext.layout.container.Fit", {
    extend: "Ext.layout.container.Container",
    alternateClassName: "Ext.layout.FitLayout",
    alias: "layout.fit",
    itemCls: Ext.baseCSSPrefix + "fit-item",
    targetCls: Ext.baseCSSPrefix + "layout-fit",
    type: "fit",
    defaultMargins: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    },
    manageMargins: true,
    sizePolicies: {
        0: {
            setsWidth: 0,
            setsHeight: 0
        },
        1: {
            setsWidth: 1,
            setsHeight: 0
        },
        2: {
            setsWidth: 0,
            setsHeight: 1
        },
        3: {
            setsWidth: 1,
            setsHeight: 1
        }
    },
    getItemSizePolicy: function(c, d) {
        var a = d || this.owner.getSizeModel(),
            e = (a.width.shrinkWrap ? 0 : 1) | (a.height.shrinkWrap ? 0 : 2);
        return this.sizePolicies[e]
    },
    beginLayoutCycle: function(m, j) {
        var v = this,
            x = v.lastHeightModel && v.lastHeightModel.calculated,
            k = v.lastWidthModel && v.lastWidthModel.calculated,
            q = k || x,
            n = 0,
            o = 0,
            u, d, r, t, g, a, l, p, s, e;
        v.callParent(arguments);
        if (q && m.targetContext.el.dom.tagName.toUpperCase() != "TD") {
            q = k = x = false
        }
        d = m.childItems;
        g = d.length;
        for (r = 0; r < g; ++r) {
            t = d[r];
            if (j) {
                u = t.target;
                l = u.minHeight;
                p = u.minWidth;
                if (p || l) {
                    a = t.marginInfo || t.getMarginInfo();
                    l += a.height;
                    p += a.height;
                    if (n < l) {
                        n = l
                    }
                    if (o < p) {
                        o = p
                    }
                }
            }
            if (q) {
                s = t.el.dom.style;
                if (x) {
                    s.height = ""
                }
                if (k) {
                    s.width = ""
                }
            }
        }
        if (j) {
            m.maxChildMinHeight = n;
            m.maxChildMinWidth = o
        }
        u = m.target;
        m.overflowX = (!m.widthModel.shrinkWrap && m.maxChildMinWidth && (u.autoScroll || u.overflowX)) || e;
        m.overflowY = (!m.heightModel.shrinkWrap && m.maxChildMinHeight && (u.autoScroll || u.overflowY)) || e
    },
    calculate: function(j) {
        var q = this,
            n = j.childItems,
            e = n.length,
            d = q.getContainerSize(j),
            g = {
                length: e,
                ownerContext: j,
                targetSize: d
            },
            t = j.widthModel.shrinkWrap,
            o = j.heightModel.shrinkWrap,
            m = j.overflowX,
            k = j.overflowY,
            p, c, r, l, a, s;
        if (m || k) {
            p = q.getScrollbarsNeeded(m && d.width, k && d.height, j.maxChildMinWidth, j.maxChildMinHeight);
            if (p) {
                c = Ext.getScrollbarSize();
                if (p & 1) {
                    d.height -= c.height
                }
                if (p & 2) {
                    d.width -= c.width
                }
            }
        }
        for (l = 0; l < e; ++l) {
            g.index = l;
            q.fitItem(n[l], g)
        }
        if (o || t) {
            r = j.targetContext.getPaddingInfo();
            if (t) {
                if (k && !d.gotHeight) {
                    q.done = false
                } else {
                    a = g.contentWidth + r.width;
                    if (p & 2) {
                        a += c.width
                    }
                    if (!j.setContentWidth(a)) {
                        q.done = false
                    }
                }
            }
            if (o) {
                if (m && !d.gotWidth) {
                    q.done = false
                } else {
                    s = g.contentHeight + r.height;
                    if (p & 1) {
                        s += c.height
                    }
                    if (!j.setContentHeight(s)) {
                        q.done = false
                    }
                }
            }
        }
    },
    fitItem: function(c, d) {
        var a = this;
        if (c.invalid) {
            a.done = false;
            return
        }
        d.margins = c.getMarginInfo();
        d.needed = d.got = 0;
        a.fitItemWidth(c, d);
        a.fitItemHeight(c, d);
        if (d.got != d.needed) {
            a.done = false
        }
    },
    fitItemWidth: function(d, e) {
        var a, c;
        if (e.ownerContext.widthModel.shrinkWrap) {
            c = d.getProp("width") + e.margins.width;
            a = e.contentWidth;
            if (a === undefined) {
                e.contentWidth = c
            } else {
                e.contentWidth = Math.max(a, c)
            }
        } else {
            if (d.widthModel.calculated) {
                ++e.needed;
                if (e.targetSize.gotWidth) {
                    ++e.got;
                    this.setItemWidth(d, e)
                }
            }
        }
        this.positionItemX(d, e)
    },
    fitItemHeight: function(d, e) {
        var c, a;
        if (e.ownerContext.heightModel.shrinkWrap) {
            a = d.getProp("height") + e.margins.height;
            c = e.contentHeight;
            if (c === undefined) {
                e.contentHeight = a
            } else {
                e.contentHeight = Math.max(c, a)
            }
        } else {
            if (d.heightModel.calculated) {
                ++e.needed;
                if (e.targetSize.gotHeight) {
                    ++e.got;
                    this.setItemHeight(d, e)
                }
            }
        }
        this.positionItemY(d, e)
    },
    positionItemX: function(a, d) {
        var c = d.margins;
        if (d.index || c.left) {
            a.setProp("x", c.left)
        }
        if (c.width) {
            a.setProp("margin-right", c.width)
        }
    },
    positionItemY: function(a, d) {
        var c = d.margins;
        if (d.index || c.top) {
            a.setProp("y", c.top)
        }
        if (c.height) {
            a.setProp("margin-bottom", c.height)
        }
    },
    setItemHeight: function(a, c) {
        a.setHeight(c.targetSize.height - c.margins.height)
    },
    setItemWidth: function(a, c) {
        a.setWidth(c.targetSize.width - c.margins.width)
    }
});
Ext.define("Ext.toolbar.Fill", {
    extend: "Ext.Component",
    alias: "widget.tbfill",
    alternateClassName: "Ext.Toolbar.Fill",
    isFill: true,
    flex: 1
});
Ext.define("Ext.toolbar.Toolbar", {
    extend: "Ext.container.Container",
    requires: ["Ext.toolbar.Fill", "Ext.layout.container.HBox", "Ext.layout.container.VBox"],
    uses: ["Ext.toolbar.Separator"],
    alias: "widget.toolbar",
    alternateClassName: "Ext.Toolbar",
    isToolbar: true,
    baseCls: Ext.baseCSSPrefix + "toolbar",
    ariaRole: "toolbar",
    defaultType: "button",
    vertical: false,
    enableOverflow: false,
    menuTriggerCls: Ext.baseCSSPrefix + "toolbar-more-icon",
    trackMenus: true,
    itemCls: Ext.baseCSSPrefix + "toolbar-item",
    statics: {
        shortcuts: {
            "-": "tbseparator",
            " ": "tbspacer"
        },
        shortcutsHV: {
            0: {
                "->": {
                    xtype: "tbfill",
                    height: 0
                }
            },
            1: {
                "->": {
                    xtype: "tbfill",
                    width: 0
                }
            }
        }
    },
    initComponent: function() {
        var c = this,
            a;
        if (!c.layout && c.enableOverflow) {
            c.layout = {
                overflowHandler: "Menu"
            }
        }
        if (c.dock === "right" || c.dock === "left") {
            c.vertical = true
        }
        c.layout = Ext.applyIf(Ext.isString(c.layout) ? {
            type: c.layout
        } : c.layout || {}, {
            type: c.vertical ? "vbox" : "hbox",
            align: c.vertical ? "stretchmax" : "middle"
        });
        if (c.vertical) {
            c.addClsWithUI("vertical")
        }
        if (c.ui === "footer") {
            c.ignoreBorderManagement = true
        }
        c.callParent();
        c.addEvents("overflowchange")
    },
    getRefItems: function(a) {
        var g = this,
            c = g.callParent(arguments),
            e = g.layout,
            d;
        if (a && g.enableOverflow) {
            d = e.overflowHandler;
            if (d && d.menu) {
                c = c.concat(d.menu.getRefItems(a))
            }
        }
        return c
    },
    lookupComponent: function(e) {
        if (typeof e == "string") {
            var d = Ext.toolbar.Toolbar,
                a = d.shortcutsHV[this.vertical ? 1 : 0][e] || d.shortcuts[e];
            if (typeof a == "string") {
                e = {
                    xtype: a
                }
            } else {
                if (a) {
                    e = Ext.apply({}, a)
                } else {
                    e = {
                        xtype: "tbtext",
                        text: e
                    }
                }
            }
            this.applyDefaults(e)
        }
        return this.callParent(arguments)
    },
    applyDefaults: function(a) {
        if (!Ext.isString(a)) {
            a = this.callParent(arguments)
        }
        return a
    },
    trackMenu: function(d, a) {
        if (this.trackMenus && d.menu) {
            var e = a ? "mun" : "mon",
                c = this;
            c[e](d, "mouseover", c.onButtonOver, c);
            c[e](d, "menushow", c.onButtonMenuShow, c);
            c[e](d, "menuhide", c.onButtonMenuHide, c)
        }
    },
    constructButton: function(a) {
        return a.events ? a : Ext.widget(a.split ? "splitbutton" : this.defaultType, a)
    },
    onBeforeAdd: function(a) {
        if (a.is("field") || (a.is("button") && this.ui != "footer")) {
            a.ui = a.ui + "-toolbar"
        }
        if (a instanceof Ext.toolbar.Separator) {
            a.setUI((this.vertical) ? "vertical" : "horizontal")
        }
        this.callParent(arguments)
    },
    onAdd: function(a) {
        this.callParent(arguments);
        this.trackMenu(a)
    },
    onRemove: function(a) {
        this.callParent(arguments);
        this.trackMenu(a, true)
    },
    getChildItemsToDisable: function() {
        return this.items.getRange()
    },
    onButtonOver: function(a) {
        if (this.activeMenuBtn && this.activeMenuBtn != a) {
            this.activeMenuBtn.hideMenu();
            a.showMenu();
            this.activeMenuBtn = a
        }
    },
    onButtonMenuShow: function(a) {
        this.activeMenuBtn = a
    },
    onButtonMenuHide: function(a) {
        delete this.activeMenuBtn
    }
});
Ext.define("Ext.container.DockingContainer", {
    requires: ["Ext.util.MixedCollection", "Ext.Element"],
    isDockingContainer: true,
    defaultDockWeights: {
        top: {
            render: 1,
            visual: 1
        },
        left: {
            render: 3,
            visual: 5
        },
        right: {
            render: 5,
            visual: 7
        },
        bottom: {
            render: 7,
            visual: 3
        }
    },
    dockOrder: {
        top: -1,
        left: -1,
        right: 1,
        bottom: 1
    },
    addDocked: function(a, j) {
        var g = this,
            c = 0,
            e, d;
        a = g.prepareItems(a);
        d = a.length;
        for (; c < d; c++) {
            e = a[c];
            e.dock = e.dock || "top";
            if (j !== undefined) {
                g.dockedItems.insert(j + c, e)
            } else {
                g.dockedItems.add(e)
            }
            if (e.onAdded !== Ext.emptyFn) {
                e.onAdded(g, c)
            }
            if (g.onDockedAdd !== Ext.emptyFn) {
                g.onDockedAdd(e)
            }
        }
        if (g.rendered && !g.suspendLayout) {
            g.updateLayout()
        }
        return a
    },
    destroyDockedItems: function() {
        var a = this.dockedItems,
            d;
        if (a) {
            while ((d = a.first())) {
                this.removeDocked(d, true)
            }
        }
    },
    doRenderDockedItems: function(d, i, j) {
        var g = i.$comp,
            e = g.componentLayout,
            c, a;
        if (e.getDockedItems && !i.$skipDockedItems) {
            c = e.getDockedItems("render", !j);
            a = c && e.getItemsRenderTree(c);
            if (a) {
                Ext.DomHelper.generateMarkup(a, d)
            }
        }
    },
    getDockedComponent: function(a) {
        if (Ext.isObject(a)) {
            a = a.getItemId()
        }
        return this.dockedItems.get(a)
    },
    getDockedItems: function(a, d) {
        var c = this.getComponentLayout().getDockedItems("render", d);
        if (a && c.length) {
            c = Ext.ComponentQuery.query(a, c)
        }
        return c
    },
    getDockingRefItems: function(c, g) {
        var a = c && "*,* *",
            e = this.getDockedItems(a, true),
            d;
        e.push.apply(e, g);
        d = this.getDockedItems(a, false);
        e.push.apply(e, d);
        return e
    },
    initDockingItems: function() {
        var c = this,
            a = c.dockedItems;
        c.dockedItems = new Ext.util.AbstractMixedCollection(false, c.getComponentId);
        if (a) {
            c.addDocked(a)
        }
    },
    insertDocked: function(c, a) {
        this.addDocked(a, c)
    },
    onDockedAdd: Ext.emptyFn,
    onDockedRemove: Ext.emptyFn,
    removeDocked: function(g, c) {
        var e = this,
            d, a;
        if (!e.dockedItems.contains(g)) {
            return g
        }
        d = e.componentLayout;
        a = d && e.rendered;
        if (a) {
            d.onRemove(g)
        }
        e.dockedItems.remove(g);
        g.onRemoved();
        e.onDockedRemove(g);
        if (c === true || (c !== false && e.autoDestroy)) {
            g.destroy()
        } else {
            if (a) {
                d.afterRemove(g)
            }
        }
        if (!e.destroying && !e.suspendLayout) {
            e.updateLayout()
        }
        return g
    },
    setupDockingRenderTpl: function(a) {
        a.renderDockedItems = this.doRenderDockedItems
    }
});
Ext.define("Ext.panel.AbstractPanel", {
    extend: "Ext.container.Container",
    mixins: {
        docking: "Ext.container.DockingContainer"
    },
    requires: ["Ext.util.MixedCollection", "Ext.Element", "Ext.toolbar.Toolbar"],
    baseCls: Ext.baseCSSPrefix + "panel",
    isPanel: true,
    componentLayout: "dock",
    childEls: ["body"],
    renderTpl: ["{% this.renderDockedItems(out,values,0); %}", (Ext.isIE6 || Ext.isIE7 || Ext.isIEQuirks) ? "<div></div>" : "", '<div id="{id}-body" class="{baseCls}-body<tpl if="bodyCls"> {bodyCls}</tpl>', ' {baseCls}-body-{ui}<tpl if="uiCls">', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>', '</tpl>"<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{%this.renderContainer(out,values);%}", "</div>", "{% this.renderDockedItems(out,values,1); %}"],
    bodyPosProps: {
        x: "x",
        y: "y"
    },
    border: true,
    emptyArray: [],
    initComponent: function() {
        var a = this;
        if (a.frame && a.border && a.bodyBorder === undefined) {
            a.bodyBorder = false
        }
        if (a.frame && a.border && (a.bodyBorder === false || a.bodyBorder === 0)) {
            a.manageBodyBorders = true
        }
        a.callParent()
    },
    beforeDestroy: function() {
        this.destroyDockedItems();
        this.callParent()
    },
    initItems: function() {
        this.callParent();
        this.initDockingItems()
    },
    initRenderData: function() {
        var a = this,
            c = a.callParent();
        a.initBodyStyles();
        a.protoBody.writeTo(c);
        delete a.protoBody;
        return c
    },
    getComponent: function(a) {
        var c = this.callParent(arguments);
        if (c === undefined && !Ext.isNumber(a)) {
            c = this.getDockedComponent(a)
        }
        return c
    },
    getProtoBody: function() {
        var c = this,
            a = c.protoBody;
        if (!a) {
            c.protoBody = a = new Ext.util.ProtoElement({
                cls: c.bodyCls,
                style: c.bodyStyle,
                clsProp: "bodyCls",
                styleProp: "bodyStyle",
                styleIsText: true
            })
        }
        return a
    },
    initBodyStyles: function() {
        var d = this,
            a = d.getProtoBody(),
            c = Ext.Element;
        if (d.bodyPadding !== undefined) {
            a.setStyle("padding", c.unitizeBox((d.bodyPadding === true) ? 5 : d.bodyPadding))
        }
        if (d.frame && d.bodyBorder) {
            if (!Ext.isNumber(d.bodyBorder)) {
                d.bodyBorder = 1
            }
            a.setStyle("border-width", c.unitizeBox(d.bodyBorder))
        }
    },
    getCollapsedDockedItems: function() {
        var a = this;
        return a.collapseMode == "placeholder" ? a.emptyArray : [a.getReExpander()]
    },
    setBodyStyle: function(c, e) {
        var d = this,
            a = d.rendered ? d.body : d.getProtoBody();
        if (Ext.isFunction(c)) {
            c = c()
        }
        if (arguments.length == 1) {
            if (Ext.isString(c)) {
                c = Ext.Element.parseStyles(c)
            }
            a.setStyle(c)
        } else {
            a.setStyle(c, e)
        }
        return d
    },
    addBodyCls: function(c) {
        var d = this,
            a = d.rendered ? d.body : d.getProtoBody();
        a.addCls(c);
        return d
    },
    removeBodyCls: function(c) {
        var d = this,
            a = d.rendered ? d.body : d.getProtoBody();
        a.removeCls(c);
        return d
    },
    addUIClsToElement: function(c) {
        var d = this,
            a = d.callParent(arguments);
        d.addBodyCls([Ext.baseCSSPrefix + c, d.baseCls + "-body-" + c, d.baseCls + "-body-" + d.ui + "-" + c]);
        return a
    },
    removeUIClsFromElement: function(c) {
        var d = this,
            a = d.callParent(arguments);
        d.removeBodyCls([Ext.baseCSSPrefix + c, d.baseCls + "-body-" + c, d.baseCls + "-body-" + d.ui + "-" + c]);
        return a
    },
    addUIToElement: function() {
        var a = this;
        a.callParent(arguments);
        a.addBodyCls(a.baseCls + "-body-" + a.ui)
    },
    removeUIFromElement: function() {
        var a = this;
        a.callParent(arguments);
        a.removeBodyCls(a.baseCls + "-body-" + a.ui)
    },
    getTargetEl: function() {
        return this.body
    },
    getRefItems: function(a) {
        var c = this.callParent(arguments);
        return this.getDockingRefItems(a, c)
    },
    setupRenderTpl: function(a) {
        this.callParent(arguments);
        this.setupDockingRenderTpl(a)
    }
});
Ext.define("Ext.layout.component.Body", {
    alias: ["layout.body"],
    extend: "Ext.layout.component.Auto",
    type: "body",
    beginLayout: function(a) {
        this.callParent(arguments);
        a.bodyContext = a.getEl("body")
    },
    calculateOwnerHeightFromContentHeight: function(d, c) {
        var a = this.callParent(arguments);
        if (d.targetContext != d) {
            a += d.getPaddingInfo().height
        }
        return a
    },
    calculateOwnerWidthFromContentWidth: function(d, a) {
        var c = this.callParent(arguments);
        if (d.targetContext != d) {
            c += d.getPaddingInfo().width
        }
        return c
    },
    measureContentWidth: function(a) {
        return a.bodyContext.setWidth(a.bodyContext.el.dom.offsetWidth, false)
    },
    measureContentHeight: function(a) {
        return a.bodyContext.setHeight(a.bodyContext.el.dom.offsetHeight, false)
    },
    publishInnerHeight: function(d, a) {
        var e = a - d.getFrameInfo().height,
            c = d.targetContext;
        if (c != d) {
            e -= d.getPaddingInfo().height
        }
        return d.bodyContext.setHeight(e, !d.heightModel.natural)
    },
    publishInnerWidth: function(e, d) {
        var a = d - e.getFrameInfo().width,
            c = e.targetContext;
        if (c != e) {
            a -= e.getPaddingInfo().width
        }
        e.bodyContext.setWidth(a, !e.widthModel.natural)
    }
});
Ext.define("Ext.panel.Header", {
    extend: "Ext.container.Container",
    uses: ["Ext.panel.Tool", "Ext.draw.Component", "Ext.util.CSS", "Ext.layout.component.Body", "Ext.Img"],
    alias: "widget.header",
    isHeader: true,
    defaultType: "tool",
    indicateDrag: false,
    weight: -1,
    componentLayout: "body",
    titleAlign: "left",
    childEls: ["body"],
    renderTpl: ['<div id="{id}-body" class="{baseCls}-body {bodyCls}', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>"', '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{%this.renderContainer(out,values)%}", "</div>"],
    headingTpl: '<span id="{id}-textEl" class="{cls}-text {cls}-text-{ui}">{title}</span>',
    shrinkWrap: 3,
    initComponent: function() {
        var c = this,
            g, e, a, d, i;
        c.addEvents("click", "dblclick");
        c.indicateDragCls = c.baseCls + "-draggable";
        c.title = c.title || "&#160;";
        c.tools = c.tools || [];
        c.items = c.items || [];
        c.orientation = c.orientation || "horizontal";
        c.dock = (c.dock) ? c.dock : (c.orientation == "horizontal") ? "top" : "left";
        c.addClsWithUI([c.orientation, c.dock]);
        if (c.indicateDrag) {
            c.addCls(c.indicateDragCls)
        }
        if (!Ext.isEmpty(c.iconCls) || !Ext.isEmpty(c.icon)) {
            c.initIconCmp();
            c.items.push(c.iconCmp)
        }
        if (c.orientation == "vertical") {
            c.layout = {
                type: "vbox",
                align: "center"
            };
            c.textConfig = {
                width: 16,
                cls: c.baseCls + "-text",
                type: "text",
                text: c.title,
                rotate: {
                    degrees: 90
                }
            };
            d = c.ui;
            if (Ext.isArray(d)) {
                d = d[0]
            }
            g = "." + c.baseCls + "-text-" + d;
            if (Ext.scopeResetCSS) {
                g = "." + Ext.baseCSSPrefix + "reset " + g
            }
            e = Ext.util.CSS.getRule(g);
            if (e) {
                a = e.style
            } else {
                a = (i = Ext.resetElement.createChild({
                    style: "position:absolute",
                    cls: c.baseCls + "-text-" + d
                })).getStyles("fontFamily", "fontWeight", "fontSize", "color");
                i.remove()
            }
            if (a) {
                Ext.apply(c.textConfig, {
                    "font-family": a.fontFamily,
                    "font-weight": a.fontWeight,
                    "font-size": a.fontSize,
                    fill: a.color
                })
            }
            c.titleCmp = new Ext.draw.Component({
                width: 16,
                ariaRole: "heading",
                focusable: false,
                viewBox: false,
                flex: 1,
                id: c.id + "_hd",
                autoSize: true,
                items: c.textConfig,
                xhooks: {
                    setSize: function(j) {
                        this.callParent([j])
                    }
                },
                childEls: [{
                    name: "textEl",
                    select: "." + c.baseCls + "-text"
                }]
            })
        } else {
            c.layout = {
                type: "hbox",
                align: "middle"
            };
            c.titleCmp = new Ext.Component({
                ariaRole: "heading",
                focusable: false,
                noWrap: true,
                flex: 1,
                id: c.id + "_hd",
                style: "text-align:" + c.titleAlign,
                cls: c.baseCls + "-text-container",
                renderTpl: c.getTpl("headingTpl"),
                renderData: {
                    title: c.title,
                    cls: c.baseCls,
                    ui: c.ui
                },
                childEls: ["textEl"]
            })
        }
        c.items.push(c.titleCmp);
        c.items = c.items.concat(c.tools);
        c.callParent();
        c.on({
            dblclick: c.onDblClick,
            click: c.onClick,
            element: "el",
            scope: c
        })
    },
    initIconCmp: function() {
        var c = this,
            a = {
                focusable: false,
                src: Ext.BLANK_IMAGE_URL,
                cls: [c.baseCls + "-icon", c.iconCls],
                id: c.id + "-iconEl",
                iconCls: c.iconCls
            };
        if (!Ext.isEmpty(c.icon)) {
            delete a.iconCls;
            a.src = c.icon
        }
        c.iconCmp = new Ext.Img(a)
    },
    afterRender: function() {
        this.el.unselectable();
        this.callParent()
    },
    addUIClsToElement: function(c) {
        var g = this,
            a = g.callParent(arguments),
            e = [g.baseCls + "-body-" + c, g.baseCls + "-body-" + g.ui + "-" + c],
            j, d;
        if (g.bodyCls) {
            j = g.bodyCls.split(" ");
            for (d = 0; d < e.length; d++) {
                if (!Ext.Array.contains(j, e[d])) {
                    j.push(e[d])
                }
            }
            g.bodyCls = j.join(" ")
        } else {
            g.bodyCls = e.join(" ")
        }
        return a
    },
    removeUIClsFromElement: function(c) {
        var g = this,
            a = g.callParent(arguments),
            e = [g.baseCls + "-body-" + c, g.baseCls + "-body-" + g.ui + "-" + c],
            j, d;
        if (g.bodyCls) {
            j = g.bodyCls.split(" ");
            for (d = 0; d < e.length; d++) {
                Ext.Array.remove(j, e[d])
            }
            g.bodyCls = j.join(" ")
        }
        return a
    },
    addUIToElement: function() {
        var c = this,
            d, a;
        c.callParent(arguments);
        a = c.baseCls + "-body-" + c.ui;
        if (c.rendered) {
            if (c.bodyCls) {
                c.body.addCls(c.bodyCls)
            } else {
                c.body.addCls(a)
            }
        } else {
            if (c.bodyCls) {
                d = c.bodyCls.split(" ");
                if (!Ext.Array.contains(d, a)) {
                    d.push(a)
                }
                c.bodyCls = d.join(" ")
            } else {
                c.bodyCls = a
            }
        }
        if (c.titleCmp && c.titleCmp.rendered && c.titleCmp.textEl) {
            c.titleCmp.textEl.addCls(c.baseCls + "-text-" + c.ui)
        }
    },
    removeUIFromElement: function() {
        var c = this,
            d, a;
        c.callParent(arguments);
        a = c.baseCls + "-body-" + c.ui;
        if (c.rendered) {
            if (c.bodyCls) {
                c.body.removeCls(c.bodyCls)
            } else {
                c.body.removeCls(a)
            }
        } else {
            if (c.bodyCls) {
                d = c.bodyCls.split(" ");
                Ext.Array.remove(d, a);
                c.bodyCls = d.join(" ")
            } else {
                c.bodyCls = a
            }
        }
        if (c.titleCmp && c.titleCmp.rendered && c.titleCmp.textEl) {
            c.titleCmp.textEl.removeCls(c.baseCls + "-text-" + c.ui)
        }
    },
    onClick: function(a) {
        this.fireClickEvent("click", a)
    },
    onDblClick: function(a) {
        this.fireClickEvent("dblclick", a)
    },
    fireClickEvent: function(a, d) {
        var c = "." + Ext.panel.Tool.prototype.baseCls;
        if (!d.getTarget(c)) {
            this.fireEvent(a, this, d)
        }
    },
    getFocusEl: function() {
        return this.el
    },
    getTargetEl: function() {
        return this.body || this.frameBody || this.el
    },
    setTitle: function(e) {
        var d = this,
            c, a;
        if (d.rendered) {
            if (d.titleCmp.rendered) {
                if (d.titleCmp.surface) {
                    d.title = e || "";
                    c = d.titleCmp.surface.items.items[0];
                    a = d.titleCmp.surface;
                    a.remove(c);
                    d.textConfig.type = "text";
                    d.textConfig.text = e;
                    c = a.add(d.textConfig);
                    c.setAttributes({
                        rotate: {
                            degrees: 90
                        }
                    }, true);
                    d.titleCmp.autoSizeSurface()
                } else {
                    d.title = e;
                    d.titleCmp.textEl.update(d.title || "&#160;")
                }
                d.titleCmp.updateLayout()
            } else {
                d.titleCmp.on({
                    render: function() {
                        d.setTitle(e)
                    },
                    single: true
                })
            }
        } else {
            d.title = e
        }
    },
    getMinWidth: function() {
        var g = this,
            e = g.titleCmp.textEl.dom,
            a, j = g.tools,
            c, d;
        e.style.display = "inline";
        a = e.offsetWidth;
        e.style.display = "";
        if (j && (c = j.length)) {
            for (d = 0; d < c; d++) {
                if (j[d].el) {
                    a += j[d].el.dom.offsetWidth
                }
            }
        }
        if (g.iconCmp) {
            a += g.iconCmp.el.dom.offsetWidth
        }
        return a + 10
    },
    setIconCls: function(a) {
        var c = this,
            e = !a || !a.length,
            d = c.iconCmp;
        c.iconCls = a;
        if (!c.iconCmp && !e) {
            c.initIconCmp();
            c.insert(0, c.iconCmp)
        } else {
            if (d) {
                if (e) {
                    c.iconCmp.destroy();
                    delete c.iconCmp
                } else {
                    d.removeCls(d.iconCls);
                    d.addCls(a);
                    d.iconCls = a
                }
            }
        }
    },
    setIcon: function(a) {
        var c = this,
            e = !a || !a.length,
            d = c.iconCmp;
        c.icon = a;
        if (!c.iconCmp && !e) {
            c.initIconCmp();
            c.insert(0, c.iconCmp)
        } else {
            if (d) {
                if (e) {
                    c.iconCmp.destroy();
                    delete c.iconCmp
                } else {
                    d.setSrc(c.icon)
                }
            }
        }
    },
    addTool: function(a) {
        this.tools.push(this.add(a))
    },
    onAdd: function(c, a) {
        this.callParent(arguments);
        if (c instanceof Ext.panel.Tool) {
            c.bindTo(this.ownerCt);
            this.tools[c.type] = c
        }
    },
    initRenderData: function() {
        return Ext.applyIf(this.callParent(), {
            bodyCls: this.bodyCls
        })
    }
});
Ext.define("Ext.dd.DragDrop", {
    requires: ["Ext.dd.DragDropManager"],
    constructor: function(d, a, c) {
        if (d) {
            this.init(d, a, c)
        }
    },
    id: null,
    config: null,
    dragElId: null,
    handleElId: null,
    invalidHandleTypes: null,
    invalidHandleIds: null,
    invalidHandleClasses: null,
    startPageX: 0,
    startPageY: 0,
    groups: null,
    locked: false,
    lock: function() {
        this.locked = true
    },
    moveOnly: false,
    unlock: function() {
        this.locked = false
    },
    isTarget: true,
    padding: null,
    _domRef: null,
    __ygDragDrop: true,
    constrainX: false,
    constrainY: false,
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0,
    maintainOffset: false,
    xTicks: null,
    yTicks: null,
    primaryButtonOnly: true,
    available: false,
    hasOuterHandles: false,
    b4StartDrag: function(a, c) {},
    startDrag: function(a, c) {},
    b4Drag: function(a) {},
    onDrag: function(a) {},
    onDragEnter: function(a, c) {},
    b4DragOver: function(a) {},
    onDragOver: function(a, c) {},
    b4DragOut: function(a) {},
    onDragOut: function(a, c) {},
    b4DragDrop: function(a) {},
    onDragDrop: function(a, c) {},
    onInvalidDrop: function(a) {},
    b4EndDrag: function(a) {},
    endDrag: function(a) {},
    b4MouseDown: function(a) {},
    onMouseDown: function(a) {},
    onMouseUp: function(a) {},
    onAvailable: function() {},
    defaultPadding: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    },
    constrainTo: function(j, g, o) {
        if (Ext.isNumber(g)) {
            g = {
                left: g,
                right: g,
                top: g,
                bottom: g
            }
        }
        g = g || this.defaultPadding;
        var l = Ext.get(this.getEl()).getBox(),
            a = Ext.get(j),
            n = a.getScroll(),
            k, d = a.dom,
            m, i, e;
        if (d == document.body) {
            k = {
                x: n.left,
                y: n.top,
                width: Ext.Element.getViewWidth(),
                height: Ext.Element.getViewHeight()
            }
        } else {
            m = a.getXY();
            k = {
                x: m[0],
                y: m[1],
                width: d.clientWidth,
                height: d.clientHeight
            }
        }
        i = l.y - k.y;
        e = l.x - k.x;
        this.resetConstraints();
        this.setXConstraint(e - (g.left || 0), k.width - e - l.width - (g.right || 0), this.xTickSize);
        this.setYConstraint(i - (g.top || 0), k.height - i - l.height - (g.bottom || 0), this.yTickSize)
    },
    getEl: function() {
        if (!this._domRef) {
            this._domRef = Ext.getDom(this.id)
        }
        return this._domRef
    },
    getDragEl: function() {
        return Ext.getDom(this.dragElId)
    },
    init: function(d, a, c) {
        this.initTarget(d, a, c);
        Ext.EventManager.on(this.id, "mousedown", this.handleMouseDown, this)
    },
    initTarget: function(d, a, c) {
        this.config = c || {};
        this.DDMInstance = Ext.dd.DragDropManager;
        this.groups = {};
        if (typeof d !== "string") {
            d = Ext.id(d)
        }
        this.id = d;
        this.addToGroup((a) ? a : "default");
        this.handleElId = d;
        this.setDragElId(d);
        this.invalidHandleTypes = {
            A: "A"
        };
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];
        this.applyConfig();
        this.handleOnAvailable()
    },
    applyConfig: function() {
        this.padding = this.config.padding || [0, 0, 0, 0];
        this.isTarget = (this.config.isTarget !== false);
        this.maintainOffset = (this.config.maintainOffset);
        this.primaryButtonOnly = (this.config.primaryButtonOnly !== false)
    },
    handleOnAvailable: function() {
        this.available = true;
        this.resetConstraints();
        this.onAvailable()
    },
    setPadding: function(d, a, e, c) {
        if (!a && 0 !== a) {
            this.padding = [d, d, d, d]
        } else {
            if (!e && 0 !== e) {
                this.padding = [d, a, d, a]
            } else {
                this.padding = [d, a, e, c]
            }
        }
    },
    setInitPosition: function(e, d) {
        var g = this.getEl(),
            c, a, i;
        if (!this.DDMInstance.verifyEl(g)) {
            return
        }
        c = e || 0;
        a = d || 0;
        i = Ext.Element.getXY(g);
        this.initPageX = i[0] - c;
        this.initPageY = i[1] - a;
        this.lastPageX = i[0];
        this.lastPageY = i[1];
        this.setStartPosition(i)
    },
    setStartPosition: function(c) {
        var a = c || Ext.Element.getXY(this.getEl());
        this.deltaSetXY = null;
        this.startPageX = a[0];
        this.startPageY = a[1]
    },
    addToGroup: function(a) {
        this.groups[a] = true;
        this.DDMInstance.regDragDrop(this, a)
    },
    removeFromGroup: function(a) {
        if (this.groups[a]) {
            delete this.groups[a]
        }
        this.DDMInstance.removeDDFromGroup(this, a)
    },
    setDragElId: function(a) {
        this.dragElId = a
    },
    setHandleElId: function(a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        this.handleElId = a;
        this.DDMInstance.regHandle(this.id, a)
    },
    setOuterHandleElId: function(a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        Ext.EventManager.on(a, "mousedown", this.handleMouseDown, this);
        this.setHandleElId(a);
        this.hasOuterHandles = true
    },
    unreg: function() {
        Ext.EventManager.un(this.id, "mousedown", this.handleMouseDown, this);
        this._domRef = null;
        this.DDMInstance._remove(this)
    },
    destroy: function() {
        this.unreg()
    },
    isLocked: function() {
        return (this.DDMInstance.isLocked() || this.locked)
    },
    handleMouseDown: function(c, a) {
        if (this.primaryButtonOnly && c.button != 0) {
            return
        }
        if (this.isLocked()) {
            return
        }
        this.DDMInstance.refreshCache(this.groups);
        if (this.hasOuterHandles || this.DDMInstance.isOverTarget(c.getPoint(), this)) {
            if (this.clickValidator(c)) {
                this.setStartPosition();
                this.b4MouseDown(c);
                this.onMouseDown(c);
                this.DDMInstance.handleMouseDown(c, this);
                this.DDMInstance.stopEvent(c)
            }
        }
    },
    clickValidator: function(c) {
        var a = c.getTarget();
        return (this.isValidHandleChild(a) && (this.id == this.handleElId || this.DDMInstance.handleWasClicked(a, this.id)))
    },
    addInvalidHandleType: function(a) {
        var c = a.toUpperCase();
        this.invalidHandleTypes[c] = c
    },
    addInvalidHandleId: function(a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        this.invalidHandleIds[a] = a
    },
    addInvalidHandleClass: function(a) {
        this.invalidHandleClasses.push(a)
    },
    removeInvalidHandleType: function(a) {
        var c = a.toUpperCase();
        delete this.invalidHandleTypes[c]
    },
    removeInvalidHandleId: function(a) {
        if (typeof a !== "string") {
            a = Ext.id(a)
        }
        delete this.invalidHandleIds[a]
    },
    removeInvalidHandleClass: function(c) {
        for (var d = 0, a = this.invalidHandleClasses.length; d < a; ++d) {
            if (this.invalidHandleClasses[d] == c) {
                delete this.invalidHandleClasses[d]
            }
        }
    },
    isValidHandleChild: function(g) {
        var d = true,
            k, c, a;
        try {
            k = g.nodeName.toUpperCase()
        } catch (j) {
            k = g.nodeName
        }
        d = d && !this.invalidHandleTypes[k];
        d = d && !this.invalidHandleIds[g.id];
        for (c = 0, a = this.invalidHandleClasses.length; d && c < a; ++c) {
            d = !Ext.fly(g).hasCls(this.invalidHandleClasses[c])
        }
        return d
    },
    setXTicks: function(e, a) {
        this.xTicks = [];
        this.xTickSize = a;
        var d = {},
            c;
        for (c = this.initPageX; c >= this.minX; c = c - a) {
            if (!d[c]) {
                this.xTicks[this.xTicks.length] = c;
                d[c] = true
            }
        }
        for (c = this.initPageX; c <= this.maxX; c = c + a) {
            if (!d[c]) {
                this.xTicks[this.xTicks.length] = c;
                d[c] = true
            }
        }
        Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort)
    },
    setYTicks: function(e, a) {
        this.yTicks = [];
        this.yTickSize = a;
        var d = {},
            c;
        for (c = this.initPageY; c >= this.minY; c = c - a) {
            if (!d[c]) {
                this.yTicks[this.yTicks.length] = c;
                d[c] = true
            }
        }
        for (c = this.initPageY; c <= this.maxY; c = c + a) {
            if (!d[c]) {
                this.yTicks[this.yTicks.length] = c;
                d[c] = true
            }
        }
        Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort)
    },
    setXConstraint: function(d, c, a) {
        this.leftConstraint = d;
        this.rightConstraint = c;
        this.minX = this.initPageX - d;
        this.maxX = this.initPageX + c;
        if (a) {
            this.setXTicks(this.initPageX, a)
        }
        this.constrainX = true
    },
    clearConstraints: function() {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks()
    },
    clearTicks: function() {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0
    },
    setYConstraint: function(a, d, c) {
        this.topConstraint = a;
        this.bottomConstraint = d;
        this.minY = this.initPageY - a;
        this.maxY = this.initPageY + d;
        if (c) {
            this.setYTicks(this.initPageY, c)
        }
        this.constrainY = true
    },
    resetConstraints: function() {
        if (this.initPageX || this.initPageX === 0) {
            var c = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0,
                a = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;
            this.setInitPosition(c, a)
        } else {
            this.setInitPosition()
        }
        if (this.constrainX) {
            this.setXConstraint(this.leftConstraint, this.rightConstraint, this.xTickSize)
        }
        if (this.constrainY) {
            this.setYConstraint(this.topConstraint, this.bottomConstraint, this.yTickSize)
        }
    },
    getTick: function(k, e) {
        if (!e) {
            return k
        } else {
            if (e[0] >= k) {
                return e[0]
            } else {
                var c, a, d, j, g;
                for (c = 0, a = e.length; c < a; ++c) {
                    d = c + 1;
                    if (e[d] && e[d] >= k) {
                        j = k - e[c];
                        g = e[d] - k;
                        return (g > j) ? e[c] : e[d]
                    }
                }
                return e[e.length - 1]
            }
        }
    },
    toString: function() {
        return ("DragDrop " + this.id)
    }
});
Ext.define("Ext.dd.DD", {
    extend: "Ext.dd.DragDrop",
    requires: ["Ext.dd.DragDropManager"],
    constructor: function(d, a, c) {
        if (d) {
            this.init(d, a, c)
        }
    },
    scroll: true,
    autoOffset: function(d, c) {
        var a = d - this.startPageX,
            e = c - this.startPageY;
        this.setDelta(a, e)
    },
    setDelta: function(c, a) {
        this.deltaX = c;
        this.deltaY = a
    },
    setDragElPos: function(d, c) {
        var a = this.getDragEl();
        this.alignElWithMouse(a, d, c)
    },
    alignElWithMouse: function(c, g, d) {
        var i = this.getTargetCoord(g, d),
            e = c.dom ? c : Ext.fly(c, "_dd"),
            n = e.getSize(),
            k = Ext.Element,
            l, a, m, j;
        if (!this.deltaSetXY) {
            l = this.cachedViewportSize = {
                width: k.getDocumentWidth(),
                height: k.getDocumentHeight()
            };
            a = [Math.max(0, Math.min(i.x, l.width - n.width)), Math.max(0, Math.min(i.y, l.height - n.height))];
            e.setXY(a);
            m = e.getLocalX();
            j = e.getLocalY();
            this.deltaSetXY = [m - i.x, j - i.y]
        } else {
            l = this.cachedViewportSize;
            e.setLeftTop(Math.max(0, Math.min(i.x + this.deltaSetXY[0], l.width - n.width)), Math.max(0, Math.min(i.y + this.deltaSetXY[1], l.height - n.height)))
        }
        this.cachePosition(i.x, i.y);
        this.autoScroll(i.x, i.y, c.offsetHeight, c.offsetWidth);
        return i
    },
    cachePosition: function(c, a) {
        if (c) {
            this.lastPageX = c;
            this.lastPageY = a
        } else {
            var d = Ext.Element.getXY(this.getEl());
            this.lastPageX = d[0];
            this.lastPageY = d[1]
        }
    },
    autoScroll: function(m, l, g, n) {
        if (this.scroll) {
            var o = Ext.Element.getViewHeight(),
                c = Ext.Element.getViewWidth(),
                q = this.DDMInstance.getScrollTop(),
                e = this.DDMInstance.getScrollLeft(),
                k = g + l,
                p = n + m,
                j = (o + q - l - this.deltaY),
                i = (c + e - m - this.deltaX),
                d = 40,
                a = (document.all) ? 80 : 30;
            if (k > o && j < d) {
                window.scrollTo(e, q + a)
            }
            if (l < q && q > 0 && l - q < d) {
                window.scrollTo(e, q - a)
            }
            if (p > c && i < d) {
                window.scrollTo(e + a, q)
            }
            if (m < e && e > 0 && m - e < d) {
                window.scrollTo(e - a, q)
            }
        }
    },
    getTargetCoord: function(d, c) {
        var a = d - this.deltaX,
            e = c - this.deltaY;
        if (this.constrainX) {
            if (a < this.minX) {
                a = this.minX
            }
            if (a > this.maxX) {
                a = this.maxX
            }
        }
        if (this.constrainY) {
            if (e < this.minY) {
                e = this.minY
            }
            if (e > this.maxY) {
                e = this.maxY
            }
        }
        a = this.getTick(a, this.xTicks);
        e = this.getTick(e, this.yTicks);
        return {
            x: a,
            y: e
        }
    },
    applyConfig: function() {
        this.callParent();
        this.scroll = (this.config.scroll !== false)
    },
    b4MouseDown: function(a) {
        this.autoOffset(a.getPageX(), a.getPageY())
    },
    b4Drag: function(a) {
        this.setDragElPos(a.getPageX(), a.getPageY())
    },
    toString: function() {
        return ("DD " + this.id)
    }
});
Ext.define("Ext.dd.DDProxy", {
    extend: "Ext.dd.DD",
    statics: {
        dragElId: "ygddfdiv"
    },
    constructor: function(d, a, c) {
        if (d) {
            this.init(d, a, c);
            this.initFrame()
        }
    },
    resizeFrame: true,
    centerFrame: false,
    createFrame: function() {
        var c = this,
            a = document.body,
            e, d;
        if (!a || !a.firstChild) {
            setTimeout(function() {
                c.createFrame()
            }, 50);
            return
        }
        e = this.getDragEl();
        if (!e) {
            e = document.createElement("div");
            e.id = this.dragElId;
            d = e.style;
            d.position = "absolute";
            d.visibility = "hidden";
            d.cursor = "move";
            d.border = "2px solid #aaa";
            d.zIndex = 999;
            a.insertBefore(e, a.firstChild)
        }
    },
    initFrame: function() {
        this.createFrame()
    },
    applyConfig: function() {
        this.callParent();
        this.resizeFrame = (this.config.resizeFrame !== false);
        this.centerFrame = (this.config.centerFrame);
        this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId)
    },
    showFrame: function(g, e) {
        var d = this.getEl(),
            a = this.getDragEl(),
            c = a.style;
        this._resizeProxy();
        if (this.centerFrame) {
            this.setDelta(Math.round(parseInt(c.width, 10) / 2), Math.round(parseInt(c.height, 10) / 2))
        }
        this.setDragElPos(g, e);
        Ext.fly(a).show()
    },
    _resizeProxy: function() {
        if (this.resizeFrame) {
            var a = this.getEl();
            Ext.fly(this.getDragEl()).setSize(a.offsetWidth, a.offsetHeight)
        }
    },
    b4MouseDown: function(c) {
        var a = c.getPageX(),
            d = c.getPageY();
        this.autoOffset(a, d);
        this.setDragElPos(a, d)
    },
    b4StartDrag: function(a, c) {
        this.showFrame(a, c)
    },
    b4EndDrag: function(a) {
        Ext.fly(this.getDragEl()).hide()
    },
    endDrag: function(d) {
        var c = this.getEl(),
            a = this.getDragEl();
        a.style.visibility = "";
        this.beforeMove();
        c.style.visibility = "hidden";
        Ext.dd.DDM.moveToEl(c, a);
        a.style.visibility = "hidden";
        c.style.visibility = "";
        this.afterDrag()
    },
    beforeMove: function() {},
    afterDrag: function() {},
    toString: function() {
        return ("DDProxy " + this.id)
    }
});
Ext.define("Ext.dd.StatusProxy", {
    extend: "Ext.Component",
    animRepair: false,
    childEls: ["ghost"],
    renderTpl: ['<div class="' + Ext.baseCSSPrefix + 'dd-drop-icon"></div><div id="{id}-ghost" class="' + Ext.baseCSSPrefix + 'dd-drag-ghost"></div>'],
    constructor: function(a) {
        var c = this;
        a = a || {};
        Ext.apply(c, {
            hideMode: "visibility",
            hidden: true,
            floating: true,
            id: c.id || Ext.id(),
            cls: Ext.baseCSSPrefix + "dd-drag-proxy " + this.dropNotAllowed,
            shadow: a.shadow || false,
            renderTo: Ext.getDetachedBody()
        });
        c.callParent(arguments);
        this.dropStatus = this.dropNotAllowed
    },
    dropAllowed: Ext.baseCSSPrefix + "dd-drop-ok",
    dropNotAllowed: Ext.baseCSSPrefix + "dd-drop-nodrop",
    setStatus: function(a) {
        a = a || this.dropNotAllowed;
        if (this.dropStatus != a) {
            this.el.replaceCls(this.dropStatus, a);
            this.dropStatus = a
        }
    },
    reset: function(c) {
        var d = this,
            a = Ext.baseCSSPrefix + "dd-drag-proxy ";
        d.el.replaceCls(a + d.dropAllowed, a + d.dropNotAllowed);
        d.dropStatus = d.dropNotAllowed;
        if (c) {
            d.ghost.update("")
        }
    },
    update: function(a) {
        if (typeof a == "string") {
            this.ghost.update(a)
        } else {
            this.ghost.update("");
            a.style.margin = "0";
            this.ghost.dom.appendChild(a)
        }
        var c = this.ghost.dom.firstChild;
        if (c) {
            Ext.fly(c).setStyle("float", "none")
        }
    },
    getGhost: function() {
        return this.ghost
    },
    hide: function(a) {
        this.callParent();
        if (a) {
            this.reset(true)
        }
    },
    stop: function() {
        if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) {
            this.anim.stop()
        }
    },
    sync: function() {
        this.el.sync()
    },
    repair: function(d, e, a) {
        var c = this;
        c.callback = e;
        c.scope = a;
        if (d && c.animRepair !== false) {
            c.el.addCls(Ext.baseCSSPrefix + "dd-drag-repair");
            c.el.hideUnders(true);
            c.anim = c.el.animate({
                duration: c.repairDuration || 500,
                easing: "ease-out",
                to: {
                    x: d[0],
                    y: d[1]
                },
                stopAnimation: true,
                callback: c.afterRepair,
                scope: c
            })
        } else {
            c.afterRepair()
        }
    },
    afterRepair: function() {
        var a = this;
        a.hide(true);
        a.el.removeCls(Ext.baseCSSPrefix + "dd-drag-repair");
        if (typeof a.callback == "function") {
            a.callback.call(a.scope || a)
        }
        delete a.callback;
        delete a.scope
    }
});
Ext.define("Ext.dd.DragSource", {
    extend: "Ext.dd.DDProxy",
    requires: ["Ext.dd.StatusProxy", "Ext.dd.DragDropManager"],
    dropAllowed: Ext.baseCSSPrefix + "dd-drop-ok",
    dropNotAllowed: Ext.baseCSSPrefix + "dd-drop-nodrop",
    animRepair: true,
    repairHighlightColor: "c3daf9",
    constructor: function(c, a) {
        this.el = Ext.get(c);
        if (!this.dragData) {
            this.dragData = {}
        }
        Ext.apply(this, a);
        if (!this.proxy) {
            this.proxy = new Ext.dd.StatusProxy({
                id: this.el.id + "-drag-status-proxy",
                animRepair: this.animRepair
            })
        }
        this.callParent([this.el.dom, this.ddGroup || this.group, {
            dragElId: this.proxy.id,
            resizeFrame: false,
            isTarget: false,
            scroll: this.scroll === true
        }]);
        this.dragging = false
    },
    getDragData: function(a) {
        return this.dragData
    },
    onDragEnter: function(d, g) {
        var c = Ext.dd.DragDropManager.getDDById(g),
            a;
        this.cachedTarget = c;
        if (this.beforeDragEnter(c, d, g) !== false) {
            if (c.isNotifyTarget) {
                a = c.notifyEnter(this, d, this.dragData);
                this.proxy.setStatus(a)
            } else {
                this.proxy.setStatus(this.dropAllowed)
            }
            if (this.afterDragEnter) {
                this.afterDragEnter(c, d, g)
            }
        }
    },
    beforeDragEnter: function(c, a, d) {
        return true
    },
    onDragOver: function(d, g) {
        var c = this.cachedTarget || Ext.dd.DragDropManager.getDDById(g),
            a;
        if (this.beforeDragOver(c, d, g) !== false) {
            if (c.isNotifyTarget) {
                a = c.notifyOver(this, d, this.dragData);
                this.proxy.setStatus(a)
            }
            if (this.afterDragOver) {
                this.afterDragOver(c, d, g)
            }
        }
    },
    beforeDragOver: function(c, a, d) {
        return true
    },
    onDragOut: function(c, d) {
        var a = this.cachedTarget || Ext.dd.DragDropManager.getDDById(d);
        if (this.beforeDragOut(a, c, d) !== false) {
            if (a.isNotifyTarget) {
                a.notifyOut(this, c, this.dragData)
            }
            this.proxy.reset();
            if (this.afterDragOut) {
                this.afterDragOut(a, c, d)
            }
        }
        this.cachedTarget = null
    },
    beforeDragOut: function(c, a, d) {
        return true
    },
    onDragDrop: function(c, d) {
        var a = this.cachedTarget || Ext.dd.DragDropManager.getDDById(d);
        if (this.beforeDragDrop(a, c, d) !== false) {
            if (a.isNotifyTarget) {
                if (a.notifyDrop(this, c, this.dragData) !== false) {
                    this.onValidDrop(a, c, d)
                } else {
                    this.onInvalidDrop(a, c, d)
                }
            } else {
                this.onValidDrop(a, c, d)
            }
            if (this.afterDragDrop) {
                this.afterDragDrop(a, c, d)
            }
        }
        delete this.cachedTarget
    },
    beforeDragDrop: function(c, a, d) {
        return true
    },
    onValidDrop: function(c, a, d) {
        this.hideProxy();
        if (this.afterValidDrop) {
            this.afterValidDrop(c, a, d)
        }
    },
    getRepairXY: function(c, a) {
        return this.el.getXY()
    },
    onInvalidDrop: function(c, a, d) {
        if (!a) {
            a = c;
            c = null;
            d = a.getTarget().id
        }
        this.beforeInvalidDrop(c, a, d);
        if (this.cachedTarget) {
            if (this.cachedTarget.isNotifyTarget) {
                this.cachedTarget.notifyOut(this, a, this.dragData)
            }
            this.cacheTarget = null
        }
        this.proxy.repair(this.getRepairXY(a, this.dragData), this.afterRepair, this);
        if (this.afterInvalidDrop) {
            this.afterInvalidDrop(a, d)
        }
    },
    afterRepair: function() {
        var a = this;
        if (Ext.enableFx) {
            a.el.highlight(a.repairHighlightColor)
        }
        a.dragging = false
    },
    beforeInvalidDrop: function(c, a, d) {
        return true
    },
    handleMouseDown: function(c) {
        if (this.dragging) {
            return
        }
        var a = this.getDragData(c);
        if (a && this.onBeforeDrag(a, c) !== false) {
            this.dragData = a;
            this.proxy.stop();
            this.callParent(arguments)
        }
    },
    onBeforeDrag: function(a, c) {
        return true
    },
    onStartDrag: Ext.emptyFn,
    alignElWithMouse: function() {
        this.proxy.ensureAttachedToBody(true);
        return this.callParent(arguments)
    },
    startDrag: function(a, c) {
        this.proxy.reset();
        this.proxy.hidden = false;
        this.dragging = true;
        this.proxy.update("");
        this.onInitDrag(a, c);
        this.proxy.show()
    },
    onInitDrag: function(a, d) {
        var c = this.el.dom.cloneNode(true);
        c.id = Ext.id();
        this.proxy.update(c);
        this.onStartDrag(a, d);
        return true
    },
    getProxy: function() {
        return this.proxy
    },
    hideProxy: function() {
        this.proxy.hide();
        this.proxy.reset(true);
        this.dragging = false
    },
    triggerCacheRefresh: function() {
        Ext.dd.DDM.refreshCache(this.groups)
    },
    b4EndDrag: function(a) {},
    endDrag: function(a) {
        this.onEndDrag(this.dragData, a)
    },
    onEndDrag: function(a, c) {},
    autoOffset: function(a, c) {
        this.setDelta(-12, -20)
    },
    destroy: function() {
        this.callParent();
        Ext.destroy(this.proxy)
    }
});
Ext.define("Ext.panel.Proxy", {
    alternateClassName: "Ext.dd.PanelProxy",
    moveOnDrag: true,
    constructor: function(a, c) {
        var d = this;
        d.panel = a;
        d.id = d.panel.id + "-ddproxy";
        Ext.apply(d, c)
    },
    insertProxy: true,
    setStatus: Ext.emptyFn,
    reset: Ext.emptyFn,
    update: Ext.emptyFn,
    stop: Ext.emptyFn,
    sync: Ext.emptyFn,
    getEl: function() {
        return this.ghost.el
    },
    getGhost: function() {
        return this.ghost
    },
    getProxy: function() {
        return this.proxy
    },
    hide: function() {
        var a = this;
        if (a.ghost) {
            if (a.proxy) {
                a.proxy.remove();
                delete a.proxy
            }
            a.panel.unghost(null, a.moveOnDrag);
            delete a.ghost
        }
    },
    show: function() {
        var c = this,
            a;
        if (!c.ghost) {
            a = c.panel.getSize();
            c.panel.el.setVisibilityMode(Ext.Element.DISPLAY);
            c.ghost = c.panel.ghost();
            if (c.insertProxy) {
                c.proxy = c.panel.el.insertSibling({
                    cls: Ext.baseCSSPrefix + "panel-dd-spacer"
                });
                c.proxy.setSize(a)
            }
        }
    },
    repair: function(c, d, a) {
        this.hide();
        Ext.callback(d, a || this)
    },
    moveProxy: function(a, c) {
        if (this.proxy) {
            a.insertBefore(this.proxy.dom, c)
        }
    }
});
Ext.define("Ext.panel.DD", {
    extend: "Ext.dd.DragSource",
    requires: ["Ext.panel.Proxy"],
    constructor: function(c, a) {
        var d = this;
        d.panel = c;
        d.dragData = {
            panel: c
        };
        d.panelProxy = new Ext.panel.Proxy(c, a);
        d.proxy = d.panelProxy.proxy;
        d.callParent([c.el, a]);
        d.setupEl(c)
    },
    setupEl: function(a) {
        var d = this,
            e = a.header,
            c = a.body;
        if (e) {
            d.setHandleElId(e.id);
            c = e.el
        }
        if (c) {
            c.setStyle("cursor", "move");
            d.scroll = false
        } else {
            a.on("boxready", d.setupEl, d, {
                single: true
            })
        }
    },
    showFrame: Ext.emptyFn,
    startDrag: Ext.emptyFn,
    b4StartDrag: function(a, c) {
        this.panelProxy.show()
    },
    b4MouseDown: function(c) {
        var a = c.getPageX(),
            d = c.getPageY();
        this.autoOffset(a, d)
    },
    onInitDrag: function(a, c) {
        this.onStartDrag(a, c);
        return true
    },
    createFrame: Ext.emptyFn,
    getDragEl: function(a) {
        return this.panelProxy.ghost.el.dom
    },
    endDrag: function(a) {
        this.panelProxy.hide();
        this.panel.saveState()
    },
    autoOffset: function(a, c) {
        a -= this.startPageX;
        c -= this.startPageY;
        this.setDelta(a, c)
    },
    onInvalidDrop: function(d, c, g) {
        var a = this;
        a.beforeInvalidDrop(d, c, g);
        if (a.cachedTarget) {
            if (a.cachedTarget.isNotifyTarget) {
                a.cachedTarget.notifyOut(a, c, a.dragData)
            }
            a.cacheTarget = null
        }
        if (a.afterInvalidDrop) {
            a.afterInvalidDrop(c, g)
        }
    }
});
Ext.define("Ext.util.Memento", (function() {
    function e(k, j, l, i) {
        k[i ? i + l : l] = j[l]
    }

    function d(j, i, k) {
        delete j[k]
    }

    function g(m, l, n, k) {
        var i = k ? k + n : n,
            j = m[i];
        if (j || m.hasOwnProperty(i)) {
            a(l, n, j)
        }
    }

    function a(j, k, i) {
        if (Ext.isDefined(i)) {
            j[k] = i
        } else {
            delete j[k]
        }
    }

    function c(j, o, n, k, l) {
        if (o) {
            if (Ext.isArray(k)) {
                var m, i = k.length;
                for (m = 0; m < i; m++) {
                    j(o, n, k[m], l)
                }
            } else {
                j(o, n, k, l)
            }
        }
    }
    return {
        data: null,
        target: null,
        constructor: function(j, i) {
            if (j) {
                this.target = j;
                if (i) {
                    this.capture(i)
                }
            }
        },
        capture: function(i, l, k) {
            var j = this;
            c(e, j.data || (j.data = {}), l || j.target, i, k)
        },
        remove: function(i) {
            c(d, this.data, null, i)
        },
        restore: function(j, i, l, k) {
            c(g, this.data, l || this.target, j, k);
            if (i !== false) {
                this.remove(j)
            }
        },
        restoreAll: function(i, m) {
            var k = this,
                j = m || this.target,
                l = k.data,
                n;
            for (n in l) {
                if (l.hasOwnProperty(n)) {
                    a(j, n, l[n])
                }
            }
            if (i !== false) {
                delete k.data
            }
        }
    }
}()));
Ext.define("Ext.panel.Panel", {
    extend: "Ext.panel.AbstractPanel",
    requires: ["Ext.panel.Header", "Ext.fx.Anim", "Ext.util.KeyMap", "Ext.panel.DD", "Ext.XTemplate", "Ext.layout.component.Dock", "Ext.util.Memento"],
    alias: "widget.panel",
    alternateClassName: "Ext.Panel",
    collapsedCls: "collapsed",
    animCollapse: Ext.enableFx,
    minButtonWidth: 75,
    collapsed: false,
    collapseFirst: true,
    hideCollapseTool: false,
    titleCollapse: false,
    floatable: true,
    collapsible: false,
    closable: false,
    closeAction: "destroy",
    placeholderCollapseHideMode: Ext.Element.VISIBILITY,
    preventHeader: false,
    header: undefined,
    headerPosition: "top",
    frame: false,
    frameHeader: true,
    titleAlign: "left",
    manageHeight: true,
    initComponent: function() {
        var a = this;
        a.addEvents("beforeclose", "close", "beforeexpand", "beforecollapse", "expand", "collapse", "titlechange", "iconchange", "iconclschange");
        if (a.collapsible) {
            this.addStateEvents(["expand", "collapse"])
        }
        if (a.unstyled) {
            a.setUI("plain")
        }
        if (a.frame) {
            a.setUI(a.ui + "-framed")
        }
        a.bridgeToolbars();
        a.callParent();
        a.collapseDirection = a.collapseDirection || a.headerPosition || Ext.Component.DIRECTION_TOP;
        a.hiddenOnCollapse = new Ext.dom.CompositeElement()
    },
    beforeDestroy: function() {
        var a = this;
        Ext.destroy(a.placeholder, a.ghostPanel, a.dd);
        a.callParent()
    },
    initAria: function() {
        this.callParent();
        this.initHeaderAria()
    },
    getFocusEl: function() {
        return this.el
    },
    initHeaderAria: function() {
        var c = this,
            a = c.el,
            d = c.header;
        if (a && d) {
            a.dom.setAttribute("aria-labelledby", d.titleCmp.id)
        }
    },
    getHeader: function() {
        return this.header
    },
    setTitle: function(i) {
        var d = this,
            c = d.title,
            g = d.header,
            a = d.reExpander,
            e = d.placeholder;
        d.title = i;
        if (g) {
            if (g.isHeader) {
                g.setTitle(i)
            } else {
                g.title = i
            }
        } else {
            d.updateHeader()
        }
        if (a) {
            a.setTitle(i)
        }
        if (e && e.setTitle) {
            e.setTitle(i)
        }
        d.fireEvent("titlechange", d, i, c)
    },
    setIconCls: function(a) {
        var d = this,
            c = d.iconCls,
            g = d.header,
            e = d.placeholder;
        d.iconCls = a;
        if (g) {
            if (g.isHeader) {
                g.setIconCls(a)
            } else {
                g.iconCls = a
            }
        } else {
            d.updateHeader()
        }
        if (e && e.setIconCls) {
            e.setIconCls(a)
        }
        d.fireEvent("iconclschange", d, a, c)
    },
    setIcon: function(a) {
        var c = this,
            d = c.icon,
            g = c.header,
            e = c.placeholder;
        c.icon = a;
        if (g) {
            if (g.isHeader) {
                g.setIcon(a)
            } else {
                g.icon = a
            }
        } else {
            c.updateHeader()
        }
        if (e && e.setIcon) {
            e.setIcon(a)
        }
        c.fireEvent("iconchange", c, a, d)
    },
    bridgeToolbars: function() {
        var a = this,
            i = [],
            d, c, g = a.minButtonWidth;

        function e(j, l, k) {
            if (Ext.isArray(j)) {
                j = {
                    xtype: "toolbar",
                    items: j
                }
            } else {
                if (!j.xtype) {
                    j.xtype = "toolbar"
                }
            }
            j.dock = l;
            if (l == "left" || l == "right") {
                j.vertical = true
            }
            if (k) {
                j.layout = Ext.applyIf(j.layout || {}, {
                    pack: {
                        left: "start",
                        center: "center"
                    }[a.buttonAlign] || "end"
                })
            }
            return j
        }
        if (a.tbar) {
            i.push(e(a.tbar, "top"));
            a.tbar = null
        }
        if (a.bbar) {
            i.push(e(a.bbar, "bottom"));
            a.bbar = null
        }
        if (a.buttons) {
            a.fbar = a.buttons;
            a.buttons = null
        }
        if (a.fbar) {
            d = e(a.fbar, "bottom", true);
            d.ui = "footer";
            if (g) {
                c = d.defaults;
                d.defaults = function(j) {
                    var k = c || {};
                    if ((!j.xtype || j.xtype === "button" || (j.isComponent && j.isXType("button"))) && !("minWidth" in k)) {
                        k = Ext.apply({
                            minWidth: g
                        }, k)
                    }
                    return k
                }
            }
            i.push(d);
            a.fbar = null
        }
        if (a.lbar) {
            i.push(e(a.lbar, "left"));
            a.lbar = null
        }
        if (a.rbar) {
            i.push(e(a.rbar, "right"));
            a.rbar = null
        }
        if (a.dockedItems) {
            if (!Ext.isArray(a.dockedItems)) {
                a.dockedItems = [a.dockedItems]
            }
            a.dockedItems = a.dockedItems.concat(i)
        } else {
            a.dockedItems = i
        }
    },
    isPlaceHolderCollapse: function() {
        return this.collapseMode == "placeholder"
    },
    onBoxReady: function() {
        this.callParent();
        if (this.collapsed) {
            this.setHiddenDocked()
        }
    },
    beforeRender: function() {
        var c = this,
            a;
        c.callParent();
        c.initTools();
        if (!(c.preventHeader || (c.header === false))) {
            c.updateHeader()
        }
        if (c.collapsed) {
            if (c.isPlaceHolderCollapse()) {
                c.hidden = true;
                c.placeholderCollapse();
                a = c.collapsed;
                c.collapsed = false
            } else {
                c.beginCollapse();
                c.addClsWithUI(c.collapsedCls)
            }
        }
        if (a) {
            c.collapsed = a
        }
    },
    initTools: function() {
        var a = this;
        a.tools = a.tools ? Ext.Array.clone(a.tools) : [];
        if (a.collapsible && !(a.hideCollapseTool || a.header === false || a.preventHeader)) {
            a.collapseDirection = a.collapseDirection || a.headerPosition || "top";
            a.collapseTool = a.expandTool = Ext.widget({
                xtype: "tool",
                type: (a.collapsed && !a.isPlaceHolderCollapse()) ? ("expand-" + a.getOppositeDirection(a.collapseDirection)) : ("collapse-" + a.collapseDirection),
                handler: a.toggleCollapse,
                scope: a
            });
            if (a.collapseFirst) {
                a.tools.unshift(a.collapseTool)
            }
        }
        a.addTools();
        if (a.closable) {
            a.addClsWithUI("closable");
            a.addTool({
                type: "close",
                handler: Ext.Function.bind(a.close, a, [])
            })
        }
        if (a.collapseTool && !a.collapseFirst) {
            a.addTool(a.collapseTool)
        }
    },
    addTools: Ext.emptyFn,
    close: function() {
        if (this.fireEvent("beforeclose", this) !== false) {
            this.doClose()
        }
    },
    doClose: function() {
        this.fireEvent("close", this);
        this[this.closeAction]()
    },
    updateHeader: function(e) {
        var d = this,
            j = d.header,
            i = d.title,
            g = d.tools,
            c = d.icon || d.iconCls,
            a = d.headerPosition == "left" || d.headerPosition == "right";
        if ((j !== false) && (e || (i || c) || (g && g.length) || (d.collapsible && !d.titleCollapse))) {
            if (j && j.isHeader) {
                j.show()
            } else {
                j = d.header = Ext.widget(Ext.apply({
                    xtype: "header",
                    title: i,
                    titleAlign: d.titleAlign,
                    orientation: a ? "vertical" : "horizontal",
                    dock: d.headerPosition || "top",
                    textCls: d.headerTextCls,
                    iconCls: d.iconCls,
                    icon: d.icon,
                    baseCls: d.baseCls + "-header",
                    tools: g,
                    ui: d.ui,
                    id: d.id + "_header",
                    indicateDrag: d.draggable,
                    frame: (d.frame || d.alwaysFramed) && d.frameHeader,
                    ignoreParentFrame: d.frame || d.overlapHeader,
                    ignoreBorderManagement: d.frame || d.ignoreHeaderBorderManagement,
                    listeners: d.collapsible && d.titleCollapse ? {
                        click: d.toggleCollapse,
                        scope: d
                    } : null
                }, d.header));
                d.addDocked(j, 0);
                d.tools = j.tools
            }
            d.initHeaderAria()
        } else {
            if (j) {
                j.hide()
            }
        }
    },
    setUI: function(c) {
        var a = this;
        a.callParent(arguments);
        if (a.header && a.header.rendered) {
            a.header.setUI(c)
        }
    },
    getContentTarget: function() {
        return this.body
    },
    getTargetEl: function() {
        var a = this;
        return a.body || a.protoBody || a.frameBody || a.el
    },
    isVisible: function(a) {
        var c = this;
        if (c.collapsed && c.placeholder) {
            return c.placeholder.isVisible(a)
        }
        return c.callParent(arguments)
    },
    onHide: function() {
        var a = this;
        if (a.collapsed && a.placeholder) {
            a.placeholder.hide()
        } else {
            a.callParent(arguments)
        }
    },
    onShow: function() {
        var a = this;
        if (a.collapsed && a.placeholder) {
            a.hidden = true;
            a.placeholder.show()
        } else {
            a.callParent(arguments)
        }
    },
    onRemoved: function(c) {
        var a = this;
        a.callParent(arguments);
        if (a.placeholder && !c) {
            a.ownerCt.remove(a.placeholder, false)
        }
    },
    addTool: function(g) {
        g = [].concat(g);
        var e = this,
            i = e.header,
            d, a = g.length,
            c;
        for (d = 0; d < a; d++) {
            c = g[d];
            e.tools.push(c);
            if (i && i.isHeader) {
                i.addTool(c)
            }
        }
        e.updateHeader()
    },
    getOppositeDirection: function(a) {
        var e = Ext.Component;
        switch (a) {
            case e.DIRECTION_TOP:
                return e.DIRECTION_BOTTOM;
            case e.DIRECTION_RIGHT:
                return e.DIRECTION_LEFT;
            case e.DIRECTION_BOTTOM:
                return e.DIRECTION_TOP;
            case e.DIRECTION_LEFT:
                return e.DIRECTION_RIGHT
        }
    },
    getWidthAuthority: function() {
        if (this.collapsed && this.collapsedHorizontal()) {
            return 1
        }
        return this.callParent()
    },
    getHeightAuthority: function() {
        if (this.collapsed && this.collapsedVertical()) {
            return 1
        }
        return this.callParent()
    },
    collapsedHorizontal: function() {
        var a = this.getCollapsed();
        return a == "left" || a == "right"
    },
    collapsedVertical: function() {
        var a = this.getCollapsed();
        return a == "top" || a == "bottom"
    },
    restoreDimension: function() {
        var a = this.collapseDirection;
        return (a === "top" || a === "bottom") ? "height" : "width"
    },
    getCollapsed: function() {
        var a = this;
        if (a.collapsed === true) {
            return a.collapseDirection
        }
        return a.collapsed
    },
    getState: function() {
        var a = this,
            c = a.callParent(),
            d;
        c = a.addPropertyToState(c, "collapsed");
        if (a.collapsed) {
            d = a.collapseMemento;
            d = d && d.data;
            if (a.collapsedVertical()) {
                if (c) {
                    delete c.height
                }
                if (d) {
                    c = a.addPropertyToState(c, "height", d.height)
                }
            } else {
                if (c) {
                    delete c.width
                }
                if (d) {
                    c = a.addPropertyToState(c, "width", d.width)
                }
            }
        }
        return c
    },
    findReExpander: function(k) {
        var j = this,
            l = Ext.Component,
            g = j.dockedItems.items,
            a = g.length,
            d, e;
        if (j.collapseMode == "mini") {
            return
        }
        switch (k) {
            case l.DIRECTION_TOP:
            case l.DIRECTION_BOTTOM:
                for (e = 0; e < a; e++) {
                    d = g[e];
                    if (!d.hidden) {
                        if (d.isHeader && (!d.dock || d.dock == "top" || d.dock == "bottom")) {
                            return d
                        }
                    }
                }
                break;
            case l.DIRECTION_LEFT:
            case l.DIRECTION_RIGHT:
                for (e = 0; e < a; e++) {
                    d = g[e];
                    if (!d.hidden) {
                        if (d.isHeader && (d.dock == "left" || d.dock == "right")) {
                            return d
                        }
                    }
                }
                break;
            default:
                throw ("Panel#findReExpander must be passed a valid collapseDirection")
        }
    },
    getReExpander: function(d) {
        var c = this,
            e = d || c.collapseDirection,
            a = c.reExpander || c.findReExpander(e);
        c.expandDirection = c.getOppositeDirection(e);
        if (!a) {
            c.reExpander = a = c.createReExpander(e, {
                dock: e,
                cls: Ext.baseCSSPrefix + "docked " + c.baseCls + "-" + c.ui + "-collapsed",
                ownerCt: c,
                ownerLayout: c.componentLayout
            });
            c.dockedItems.insert(0, a)
        }
        return a
    },
    createReExpander: function(i, g) {
        var e = this,
            k = i == "left",
            d = i == "right",
            j = k || d,
            c, a = Ext.apply({
                hideMode: "offsets",
                title: e.title,
                orientation: j ? "vertical" : "horizontal",
                textCls: e.headerTextCls,
                icon: e.icon,
                iconCls: e.iconCls,
                baseCls: e.baseCls + "-header",
                ui: e.ui,
                frame: e.frame && e.frameHeader,
                ignoreParentFrame: e.frame || e.overlapHeader,
                indicateDrag: e.draggable
            }, g);
        if (e.collapseMode == "mini") {
            if (j) {
                a.width = 1
            } else {
                a.height = 1
            }
        }
        if (!e.hideCollapseTool) {
            c = k || (d && e.isPlaceHolderCollapse());
            a[c ? "items" : "tools"] = [{
                xtype: "tool",
                type: "expand-" + e.getOppositeDirection(i),
                uiCls: ["top"],
                handler: e.toggleCollapse,
                scope: e
            }]
        }
        a = new Ext.panel.Header(a);
        a.addClsWithUI(e.getHeaderCollapsedClasses(a));
        return a
    },
    getHeaderCollapsedClasses: function(e) {
        var c = this,
            d = c.collapsedCls,
            a;
        a = [d, d + "-" + e.dock];
        if (c.border && (!c.frame || (c.frame && Ext.supports.CSS3BorderRadius))) {
            a.push(d + "-border-" + e.dock)
        }
        return a
    },
    beginCollapse: function() {
        var g = this,
            d = g.lastBox,
            i = g.rendered,
            c = g.collapseMemento || (g.collapseMemento = new Ext.util.Memento(g)),
            e = g.getSizeModel(),
            a;
        c.capture(["height", "minHeight", "width", "minWidth"]);
        if (d) {
            c.capture(g.restoreDimension(), d, "last.")
        }
        if (g.collapsedVertical()) {
            if (e.width.shrinkWrap) {
                g.width = i ? g.getWidth() : g.width || g.minWidth || 100
            }
            delete g.height;
            g.minHeight = 0
        } else {
            if (g.collapsedHorizontal()) {
                if (e.height.shrinkWrap) {
                    g.height = i ? g.getHeight() : g.height || g.minHeight || 100
                }
                delete g.width;
                g.minWidth = 0
            }
        }
        if (g.ownerCt) {
            g.ownerCt.getLayout().beginCollapse(g)
        }
        if (!g.isPlaceHolderCollapse()) {
            if (g.header === (a = g.getReExpander())) {
                g.header.addClsWithUI(g.getHeaderCollapsedClasses(g.header));
                if (g.header.rendered) {
                    g.header.updateFrame()
                }
            } else {
                if (a.el) {
                    a.el.show();
                    a.hidden = false
                }
            }
        }
        if (g.resizer) {
            g.resizer.disable()
        }
    },
    beginExpand: function() {
        var g = this,
            e = g.lastBox,
            d = g.collapseMemento,
            a = this.restoreDimension(),
            c;
        d.restore(["minHeight", "minWidth", a]);
        if (e) {
            d.restore(a, true, e, "last.")
        }
        if (g.ownerCt) {
            g.ownerCt.getLayout().beginExpand(g)
        }
        if (!g.isPlaceHolderCollapse()) {
            if (g.header === (c = g.getReExpander())) {
                g.header.removeClsWithUI(g.getHeaderCollapsedClasses(g.header));
                if (g.header.rendered) {
                    g.header.updateFrame()
                }
            } else {
                c.hidden = true;
                c.el.hide()
            }
        }
        if (g.resizer) {
            g.resizer.enable()
        }
    },
    collapse: function(e, a) {
        var d = this,
            g = e || d.collapseDirection,
            c = d.ownerCt;
        if (d.isCollapsingOrExpanding) {
            return d
        }
        if (arguments.length < 2) {
            a = d.animCollapse
        }
        if (d.collapsed || d.fireEvent("beforecollapse", d, e, a) === false) {
            return d
        }
        if (c && d.isPlaceHolderCollapse()) {
            return d.placeholderCollapse(e, a)
        }
        d.collapsed = g;
        d.beginCollapse();
        d.fireHierarchyEvent("collapse");
        return d.doCollapseExpand(1, a)
    },
    doCollapseExpand: function(a, c) {
        var e = this,
            d = e.animCollapse,
            g = e.ownerLayout;
        e.animCollapse = c;
        e.isCollapsingOrExpanding = a;
        if (g && !c) {
            g.onContentChange(e)
        } else {
            e.updateLayout({
                isRoot: true
            })
        }
        e.animCollapse = d;
        return e
    },
    afterCollapse: function(c) {
        var a = this,
            d = a.ownerLayout;
        a.isCollapsingOrExpanding = 0;
        if (a.collapseTool) {
            a.collapseTool.setType("expand-" + a.getOppositeDirection(a.collapseDirection))
        }
        if (d && c) {
            d.onContentChange(a)
        }
        a.setHiddenDocked();
        a.fireEvent("collapse", a)
    },
    setHiddenDocked: function() {
        var k = this,
            e = k.hiddenOnCollapse,
            c = k.getReExpander(),
            d = k.getDockedItems(),
            a = d.length,
            g = 0,
            j;
        e.add(k.body);
        for (; g < a; g++) {
            j = d[g];
            if (j && j !== c && j.el) {
                e.add(j.el)
            }
        }
        e.setStyle("visibility", "hidden")
    },
    restoreHiddenDocked: function() {
        var a = this.hiddenOnCollapse;
        a.setStyle("visibility", "");
        a.clear()
    },
    getPlaceholder: function(d) {
        var c = this,
            g = d || c.collapseDirection,
            a = null,
            e = c.placeholder;
        if (!e) {
            if (c.floatable || (c.collapsible && c.titleCollapse)) {
                a = {
                    click: {
                        fn: c.floatable ? c.floatCollapsedPanel : c.toggleCollapse,
                        element: "el",
                        scope: c
                    }
                }
            }
            c.placeholder = e = Ext.widget(c.createReExpander(g, {
                id: c.id + "-placeholder",
                listeners: a
            }))
        }
        if (!e.placeholderFor) {
            if (!e.isComponent) {
                c.placeholder = e = c.lookupComponent(e)
            }
            Ext.applyIf(e, {
                margins: c.margins,
                placeholderFor: c
            });
            e.addCls([Ext.baseCSSPrefix + "region-collapsed-placeholder", Ext.baseCSSPrefix + "region-collapsed-" + g + "-placeholder", c.collapsedCls])
        }
        return e
    },
    placeholderCollapse: function(g, a) {
        var e = this,
            d = e.ownerCt,
            j = g || e.collapseDirection,
            c = Ext.baseCSSPrefix + "border-region-slide-in",
            i = e.getPlaceholder(g);
        e.isCollapsingOrExpanding = 1;
        e.hidden = true;
        e.collapsed = j;
        if (i.rendered) {
            if (i.el.dom.parentNode !== e.el.dom.parentNode) {
                e.el.dom.parentNode.insertBefore(i.el.dom, e.el.dom)
            }
            i.hidden = false;
            i.el.show();
            d.updateLayout()
        } else {
            d.insert(d.items.indexOf(e), i)
        }
        if (e.rendered) {
            e.el.setVisibilityMode(e.placeholderCollapseHideMode);
            if (a) {
                e.el.addCls(c);
                i.el.hide();
                e.el.slideOut(j.substr(0, 1), {
                    preserveScroll: true,
                    duration: Ext.Number.from(a, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: function() {
                            e.el.removeCls(c);
                            i.el.show().setStyle("display", "none").slideIn(j.substr(0, 1), {
                                easing: "linear",
                                duration: 100,
                                listeners: {
                                    afteranimate: function() {
                                        i.focus();
                                        e.isCollapsingOrExpanding = 0;
                                        e.fireEvent("collapse", e)
                                    }
                                }
                            })
                        }
                    }
                })
            } else {
                e.el.hide();
                e.isCollapsingOrExpanding = 0;
                e.fireEvent("collapse", e)
            }
        } else {
            e.isCollapsingOrExpanding = 0;
            e.fireEvent("collapse", e)
        }
        return e
    },
    floatCollapsedPanel: function() {
        var i = this,
            k = i.placeholder,
            j = k.getBox(true),
            e, g = Ext.baseCSSPrefix + "border-region-slide-in",
            c = i.collapsed,
            l = i.ownerCt || i,
            a;
        if (i.el.hasCls(g)) {
            i.slideOutFloatedPanel();
            return
        }
        if (i.isSliding) {
            return
        }
        i.isSliding = true;

        function d(n) {
            if (!i.isDestroyed) {
                var m = i.el.getRegion().union(k.el.getRegion()).adjust(1, -1, -1, 1);
                if (!m.contains(n.getPoint())) {
                    i.slideOutFloatedPanel()
                }
            }
        }
        i.placeholder.el.hide();
        i.placeholder.hidden = true;
        i.el.show();
        i.hidden = false;
        i.collapsed = false;
        l.updateLayout();
        e = i.getBox(true);
        i.placeholder.el.show();
        i.placeholder.hidden = false;
        i.el.hide();
        i.hidden = true;
        i.collapsed = c;
        l.updateLayout();
        i.placeholderMouseMon = k.el.monitorMouseLeave(500, d);
        i.panelMouseMon = i.el.monitorMouseLeave(500, d);
        i.el.addCls(g);
        if (i.collapseTool) {
            i.collapseTool.el.hide()
        }
        switch (i.collapsed) {
            case "top":
                i.el.setLeftTop(j.x, j.y + j.height - 1);
                a = "t";
                break;
            case "right":
                i.el.setLeftTop(j.x - e.width + 1, j.y);
                a = "r";
                break;
            case "bottom":
                i.el.setLeftTop(j.x, j.y - e.height + 1);
                a = "b";
                break;
            case "left":
                i.el.setLeftTop(j.x + j.width - 1, j.y);
                a = "l";
                break
        }
        i.floatedFromCollapse = i.collapsed;
        i.collapsed = i.hidden = false;
        i.el.slideIn(a, {
            preserveScroll: true,
            listeners: {
                afteranimate: function() {
                    i.isSliding = false
                }
            }
        })
    },
    isLayoutRoot: function() {
        if (this.floatedFromCollapse) {
            return true
        }
        return this.callParent()
    },
    slideOutFloatedPanel: function() {
        var a = this,
            d = this.el,
            c;
        if (a.isSliding) {
            return
        }
        a.isSliding = true;
        a.slideOutFloatedPanelBegin();
        if (typeof a.collapsed == "string") {
            c = a.collapsed.charAt(0)
        }
        d.slideOut(c, {
            preserveScroll: true,
            listeners: {
                afteranimate: function() {
                    a.slideOutFloatedPanelEnd();
                    a.el.removeCls(Ext.baseCSSPrefix + "border-region-slide-in");
                    a.isSliding = false
                }
            }
        })
    },
    slideOutFloatedPanelBegin: function() {
        var a = this,
            c = this.el;
        a.collapsed = a.floatedFromCollapse;
        a.hidden = true;
        a.floatedFromCollapse = null;
        c.un(a.panelMouseMon);
        a.placeholder.el.un(a.placeholderMouseMon)
    },
    slideOutFloatedPanelEnd: function() {
        if (this.collapseTool) {
            this.collapseTool.el.show()
        }
    },
    expand: function(a) {
        var c = this;
        if (c.isCollapsingOrExpanding) {
            return c
        }
        if (!arguments.length) {
            a = c.animCollapse
        }
        if (!c.collapsed && !c.floatedFromCollapse) {
            return c
        }
        if (c.fireEvent("beforeexpand", c, a) === false) {
            return c
        }
        if (c.isPlaceHolderCollapse()) {
            return c.placeholderExpand(a)
        }
        c.restoreHiddenDocked();
        c.beginExpand();
        c.collapsed = false;
        c.fireHierarchyEvent("expand");
        return c.doCollapseExpand(2, a)
    },
    placeholderExpand: function(c) {
        var e = this,
            j = e.collapsed,
            d = Ext.baseCSSPrefix + "border-region-slide-in",
            g, a, i;
        if (e.floatedFromCollapse) {
            a = e.getPosition(true);
            e.slideOutFloatedPanelBegin();
            e.slideOutFloatedPanelEnd()
        }
        e.isCollapsingOrExpanding = 2;
        e.placeholder.hidden = true;
        e.placeholder.el.hide();
        e.collapsed = false;
        e.show();
        if (c) {
            if (a) {
                g = e.el.getXY();
                e.el.setLeftTop(a[0], a[1]);
                e.el.moveTo(g[0], g[1], {
                    duration: Ext.Number.from(c, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: function() {
                            e.el.removeCls(d);
                            e.isCollapsingOrExpanding = 0;
                            e.fireEvent("expand", e)
                        }
                    }
                })
            } else {
                e.hidden = true;
                e.el.addCls(d);
                e.el.hide();
                e.collapsed = j;
                e.placeholder.show();
                i = j.substr(0, 1);
                e.hidden = false;
                e.el.slideIn(i, {
                    preserveScroll: true,
                    duration: Ext.Number.from(c, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: function() {
                            e.collapsed = false;
                            e.el.removeCls(d);
                            e.placeholder.hide();
                            e.isCollapsingOrExpanding = 0;
                            e.fireEvent("expand", e)
                        }
                    }
                })
            }
        } else {
            e.isCollapsingOrExpanding = 0;
            e.fireEvent("expand", e)
        }
        return e
    },
    afterExpand: function(c) {
        var a = this,
            d = a.ownerLayout;
        a.isCollapsingOrExpanding = 0;
        if (a.collapseTool) {
            a.collapseTool.setType("collapse-" + a.collapseDirection)
        }
        if (d && c) {
            d.onContentChange(a)
        }
        a.fireEvent("expand", a)
    },
    setBorder: function(a, d) {
        if (d) {
            return
        }
        var c = this,
            e = c.header;
        if (!a) {
            a = 0
        } else {
            a = Ext.Element.unitizeBox((a === true) ? 1 : a)
        }
        if (e) {
            if (e.isHeader) {
                e.setBorder(a)
            } else {
                e.border = a
            }
        }
        if (c.rendered && c.bodyBorder !== false) {
            c.body.setStyle("border-width", a)
        }
        c.updateLayout();
        c.border = a
    },
    toggleCollapse: function() {
        return (this.collapsed || this.floatedFromCollapse) ? this.expand() : this.collapse()
    },
    getKeyMap: function() {
        return this.keyMap || (this.keyMap = new Ext.util.KeyMap(Ext.apply({
            target: this.el
        }, this.keys)))
    },
    initDraggable: function() {
        this.dd = new Ext.panel.DD(this, Ext.isBoolean(this.draggable) ? null : this.draggable)
    },
    ghostTools: function() {
        var g = [],
            i = this.header,
            e = i ? i.query("tool[hidden=false]") : [],
            d, a, c;
        if (e.length) {
            d = 0;
            a = e.length;
            for (; d < a; d++) {
                c = e[d];
                g.push({
                    type: c.type
                })
            }
        } else {
            g = [{
                type: "placeholder"
            }]
        }
        return g
    },
    ghost: function(a) {
        var e = this,
            c = e.ghostPanel,
            d = e.getBox(),
            g;
        if (!c) {
            c = new Ext.panel.Panel({
                renderTo: document.body,
                floating: {
                    shadow: false
                },
                frame: e.frame && !e.alwaysFramed,
                alwaysFramed: e.alwaysFramed,
                overlapHeader: e.overlapHeader,
                headerPosition: e.headerPosition,
                baseCls: e.baseCls,
                cls: e.baseCls + "-ghost " + (a || "")
            });
            e.ghostPanel = c
        } else {
            c.el.show()
        }
        c.floatParent = e.floatParent;
        if (e.floating) {
            c.setZIndex(Ext.Number.from(e.el.getStyle("zIndex"), 0))
        } else {
            c.toFront()
        }
        if (!(e.preventHeader || (e.header === false))) {
            g = c.header;
            if (g) {
                g.suspendLayouts();
                Ext.Array.forEach(g.query("tool"), g.remove, g);
                g.resumeLayouts()
            }
            c.addTool(e.ghostTools());
            c.setTitle(e.title);
            c.setIconCls(e.iconCls)
        }
        c.setPagePosition(d.x, d.y);
        c.setSize(d.width, d.height);
        e.el.hide();
        return c
    },
    unghost: function(c, a) {
        var d = this;
        if (!d.ghostPanel) {
            return
        }
        if (c !== false) {
            d.el.show();
            if (a !== false) {
                d.setPagePosition(d.ghostPanel.el.getXY());
                if (d.hideMode == "offsets") {
                    delete d.el.hideModeStyles
                }
            }
            Ext.defer(d.focus, 10, d)
        }
        d.ghostPanel.el.hide()
    },
    beginDrag: function() {
        if (this.floatingDescendants) {
            this.floatingDescendants.hide()
        }
    },
    endDrag: function() {
        if (this.floatingDescendants) {
            this.floatingDescendants.show()
        }
    },
    initResizable: function(a) {
        if (this.collapsed) {
            a.disabled = true
        }
        this.callParent([a])
    }
}, function() {
    this.prototype.animCollapse = Ext.enableFx
});
Ext.define("Ext.data.proxy.Client", {
    extend: "Ext.data.proxy.Proxy",
    alternateClassName: "Ext.data.ClientProxy",
    isSynchronous: true,
    clear: function() {}
});
Ext.define("Ext.data.proxy.Memory", {
    extend: "Ext.data.proxy.Client",
    alias: "proxy.memory",
    alternateClassName: "Ext.data.MemoryProxy",
    constructor: function(a) {
        this.callParent([a]);
        this.setReader(this.reader)
    },
    updateOperation: function(c, j, e) {
        var d = 0,
            g = c.getRecords(),
            a = g.length;
        for (d; d < a; d++) {
            g[d].commit()
        }
        c.setCompleted();
        c.setSuccessful();
        Ext.callback(j, e || this, [c])
    },
    create: function() {
        this.updateOperation.apply(this, arguments)
    },
    update: function() {
        this.updateOperation.apply(this, arguments)
    },
    destroy: function() {
        this.updateOperation.apply(this, arguments)
    },
    read: function(a, e, c) {
        var d = this;
        a.resultSet = d.getReader().read(d.data);
        a.setCompleted();
        a.setSuccessful();
        Ext.callback(e, c || d, [a])
    },
    clear: Ext.emptyFn
});
Ext.define("DemoApp.model.LayerModel", {
    alternateClassName: "DemoApp.model.LayerRecord",
    extend: "Ext.data.Model",
    requires: ["Ext.data.proxy.Memory", "Ext.data.reader.Json"],
    alias: "model.gx_layer",
    statics: {
        createFromLayer: function(a) {
            return this.proxy.reader.readRecords([a]).records[0]
        }
    },
    fields: ["id", {
        name: "title",
        type: "string",
        mapping: "name"
    }, {
        name: "legendURL",
        type: "string",
        mapping: "metadata.legendURL"
    }, {
        name: "hideTitle",
        type: "bool",
        mapping: "metadata.hideTitle"
    }, {
        name: "hideInLegend",
        type: "bool",
        mapping: "metadata.hideInLegend"
    }],
    proxy: {
        type: "memory",
        reader: {
            type: "json"
        }
    },
    getLayer: function() {
        return this.raw
    }
});
Ext.define("Ext.data.StoreManager", {
    extend: "Ext.util.MixedCollection",
    alternateClassName: ["Ext.StoreMgr", "Ext.data.StoreMgr", "Ext.StoreManager"],
    singleton: true,
    uses: ["Ext.data.ArrayStore"],
    register: function() {
        for (var a = 0, c;
            (c = arguments[a]); a++) {
            this.add(c)
        }
    },
    unregister: function() {
        for (var a = 0, c;
            (c = arguments[a]); a++) {
            this.remove(this.lookup(c))
        }
    },
    lookup: function(d) {
        if (Ext.isArray(d)) {
            var c = ["field1"],
                g = !Ext.isArray(d[0]),
                j = d,
                e, a;
            if (g) {
                j = [];
                for (e = 0, a = d.length; e < a; ++e) {
                    j.push([d[e]])
                }
            } else {
                for (e = 2, a = d[0].length; e <= a; ++e) {
                    c.push("field" + e)
                }
            }
            return new Ext.data.ArrayStore({
                data: j,
                fields: c,
                autoDestroy: true,
                autoCreated: true,
                expanded: g
            })
        }
        if (Ext.isString(d)) {
            return this.get(d)
        } else {
            return Ext.data.AbstractStore.create(d)
        }
    },
    getKey: function(a) {
        return a.storeId
    }
}, function() {
    Ext.regStore = function(d, c) {
        var a;
        if (Ext.isObject(d)) {
            c = d
        } else {
            c.storeId = d
        }
        if (c instanceof Ext.data.Store) {
            a = c
        } else {
            a = new Ext.data.Store(c)
        }
        return Ext.data.StoreManager.register(a)
    };
    Ext.getStore = function(a) {
        return Ext.data.StoreManager.lookup(a)
    }
});
Ext.define("Ext.util.LruCache", {
    extend: "Ext.util.HashMap",
    constructor: function(a) {
        Ext.apply(this, a);
        this.callParent([a])
    },
    add: function(c, g) {
        var e = this,
            a = e.findKey(g),
            d;
        if (a) {
            e.unlinkEntry(d = e.map[a]);
            d.prev = e.last;
            d.next = null
        } else {
            d = {
                prev: e.last,
                next: null,
                key: c,
                value: g
            }
        }
        if (e.last) {
            e.last.next = d
        } else {
            e.first = d
        }
        e.last = d;
        e.callParent([c, d]);
        e.prune();
        return g
    },
    insertBefore: function(c, i, d) {
        var g = this,
            a, e;
        if (d = this.map[this.findKey(d)]) {
            a = g.findKey(i);
            if (a) {
                g.unlinkEntry(e = g.map[a])
            } else {
                e = {
                    prev: d.prev,
                    next: d,
                    key: c,
                    value: i
                }
            }
            if (d.prev) {
                e.prev.next = e
            } else {
                g.first = e
            }
            e.next = d;
            d.prev = e;
            g.prune();
            return i
        } else {
            return g.add(c, i)
        }
    },
    get: function(a) {
        var c = this.map[a];
        if (c) {
            if (c.next) {
                this.moveToEnd(c)
            }
            return c.value
        }
    },
    removeAtKey: function(a) {
        this.unlinkEntry(this.map[a]);
        return this.callParent(arguments)
    },
    clear: function(a) {
        this.first = this.last = null;
        return this.callParent(arguments)
    },
    unlinkEntry: function(a) {
        if (a) {
            if (a.next) {
                a.next.prev = a.prev
            } else {
                this.last = a.prev
            }
            if (a.prev) {
                a.prev.next = a.next
            } else {
                this.first = a.next
            }
            a.prev = a.next = null
        }
    },
    moveToEnd: function(a) {
        this.unlinkEntry(a);
        if (a.prev = this.last) {
            this.last.next = a
        } else {
            this.first = a
        }
        this.last = a
    },
    getArray: function(d) {
        var a = [],
            c = this.first;
        while (c) {
            a.push(d ? c.key : c.value);
            c = c.next
        }
        return a
    },
    each: function(d, c, a) {
        var i = this,
            g = a ? i.last : i.first,
            e = i.length;
        c = c || i;
        while (g) {
            if (d.call(c, g.key, g.value, e) === false) {
                break
            }
            g = a ? g.prev : g.next
        }
        return i
    },
    findKey: function(c) {
        var a, d = this.map;
        for (a in d) {
            if (d.hasOwnProperty(a) && d[a].value === c) {
                return a
            }
        }
        return undefined
    },
    prune: function() {
        var a = this,
            c = a.maxSize ? (a.length - a.maxSize) : 0;
        if (c > 0) {
            for (; a.first && c; c--) {
                a.removeAtKey(a.first.key)
            }
        }
    }
});
Ext.define("Ext.data.Store", {
    extend: "Ext.data.AbstractStore",
    alias: "store.store",
    requires: ["Ext.data.StoreManager", "Ext.data.Model", "Ext.data.proxy.Ajax", "Ext.data.proxy.Memory", "Ext.data.reader.Json", "Ext.data.writer.Json", "Ext.util.LruCache"],
    uses: ["Ext.ModelManager", "Ext.util.Grouper"],
    remoteSort: false,
    remoteFilter: false,
    remoteGroup: false,
    groupField: undefined,
    groupDir: "ASC",
    trailingBufferZone: 25,
    leadingBufferZone: 200,
    pageSize: undefined,
    currentPage: 1,
    clearOnPageLoad: true,
    loading: false,
    sortOnFilter: true,
    buffered: false,
    purgePageCount: 5,
    clearRemovedOnLoad: true,
    defaultPageSize: 25,
    addRecordsOptions: {
        addRecords: true
    },
    statics: {
        recordIdFn: function(a) {
            return a.internalId
        },
        recordIndexFn: function(a) {
            return a.index
        }
    },
    onClassExtended: function(c, e, a) {
        var d = e.model,
            g;
        if (typeof d == "string") {
            g = a.onBeforeCreated;
            a.onBeforeCreated = function() {
                var j = this,
                    i = arguments;
                Ext.require(d, function() {
                    g.apply(j, i)
                })
            }
        }
    },
    constructor: function(c) {
        c = Ext.Object.merge({}, c);
        var e = this,
            i = c.groupers || e.groupers,
            a = c.groupField || e.groupField,
            d, g;
        g = c.data || e.data;
        e.data = new Ext.util.MixedCollection(false, Ext.data.Store.recordIdFn);
        if (g) {
            e.inlineData = g;
            delete c.data
        }
        if (!i && a) {
            i = [{
                property: a,
                direction: c.groupDir || e.groupDir
            }]
        }
        delete c.groupers;
        e.groupers = new Ext.util.MixedCollection();
        e.groupers.addAll(e.decodeGroupers(i));
        this.callParent([c]);
        if (e.buffered) {
            e.pageMap = new e.PageMap({
                pageSize: e.pageSize,
                maxSize: e.purgePageCount,
                listeners: {
                    clear: e.cancelAllPrefetches,
                    scope: e
                }
            });
            e.pageRequests = {};
            e.sortOnLoad = false;
            e.filterOnLoad = false
        }
        if (e.remoteGroup) {
            e.remoteSort = true
        }
        if (e.groupers.items.length && !e.remoteGroup) {
            e.sort(e.groupers.items, "prepend", false)
        }
        d = e.proxy;
        g = e.inlineData;
        if (!e.buffered && !e.pageSize) {
            e.pageSize = e.defaultPageSize
        }
        if (g) {
            if (d instanceof Ext.data.proxy.Memory) {
                d.data = g;
                e.read()
            } else {
                e.add.apply(e, [g])
            }
            e.sort();
            delete e.inlineData
        } else {
            if (e.autoLoad) {
                Ext.defer(e.load, 10, e, [typeof e.autoLoad === "object" ? e.autoLoad : undefined])
            }
        }
    },
    destroyStore: function() {
        this.callParent(arguments);
        if (this.pageMap) {
            this.pageMap.clear()
        }
    },
    onBeforeSort: function() {
        var a = this.groupers;
        if (a.getCount() > 0) {
            this.sort(a.items, "prepend", false)
        }
    },
    decodeGroupers: function(g) {
        if (!Ext.isArray(g)) {
            if (g === undefined) {
                g = []
            } else {
                g = [g]
            }
        }
        var e = g.length,
            j = Ext.util.Grouper,
            c, d, a = [];
        for (d = 0; d < e; d++) {
            c = g[d];
            if (!(c instanceof j)) {
                if (Ext.isString(c)) {
                    c = {
                        property: c
                    }
                }
                c = Ext.apply({
                    root: "data",
                    direction: "ASC"
                }, c);
                if (c.fn) {
                    c.sorterFn = c.fn
                }
                if (typeof c == "function") {
                    c = {
                        sorterFn: c
                    }
                }
                a.push(new j(c))
            } else {
                a.push(c)
            }
        }
        return a
    },
    group: function(g, i) {
        var e = this,
            d = false,
            c, a;
        if (Ext.isArray(g)) {
            a = g
        } else {
            if (Ext.isObject(g)) {
                a = [g]
            } else {
                if (Ext.isString(g)) {
                    c = e.groupers.get(g);
                    if (!c) {
                        c = {
                            property: g,
                            direction: i
                        };
                        a = [c]
                    } else {
                        if (i === undefined) {
                            c.toggle()
                        } else {
                            c.setDirection(i)
                        }
                    }
                }
            }
        }
        if (a && a.length) {
            d = true;
            a = e.decodeGroupers(a);
            e.groupers.clear();
            e.groupers.addAll(a)
        }
        if (e.remoteGroup) {
            if (e.buffered) {
                e.pageMap.clear();
                e.loadPage(1, {
                    groupChange: true
                })
            } else {
                e.load({
                    scope: e,
                    callback: e.fireGroupChange
                })
            }
        } else {
            e.sort(null, null, null, d);
            e.fireGroupChange()
        }
    },
    clearGrouping: function() {
        var e = this,
            i = e.groupers.items,
            d = i.length,
            a, c;
        for (c = 0; c < d; c++) {
            a = i[c];
            e.sorters.remove(a)
        }
        e.groupers.clear();
        if (e.remoteGroup) {
            if (e.buffered) {
                e.pageMap.clear();
                e.loadPage(1, {
                    groupChange: true
                })
            } else {
                e.load({
                    scope: e,
                    callback: e.fireGroupChange
                })
            }
        } else {
            e.sort();
            e.fireGroupChange()
        }
    },
    isGrouped: function() {
        return this.groupers.getCount() > 0
    },
    fireGroupChange: function() {
        this.fireEvent("groupchange", this, this.groupers)
    },
    getGroups: function(c) {
        var e = this.data.items,
            a = e.length,
            d = [],
            m = {},
            j, k, l, g;
        for (g = 0; g < a; g++) {
            j = e[g];
            k = this.getGroupString(j);
            l = m[k];
            if (l === undefined) {
                l = {
                    name: k,
                    children: []
                };
                d.push(l);
                m[k] = l
            }
            l.children.push(j)
        }
        return c ? m[c] : d
    },
    getGroupsForGrouper: function(j, c) {
        var e = j.length,
            g = [],
            a, d, l, m, k;
        for (k = 0; k < e; k++) {
            l = j[k];
            d = c.getGroupString(l);
            if (d !== a) {
                m = {
                    name: d,
                    grouper: c,
                    records: []
                };
                g.push(m)
            }
            m.records.push(l);
            a = d
        }
        return g
    },
    getGroupsForGrouperIndex: function(d, l) {
        var j = this,
            k = j.groupers,
            c = k.getAt(l),
            a = j.getGroupsForGrouper(d, c),
            g = a.length,
            e;
        if (l + 1 < k.length) {
            for (e = 0; e < g; e++) {
                a[e].children = j.getGroupsForGrouperIndex(a[e].records, l + 1)
            }
        }
        for (e = 0; e < g; e++) {
            a[e].depth = l
        }
        return a
    },
    getGroupData: function(a) {
        var c = this;
        if (a !== false) {
            c.sort()
        }
        return c.getGroupsForGrouperIndex(c.data.items, 0)
    },
    getGroupString: function(a) {
        var c = this.groupers.first();
        if (c) {
            return a.get(c.property)
        }
        return ""
    },
    insert: function(e, d) {
        var k = this,
            j = false,
            g, c, a;
        d = [].concat(d);
        for (g = 0, a = d.length; g < a; g++) {
            c = k.createModel(d[g]);
            c.set(k.modelDefaults);
            d[g] = c;
            k.data.insert(e + g, c);
            c.join(k);
            j = j || c.phantom === true
        }
        if (k.snapshot) {
            k.snapshot.addAll(d)
        }
        if (k.requireSort) {
            k.suspendEvents();
            k.sort();
            k.resumeEvents()
        }
        k.fireEvent("add", k, d, e);
        k.fireEvent("datachanged", k);
        if (k.autoSync && j && !k.autoSyncSuspended) {
            k.sync()
        }
    },
    add: function(c) {
        if (!Ext.isArray(c)) {
            c = Array.prototype.slice.apply(arguments)
        } else {
            c = c.slice(0)
        }
        var g = this,
            d = 0,
            e = c.length,
            a, j = !g.remoteSort && g.sorters && g.sorters.items.length;
        if (j && e === 1) {
            return [g.addSorted(g.createModel(c[0]))]
        }
        for (; d < e; d++) {
            a = g.createModel(c[d]);
            c[d] = a
        }
        if (j) {
            g.requireSort = true
        }
        g.insert(g.data.length, c);
        delete g.requireSort;
        return c
    },
    addSorted: function(a) {
        var d = this,
            c = d.data.findInsertionIndex(a, d.generateComparator());
        d.insert(c, a);
        return a
    },
    createModel: function(a) {
        if (!a.isModel) {
            a = Ext.ModelManager.create(a, this.model)
        }
        return a
    },
    each: function(g, e) {
        var i = this.data.items,
            c = i.length,
            a, j;
        for (j = 0; j < c; j++) {
            a = i[j];
            if (g.call(e || a, a, j, c) === false) {
                break
            }
        }
    },
    remove: function(d, m) {
        if (!Ext.isArray(d)) {
            d = [d]
        }
        m = m === true;
        var k = this,
            l = false,
            e = 0,
            a = d.length,
            c, j, g;
        for (; e < a; e++) {
            g = d[e];
            j = k.data.indexOf(g);
            if (k.snapshot) {
                k.snapshot.remove(g)
            }
            if (j > -1) {
                c = g.phantom !== true;
                if (!m && c) {
                    g.removedFrom = j;
                    k.removed.push(g)
                }
                g.unjoin(k);
                k.data.remove(g);
                l = l || c;
                k.fireEvent("remove", k, g, j)
            }
        }
        k.fireEvent("datachanged", k);
        if (!m && k.autoSync && l && !k.autoSyncSuspended) {
            k.sync()
        }
    },
    removeAt: function(c) {
        var a = this.getAt(c);
        if (a) {
            this.remove(a)
        }
    },
    load: function(a) {
        var c = this;
        a = a || {};
        if (typeof a == "function") {
            a = {
                callback: a
            }
        }
        a.groupers = a.groupers || c.groupers.items;
        a.page = a.page || c.currentPage;
        a.start = (a.start !== undefined) ? a.start : (a.page - 1) * c.pageSize;
        a.limit = a.limit || c.pageSize;
        a.addRecords = a.addRecords || false;
        if (c.buffered) {
            return c.loadToPrefetch(a)
        }
        return c.callParent([a])
    },
    reload: function(n) {
        var j = this,
            k, c, g, m, e, a, l, d;
        if (!n) {
            n = {}
        }
        if (j.buffered) {
            delete j.totalCount;
            a = function() {
                if (j.rangeCached(k, c)) {
                    j.loading = false;
                    j.pageMap.un("pageAdded", a);
                    d = j.pageMap.getRange(k, c);
                    j.loadRecords(d, {
                        start: k
                    });
                    j.fireEvent("load", j, d, true)
                }
            };
            l = Math.ceil((j.leadingBufferZone + j.trailingBufferZone) / 2);
            k = n.start || j.getAt(0).index;
            c = k + (n.count || j.getCount()) - 1;
            g = j.getPageFromRecordIndex(Math.max(k - l, 0));
            m = j.getPageFromRecordIndex(c + l);
            j.pageMap.clear(true);
            if (j.fireEvent("beforeload", j, n) !== false) {
                j.loading = true;
                for (e = g; e <= m; e++) {
                    j.prefetchPage(e, n)
                }
                j.pageMap.on("pageAdded", a)
            }
        } else {
            return j.callParent(arguments)
        }
    },
    onProxyLoad: function(c) {
        var e = this,
            d = c.getResultSet(),
            a = c.getRecords(),
            g = c.wasSuccessful();
        if (d) {
            e.totalCount = d.total
        }
        if (g) {
            e.loadRecords(a, c)
        }
        e.loading = false;
        if (e.hasListeners.load) {
            e.fireEvent("load", e, a, g)
        }
        if (e.hasListeners.read) {
            e.fireEvent("read", e, a, g)
        }
        Ext.callback(c.callback, c.scope || e, [a, c, g])
    },
    getNewRecords: function() {
        return this.data.filterBy(this.filterNew).items
    },
    getUpdatedRecords: function() {
        return this.data.filterBy(this.filterUpdated).items
    },
    filter: function(g, j) {
        if (Ext.isString(g)) {
            g = {
                property: g,
                value: j
            }
        }
        var e = this,
            a = e.decodeFilters(g),
            c = 0,
            k = e.sorters.length && e.sortOnFilter && !e.remoteSort,
            d = a.length;
        for (; c < d; c++) {
            e.filters.replace(a[c])
        }
        if (e.remoteFilter) {
            delete e.totalCount;
            if (e.buffered) {
                e.pageMap.clear();
                e.loadPage(1)
            } else {
                e.currentPage = 1;
                e.load()
            }
        } else {
            if (e.filters.getCount()) {
                e.snapshot = e.snapshot || e.data.clone();
                e.data = e.data.filter(e.filters.items);
                if (k) {
                    e.sort()
                } else {
                    e.fireEvent("datachanged", e);
                    e.fireEvent("refresh", e)
                }
            }
        }
    },
    clearFilter: function(a) {
        var c = this;
        c.filters.clear();
        if (c.remoteFilter) {
            if (a) {
                return
            }
            delete c.totalCount;
            if (c.buffered) {
                c.pageMap.clear();
                c.loadPage(1)
            } else {
                c.currentPage = 1;
                c.load()
            }
        } else {
            if (c.isFiltered()) {
                c.data = c.snapshot.clone();
                delete c.snapshot;
                if (a !== true) {
                    c.fireEvent("datachanged", c);
                    c.fireEvent("refresh", c)
                }
            }
        }
    },
    isFiltered: function() {
        var a = this.snapshot;
        return !!a && a !== this.data
    },
    filterBy: function(c, a) {
        var d = this;
        d.snapshot = d.snapshot || d.data.clone();
        d.data = d.queryBy(c, a || d);
        d.fireEvent("datachanged", d);
        d.fireEvent("refresh", d)
    },
    queryBy: function(c, a) {
        var d = this,
            e = d.snapshot || d.data;
        return e.filterBy(c, a || d)
    },
    query: function(j, i, k, a, g) {
        var e = this,
            c = e.createFilterFn(j, i, k, a, g),
            d = e.queryBy(c);
        if (!d) {
            d = new Ext.util.MixedCollection()
        }
        return d
    },
    loadData: function(l, a) {
        var k = this,
            d = k.model,
            j = l.length,
            g = [],
            e, c;
        for (e = 0; e < j; e++) {
            c = l[e];
            if (!(c.isModel)) {
                c = Ext.ModelManager.create(c, d)
            }
            g.push(c)
        }
        k.loadRecords(g, a ? k.addRecordsOptions : undefined)
    },
    loadRawData: function(g, c) {
        var e = this,
            a = e.proxy.reader.read(g),
            d = a.records;
        if (a.success) {
            e.totalCount = a.total;
            e.loadRecords(d, c ? e.addRecordsOptions : undefined);
            e.fireEvent("load", e, d, true)
        }
    },
    loadRecords: function(c, d) {
        var k = this,
            e = 0,
            j = c.length,
            l, g, a = k.snapshot;
        if (d) {
            l = d.start;
            g = d.addRecords
        }
        if (!g) {
            delete k.snapshot;
            k.clearData(true)
        } else {
            if (a) {
                a.addAll(c)
            }
        }
        k.data.addAll(c);
        if (l !== undefined) {
            for (; e < j; e++) {
                c[e].index = l + e;
                c[e].join(k)
            }
        } else {
            for (; e < j; e++) {
                c[e].join(k)
            }
        }
        k.suspendEvents();
        if (k.filterOnLoad && !k.remoteFilter) {
            k.filter()
        }
        if (k.sortOnLoad && !k.remoteSort) {
            k.sort(undefined, undefined, undefined, true)
        }
        k.resumeEvents();
        k.fireEvent("datachanged", k);
        k.fireEvent("refresh", k)
    },
    loadPage: function(d, a) {
        var c = this;
        c.currentPage = d;
        a = Ext.apply({
            page: d,
            start: (d - 1) * c.pageSize,
            limit: c.pageSize,
            addRecords: !c.clearOnPageLoad
        }, a);
        if (c.buffered) {
            return c.loadToPrefetch(a)
        }
        c.read(a)
    },
    nextPage: function(a) {
        this.loadPage(this.currentPage + 1, a)
    },
    previousPage: function(a) {
        this.loadPage(this.currentPage - 1, a)
    },
    clearData: function(e) {
        var d = this,
            a = d.data.items,
            c = a.length;
        while (c--) {
            a[c].unjoin(d)
        }
        d.data.clear();
        if (e !== true || d.clearRemovedOnLoad) {
            d.removed.length = 0
        }
    },
    loadToPrefetch: function(n) {
        var k = this,
            e, c, l = n.start,
            a = n.start + n.limit - 1,
            g = n.start + (k.viewSize || n.limit) - 1,
            j = k.getPageFromRecordIndex(Math.max(l - k.trailingBufferZone, 0)),
            m = k.getPageFromRecordIndex(a + k.leadingBufferZone),
            d = function() {
                if (k.rangeCached(l, g)) {
                    k.loading = false;
                    c = k.pageMap.getRange(l, g);
                    k.pageMap.un("pageAdded", d);
                    if (k.hasListeners.guaranteedrange) {
                        k.guaranteeRange(l, g, n.callback, n.scope)
                    } else {
                        k.loadRecords(c, {
                            start: l
                        })
                    }
                    k.fireEvent("load", k, c, true);
                    if (n.groupChange) {
                        k.fireGroupChange()
                    }
                }
            };
        if (k.fireEvent("beforeload", k, n) !== false) {
            delete k.totalCount;
            k.loading = true;
            k.pageMap.on("pageAdded", d);
            k.on("prefetch", function() {
                for (e = j + 1; e <= m; ++e) {
                    k.prefetchPage(e, n)
                }
            }, null, {
                single: true
            });
            k.prefetchPage(j, n)
        }
    },
    prefetch: function(d) {
        var g = this,
            a = g.pageSize,
            e, c;
        if (a) {
            if (g.lastPageSize && a != g.lastPageSize) {
                Ext.error.raise("pageSize cannot be dynamically altered")
            }
            if (!g.pageMap.pageSize) {
                g.pageMap.pageSize = a
            }
        } else {
            g.pageSize = g.pageMap.pageSize = a = d.limit
        }
        g.lastPageSize = a;
        if (!d.page) {
            d.page = g.getPageFromRecordIndex(d.start);
            d.start = (d.page - 1) * a;
            d.limit = Math.ceil(d.limit / a) * a
        }
        if (!g.pageRequests[d.page]) {
            d = Ext.apply({
                action: "read",
                filters: g.filters.items,
                sorters: g.sorters.items,
                groupers: g.groupers.items,
                generation: g.pageMap.generation
            }, d);
            c = new Ext.data.Operation(d);
            if (g.fireEvent("beforeprefetch", g, c) !== false) {
                g.loading = true;
                e = g.proxy;
                g.pageRequests[d.page] = e.read(c, g.onProxyPrefetch, g);
                if (e.isSynchronous) {
                    delete g.pageRequests[d.page]
                }
            }
        }
        return g
    },
    cancelAllPrefetches: function() {
        var d = this,
            a = d.pageRequests,
            c, e;
        if (d.pageMap.events.pageadded) {
            d.pageMap.events.pageadded.clearListeners()
        }
        for (e in a) {
            if (a.hasOwnProperty(e)) {
                c = a[e];
                delete a[e];
                delete c.callback
            }
        }
    },
    prefetchPage: function(g, c) {
        var e = this,
            a = e.pageSize || e.defaultPageSize,
            i = (g - 1) * e.pageSize,
            d = e.totalCount;
        if (d !== undefined && e.getCount() === d) {
            return
        }
        e.prefetch(Ext.applyIf({
            page: g,
            start: i,
            limit: a
        }, c))
    },
    onProxyPrefetch: function(c) {
        var e = this,
            d = c.getResultSet(),
            a = c.getRecords(),
            i = c.wasSuccessful(),
            g = c.page;
        if (c.generation === e.pageMap.generation) {
            if (d) {
                e.totalCount = d.total;
                e.fireEvent("totalcountchange", e.totalCount)
            }
            if (g !== undefined) {
                delete e.pageRequests[g]
            }
            if (i) {
                e.cachePage(a, c.page)
            }
            e.loading = false;
            e.fireEvent("prefetch", e, a, i, c);
            Ext.callback(c.callback, c.scope || e, [a, c, i])
        }
    },
    cachePage: function(a, d) {
        var c = this;
        if (!Ext.isDefined(c.totalCount)) {
            c.totalCount = a.length;
            c.fireEvent("totalcountchange", c.totalCount)
        }
        c.pageMap.addPage(d, a)
    },
    rangeCached: function(c, a) {
        return this.pageMap && this.pageMap.hasRange(c, a)
    },
    pageCached: function(a) {
        return this.pageMap && this.pageMap.hasPage(a)
    },
    rangeSatisfied: function(c, a) {
        return this.rangeCached(c, a)
    },
    getPageFromRecordIndex: function(a) {
        return Math.floor(a / this.pageSize) + 1
    },
    onGuaranteedRange: function(e) {
        var g = this,
            c = g.getTotalCount(),
            i = e.prefetchStart,
            a = ((c - 1) < e.prefetchEnd) ? c - 1 : e.prefetchEnd,
            d;
        a = Math.max(0, a);
        d = g.pageMap.getRange(i, a);
        g.fireEvent("guaranteedrange", d, i, a);
        if (e.cb) {
            e.cb.call(e.scope || g, d, i, a)
        }
    },
    prefetchRange: function(i, c) {
        var e = this,
            d, a, g;
        if (!e.rangeCached(i, c)) {
            d = e.getPageFromRecordIndex(i);
            a = e.getPageFromRecordIndex(c);
            e.pageMap.maxSize = e.purgePageCount ? (a - d + 1) + e.purgePageCount : 0;
            for (g = d; g <= a; g++) {
                if (!e.pageCached(g)) {
                    e.prefetchPage(g)
                }
            }
        }
    },
    guaranteeRange: function(k, d, a, i) {
        d = (d > this.totalCount) ? this.totalCount - 1 : d;
        var j = this,
            g = j.lastRequestStart,
            e = {
                prefetchStart: k,
                prefetchEnd: d,
                cb: a,
                scope: i
            },
            c;
        j.lastRequestStart = k;
        if (j.rangeCached(k, d)) {
            if (k < g) {
                k = Math.max(k - j.leadingBufferZone, 0);
                d = Math.min(d + j.trailingBufferZone, j.totalCount - 1)
            } else {
                k = Math.max(Math.min(k - j.trailingBufferZone, j.totalCount - j.pageSize), 0);
                d = Math.min(d + j.leadingBufferZone, j.totalCount - 1)
            }
            if (!j.rangeCached(k, d)) {
                j.prefetchRange(k, d)
            }
            j.onGuaranteedRange(e)
        } else {
            j.fireEvent("cachemiss", j, k, d);
            k = Math.min(Math.max(Math.floor(k - ((j.leadingBufferZone + j.trailingBufferZone) / 2)), 0), j.totalCount - j.pageSize);
            d = Math.min(Math.max(Math.ceil(d + ((j.leadingBufferZone + j.trailingBufferZone) / 2)), 0), j.totalCount - 1);
            c = function(m, l) {
                if (j.rangeCached(e.prefetchStart, e.prefetchEnd)) {
                    j.fireEvent("cachefilled", j, k, d);
                    j.pageMap.un("pageAdded", c);
                    j.onGuaranteedRange(e)
                }
            };
            j.pageMap.on("pageAdded", c);
            j.prefetchRange(e.prefetchStart, e.prefetchEnd);
            j.prefetchRange(k, d)
        }
    },
    sort: function() {
        var c = this,
            a = c.pageMap;
        if (c.buffered) {
            if (c.remoteSort) {
                a.clear();
                c.callParent(arguments)
            } else {
                c.callParent(arguments)
            }
        } else {
            c.callParent(arguments)
        }
    },
    doSort: function(c) {
        var g = this,
            a, e, d;
        if (g.remoteSort) {
            if (g.buffered) {
                g.pageMap.clear();
                g.loadPage(1)
            } else {
                g.load()
            }
        } else {
            g.data.sortBy(c);
            if (!g.buffered) {
                a = g.getRange();
                e = a.length;
                for (d = 0; d < e; d++) {
                    a[d].index = d
                }
            }
            g.fireEvent("datachanged", g);
            g.fireEvent("refresh", g)
        }
    },
    find: function(g, e, j, i, a, d) {
        var c = this.createFilterFn(g, e, i, a, d);
        return c ? this.data.findIndexBy(c, null, j) : -1
    },
    findRecord: function() {
        var c = this,
            a = c.find.apply(c, arguments);
        return a !== -1 ? c.getAt(a) : null
    },
    createFilterFn: function(e, d, g, a, c) {
        if (Ext.isEmpty(d)) {
            return false
        }
        d = this.data.createValueMatcher(d, g, a, c);
        return function(i) {
            return d.test(i.data[e])
        }
    },
    findExact: function(c, a, d) {
        return this.data.findIndexBy(function(e) {
            return e.isEqual(e.get(c), a)
        }, this, d)
    },
    findBy: function(c, a, d) {
        return this.data.findIndexBy(c, a, d)
    },
    collect: function(c, a, d) {
        var e = this,
            g = (d === true && e.snapshot) ? e.snapshot : e.data;
        return g.collect(c, "data", a)
    },
    getCount: function() {
        return this.data.length || 0
    },
    getTotalCount: function() {
        return this.totalCount || 0
    },
    getAt: function(a) {
        return this.data.getAt(a)
    },
    getRange: function(c, a) {
        return this.data.getRange(c, a)
    },
    getById: function(a) {
        return (this.snapshot || this.data).findBy(function(c) {
            return c.getId() === a
        })
    },
    indexOf: function(a) {
        return this.data.indexOf(a)
    },
    indexOfTotal: function(a) {
        var c = a.index;
        if (c || c === 0) {
            return c
        }
        return this.indexOf(a)
    },
    indexOfId: function(a) {
        return this.indexOf(this.getById(a))
    },
    removeAll: function(a) {
        var c = this;
        c.clearData();
        if (c.snapshot) {
            c.snapshot.clear()
        }
        if (c.pageMap) {
            c.pageMap.clear()
        }
        if (a !== true) {
            c.fireEvent("clear", c)
        }
    },
    first: function(a) {
        var c = this;
        if (a && c.isGrouped()) {
            return c.aggregate(function(d) {
                return d.length ? d[0] : undefined
            }, c, true)
        } else {
            return c.data.first()
        }
    },
    last: function(a) {
        var c = this;
        if (a && c.isGrouped()) {
            return c.aggregate(function(e) {
                var d = e.length;
                return d ? e[d - 1] : undefined
            }, c, true)
        } else {
            return c.data.last()
        }
    },
    sum: function(d, a) {
        var c = this;
        if (a && c.isGrouped()) {
            return c.aggregate(c.getSum, c, true, [d])
        } else {
            return c.getSum(c.data.items, d)
        }
    },
    getSum: function(c, g) {
        var e = 0,
            d = 0,
            a = c.length;
        for (; d < a; ++d) {
            e += c[d].get(g)
        }
        return e
    },
    count: function(a) {
        var c = this;
        if (a && c.isGrouped()) {
            return c.aggregate(function(d) {
                return d.length
            }, c, true)
        } else {
            return c.getCount()
        }
    },
    min: function(d, a) {
        var c = this;
        if (a && c.isGrouped()) {
            return c.aggregate(c.getMin, c, true, [d])
        } else {
            return c.getMin(c.data.items, d)
        }
    },
    getMin: function(c, j) {
        var e = 1,
            a = c.length,
            g, d;
        if (a > 0) {
            d = c[0].get(j)
        }
        for (; e < a; ++e) {
            g = c[e].get(j);
            if (g < d) {
                d = g
            }
        }
        return d
    },
    max: function(d, a) {
        var c = this;
        if (a && c.isGrouped()) {
            return c.aggregate(c.getMax, c, true, [d])
        } else {
            return c.getMax(c.data.items, d)
        }
    },
    getMax: function(d, j) {
        var e = 1,
            c = d.length,
            g, a;
        if (c > 0) {
            a = d[0].get(j)
        }
        for (; e < c; ++e) {
            g = d[e].get(j);
            if (g > a) {
                a = g
            }
        }
        return a
    },
    average: function(d, a) {
        var c = this;
        if (a && c.isGrouped()) {
            return c.aggregate(c.getAverage, c, true, [d])
        } else {
            return c.getAverage(c.data.items, d)
        }
    },
    getAverage: function(c, g) {
        var d = 0,
            a = c.length,
            e = 0;
        if (c.length > 0) {
            for (; d < a; ++d) {
                e += c[d].get(g)
            }
            return e / a
        }
        return 0
    },
    aggregate: function(k, m, g, j) {
        j = j || [];
        if (g && this.isGrouped()) {
            var a = this.getGroups(),
                d = 0,
                e = a.length,
                c = {},
                l;
            for (; d < e; ++d) {
                l = a[d];
                c[l.name] = k.apply(m || this, [l.children].concat(j))
            }
            return c
        } else {
            return k.apply(m || this, [this.data.items].concat(j))
        }
    },
    commitChanges: function() {
        var d = this,
            e = d.getModifiedRecords(),
            a = e.length,
            c = 0;
        for (; c < a; c++) {
            e[c].commit()
        }
        d.removed.length = 0
    },
    filterNewOnly: function(a) {
        return a.phantom === true
    },
    getRejectRecords: function() {
        return Ext.Array.push(this.data.filterBy(this.filterNewOnly).items, this.getUpdatedRecords())
    },
    rejectChanges: function() {
        var d = this,
            e = d.getRejectRecords(),
            a = e.length,
            c = 0,
            g;
        for (; c < a; c++) {
            g = e[c];
            g.reject();
            if (g.phantom) {
                d.remove(g)
            }
        }
        e = d.removed;
        a = e.length;
        for (c = 0; c < a; c++) {
            g = e[c];
            d.insert(g.removedFrom || 0, g);
            g.reject()
        }
        d.removed.length = 0
    }
}, function() {
    Ext.regStore("ext-empty-store", {
        fields: [],
        proxy: "memory"
    });
    this.prototype.PageMap = new Ext.Class({
        extend: "Ext.util.LruCache",
        clear: function(a) {
            this.generation = (this.generation || 0) + 1;
            this.callParent(arguments)
        },
        getPageFromRecordIndex: this.prototype.getPageFromRecordIndex,
        addPage: function(c, a) {
            this.add(c, a);
            this.fireEvent("pageAdded", c, a)
        },
        getPage: function(a) {
            return this.get(a)
        },
        hasRange: function(e, c) {
            var d = this.getPageFromRecordIndex(e),
                a = this.getPageFromRecordIndex(c);
            for (; d <= a; d++) {
                if (!this.hasPage(d)) {
                    return false
                }
            }
            return true
        },
        hasPage: function(a) {
            return !!this.get(a)
        },
        getRange: function(a, c) {
            if (!this.hasRange(a, c)) {
                Ext.Error.raise("PageMap asked for range which it does not have")
            }
            var m = this,
                j = m.getPageFromRecordIndex(a),
                p = m.getPageFromRecordIndex(c),
                d = (j - 1) * m.pageSize,
                q = (p * m.pageSize) - 1,
                l = j,
                r = [],
                o, k, n, e = 0,
                g;
            for (; l <= p; l++) {
                if (l == j) {
                    o = a - d;
                    n = true
                } else {
                    o = 0;
                    n = false
                }
                if (l == p) {
                    k = m.pageSize - (q - c);
                    n = true
                }
                if (n) {
                    Ext.Array.push(r, Ext.Array.slice(m.getPage(l), o, k))
                } else {
                    Ext.Array.push(r, m.getPage(l))
                }
            }
            for (g = r.length; e < g; e++) {
                r[e].index = a++
            }
            return r
        }
    })
});
Ext.define("DemoApp.store.LayerStore", {
    requires: ["DemoApp.model.LayerModel"],
    extend: "Ext.data.Store",
    model: "DemoApp.model.LayerModel",
    statics: {
        MAP_TO_STORE: 1,
        STORE_TO_MAP: 2
    },
    map: null,
    constructor: function(c) {
        var d = this;
        c = Ext.apply({}, c);
        var e = (DemoApp.MapPanel && c.map instanceof DemoApp.MapPanel) ? c.map.map : c.map;
        delete c.map;
        if (c.layers) {
            c.data = c.layers
        }
        delete c.layers;
        var a = {
            initDir: c.initDir
        };
        delete c.initDir;
        d.callParent([c]);
        if (e) {
            this.bind(e, a)
        }
    },
    bind: function(g, a) {
        var c = this;
        if (c.map) {
            return
        }
        c.map = g;
        a = Ext.apply({}, a);
        var d = a.initDir;
        if (a.initDir == undefined) {
            d = DemoApp.store.LayerStore.MAP_TO_STORE | DemoApp.store.LayerStore.STORE_TO_MAP
        }
        var e = g.layers.slice(0);
        if (d & DemoApp.store.LayerStore.STORE_TO_MAP) {
            c.each(function(i) {
                c.map.addLayer(i.getLayer())
            }, c)
        }
        if (d & DemoApp.store.LayerStore.MAP_TO_STORE) {
            c.loadRawData(e, true)
        }
        g.events.on({
            changelayer: c.onChangeLayer,
            addlayer: c.onAddLayer,
            removelayer: c.onRemoveLayer,
            scope: c
        });
        c.on({
            load: c.onLoad,
            clear: c.onClear,
            add: c.onAdd,
            remove: c.onRemove,
            update: c.onUpdate,
            scope: c
        });
        c.data.on({
            replace: c.onReplace,
            scope: c
        });
        c.fireEvent("bind", c, g)
    },
    unbind: function() {
        var a = this;
        if (a.map) {
            a.map.events.un({
                changelayer: a.onChangeLayer,
                addlayer: a.onAddLayer,
                removelayer: a.onRemoveLayer,
                scope: a
            });
            a.un("load", a.onLoad, a);
            a.un("clear", a.onClear, a);
            a.un("add", a.onAdd, a);
            a.un("remove", a.onRemove, a);
            a.data.un("replace", a.onReplace, a);
            a.map = null
        }
    },
    onChangeLayer: function(c) {
        var g = c.layer;
        var d = this.findBy(function(i, j) {
            return i.getLayer() === g
        });
        if (d > -1) {
            var a = this.getAt(d);
            if (c.property === "order") {
                if (!this._adding && !this._removing) {
                    var e = this.map.getLayerIndex(g);
                    if (e !== d) {
                        this._removing = true;
                        this.remove(a);
                        delete this._removing;
                        this._adding = true;
                        this.insert(e, [a]);
                        delete this._adding
                    }
                }
            } else {
                if (c.property === "name") {
                    a.set("title", g.name)
                } else {
                    this.fireEvent("update", this, a, Ext.data.Record.EDIT)
                }
            }
        }
    },
    onAddLayer: function(c) {
        var d = this;
        if (!d._adding) {
            d._adding = true;
            var a = d.proxy.reader.read(c.layer);
            d.add(a.records);
            delete d._adding
        }
    },
    onRemoveLayer: function(a) {
        if (this.map.unloadDestroy) {
            if (!this._removing) {
                var c = a.layer;
                this._removing = true;
                this.remove(this.getByLayer(c));
                delete this._removing
            }
        } else {
            this.unbind()
        }
    },
    onLoad: function(d, c, l) {
        if (l) {
            if (!Ext.isArray(c)) {
                c = [c]
            }
            if (!this._addRecords) {
                this._removing = true;
                for (var g = this.map.layers.length - 1; g >= 0; g--) {
                    this.map.removeLayer(this.map.layers[g])
                }
                delete this._removing
            }
            var a = c.length;
            if (a > 0) {
                var k = new Array(a);
                for (var e = 0; e < a; e++) {
                    k[e] = c[e].getLayer()
                }
                this._adding = true;
                this.map.addLayers(k);
                delete this._adding
            }
        }
        delete this._addRecords
    },
    onClear: function(a) {
        this._removing = true;
        for (var c = this.map.layers.length - 1; c >= 0; c--) {
            this.map.removeLayer(this.map.layers[c])
        }
        delete this._removing
    },
    onAdd: function(c, a, d) {
        if (!this._adding) {
            this._adding = true;
            var g;
            for (var e = a.length - 1; e >= 0; --e) {
                g = a[e].getLayer();
                this.map.addLayer(g);
                if (d !== this.map.layers.length - 1) {
                    this.map.setLayerIndex(g, d);
                    console.log("Changed index")
                }
            }
            delete this._adding
        }
    },
    onRemove: function(c, a, d) {
        if (!this._removing) {
            var e = a.getLayer();
            if (this.map.getLayer(e.id) != null) {
                this._removing = true;
                this.removeMapLayer(a);
                delete this._removing
            }
        }
    },
    onUpdate: function(d, a, c) {
        if (c === Ext.data.Record.EDIT) {
            if (a.modified && a.modified.title) {
                var e = a.getLayer();
                var g = a.get("title");
                if (g !== e.name) {
                    e.setName(g)
                }
            }
        }
    },
    removeMapLayer: function(a) {
        this.map.removeLayer(a.getLayer())
    },
    onReplace: function(d, a, c) {
        this.removeMapLayer(a)
    },
    getByLayer: function(c) {
        var a = this.findBy(function(d) {
            return d.getLayer() === c
        });
        if (a > -1) {
            return this.getAt(a)
        }
    },
    destroy: function() {
        var a = this;
        a.unbind();
        a.callParent()
    },
    loadRecords: function(a, c) {
        if (c && c.addRecords) {
            this._addRecords = true
        }
        this.callParent(arguments)
    }
});
Ext.define("DemoApp.view.OSMMap", {
    extend: "Ext.panel.Panel",
    requires: ["DemoApp.store.LayerStore"],
    alias: "widget.gx_osmmap",
    alternateClassName: "MMDemo.MapPanel",
    statics: {
        guess: function() {
            var a = Ext.ComponentQuery.query("gx_mappanel");
            return ((a && a.length > 0) ? a[0] : null)
        }
    },
    center: null,
    zoom: null,
    extent: null,
    prettyStateKeys: false,
    map: null,
    layers: null,
    stateEvents: ["aftermapmove", "afterlayervisibilitychange", "afterlayeropacitychange", "afterlayerorderchange", "afterlayernamechange", "afterlayeradd", "afterlayerremove"],
    initComponent: function() {
        if (!(this.map instanceof OpenLayers.Map)) {
            damap = this.map = new OpenLayers.Map(Ext.applyIf(this.map || {}, {
                allOverlays: true
            }));
            var a = new OpenLayers.Layer.OSM("OSM_Layer");
            this.map.addLayer(a);
            this.map.setLayerIndex(a, 0);
            a.setZIndex(0)
        }
        this.layers = Ext.getStore("LayerStore");
        if (Ext.isString(this.center)) {
            this.center = OpenLayers.LonLat.fromString(this.center)
        } else {
            if (Ext.isArray(this.center)) {
                this.center = new OpenLayers.LonLat(this.center[0], this.center[1])
            }
        }
        if (Ext.isString(this.extent)) {
            this.extent = OpenLayers.Bounds.fromString(this.extent)
        } else {
            if (Ext.isArray(this.extent)) {
                this.extent = OpenLayers.Bounds.fromArray(this.extent)
            }
        }
        this.callParent(arguments);
        this.on("resize", this.onResize, this);
        this.on("afterlayout", function() {
            if (typeof this.map.getViewport === "function") {
                this.items.each(function(c) {
                    if (typeof c.addToMapPanel === "function") {
                        c.getEl().appendTo(this.map.getViewport())
                    }
                }, this)
            }
        }, this);
        this.map.events.on({
            moveend: this.onMoveend,
            changelayer: this.onChangelayer,
            addlayer: this.onAddlayer,
            removelayer: this.onRemovelayer,
            scope: this
        })
    },
    onMoveend: function(a) {
        this.fireEvent("aftermapmove", this, this.map, a)
    },
    onChangelayer: function(c) {
        var a = this.map;
        if (c.property) {
            if (c.property === "visibility") {
                this.fireEvent("afterlayervisibilitychange", this, a, c)
            } else {
                if (c.property === "order") {
                    this.fireEvent("afterlayerorderchange", this, a, c)
                } else {
                    if (c.property === "nathis") {
                        this.fireEvent("afterlayernathischange", this, a, c)
                    } else {
                        if (c.property === "opacity") {
                            this.fireEvent("afterlayeropacitychange", this, a, c)
                        }
                    }
                }
            }
        }
    },
    onAddlayer: function() {
        this.fireEvent("afterlayeradd")
    },
    onRemovelayer: function() {
        this.fireEvent("afterlayerremove")
    },
    onResize: function() {
        var a = this.map;
        if (this.body.dom !== a.div) {
            a.render(this.body.dom);
            this.layers.bind(a);
            if (a.layers.length > 0) {
                this.setInitialExtent()
            } else {
                this.layers.on("add", this.setInitialExtent, this, {
                    single: true
                })
            }
        } else {
            a.updateSize()
        }
    },
    setInitialExtent: function() {
        var a = this.map;
        if (!a.getCenter()) {
            if (this.center || this.zoom) {
                a.setCenter(this.center, this.zoom)
            } else {
                if (this.extent instanceof OpenLayers.Bounds) {
                    a.zoomToExtent(this.extent, true)
                } else {
                    a.zoomToMaxExtent()
                }
            }
        }
    },
    getState: function() {
        var d = this,
            g = d.map,
            e = d.callParent(arguments) || {},
            c;
        if (!g) {
            return
        }
        var a = g.getCenter();
        a && Ext.applyIf(e, {
            x: a.lon,
            y: a.lat,
            zoom: g.getZoom()
        });
        d.layers.each(function(i) {
            c = i.getLayer();
            layerId = this.prettyStateKeys ? i.get("title") : i.get("id");
            e = d.addPropertyToState(e, "visibility_" + layerId, c.getVisibility());
            e = d.addPropertyToState(e, "opacity_" + layerId, (c.opacity === null) ? 1 : c.opacity)
        }, d);
        return e
    },
    applyState: function(a) {
        var n = this;
        map = n.map;
        n.center = new OpenLayers.LonLat(a.x, a.y);
        n.zoom = a.zoom;
        var j, d, k, e, c, m;
        var g = map.layers;
        for (j = 0, d = g.length; j < d; j++) {
            k = g[j];
            e = n.prettyStateKeys ? k.name : k.id;
            c = a["visibility_" + e];
            if (c !== undefined) {
                c = (/^true$/i).test(c);
                if (k.isBaseLayer) {
                    if (c) {
                        map.setBaseLayer(k)
                    }
                } else {
                    k.setVisibility(c)
                }
            }
            m = a["opacity_" + e];
            if (m !== undefined) {
                k.setOpacity(m)
            }
        }
    },
    onBeforeAdd: function(a) {
        if (Ext.isFunction(a.addToMapPanel)) {
            a.addToMapPanel(this)
        }
        this.callParent(arguments)
    },
    beforeDestroy: function() {
        if (this.map && this.map.events) {
            this.map.events.un({
                moveend: this.onMoveend,
                changelayer: this.onChangelayer,
                scope: this
            })
        }
        if (!this.initialConfig.map || !(this.initialConfig.map instanceof OpenLayers.Map)) {
            if (this.map && this.map.destroy) {
                this.map.destroy()
            }
        }
        delete this.map;
        this.callParent(arguments)
    }
});
Ext.define("Ext.grid.ColumnComponentLayout", {
    extend: "Ext.layout.component.Auto",
    alias: "layout.columncomponent",
    type: "columncomponent",
    setWidthInDom: true,
    getContentHeight: function(a) {
        return this.owner.isGroupHeader ? a.getProp("contentHeight") : this.callParent(arguments)
    },
    calculateOwnerHeightFromContentHeight: function(d, c) {
        var a = this.callParent(arguments);
        if (this.owner.isGroupHeader) {
            a += this.owner.titleEl.dom.offsetHeight
        }
        return a
    },
    getContentWidth: function(a) {
        return this.owner.isGroupHeader ? a.getProp("contentWidth") : this.callParent(arguments)
    },
    calculateOwnerWidthFromContentWidth: function(c, a) {
        return a + c.getPaddingInfo().width
    }
});
Ext.define("Ext.grid.ColumnLayout", {
    extend: "Ext.layout.container.HBox",
    alias: "layout.gridcolumn",
    type: "gridcolumn",
    reserveOffset: false,
    firstHeaderCls: Ext.baseCSSPrefix + "column-header-first",
    lastHeaderCls: Ext.baseCSSPrefix + "column-header-last",
    initLayout: function() {
        this.grid = this.owner.up("[scrollerOwner]");
        this.callParent()
    },
    beginLayout: function(l) {
        var k = this,
            g = k.grid,
            c = g.view,
            e = 0,
            d = k.getVisibleItems(),
            a = d.length,
            j;
        l.gridContext = l.context.getCmp(k.grid);
        if (g.lockable) {
            if (k.owner.up("tablepanel") === c.normalGrid) {
                c = c.normalGrid.getView()
            } else {
                c = null
            }
        }
        k.callParent(arguments);
        for (; e < a; e++) {
            j = d[e];
            j.removeCls([k.firstHeaderCls, k.lastHeaderCls]);
            j.el.setStyle({
                height: "auto"
            });
            j.titleEl.setStyle({
                height: "auto",
                paddingTop: ""
            })
        }
        if (a > 0) {
            d[0].addCls(k.firstHeaderCls);
            d[a - 1].addCls(k.lastHeaderCls)
        }
        if (!k.owner.isHeader && Ext.getScrollbarSize().width && !g.collapsed && c && c.table.dom && (c.autoScroll || c.overflowY)) {
            l.viewContext = l.context.getCmp(c)
        }
    },
    roundFlex: function(a) {
        return Math.floor(a)
    },
    calculate: function(g) {
        var e = this,
            d = g.viewContext,
            c, a;
        e.callParent(arguments);
        if (g.state.parallelDone) {
            g.setProp("columnWidthsDone", true)
        }
        if (d && !g.state.overflowAdjust.width && !g.gridContext.heightModel.shrinkWrap) {
            c = d.tableContext.getProp("height");
            a = d.getProp("height");
            if (isNaN(c + a)) {
                e.done = false
            } else {
                if (c >= a) {
                    g.gridContext.invalidate({
                        after: function() {
                            g.state.overflowAdjust = {
                                width: Ext.getScrollbarSize().width,
                                height: 0
                            }
                        }
                    })
                }
            }
        }
    },
    completeLayout: function(d) {
        var l = this,
            c = l.owner,
            a = d.state,
            j = false,
            m = l.sizeModels.calculated,
            g, k, e, o, n;
        l.callParent(arguments);
        if (!a.flexesCalculated && c.forceFit && !c.isHeader) {
            g = d.childItems;
            k = g.length;
            for (e = 0; e < k; e++) {
                o = g[e];
                n = o.target;
                if (n.width) {
                    n.flex = d.childItems[e].flex = n.width;
                    delete n.width;
                    o.widthModel = m;
                    j = true
                }
            }
            if (j) {
                l.cacheFlexes(d);
                d.invalidate({
                    state: {
                        flexesCalculated: true
                    }
                })
            }
        }
    },
    finalizeLayout: function() {
        var j = this,
            g = 0,
            e, c, k, a = j.owner,
            d = a.titleEl;
        e = j.getVisibleItems();
        c = e.length;
        k = a.el.getViewSize().height;
        if (d) {
            k -= d.getHeight()
        }
        for (; g < c; g++) {
            e[g].setPadding(k)
        }
    },
    publishInnerCtSize: function(g) {
        var e = this,
            d = g.state.boxPlan.targetSize,
            c = g.peek("contentWidth"),
            a;
        if ((c != null) && !e.owner.isHeader) {
            d.width = c;
            a = e.owner.ownerCt.view;
            if (a.autoScroll || a.overflowY) {
                d.width += Ext.getScrollbarSize().width
            }
        }
        return e.callParent(arguments)
    }
});
Ext.define("Ext.AbstractPlugin", {
    disabled: false,
    constructor: function(a) {
        this.initialConfig = a;
        Ext.apply(this, a)
    },
    clone: function() {
        return new this.self(this.initialConfig)
    },
    getCmp: function() {
        return this.cmp
    },
    init: Ext.emptyFn,
    destroy: Ext.emptyFn,
    enable: function() {
        this.disabled = false
    },
    disable: function() {
        this.disabled = true
    }
});
Ext.define("Ext.dd.DragTracker", {
    uses: ["Ext.util.Region"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    active: false,
    trackOver: false,
    tolerance: 5,
    autoStart: false,
    constructor: function(a) {
        var c = this;
        Ext.apply(c, a);
        c.addEvents("mouseover", "mouseout", "mousedown", "mouseup", "mousemove", "beforedragstart", "dragstart", "dragend", "drag");
        c.dragRegion = new Ext.util.Region(0, 0, 0, 0);
        if (c.el) {
            c.initEl(c.el)
        }
        c.mixins.observable.constructor.call(c);
        if (c.disabled) {
            c.disable()
        }
    },
    initEl: function(a) {
        var c = this;
        c.el = Ext.get(a);
        c.handle = Ext.get(c.delegate);
        c.delegate = c.handle ? undefined : c.delegate;
        if (!c.handle) {
            c.handle = c.el
        }
        c.mon(c.handle, {
            mousedown: c.onMouseDown,
            delegate: c.delegate,
            scope: c
        });
        if (c.trackOver || c.overCls) {
            c.mon(c.handle, {
                mouseover: c.onMouseOver,
                mouseout: c.onMouseOut,
                delegate: c.delegate,
                scope: c
            })
        }
    },
    disable: function() {
        this.disabled = true
    },
    enable: function() {
        this.disabled = false
    },
    destroy: function() {
        this.clearListeners();
        delete this.el
    },
    onMouseOver: function(d, c) {
        var a = this;
        if (!a.disabled) {
            if (Ext.EventManager.contains(d) || a.delegate) {
                a.mouseIsOut = false;
                if (a.overCls) {
                    a.el.addCls(a.overCls)
                }
                a.fireEvent("mouseover", a, d, a.delegate ? d.getTarget(a.delegate, c) : a.handle)
            }
        }
    },
    onMouseOut: function(c) {
        var a = this;
        if (a.mouseIsDown) {
            a.mouseIsOut = true
        } else {
            if (a.overCls) {
                a.el.removeCls(a.overCls)
            }
            a.fireEvent("mouseout", a, c)
        }
    },
    onMouseDown: function(g, d) {
        var c = this,
            a;
        if (c.disabled || g.dragTracked) {
            return
        }
        c.dragTarget = c.delegate ? d : c.handle.dom;
        c.startXY = c.lastXY = g.getXY();
        c.startRegion = Ext.fly(c.dragTarget).getRegion();
        if (c.fireEvent("mousedown", c, g) === false || c.fireEvent("beforedragstart", c, g) === false || c.onBeforeStart(g) === false) {
            return
        }
        c.mouseIsDown = true;
        g.dragTracked = true;
        a = c.el.dom;
        if (Ext.isIE && a.setCapture) {
            a.setCapture()
        }
        if (c.preventDefault !== false) {
            g.preventDefault()
        }
        Ext.getDoc().on({
            scope: c,
            mouseup: c.onMouseUp,
            mousemove: c.onMouseMove,
            selectstart: c.stopSelect
        });
        if (c.autoStart) {
            c.timer = Ext.defer(c.triggerStart, c.autoStart === true ? 1000 : c.autoStart, c, [g])
        }
    },
    onMouseMove: function(i, g) {
        var c = this,
            d = i.getXY(),
            a = c.startXY;
        i.preventDefault();
        c.lastXY = d;
        if (!c.active) {
            if (Math.max(Math.abs(a[0] - d[0]), Math.abs(a[1] - d[1])) > c.tolerance) {
                c.triggerStart(i)
            } else {
                return
            }
        }
        if (c.fireEvent("mousemove", c, i) === false) {
            c.onMouseUp(i)
        } else {
            c.onDrag(i);
            c.fireEvent("drag", c, i)
        }
    },
    onMouseUp: function(c) {
        var a = this;
        a.mouseIsDown = false;
        if (a.mouseIsOut) {
            a.mouseIsOut = false;
            a.onMouseOut(c)
        }
        c.preventDefault();
        if (Ext.isIE && document.releaseCapture) {
            document.releaseCapture()
        }
        a.fireEvent("mouseup", a, c);
        a.endDrag(c)
    },
    endDrag: function(g) {
        var c = this,
            d = Ext.getDoc(),
            a = c.active;
        d.un("mousemove", c.onMouseMove, c);
        d.un("mouseup", c.onMouseUp, c);
        d.un("selectstart", c.stopSelect, c);
        c.clearStart();
        c.active = false;
        if (a) {
            c.onEnd(g);
            c.fireEvent("dragend", c, g)
        }
        delete c._constrainRegion;
        delete Ext.EventObject.dragTracked
    },
    triggerStart: function(c) {
        var a = this;
        a.clearStart();
        a.active = true;
        a.onStart(c);
        a.fireEvent("dragstart", a, c)
    },
    clearStart: function() {
        var a = this.timer;
        if (a) {
            clearTimeout(a);
            delete this.timer
        }
    },
    stopSelect: function(a) {
        a.stopEvent();
        return false
    },
    onBeforeStart: function(a) {},
    onStart: function(a) {},
    onDrag: function(a) {},
    onEnd: function(a) {},
    getDragTarget: function() {
        return this.dragTarget
    },
    getDragCt: function() {
        return this.el
    },
    getConstrainRegion: function() {
        var a = this;
        if (a.constrainTo) {
            if (a.constrainTo instanceof Ext.util.Region) {
                return a.constrainTo
            }
            if (!a._constrainRegion) {
                a._constrainRegion = Ext.fly(a.constrainTo).getViewRegion()
            }
        } else {
            if (!a._constrainRegion) {
                a._constrainRegion = a.getDragCt().getViewRegion()
            }
        }
        return a._constrainRegion
    },
    getXY: function(a) {
        return a ? this.constrainModes[a](this, this.lastXY) : this.lastXY
    },
    getOffset: function(d) {
        var c = this.getXY(d),
            a = this.startXY;
        return [c[0] - a[0], c[1] - a[1]]
    },
    constrainModes: {
        point: function(c, e) {
            var d = c.dragRegion,
                a = c.getConstrainRegion();
            if (!a) {
                return e
            }
            d.x = d.left = d[0] = d.right = e[0];
            d.y = d.top = d[1] = d.bottom = e[1];
            d.constrainTo(a);
            return [d.left, d.top]
        },
        dragTarget: function(d, i) {
            var c = d.startXY,
                g = d.startRegion.copy(),
                a = d.getConstrainRegion(),
                e;
            if (!a) {
                return i
            }
            g.translateBy(i[0] - c[0], i[1] - c[1]);
            if (g.right > a.right) {
                i[0] += e = (a.right - g.right);
                g.left += e
            }
            if (g.left < a.left) {
                i[0] += (a.left - g.left)
            }
            if (g.bottom > a.bottom) {
                i[1] += e = (a.bottom - g.bottom);
                g.top += e
            }
            if (g.top < a.top) {
                i[1] += (a.top - g.top)
            }
            return i
        }
    }
});
Ext.define("Ext.grid.plugin.HeaderResizer", {
    extend: "Ext.AbstractPlugin",
    requires: ["Ext.dd.DragTracker", "Ext.util.Region"],
    alias: "plugin.gridheaderresizer",
    disabled: false,
    config: {
        dynamic: false
    },
    colHeaderCls: Ext.baseCSSPrefix + "column-header",
    minColWidth: 40,
    maxColWidth: 1000,
    wResizeCursor: "col-resize",
    eResizeCursor: "col-resize",
    init: function(a) {
        this.headerCt = a;
        a.on("render", this.afterHeaderRender, this, {
            single: true
        })
    },
    destroy: function() {
        if (this.tracker) {
            this.tracker.destroy()
        }
    },
    afterHeaderRender: function() {
        var c = this.headerCt,
            a = c.el;
        c.mon(a, "mousemove", this.onHeaderCtMouseMove, this);
        this.tracker = new Ext.dd.DragTracker({
            disabled: this.disabled,
            onBeforeStart: Ext.Function.bind(this.onBeforeStart, this),
            onStart: Ext.Function.bind(this.onStart, this),
            onDrag: Ext.Function.bind(this.onDrag, this),
            onEnd: Ext.Function.bind(this.onEnd, this),
            tolerance: 3,
            autoStart: 300,
            el: a
        })
    },
    onHeaderCtMouseMove: function(c, m) {
        var g = this,
            a, k, l, i, d, j;
        if (g.headerCt.dragging) {
            if (g.activeHd) {
                g.activeHd.el.dom.style.cursor = "";
                delete g.activeHd
            }
        } else {
            k = c.getTarget("." + g.colHeaderCls, 3, true);
            if (k) {
                l = Ext.getCmp(k.id);
                if (l.isOnLeftEdge(c)) {
                    i = l.previousNode("gridcolumn:not([hidden]):not([isGroupHeader])");
                    if (i) {
                        j = g.headerCt.up("tablepanel");
                        d = i.up("tablepanel");
                        if (!((d === j) || ((j.ownerCt.isXType("tablepanel")) && j.ownerCt.view.lockedGrid === d))) {
                            i = null
                        }
                    }
                } else {
                    if (l.isOnRightEdge(c)) {
                        i = l
                    } else {
                        i = null
                    }
                }
                if (i) {
                    if (i.isGroupHeader) {
                        a = i.getGridColumns();
                        i = a[a.length - 1]
                    }
                    if (i && !(i.fixed || (i.resizable === false) || g.disabled)) {
                        g.activeHd = i;
                        l.el.dom.style.cursor = g.eResizeCursor
                    }
                } else {
                    l.el.dom.style.cursor = "";
                    delete g.activeHd
                }
            }
        }
    },
    onBeforeStart: function(c) {
        var a = c.getTarget();
        this.dragHd = this.activeHd;
        if (!!this.dragHd && !Ext.fly(a).hasCls(Ext.baseCSSPrefix + "column-header-trigger") && !this.headerCt.dragging) {
            this.tracker.constrainTo = this.getConstrainRegion();
            return true
        } else {
            this.headerCt.dragging = false;
            return false
        }
    },
    getConstrainRegion: function() {
        var d = this,
            a = d.dragHd.el,
            e = Ext.util.Region.getRegion(a),
            c;
        if (d.headerCt.forceFit) {
            c = d.dragHd.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])")
        }
        return e.adjust(0, d.headerCt.forceFit ? (c ? c.getWidth() - d.minColWidth : 0) : d.maxColWidth - a.getWidth(), 0, d.minColWidth)
    },
    onStart: function(x) {
        var y = this,
            j = y.dragHd,
            c = j.el,
            q = c.getWidth(),
            l = y.headerCt,
            n = x.getTarget(),
            g, u, i, m, d, p, a, k, v, s, r, o;
        if (y.dragHd && !Ext.fly(n).hasCls(Ext.baseCSSPrefix + "column-header-trigger")) {
            l.dragging = true
        }
        y.origWidth = q;
        if (!y.dynamic) {
            g = c.getXY();
            u = l.up("[scrollerOwner]");
            i = y.dragHd.up(":not([isGroupHeader])");
            m = i.up();
            d = u.getLhsMarker();
            p = u.getRhsMarker();
            a = p.parent();
            k = a.getLocalX();
            v = a.getLocalY();
            s = a.translatePoints(g);
            r = m.body.getHeight() + l.getHeight();
            o = s.top - v;
            d.setTop(o);
            p.setTop(o);
            d.setHeight(r);
            p.setHeight(r);
            d.setLeft(s.left - k);
            p.setLeft(s.left + q - k)
        }
    },
    onDrag: function(j) {
        if (!this.dynamic) {
            var i = this.tracker.getXY("point"),
                a = this.headerCt.up("[scrollerOwner]"),
                k = a.getRhsMarker(),
                d = k.parent(),
                c = d.translatePoints(i),
                g = d.getLocalX();
            k.setLeft(c.left - g)
        } else {
            this.doResize()
        }
    },
    onEnd: function(i) {
        this.headerCt.dragging = false;
        if (this.dragHd) {
            if (!this.dynamic) {
                var g = this.dragHd,
                    c = this.headerCt.up("[scrollerOwner]"),
                    d = c.getLhsMarker(),
                    j = c.getRhsMarker(),
                    a = -9999;
                d.setLeft(a);
                j.setLeft(a)
            }
            this.doResize()
        }
    },
    doResize: function() {
        if (this.dragHd) {
            var c = this.dragHd,
                a, d = this.tracker.getOffset("point");
            if (c.flex) {
                delete c.flex
            }
            Ext.suspendLayouts();
            c.setWidth(this.origWidth + d[0]);
            if (this.headerCt.forceFit) {
                a = c.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])");
                if (a) {
                    delete a.flex;
                    a.setWidth(a.getWidth() - d[0])
                }
            }
            Ext.resumeLayouts(true)
        }
    },
    disable: function() {
        this.disabled = true;
        if (this.tracker) {
            this.tracker.disable()
        }
    },
    enable: function() {
        this.disabled = false;
        if (this.tracker) {
            this.tracker.enable()
        }
    }
});
Ext.define("Ext.dd.DragZone", {
    extend: "Ext.dd.DragSource",
    constructor: function(c, a) {
        this.callParent([c, a]);
        if (this.containerScroll) {
            Ext.dd.ScrollManager.register(this.el)
        }
    },
    getDragData: function(a) {
        return Ext.dd.Registry.getHandleFromEvent(a)
    },
    onInitDrag: function(a, c) {
        this.proxy.update(this.dragData.ddel.cloneNode(true));
        this.onStartDrag(a, c);
        return true
    },
    afterRepair: function() {
        var a = this;
        if (Ext.enableFx) {
            Ext.fly(a.dragData.ddel).highlight(a.repairHighlightColor)
        }
        a.dragging = false
    },
    getRepairXY: function(a) {
        return Ext.fly(this.dragData.ddel).getXY()
    },
    destroy: function() {
        this.callParent();
        if (this.containerScroll) {
            Ext.dd.ScrollManager.unregister(this.el)
        }
    }
});
Ext.define("Ext.grid.header.DragZone", {
    extend: "Ext.dd.DragZone",
    colHeaderCls: Ext.baseCSSPrefix + "column-header",
    maxProxyWidth: 120,
    constructor: function(a) {
        this.headerCt = a;
        this.ddGroup = this.getDDGroup();
        this.callParent([a.el]);
        this.proxy.el.addCls(Ext.baseCSSPrefix + "grid-col-dd")
    },
    getDDGroup: function() {
        return "header-dd-zone-" + this.headerCt.up("[scrollerOwner]").id
    },
    getDragData: function(c) {
        var g = c.getTarget("." + this.colHeaderCls),
            a, d;
        if (g) {
            a = Ext.getCmp(g.id);
            if (!this.headerCt.dragging && a.draggable && !(a.isOnLeftEdge(c) || a.isOnRightEdge(c))) {
                d = document.createElement("div");
                d.innerHTML = Ext.getCmp(g.id).text;
                return {
                    ddel: d,
                    header: a
                }
            }
        }
        return false
    },
    onBeforeDrag: function() {
        return !(this.headerCt.dragging || this.disabled)
    },
    onInitDrag: function() {
        this.headerCt.dragging = true;
        this.callParent(arguments)
    },
    onDragDrop: function() {
        this.headerCt.dragging = false;
        this.callParent(arguments)
    },
    afterRepair: function() {
        this.callParent();
        this.headerCt.dragging = false
    },
    getRepairXY: function() {
        return this.dragData.header.el.getXY()
    },
    disable: function() {
        this.disabled = true
    },
    enable: function() {
        this.disabled = false
    }
});
Ext.define("Ext.dd.DDTarget", {
    extend: "Ext.dd.DragDrop",
    constructor: function(d, a, c) {
        if (d) {
            this.initTarget(d, a, c)
        }
    },
    getDragEl: Ext.emptyFn,
    isValidHandleChild: Ext.emptyFn,
    startDrag: Ext.emptyFn,
    endDrag: Ext.emptyFn,
    onDrag: Ext.emptyFn,
    onDragDrop: Ext.emptyFn,
    onDragEnter: Ext.emptyFn,
    onDragOut: Ext.emptyFn,
    onDragOver: Ext.emptyFn,
    onInvalidDrop: Ext.emptyFn,
    onMouseDown: Ext.emptyFn,
    onMouseUp: Ext.emptyFn,
    setXConstraint: Ext.emptyFn,
    setYConstraint: Ext.emptyFn,
    resetConstraints: Ext.emptyFn,
    clearConstraints: Ext.emptyFn,
    clearTicks: Ext.emptyFn,
    setInitPosition: Ext.emptyFn,
    setDragElId: Ext.emptyFn,
    setHandleElId: Ext.emptyFn,
    setOuterHandleElId: Ext.emptyFn,
    addInvalidHandleClass: Ext.emptyFn,
    addInvalidHandleId: Ext.emptyFn,
    addInvalidHandleType: Ext.emptyFn,
    removeInvalidHandleClass: Ext.emptyFn,
    removeInvalidHandleId: Ext.emptyFn,
    removeInvalidHandleType: Ext.emptyFn,
    toString: function() {
        return ("DDTarget " + this.id)
    }
});
Ext.define("Ext.dd.ScrollManager", {
    singleton: true,
    requires: ["Ext.dd.DragDropManager"],
    constructor: function() {
        var a = Ext.dd.DragDropManager;
        a.fireEvents = Ext.Function.createSequence(a.fireEvents, this.onFire, this);
        a.stopDrag = Ext.Function.createSequence(a.stopDrag, this.onStop, this);
        this.doScroll = Ext.Function.bind(this.doScroll, this);
        this.ddmInstance = a;
        this.els = {};
        this.dragEl = null;
        this.proc = {}
    },
    onStop: function(a) {
        var c = Ext.dd.ScrollManager;
        c.dragEl = null;
        c.clearProc()
    },
    triggerRefresh: function() {
        if (this.ddmInstance.dragCurrent) {
            this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups)
        }
    },
    doScroll: function() {
        if (this.ddmInstance.dragCurrent) {
            var a = this.proc,
                c = a.el,
                d = a.el.ddScrollConfig,
                e = d ? d.increment : this.increment;
            if (!this.animate) {
                if (c.scroll(a.dir, e)) {
                    this.triggerRefresh()
                }
            } else {
                c.scroll(a.dir, e, true, this.animDuration, this.triggerRefresh)
            }
        }
    },
    clearProc: function() {
        var a = this.proc;
        if (a.id) {
            clearInterval(a.id)
        }
        a.id = 0;
        a.el = null;
        a.dir = ""
    },
    startProc: function(c, a) {
        this.clearProc();
        this.proc.el = c;
        this.proc.dir = a;
        var e = c.ddScrollConfig ? c.ddScrollConfig.ddGroup : undefined,
            d = (c.ddScrollConfig && c.ddScrollConfig.frequency) ? c.ddScrollConfig.frequency : this.frequency;
        if (e === undefined || this.ddmInstance.dragCurrent.ddGroup == e) {
            this.proc.id = setInterval(this.doScroll, d)
        }
    },
    onFire: function(j, m) {
        if (m || !this.ddmInstance.dragCurrent) {
            return
        }
        if (!this.dragEl || this.dragEl != this.ddmInstance.dragCurrent) {
            this.dragEl = this.ddmInstance.dragCurrent;
            this.refreshCache()
        }
        var n = j.getXY(),
            o = j.getPoint(),
            k = this.proc,
            i = this.els,
            d, g, a, l;
        for (d in i) {
            g = i[d];
            a = g._region;
            l = g.ddScrollConfig ? g.ddScrollConfig : this;
            if (a && a.contains(o) && g.isScrollable()) {
                if (a.bottom - o.y <= l.vthresh) {
                    if (k.el != g) {
                        this.startProc(g, "down")
                    }
                    return
                } else {
                    if (a.right - o.x <= l.hthresh) {
                        if (k.el != g) {
                            this.startProc(g, "left")
                        }
                        return
                    } else {
                        if (o.y - a.top <= l.vthresh) {
                            if (k.el != g) {
                                this.startProc(g, "up")
                            }
                            return
                        } else {
                            if (o.x - a.left <= l.hthresh) {
                                if (k.el != g) {
                                    this.startProc(g, "right")
                                }
                                return
                            }
                        }
                    }
                }
            }
        }
        this.clearProc()
    },
    register: function(d) {
        if (Ext.isArray(d)) {
            for (var c = 0, a = d.length; c < a; c++) {
                this.register(d[c])
            }
        } else {
            d = Ext.get(d);
            this.els[d.id] = d
        }
    },
    unregister: function(d) {
        if (Ext.isArray(d)) {
            for (var c = 0, a = d.length; c < a; c++) {
                this.unregister(d[c])
            }
        } else {
            d = Ext.get(d);
            delete this.els[d.id]
        }
    },
    vthresh: 25,
    hthresh: 25,
    increment: 100,
    frequency: 500,
    animate: true,
    animDuration: 0.4,
    ddGroup: undefined,
    refreshCache: function() {
        var a = this.els,
            c;
        for (c in a) {
            if (typeof a[c] == "object") {
                a[c]._region = a[c].getRegion()
            }
        }
    }
});
Ext.define("Ext.dd.DropTarget", {
    extend: "Ext.dd.DDTarget",
    requires: ["Ext.dd.ScrollManager"],
    constructor: function(c, a) {
        this.el = Ext.get(c);
        Ext.apply(this, a);
        if (this.containerScroll) {
            Ext.dd.ScrollManager.register(this.el)
        }
        this.callParent([this.el.dom, this.ddGroup || this.group, {
            isTarget: true
        }])
    },
    dropAllowed: Ext.baseCSSPrefix + "dd-drop-ok",
    dropNotAllowed: Ext.baseCSSPrefix + "dd-drop-nodrop",
    isTarget: true,
    isNotifyTarget: true,
    notifyEnter: function(a, d, c) {
        if (this.overClass) {
            this.el.addCls(this.overClass)
        }
        return this.dropAllowed
    },
    notifyOver: function(a, d, c) {
        return this.dropAllowed
    },
    notifyOut: function(a, d, c) {
        if (this.overClass) {
            this.el.removeCls(this.overClass)
        }
    },
    notifyDrop: function(a, d, c) {
        return false
    },
    destroy: function() {
        this.callParent();
        if (this.containerScroll) {
            Ext.dd.ScrollManager.unregister(this.el)
        }
    }
});
Ext.define("Ext.dd.Registry", {
    singleton: true,
    constructor: function() {
        this.elements = {};
        this.handles = {};
        this.autoIdSeed = 0
    },
    getId: function(c, a) {
        if (typeof c == "string") {
            return c
        }
        var d = c.id;
        if (!d && a !== false) {
            d = "extdd-" + (++this.autoIdSeed);
            c.id = d
        }
        return d
    },
    register: function(e, g) {
        g = g || {};
        if (typeof e == "string") {
            e = document.getElementById(e)
        }
        g.ddel = e;
        this.elements[this.getId(e)] = g;
        if (g.isHandle !== false) {
            this.handles[g.ddel.id] = g
        }
        if (g.handles) {
            var d = g.handles,
                c, a;
            for (c = 0, a = d.length; c < a; c++) {
                this.handles[this.getId(d[c])] = g
            }
        }
    },
    unregister: function(e) {
        var j = this.getId(e, false),
            g = this.elements[j],
            d, c, a;
        if (g) {
            delete this.elements[j];
            if (g.handles) {
                d = g.handles;
                for (c = 0, a = d.length; c < a; c++) {
                    delete this.handles[this.getId(d[c], false)]
                }
            }
        }
    },
    getHandle: function(a) {
        if (typeof a != "string") {
            a = a.id
        }
        return this.handles[a]
    },
    getHandleFromEvent: function(c) {
        var a = c.getTarget();
        return a ? this.handles[a.id] : null
    },
    getTarget: function(a) {
        if (typeof a != "string") {
            a = a.id
        }
        return this.elements[a]
    },
    getTargetFromEvent: function(c) {
        var a = c.getTarget();
        return a ? this.elements[a.id] || this.handles[a.id] : null
    }
});
Ext.define("Ext.dd.DropZone", {
    extend: "Ext.dd.DropTarget",
    requires: ["Ext.dd.Registry"],
    getTargetFromEvent: function(a) {
        return Ext.dd.Registry.getTargetFromEvent(a)
    },
    onNodeEnter: function(g, a, d, c) {},
    onNodeOver: function(g, a, d, c) {
        return this.dropAllowed
    },
    onNodeOut: function(g, a, d, c) {},
    onNodeDrop: function(g, a, d, c) {
        return false
    },
    onContainerOver: function(a, d, c) {
        return this.dropNotAllowed
    },
    onContainerDrop: function(a, d, c) {
        return false
    },
    notifyEnter: function(a, d, c) {
        return this.dropNotAllowed
    },
    notifyOver: function(a, d, c) {
        var g = this.getTargetFromEvent(d);
        if (!g) {
            if (this.lastOverNode) {
                this.onNodeOut(this.lastOverNode, a, d, c);
                this.lastOverNode = null
            }
            return this.onContainerOver(a, d, c)
        }
        if (this.lastOverNode != g) {
            if (this.lastOverNode) {
                this.onNodeOut(this.lastOverNode, a, d, c)
            }
            this.onNodeEnter(g, a, d, c);
            this.lastOverNode = g
        }
        return this.onNodeOver(g, a, d, c)
    },
    notifyOut: function(a, d, c) {
        if (this.lastOverNode) {
            this.onNodeOut(this.lastOverNode, a, d, c);
            this.lastOverNode = null
        }
    },
    notifyDrop: function(a, d, c) {
        if (this.lastOverNode) {
            this.onNodeOut(this.lastOverNode, a, d, c);
            this.lastOverNode = null
        }
        var g = this.getTargetFromEvent(d);
        return g ? this.onNodeDrop(g, a, d, c) : this.onContainerDrop(a, d, c)
    },
    triggerCacheRefresh: function() {
        Ext.dd.DDM.refreshCache(this.groups)
    }
});
Ext.define("Ext.grid.header.DropZone", {
    extend: "Ext.dd.DropZone",
    colHeaderCls: Ext.baseCSSPrefix + "column-header",
    proxyOffsets: [-4, -9],
    constructor: function(a) {
        this.headerCt = a;
        this.ddGroup = this.getDDGroup();
        this.callParent([a.el])
    },
    getDDGroup: function() {
        return "header-dd-zone-" + this.headerCt.up("[scrollerOwner]").id
    },
    getTargetFromEvent: function(a) {
        return a.getTarget("." + this.colHeaderCls)
    },
    getTopIndicator: function() {
        if (!this.topIndicator) {
            this.topIndicator = Ext.DomHelper.append(Ext.getBody(), {
                cls: "col-move-top",
                html: "&#160;"
            }, true)
        }
        return this.topIndicator
    },
    getBottomIndicator: function() {
        if (!this.bottomIndicator) {
            this.bottomIndicator = Ext.DomHelper.append(Ext.getBody(), {
                cls: "col-move-bottom",
                html: "&#160;"
            }, true)
        }
        return this.bottomIndicator
    },
    getLocation: function(g, c) {
        var a = g.getXY()[0],
            d = Ext.fly(c).getRegion(),
            j, i;
        if ((d.right - a) <= (d.right - d.left) / 2) {
            j = "after"
        } else {
            j = "before"
        }
        return {
            pos: j,
            header: Ext.getCmp(c.id),
            node: c
        }
    },
    positionIndicator: function(y, q, x) {
        var a = this.getLocation(x, q),
            s = a.header,
            j = a.pos,
            g = y.nextSibling("gridcolumn:not([hidden])"),
            v = y.previousSibling("gridcolumn:not([hidden])"),
            n, t, u, c, d, m, o, A, z, p, l, r, k;
        if (!s.draggable && s.getIndex() === 0) {
            return false
        }
        this.lastLocation = a;
        if ((y !== s) && ((j === "before" && g !== s) || (j === "after" && v !== s)) && !s.isDescendantOf(y)) {
            p = Ext.dd.DragDropManager.getRelated(this);
            l = p.length;
            r = 0;
            for (; r < l; r++) {
                k = p[r];
                if (k !== this && k.invalidateDrop) {
                    k.invalidateDrop()
                }
            }
            this.valid = true;
            n = this.getTopIndicator();
            t = this.getBottomIndicator();
            if (j === "before") {
                u = "tl";
                c = "bl"
            } else {
                u = "tr";
                c = "br"
            }
            d = s.el.getAnchorXY(u);
            m = s.el.getAnchorXY(c);
            o = this.headerCt.el;
            A = o.getLeft();
            z = o.getRight();
            d[0] = Ext.Number.constrain(d[0], A, z);
            m[0] = Ext.Number.constrain(m[0], A, z);
            d[0] -= 4;
            d[1] -= 9;
            m[0] -= 4;
            n.setXY(d);
            t.setXY(m);
            n.show();
            t.show()
        } else {
            this.invalidateDrop()
        }
    },
    invalidateDrop: function() {
        this.valid = false;
        this.hideIndicators()
    },
    onNodeOver: function(c, j, i, d) {
        var k = this,
            g = k.headerCt,
            a = true,
            m = d.header,
            l;
        if (d.header.el.dom === c) {
            a = false
        } else {
            l = k.getLocation(i, c).header;
            a = (m.ownerCt === l.ownerCt) || (!m.ownerCt.sealed && !l.ownerCt.sealed)
        }
        if (a) {
            k.positionIndicator(d.header, c, i)
        } else {
            k.valid = false
        }
        return k.valid ? k.dropAllowed : k.dropNotAllowed
    },
    hideIndicators: function() {
        this.getTopIndicator().hide();
        this.getBottomIndicator().hide()
    },
    onNodeOut: function() {
        this.hideIndicators()
    },
    onNodeDrop: function(q, g, t, x) {
        if (this.valid) {
            var s = x.header,
                i = this.lastLocation,
                m = i.header,
                v = s.ownerCt,
                p = s.up("headercontainer:not(gridcolumn)"),
                n = v.items.indexOf(s),
                a = m.ownerCt,
                l = m.up("headercontainer:not(gridcolumn)"),
                r = a.items.indexOf(m),
                k = this.headerCt,
                c = k.getHeaderIndex(s),
                o = s.isGroupHeader ? s.query(":not([isGroupHeader])").length : 1,
                u = k.getHeaderIndex(m),
                d, j;
            if (i.pos === "after") {
                r++;
                u += m.isGroupHeader ? m.query(":not([isGroupHeader])").length : 1
            }
            if (p !== l && p.lockableInjected && l.lockableInjected && l.lockedCt) {
                j = v.up("[scrollerOwner]");
                j.lock(s, r);
                this.onNodeDrop(q, g, t, x)
            } else {
                if (p !== l && p.lockableInjected && l.lockableInjected && p.lockedCt) {
                    j = v.up("[scrollerOwner]");
                    j.unlock(s, r);
                    this.onNodeDrop(q, g, t, x)
                } else {
                    this.invalidateDrop();
                    if ((v === a) && (r > n)) {
                        r -= 1
                    }
                    Ext.suspendLayouts();
                    if (v !== a) {
                        v.remove(s, false);
                        if (v.isGroupHeader) {
                            if (!v.items.getCount()) {
                                d = v.ownerCt;
                                d.remove(v, false);
                                v.el.dom.parentNode.removeChild(v.el.dom)
                            }
                        }
                    }
                    if (v === a) {
                        a.move(n, r)
                    } else {
                        a.insert(r, s)
                    }
                    if (a.isGroupHeader) {
                        if (a !== v) {
                            s.savedFlex = s.flex;
                            delete s.flex;
                            s.width = s.getWidth()
                        }
                    } else {
                        if (s.savedFlex) {
                            s.flex = s.savedFlex;
                            delete s.width
                        }
                    }
                    k.purgeCache();
                    Ext.resumeLayouts(true);
                    k.onHeaderMoved(s, o, c, u);
                    if (!v.items.getCount()) {
                        v.destroy()
                    }
                }
            }
        }
    }
});
Ext.define("Ext.grid.plugin.HeaderReorderer", {
    extend: "Ext.AbstractPlugin",
    requires: ["Ext.grid.header.DragZone", "Ext.grid.header.DropZone"],
    alias: "plugin.gridheaderreorderer",
    init: function(a) {
        this.headerCt = a;
        a.on({
            render: this.onHeaderCtRender,
            single: true,
            scope: this
        })
    },
    destroy: function() {
        Ext.destroy(this.dragZone, this.dropZone)
    },
    onHeaderCtRender: function() {
        var a = this;
        a.dragZone = new Ext.grid.header.DragZone(a.headerCt);
        a.dropZone = new Ext.grid.header.DropZone(a.headerCt);
        if (a.disabled) {
            a.dragZone.disable()
        }
    },
    enable: function() {
        this.disabled = false;
        if (this.dragZone) {
            this.dragZone.enable()
        }
    },
    disable: function() {
        this.disabled = true;
        if (this.dragZone) {
            this.dragZone.disable()
        }
    }
});
Ext.define("Ext.grid.header.Container", {
    extend: "Ext.container.Container",
    requires: ["Ext.grid.ColumnLayout", "Ext.grid.plugin.HeaderResizer", "Ext.grid.plugin.HeaderReorderer"],
    uses: ["Ext.grid.column.Column", "Ext.menu.Menu", "Ext.menu.CheckItem", "Ext.menu.Separator"],
    border: true,
    alias: "widget.headercontainer",
    baseCls: Ext.baseCSSPrefix + "grid-header-ct",
    dock: "top",
    weight: 100,
    defaultType: "gridcolumn",
    detachOnRemove: false,
    defaultWidth: 100,
    sortAscText: "Sort Ascending",
    sortDescText: "Sort Descending",
    sortClearText: "Clear Sort",
    columnsText: "Columns",
    headerOpenCls: Ext.baseCSSPrefix + "column-header-open",
    triStateSort: false,
    ddLock: false,
    dragging: false,
    sortable: true,
    initComponent: function() {
        var a = this;
        a.headerCounter = 0;
        a.plugins = a.plugins || [];
        if (!a.isHeader) {
            if (a.enableColumnResize) {
                a.resizer = new Ext.grid.plugin.HeaderResizer();
                a.plugins.push(a.resizer)
            }
            if (a.enableColumnMove) {
                a.reorderer = new Ext.grid.plugin.HeaderReorderer();
                a.plugins.push(a.reorderer)
            }
        }
        if (a.isHeader && !a.items) {
            a.layout = a.layout || "auto"
        } else {
            a.layout = Ext.apply({
                type: "gridcolumn",
                align: "stretchmax"
            }, a.initialConfig.layout)
        }
        a.defaults = a.defaults || {};
        Ext.applyIf(a.defaults, {
            triStateSort: a.triStateSort,
            sortable: a.sortable
        });
        a.menuTask = new Ext.util.DelayedTask(a.updateMenuDisabledState, a);
        a.callParent();
        a.addEvents("columnresize", "headerclick", "headertriggerclick", "columnmove", "columnhide", "columnshow", "sortchange", "menucreate")
    },
    onDestroy: function() {
        var a = this;
        a.menuTask.cancel();
        Ext.destroy(a.resizer, a.reorderer);
        a.callParent()
    },
    applyColumnsState: function(g) {
        if (!g || !g.length) {
            return
        }
        var o = this,
            m = o.items.items,
            l = m.length,
            j = 0,
            d = g.length,
            n, e, a, k;
        for (n = 0; n < d; n++) {
            a = g[n];
            for (k = l; k--;) {
                e = m[k];
                if (e.getStateId && e.getStateId() == a.id) {
                    if (j !== k) {
                        o.moveHeader(k, j)
                    }
                    if (e.applyColumnState) {
                        e.applyColumnState(a)
                    }++j;
                    break
                }
            }
        }
    },
    getColumnsState: function() {
        var c = this,
            a = [],
            d;
        c.items.each(function(e) {
            d = e.getColumnState && e.getColumnState();
            if (d) {
                a.push(d)
            }
        });
        return a
    },
    onAdd: function(e) {
        var a = this,
            d = a.isHeader ? a.getOwnerHeaderCt() : a;
        if (!e.headerId) {
            e.headerId = e.initialConfig.id || Ext.id(null, "header-")
        }
        if (!e.stateId) {
            e.stateId = e.initialConfig.id || ("h" + (++a.headerCounter))
        }
        a.callParent(arguments);
        if (d) {
            d.purgeCache()
        }
    },
    onRemove: function(e) {
        var a = this,
            d = a.isHeader ? a.getOwnerHeaderCt() : a;
        a.callParent(arguments);
        if (d) {
            a.purgeCache()
        }
    },
    applyDefaults: function(c) {
        var a;
        if (c && !c.isComponent && c.xtype == "rownumberer") {
            a = c
        } else {
            a = this.callParent(arguments);
            if (!c.isGroupHeader && !("width" in a) && !a.flex) {
                a.width = this.defaultWidth
            }
        }
        return a
    },
    afterRender: function() {
        this.callParent();
        this.setSortState()
    },
    setSortState: function() {
        var a = this.up("[store]").store,
            d = a.getFirstSorter(),
            c;
        if (d) {
            c = this.down("gridcolumn[dataIndex=" + d.property + "]");
            if (c) {
                c.setSortState(d.direction, false, true)
            }
        } else {
            this.clearOtherSortStates(null)
        }
    },
    getHeaderMenu: function() {
        var c = this.getMenu(),
            a;
        if (c) {
            a = c.child("#columnItem");
            if (a) {
                return a.menu
            }
        }
        return null
    },
    onHeaderVisibilityChange: function(g, e) {
        var c = this,
            d = c.getHeaderMenu(),
            a;
        if (d) {
            a = c.getMenuItemForHeader(d, g);
            if (a) {
                a.setChecked(e, true)
            }
            c.menuTask.delay(50)
        }
    },
    getLeafMenuItems: function() {
        var k = this,
            e = k.getGridColumns(),
            c = [],
            d = 0,
            j = 0,
            a = e.length,
            l = k.getMenu(),
            g;
        for (; d < a; ++d) {
            g = e[d];
            if (g.hideable) {
                g = k.getMenuItemForHeader(l, g);
                if (g) {
                    c.push(g);
                    if (g.checked) {
                        ++j
                    }
                }
            } else {
                if (!g.hidden && !g.menuDisabled) {
                    ++j
                }
            }
        }
        return {
            items: c,
            checkedCount: j
        }
    },
    updateMenuDisabledState: function() {
        var k = this,
            c = k.getLeafMenuItems(),
            j = c.checkedCount,
            e = c.items,
            a = e.length,
            g = 0,
            d = k.getMenu().child("#columnItem");
        if (j <= 1) {
            k.disableMenuItems(d, Ext.ComponentQuery.query("[checked=true]", e)[0])
        } else {
            for (; g < a; ++g) {
                k.setMenuItemState(j, d, e[g])
            }
        }
    },
    disableMenuItems: function(a, c) {
        while (c && c != a) {
            c.disableCheckChange();
            c = c.parentMenu.ownerItem
        }
    },
    setMenuItemState: function(g, a, e) {
        var d, c;
        while (e && e != a) {
            d = e.parentMenu;
            c = e.parentMenu.query("[checked=true]:not([menu])").length;
            e.enableCheckChange();
            e = d.ownerItem;
            if (c === g) {
                break
            }
        }
        this.disableMenuItems(a, e)
    },
    getMenuItemForHeader: function(a, c) {
        return c ? a.down("menucheckitem[headerId=" + c.id + "]") : null
    },
    onHeaderShow: function(d) {
        var c = this,
            a = c.ownerCt;
        c.onHeaderVisibilityChange(d, true);
        if (!d.isGroupHeader) {
            if (a) {
                a.onHeaderShow(c, d)
            }
        }
        c.fireEvent("columnshow", c, d)
    },
    onHeaderHide: function(d) {
        var c = this,
            a = c.ownerCt;
        c.onHeaderVisibilityChange(d, false);
        if (!d.isGroupHeader) {
            if (a) {
                a.onHeaderHide(c, d)
            }
        }
        c.fireEvent("columnhide", c, d)
    },
    tempLock: function() {
        this.ddLock = true;
        Ext.Function.defer(function() {
            this.ddLock = false
        }, 200, this)
    },
    onHeaderResize: function(i, c, g) {
        var e = this,
            a = e.view,
            d = e.ownerCt;
        if (a && a.table.dom) {
            e.tempLock();
            if (d) {
                d.onHeaderResize(e, i, c)
            }
        }
        e.fireEvent("columnresize", this, i, c)
    },
    onHeaderClick: function(d, c, a) {
        d.fireEvent("headerclick", this, d, c, a);
        this.fireEvent("headerclick", this, d, c, a)
    },
    onHeaderTriggerClick: function(g, d, a) {
        var c = this;
        if (g.fireEvent("headertriggerclick", c, g, d, a) !== false && c.fireEvent("headertriggerclick", c, g, d, a) !== false) {
            c.showMenuBy(a, g)
        }
    },
    showMenuBy: function(c, i) {
        var e = this.getMenu(),
            g = e.down("#ascItem"),
            d = e.down("#descItem"),
            a;
        e.activeHeader = e.ownerCt = i;
        e.setFloatParent(i);
        i.titleEl.addCls(this.headerOpenCls);
        a = i.sortable ? "enable" : "disable";
        if (g) {
            g[a]()
        }
        if (d) {
            d[a]()
        }
        e.showBy(c)
    },
    onMenuDeactivate: function() {
        var a = this.getMenu();
        a.activeHeader.titleEl.removeCls(this.headerOpenCls)
    },
    moveHeader: function(a, c) {
        this.tempLock();
        this.onHeaderMoved(this.move(a, c), 1, a, c)
    },
    purgeCache: function() {
        var a = this;
        delete a.gridDataColumns;
        delete a.hideableColumns;
        if (a.menu) {
            a.menu.hide();
            a.menu.destroy();
            delete a.menu
        }
    },
    onHeaderMoved: function(i, a, d, g) {
        var e = this,
            c = e.ownerCt;
        if (c && c.onHeaderMove) {
            c.onHeaderMove(e, i, a, d, g)
        }
        e.fireEvent("columnmove", e, i, d, g)
    },
    getMenu: function() {
        var a = this;
        if (!a.menu) {
            a.menu = new Ext.menu.Menu({
                hideOnParentHide: false,
                items: a.getMenuItems(),
                listeners: {
                    deactivate: a.onMenuDeactivate,
                    scope: a
                }
            });
            a.updateMenuDisabledState();
            a.fireEvent("menucreate", a, a.menu)
        }
        return a.menu
    },
    getMenuItems: function() {
        var d = this,
            c = [],
            a = d.enableColumnHide ? d.getColumnMenu(d) : null;
        if (d.sortable) {
            c = [{
                itemId: "ascItem",
                text: d.sortAscText,
                cls: Ext.baseCSSPrefix + "hmenu-sort-asc",
                handler: d.onSortAscClick,
                scope: d
            }, {
                itemId: "descItem",
                text: d.sortDescText,
                cls: Ext.baseCSSPrefix + "hmenu-sort-desc",
                handler: d.onSortDescClick,
                scope: d
            }]
        }
        if (a && a.length) {
            c.push("-", {
                itemId: "columnItem",
                text: d.columnsText,
                cls: Ext.baseCSSPrefix + "cols-icon",
                menu: a
            })
        }
        return c
    },
    onSortAscClick: function() {
        var c = this.getMenu(),
            a = c.activeHeader;
        a.setSortState("ASC")
    },
    onSortDescClick: function() {
        var c = this.getMenu(),
            a = c.activeHeader;
        a.setSortState("DESC")
    },
    getColumnMenu: function(j) {
        var d = [],
            c = 0,
            g, a = j.query(">gridcolumn[hideable]"),
            k = a.length,
            e;
        for (; c < k; c++) {
            g = a[c];
            e = new Ext.menu.CheckItem({
                text: g.menuText || g.text,
                checked: !g.hidden,
                hideOnClick: false,
                headerId: g.id,
                menu: g.isGroupHeader ? this.getColumnMenu(g) : undefined,
                checkHandler: this.onColumnCheckChange,
                scope: this
            });
            d.push(e);
            g.on({
                destroy: Ext.Function.bind(e.destroy, e)
            })
        }
        return d
    },
    onColumnCheckChange: function(a, c) {
        var d = Ext.getCmp(a.headerId);
        d[c ? "show" : "hide"]()
    },
    getColumnsForTpl: function(g) {
        var d = [],
            e = this.getGridColumns(g),
            k = e.length,
            a = 0,
            j, c;
        for (; a < k; a++) {
            j = e[a];
            if (j.hidden || j.up("headercontainer[hidden=true]")) {
                c = 0
            } else {
                c = j.getDesiredWidth()
            }
            d.push({
                dataIndex: j.dataIndex,
                align: j.align,
                width: c,
                id: j.id,
                cls: j.tdCls,
                columnId: j.getItemId()
            })
        }
        return d
    },
    getColumnCount: function() {
        return this.getGridColumns().length
    },
    getFullWidth: function(e) {
        var d = 0,
            c = this.getVisibleGridColumns(e),
            j = c.length,
            a = 0,
            g;
        for (; a < j; a++) {
            g = c[a];
            if (g.getDesiredWidth) {
                d += g.getDesiredWidth() || 0
            } else {
                d += g.getWidth()
            }
        }
        return d
    },
    clearOtherSortStates: function(a) {
        var d = this.getGridColumns(),
            e = d.length,
            c = 0;
        for (; c < e; c++) {
            if (d[c] !== a) {
                d[c].setSortState(null, true)
            }
        }
    },
    getVisibleGridColumns: function(a) {
        return Ext.ComponentQuery.query(":not([hidden])", this.getGridColumns(a))
    },
    getGridColumns: function(c) {
        var d = this,
            a = c ? null : d.gridDataColumns;
        if (!a) {
            d.gridDataColumns = a = [];
            d.cascade(function(e) {
                if ((e !== d) && !e.isGroupHeader) {
                    a.push(e)
                }
            })
        }
        return a
    },
    getHideableColumns: function(c) {
        var d = this,
            a = c ? null : d.hideableColumns;
        if (!a) {
            a = d.hideableColumns = d.query("[hideable]")
        }
        return a
    },
    getHeaderIndex: function(a) {
        if (a.isGroupHeader) {
            a = a.down(":not([isgroupHeader])")
        }
        return Ext.Array.indexOf(this.getGridColumns(), a)
    },
    getHeaderAtIndex: function(a) {
        var c = this.getGridColumns();
        return c.length ? c[a] : null
    },
    getVisibleHeaderClosestToIndex: function(c) {
        var a = this.getHeaderAtIndex(c);
        if (a && a.hidden) {
            a = a.next(":not([hidden])") || a.prev(":not([hidden])")
        }
        return a
    },
    prepareData: function(k, d, m, p, a) {
        var o = this,
            j = {},
            e = o.gridDataColumns || o.getGridColumns(),
            g = e.length,
            i = 0,
            l, s, n, r, c, q = a.store;
        for (; i < g; i++) {
            c = {
                tdCls: "",
                style: ""
            };
            l = e[i];
            s = l.id;
            n = l.renderer;
            r = k[l.dataIndex];
            if (typeof n == "function") {
                r = n.call(l.scope || o.ownerCt, r, c, m, d, i, q, p)
            }
            if (o.markDirty) {
                j[s + "-modified"] = m.isModified(l.dataIndex) ? Ext.baseCSSPrefix + "grid-dirty-cell" : ""
            }
            j[s + "-tdCls"] = c.tdCls;
            j[s + "-tdAttr"] = c.tdAttr;
            j[s + "-style"] = c.style;
            if (typeof r === "undefined" || r === null || r === "") {
                r = l.emptyCellText
            }
            j[s] = r
        }
        return j
    },
    expandToFit: function(c) {
        var a = this.view;
        if (a) {
            a.expandToFit(c)
        }
    }
});
Ext.define("Ext.util.KeyNav", {
    alternateClassName: "Ext.KeyNav",
    requires: ["Ext.util.KeyMap"],
    statics: {
        keyOptions: {
            left: 37,
            right: 39,
            up: 38,
            down: 40,
            space: 32,
            pageUp: 33,
            pageDown: 34,
            del: 46,
            backspace: 8,
            home: 36,
            end: 35,
            enter: 13,
            esc: 27,
            tab: 9
        }
    },
    constructor: function(a) {
        var c = this;
        if (arguments.length === 2) {
            c.legacyConstructor.apply(c, arguments);
            return
        }
        c.setConfig(a)
    },
    legacyConstructor: function(c, a) {
        this.setConfig(Ext.apply({
            target: c
        }, a))
    },
    setConfig: function(c) {
        var g = this,
            d = {
                target: c.target,
                ignoreInputFields: c.ignoreInputFields,
                eventName: g.getKeyEvent("forceKeyDown" in c ? c.forceKeyDown : g.forceKeyDown, c.eventName)
            },
            i, a, k, e, j;
        if (g.map) {
            g.map.destroy()
        }
        if (c.processEvent) {
            d.processEvent = c.processEvent;
            d.processEventScope = c.processEventScope || g
        }
        i = g.map = new Ext.util.KeyMap(d);
        a = Ext.util.KeyNav.keyOptions;
        k = c.scope || g;
        for (e in a) {
            if (a.hasOwnProperty(e)) {
                if (j = c[e]) {
                    if (typeof j === "function") {
                        j = {
                            handler: j,
                            defaultAction: (c.defaultEventAction !== undefined) ? c.defaultEventAction : g.defaultEventAction
                        }
                    }
                    i.addBinding({
                        key: a[e],
                        handler: Ext.Function.bind(g.handleEvent, j.scope || k, j.handler || j.fn, true),
                        defaultEventAction: (j.defaultEventAction !== undefined) ? j.defaultAction : g.defaultEventAction
                    })
                }
            }
        }
        i.disable();
        if (!c.disabled) {
            i.enable()
        }
    },
    handleEvent: function(d, c, a) {
        return a.call(this, c)
    },
    disabled: false,
    defaultEventAction: "stopEvent",
    forceKeyDown: false,
    eventName: "keypress",
    destroy: function(a) {
        this.map.destroy(a);
        delete this.map
    },
    enable: function() {
        this.map.enable();
        this.disabled = false
    },
    disable: function() {
        this.map.disable();
        this.disabled = true
    },
    setDisabled: function(a) {
        this.map.setDisabled(a);
        this.disabled = a
    },
    getKeyEvent: function(c, a) {
        if (c || (Ext.EventManager.useKeyDown && !a)) {
            return "keydown"
        } else {
            return a || this.eventName
        }
    }
});
Ext.define("Ext.grid.column.Column", {
    extend: "Ext.grid.header.Container",
    alias: "widget.gridcolumn",
    requires: ["Ext.util.KeyNav", "Ext.grid.ColumnComponentLayout", "Ext.grid.ColumnLayout"],
    alternateClassName: "Ext.grid.Column",
    baseCls: Ext.baseCSSPrefix + "column-header " + Ext.baseCSSPrefix + "unselectable",
    hoverCls: Ext.baseCSSPrefix + "column-header-over",
    handleWidth: 5,
    sortState: null,
    possibleSortStates: ["ASC", "DESC"],
    childEls: ["titleEl", "triggerEl", "textEl"],
    renderTpl: '<div id="{id}-titleEl" {tipMarkup}class="' + Ext.baseCSSPrefix + 'column-header-inner"><span id="{id}-textEl" class="' + Ext.baseCSSPrefix + 'column-header-text">{text}</span><tpl if="!menuDisabled"><div id="{id}-triggerEl" class="' + Ext.baseCSSPrefix + 'column-header-trigger"></div></tpl></div>{%this.renderContainer(out,values)%}',
    dataIndex: null,
    text: "&#160;",
    menuText: null,
    emptyCellText: "&#160;",
    sortable: true,
    resizable: true,
    hideable: true,
    menuDisabled: false,
    renderer: false,
    editRenderer: false,
    align: "left",
    draggable: true,
    tooltipType: "qtip",
    initDraggable: Ext.emptyFn,
    isHeader: true,
    componentLayout: "columncomponent",
    initResizable: Ext.emptyFn,
    initComponent: function() {
        var a = this,
            c;
        if (Ext.isDefined(a.header)) {
            a.text = a.header;
            delete a.header
        }
        if (!a.triStateSort) {
            a.possibleSortStates.length = 2
        }
        if (Ext.isDefined(a.columns)) {
            a.isGroupHeader = true;
            a.items = a.columns;
            delete a.columns;
            delete a.flex;
            delete a.width;
            a.cls = (a.cls || "") + " " + Ext.baseCSSPrefix + "group-header";
            a.sortable = false;
            a.resizable = false;
            a.align = "center"
        } else {
            a.isContainer = false;
            if (a.flex) {
                a.minWidth = a.minWidth || Ext.grid.plugin.HeaderResizer.prototype.minColWidth
            }
        }
        a.addCls(Ext.baseCSSPrefix + "column-header-align-" + a.align);
        c = a.renderer;
        if (c) {
            if (typeof c == "string") {
                a.renderer = Ext.util.Format[c]
            }
            a.hasCustomRenderer = true
        } else {
            if (a.defaultRenderer) {
                a.scope = a;
                a.renderer = a.defaultRenderer
            }
        }
        a.callParent(arguments);
        a.on({
            element: "el",
            click: a.onElClick,
            dblclick: a.onElDblClick,
            scope: a
        });
        a.on({
            element: "titleEl",
            mouseenter: a.onTitleMouseOver,
            mouseleave: a.onTitleMouseOut,
            scope: a
        })
    },
    onAdd: function(a) {
        a.isSubHeader = true;
        a.addCls(Ext.baseCSSPrefix + "group-sub-header");
        this.callParent(arguments)
    },
    onRemove: function(a) {
        a.isSubHeader = false;
        a.removeCls(Ext.baseCSSPrefix + "group-sub-header");
        this.callParent(arguments)
    },
    initRenderData: function() {
        var c = this,
            e = "",
            d = c.tooltip,
            a = c.tooltipType == "qtip" ? "data-qtip" : "title";
        if (!Ext.isEmpty(d)) {
            e = a + '="' + d + '" '
        }
        return Ext.applyIf(c.callParent(arguments), {
            text: c.text,
            menuDisabled: c.menuDisabled,
            tipMarkup: e
        })
    },
    applyColumnState: function(c) {
        var a = this,
            d = Ext.isDefined;
        a.applyColumnsState(c.columns);
        if (d(c.hidden)) {
            a.hidden = c.hidden
        }
        if (d(c.locked)) {
            a.locked = c.locked
        }
        if (d(c.sortable)) {
            a.sortable = c.sortable
        }
        if (d(c.width)) {
            delete a.flex;
            a.width = c.width
        } else {
            if (d(c.flex)) {
                delete a.width;
                a.flex = c.flex
            }
        }
    },
    getColumnState: function() {
        var g = this,
            c = g.items.items,
            a = c ? c.length : 0,
            e, d = [],
            j = {
                id: g.getStateId()
            };
        g.savePropsToState(["hidden", "sortable", "locked", "flex", "width"], j);
        if (g.isGroupHeader) {
            for (e = 0; e < a; e++) {
                d.push(c[e].getColumnState())
            }
            if (d.length) {
                j.columns = d
            }
        } else {
            if (g.isSubHeader && g.ownerCt.hidden) {
                delete g.hidden
            }
        }
        if ("width" in j) {
            delete j.flex
        }
        return j
    },
    getStateId: function() {
        return this.stateId || this.headerId
    },
    setText: function(a) {
        this.text = a;
        if (this.rendered) {
            this.textEl.update(a)
        }
    },
    getOwnerHeaderCt: function() {
        return this.up(":not([isHeader])")
    },
    getIndex: function() {
        return this.isGroupColumn ? false : this.getOwnerHeaderCt().getHeaderIndex(this)
    },
    getVisibleIndex: function() {
        return this.isGroupColumn ? false : Ext.Array.indexOf(this.getOwnerHeaderCt().getVisibleGridColumns(), this)
    },
    beforeRender: function() {
        var c = this,
            a = c.up("tablepanel");
        c.callParent();
        if (a && (!c.sortable || a.sortableColumns === false) && !c.groupable && !c.lockable && (a.enableColumnHide === false || !c.getOwnerHeaderCt().getHideableColumns().length)) {
            c.menuDisabled = true
        }
    },
    afterRender: function() {
        var c = this,
            a = c.el;
        c.callParent(arguments);
        if (c.overCls) {
            a.addClsOnOver(c.overCls)
        }
        if (!Ext.isIE8 || !Ext.isStrict) {
            c.mon(c.getFocusEl(), {
                focus: c.onTitleMouseOver,
                blur: c.onTitleMouseOut,
                scope: c
            })
        }
        c.keyNav = new Ext.util.KeyNav(a, {
            enter: c.onEnterKey,
            down: c.onDownKey,
            scope: c
        })
    },
    afterComponentLayout: function(e, a, d, i) {
        var g = this,
            c = g.getOwnerHeaderCt();
        g.callParent(arguments);
        if (c && (d != null || g.flex) && e !== d) {
            c.onHeaderResize(g, e, true)
        }
    },
    setPadding: function(a) {
        var g = this,
            e = parseInt(g.textEl.getStyle("line-height"), 10),
            j = g.textEl.dom.offsetHeight,
            c = g.titleEl,
            i = a - g.el.getBorderWidth("tb"),
            d;
        if (!g.isGroupHeader) {
            if (c.getHeight() < i) {
                c.setHeight(i);
                g.ownerCt.layout.innerCt.setHeight(a)
            }
        }
        d = c.getViewSize().height;
        if (j) {
            if (e) {
                j = Math.ceil(j / e) * e
            }
            c.setStyle({
                paddingTop: Math.floor(Math.max(((d - j) / 2), 0)) + "px"
            })
        }
        if (Ext.isIE && g.triggerEl) {
            g.triggerEl.setHeight(d)
        }
    },
    onDestroy: function() {
        var a = this;
        Ext.destroy(a.textEl, a.keyNav, a.field);
        delete a.keyNav;
        a.callParent(arguments)
    },
    onTitleMouseOver: function() {
        this.titleEl.addCls(this.hoverCls)
    },
    onTitleMouseOut: function() {
        this.titleEl.removeCls(this.hoverCls)
    },
    onDownKey: function(a) {
        if (this.triggerEl) {
            this.onElClick(a, this.triggerEl.dom || this.el.dom)
        }
    },
    onEnterKey: function(a) {
        this.onElClick(a, this.el.dom)
    },
    onElDblClick: function(g, a) {
        var d = this,
            c = d.ownerCt;
        if (c && Ext.Array.indexOf(c.items, d) !== 0 && d.isOnLeftEdge(g)) {
            c.expandToFit(d.previousSibling("gridcolumn"))
        }
    },
    onElClick: function(g, c) {
        var d = this,
            a = d.getOwnerHeaderCt();
        if (a && !a.ddLock) {
            if (d.triggerEl && (g.target === d.triggerEl.dom || c === d.triggerEl.dom || g.within(d.triggerEl))) {
                a.onHeaderTriggerClick(d, g, c)
            } else {
                if (g.getKey() || (!d.isOnLeftEdge(g) && !d.isOnRightEdge(g))) {
                    d.toggleSortState();
                    a.onHeaderClick(d, g, c)
                }
            }
        }
    },
    processEvent: function(i, c, a, d, g, j) {
        return this.fireEvent.apply(this, arguments)
    },
    toggleSortState: function() {
        var c = this,
            a, d;
        if (c.sortable) {
            a = Ext.Array.indexOf(c.possibleSortStates, c.sortState);
            d = (a + 1) % c.possibleSortStates.length;
            c.setSortState(c.possibleSortStates[d])
        }
    },
    doSort: function(c) {
        var a = this.up("tablepanel").store;
        a.sort({
            property: this.getSortParam(),
            direction: c
        })
    },
    getSortParam: function() {
        return this.dataIndex
    },
    setSortState: function(a, m, i) {
        var j = this,
            k = Ext.baseCSSPrefix + "column-header-sort-",
            l = k + "ASC",
            d = k + "DESC",
            c = k + "null",
            g = j.getOwnerHeaderCt(),
            e = j.sortState;
        if (e !== a && j.getSortParam()) {
            j.addCls(k + a);
            if (a && !i) {
                j.doSort(a)
            }
            switch (a) {
                case "DESC":
                    j.removeCls([l, c]);
                    break;
                case "ASC":
                    j.removeCls([d, c]);
                    break;
                case null:
                    j.removeCls([l, d]);
                    break
            }
            if (g && !j.triStateSort && !m) {
                g.clearOtherSortStates(j)
            }
            j.sortState = a;
            if (j.triStateSort || a != null) {
                g.fireEvent("sortchange", g, j, a)
            }
        }
    },
    hide: function(d) {
        var l = this,
            g = l.getOwnerHeaderCt(),
            c = l.ownerCt,
            a = c.isGroupHeader,
            m, k, j, e;
        if (a && !d) {
            k = c.query(">:not([hidden])");
            if (k.length === 1 && k[0] == l) {
                l.ownerCt.hide();
                return
            }
        }
        Ext.suspendLayouts();
        if (l.isGroupHeader) {
            k = l.items.items;
            for (e = 0, j = k.length; e < j; e++) {
                m = k[e];
                if (!m.hidden) {
                    m.hide(true)
                }
            }
        }
        l.callParent();
        g.onHeaderHide(l);
        Ext.resumeLayouts(true)
    },
    show: function(e, c) {
        var l = this,
            j = l.ownerCt,
            d, a, g, k;
        Ext.suspendLayouts();
        if (l.isSubHeader && j.hidden) {
            j.show(false, true)
        }
        l.callParent(arguments);
        if (l.isGroupHeader && c !== true && !l.query(":not([hidden])").length) {
            d = l.query(">*");
            for (g = 0, a = d.length; g < a; g++) {
                k = d[g];
                if (k.hidden) {
                    k.show(true)
                }
            }
        }
        Ext.resumeLayouts(true);
        j = l.getOwnerHeaderCt();
        if (j) {
            j.onHeaderShow(l)
        }
    },
    getDesiredWidth: function() {
        var a = this;
        if (a.rendered && a.componentLayout && a.componentLayout.lastComponentSize) {
            return a.componentLayout.lastComponentSize.width
        } else {
            if (a.flex) {
                return a.width
            } else {
                return a.width
            }
        }
    },
    getCellSelector: function() {
        return "." + Ext.baseCSSPrefix + "grid-cell-" + this.getItemId()
    },
    getCellInnerSelector: function() {
        return this.getCellSelector() + " ." + Ext.baseCSSPrefix + "grid-cell-inner"
    },
    isOnLeftEdge: function(a) {
        return (a.getXY()[0] - this.el.getLeft() <= this.handleWidth)
    },
    isOnRightEdge: function(a) {
        return (this.el.getRight() - a.getXY()[0] <= this.handleWidth)
    }
});
Ext.define("Ext.tree.Column", {
    extend: "Ext.grid.column.Column",
    alias: "widget.treecolumn",
    tdCls: Ext.baseCSSPrefix + "grid-cell-treecolumn",
    treePrefix: Ext.baseCSSPrefix + "tree-",
    elbowPrefix: Ext.baseCSSPrefix + "tree-elbow-",
    expanderCls: Ext.baseCSSPrefix + "tree-expander",
    imgText: '<img src="{1}" class="{0}" />',
    checkboxText: '<input type="button" role="checkbox" class="{0}" {1} />',
    initComponent: function() {
        var a = this;
        a.origRenderer = a.renderer || a.defaultRenderer;
        a.origScope = a.scope || window;
        a.renderer = a.treeRenderer;
        a.scope = a;
        a.callParent()
    },
    treeRenderer: function(n, p, d, c, m, g, l) {
        var u = this,
            t = [],
            r = Ext.String.format,
            x = d.getDepth(),
            s = u.treePrefix,
            e = u.elbowPrefix,
            o = u.expanderCls,
            k = u.imgText,
            y = u.checkboxText,
            j = u.origRenderer.apply(u.origScope, arguments),
            i = Ext.BLANK_IMAGE_URL,
            q = d.get("href"),
            v = d.get("hrefTarget"),
            a = d.get("cls");
        while (d) {
            if (!d.isRoot() || (d.isRoot() && l.rootVisible)) {
                if (d.getDepth() === x) {
                    t.unshift(r(k, s + "icon " + s + "icon" + (d.get("icon") ? "-inline " : (d.isLeaf() ? "-leaf " : "-parent ")) + (d.get("iconCls") || ""), d.get("icon") || i));
                    if (d.get("checked") !== null) {
                        t.unshift(r(y, (s + "checkbox") + (d.get("checked") ? " " + s + "checkbox-checked" : ""), d.get("checked") ? 'aria-checked="true"' : ""));
                        if (d.get("checked")) {
                            p.tdCls += (" " + s + "checked")
                        }
                    }
                    if (d.isLast()) {
                        if (d.isExpandable()) {
                            t.unshift(r(k, (e + "end-plus " + o), i))
                        } else {
                            t.unshift(r(k, (e + "end"), i))
                        }
                    } else {
                        if (d.isExpandable()) {
                            t.unshift(r(k, (e + "plus " + o), i))
                        } else {
                            t.unshift(r(k, (s + "elbow"), i))
                        }
                    }
                } else {
                    if (d.isLast() || d.getDepth() === 0) {
                        t.unshift(r(k, (e + "empty"), i))
                    } else {
                        if (d.getDepth() !== 0) {
                            t.unshift(r(k, (e + "line"), i))
                        }
                    }
                }
            }
            d = d.parentNode
        }
        if (q) {
            t.push('<a href="', q, '" target="', v, '">', j, "</a>")
        } else {
            t.push(j)
        }
        if (a) {
            p.tdCls += " " + a
        }
        return t.join("")
    },
    defaultRenderer: function(a) {
        return a
    }
});
Ext.define("Ext.grid.column.Date", {
    extend: "Ext.grid.column.Column",
    alias: ["widget.datecolumn"],
    requires: ["Ext.Date"],
    alternateClassName: "Ext.grid.DateColumn",
    initComponent: function() {
        if (!this.format) {
            this.format = Ext.Date.defaultFormat
        }
        this.callParent(arguments)
    },
    defaultRenderer: function(a) {
        return Ext.util.Format.date(a, this.format)
    }
});
Ext.define("Ext.panel.Table", {
    extend: "Ext.panel.Panel",
    alias: "widget.tablepanel",
    uses: ["Ext.selection.RowModel", "Ext.selection.CellModel", "Ext.selection.CheckboxModel", "Ext.grid.PagingScroller", "Ext.grid.header.Container", "Ext.grid.Lockable"],
    extraBaseCls: Ext.baseCSSPrefix + "grid",
    extraBodyCls: Ext.baseCSSPrefix + "grid-body",
    layout: "fit",
    hasView: false,
    viewType: null,
    selType: "rowmodel",
    scroll: true,
    deferRowRender: true,
    sortableColumns: true,
    enableLocking: false,
    scrollerOwner: true,
    enableColumnMove: true,
    sealedColumns: false,
    enableColumnResize: true,
    enableColumnHide: true,
    rowLines: true,
    initComponent: function() {
        var k = this,
            m = k.scroll,
            c = false,
            a = false,
            j = k.columns || k.colModel,
            l, d = k.border,
            e, g;
        if (k.columnLines) {
            k.addCls(Ext.baseCSSPrefix + "grid-with-col-lines")
        }
        if (k.rowLines) {
            k.addCls(Ext.baseCSSPrefix + "grid-with-row-lines")
        }
        k.store = Ext.data.StoreManager.lookup(k.store || "ext-empty-store");
        if (j instanceof Ext.grid.header.Container) {
            k.headerCt = j;
            k.headerCt.border = d;
            k.columns = k.headerCt.items.items
        } else {
            if (Ext.isArray(j)) {
                j = {
                    items: j,
                    border: d
                }
            }
            Ext.apply(j, {
                forceFit: k.forceFit,
                sortable: k.sortableColumns,
                enableColumnMove: k.enableColumnMove,
                enableColumnResize: k.enableColumnResize,
                enableColumnHide: k.enableColumnHide,
                border: d,
                sealed: k.sealedColumns
            });
            k.columns = j.items;
            if (k.enableLocking || Ext.ComponentQuery.query("{locked !== undefined}{processed != true}", k.columns).length) {
                k.self.mixin("lockable", Ext.grid.Lockable);
                k.injectLockable()
            }
        }
        k.scrollTask = new Ext.util.DelayedTask(k.syncHorizontalScroll, k);
        k.addEvents("reconfigure", "viewready");
        k.bodyCls = k.bodyCls || "";
        k.bodyCls += (" " + k.extraBodyCls);
        k.cls = k.cls || "";
        k.cls += (" " + k.extraBaseCls);
        delete k.autoScroll;
        if (!k.hasView) {
            if (!k.headerCt) {
                k.headerCt = new Ext.grid.header.Container(j)
            }
            k.columns = k.headerCt.items.items;
            if (k.store.buffered && !k.store.remoteSort) {
                for (e = 0, g = k.columns.length; e < g; e++) {
                    k.columns[e].sortable = false
                }
            }
            if (k.hideHeaders) {
                k.headerCt.height = 0;
                k.headerCt.addCls(Ext.baseCSSPrefix + "grid-header-ct-hidden");
                k.addCls(Ext.baseCSSPrefix + "grid-header-hidden");
                if (Ext.isIEQuirks) {
                    k.headerCt.style = {
                        display: "none"
                    }
                }
            }
            if (m === true || m === "both") {
                c = a = true
            } else {
                if (m === "horizontal") {
                    a = true
                } else {
                    if (m === "vertical") {
                        c = true
                    }
                }
            }
            k.relayHeaderCtEvents(k.headerCt);
            k.features = k.features || [];
            if (!Ext.isArray(k.features)) {
                k.features = [k.features]
            }
            k.dockedItems = [].concat(k.dockedItems || []);
            k.dockedItems.unshift(k.headerCt);
            k.viewConfig = k.viewConfig || {};
            if (k.store && k.store.buffered) {
                k.viewConfig.preserveScrollOnRefresh = true
            } else {
                if (k.invalidateScrollerOnRefresh !== undefined) {
                    k.viewConfig.preserveScrollOnRefresh = !k.invalidateScrollerOnRefresh
                }
            }
            l = k.getView();
            k.items = [l];
            k.hasView = true;
            if (c) {
                if (k.store.buffered) {
                    k.verticalScroller = new Ext.grid.PagingScroller(Ext.apply({
                        panel: k,
                        store: k.store,
                        view: k.view
                    }, k.verticalScroller))
                }
            }
            if (a) {
                if (!k.hideHeaders) {
                    l.on({
                        scroll: {
                            fn: k.onHorizontalScroll,
                            element: "el",
                            scope: k
                        }
                    })
                }
            }
            k.mon(l.store, {
                load: k.onStoreLoad,
                scope: k
            });
            k.mon(l, {
                viewready: k.onViewReady,
                refresh: k.onRestoreHorzScroll,
                scope: k
            })
        }
        this.relayEvents(k.view, ["beforeitemmousedown", "beforeitemmouseup", "beforeitemmouseenter", "beforeitemmouseleave", "beforeitemclick", "beforeitemdblclick", "beforeitemcontextmenu", "itemmousedown", "itemmouseup", "itemmouseenter", "itemmouseleave", "itemclick", "itemdblclick", "itemcontextmenu", "beforecontainermousedown", "beforecontainermouseup", "beforecontainermouseover", "beforecontainermouseout", "beforecontainerclick", "beforecontainerdblclick", "beforecontainercontextmenu", "containermouseup", "containermouseover", "containermouseout", "containerclick", "containerdblclick", "containercontextmenu", "selectionchange", "beforeselect", "select", "beforedeselect", "deselect"]);
        k.callParent(arguments);
        k.addStateEvents(["columnresize", "columnmove", "columnhide", "columnshow", "sortchange"]);
        if (k.headerCt) {
            k.headerCt.on("afterlayout", k.onRestoreHorzScroll, k)
        }
    },
    relayHeaderCtEvents: function(a) {
        this.relayEvents(a, ["columnresize", "columnmove", "columnhide", "columnshow", "sortchange"])
    },
    getState: function() {
        var a = this,
            c = a.callParent(),
            d = a.store.sorters.first();
        c = a.addPropertyToState(c, "columns", (a.headerCt || a).getColumnsState());
        if (d) {
            c = a.addPropertyToState(c, "sort", {
                property: d.property,
                direction: d.direction,
                root: d.root
            })
        }
        return c
    },
    applyState: function(e) {
        var d = this,
            g = e.sort,
            a = d.store,
            c = e.columns;
        delete e.columns;
        d.callParent(arguments);
        if (c) {
            (d.headerCt || d).applyColumnsState(c)
        }
        if (g) {
            if (a.remoteSort) {
                a.sort({
                    property: g.property,
                    direction: g.direction,
                    root: g.root
                }, null, false)
            } else {
                a.sort(g.property, g.direction)
            }
        }
    },
    getStore: function() {
        return this.store
    },
    getView: function() {
        var a = this,
            c;
        if (!a.view) {
            c = a.getSelectionModel();
            a.view = Ext.widget(Ext.apply({}, a.viewConfig, {
                grid: a,
                deferInitialRefresh: a.deferRowRender !== false,
                scroll: a.scroll,
                xtype: a.viewType,
                store: a.store,
                headerCt: a.headerCt,
                selModel: c,
                features: a.features,
                panel: a,
                emptyText: a.emptyText ? '<div class="' + Ext.baseCSSPrefix + 'grid-empty">' + a.emptyText + "</div>" : ""
            }));
            a.view.getComponentLayout().headerCt = a.headerCt;
            a.mon(a.view, {
                uievent: a.processEvent,
                scope: a
            });
            c.view = a.view;
            a.headerCt.view = a.view;
            a.relayEvents(a.view, ["cellclick", "celldblclick"])
        }
        return a.view
    },
    setAutoScroll: Ext.emptyFn,
    processEvent: function(i, c, a, d, g, k) {
        var j = this,
            l;
        if (g !== -1) {
            l = j.headerCt.getGridColumns()[g];
            return l.processEvent.apply(l, arguments)
        }
    },
    determineScrollbars: function() {},
    invalidateScroller: function() {},
    scrollByDeltaY: function(c, a) {
        this.getView().scrollBy(0, c, a)
    },
    scrollByDeltaX: function(c, a) {
        this.getView().scrollBy(c, 0, a)
    },
    afterCollapse: function() {
        var a = this;
        a.saveScrollPos();
        a.saveScrollPos();
        a.callParent(arguments)
    },
    afterExpand: function() {
        var a = this;
        a.callParent(arguments);
        a.restoreScrollPos();
        a.restoreScrollPos()
    },
    saveScrollPos: Ext.emptyFn,
    restoreScrollPos: Ext.emptyFn,
    onHeaderResize: function() {
        this.delayScroll()
    },
    onHeaderMove: function(g, i, a, c, e) {
        var d = this;
        if (d.optimizedColumnMove === false) {
            d.view.refresh()
        } else {
            d.view.moveColumn(c, e, a)
        }
        d.delayScroll()
    },
    onHeaderHide: function(a, c) {
        this.delayScroll()
    },
    onHeaderShow: function(a, c) {
        this.delayScroll()
    },
    delayScroll: function() {
        var a = this.getScrollTarget().el;
        if (a) {
            this.scrollTask.delay(10, null, null, [a.dom.scrollLeft])
        }
    },
    onViewReady: function() {
        this.fireEvent("viewready", this)
    },
    onRestoreHorzScroll: function() {
        var a = this.scrollLeftPos;
        if (a) {
            this.syncHorizontalScroll(a, true)
        }
    },
    getScrollerOwner: function() {
        var a = this;
        if (!this.scrollerOwner) {
            a = this.up("[scrollerOwner]")
        }
        return a
    },
    getLhsMarker: function() {
        var a = this;
        return a.lhsMarker || (a.lhsMarker = Ext.DomHelper.append(a.el, {
            cls: Ext.baseCSSPrefix + "grid-resize-marker"
        }, true))
    },
    getRhsMarker: function() {
        var a = this;
        return a.rhsMarker || (a.rhsMarker = Ext.DomHelper.append(a.el, {
            cls: Ext.baseCSSPrefix + "grid-resize-marker"
        }, true))
    },
    getSelectionModel: function() {
        if (!this.selModel) {
            this.selModel = {}
        }
        var c = "SINGLE",
            a;
        if (this.simpleSelect) {
            c = "SIMPLE"
        } else {
            if (this.multiSelect) {
                c = "MULTI"
            }
        }
        Ext.applyIf(this.selModel, {
            allowDeselect: this.allowDeselect,
            mode: c
        });
        if (!this.selModel.events) {
            a = this.selModel.selType || this.selType;
            this.selModel = Ext.create("selection." + a, this.selModel)
        }
        if (!this.selModel.hasRelaySetup) {
            this.relayEvents(this.selModel, ["selectionchange", "beforeselect", "beforedeselect", "select", "deselect"]);
            this.selModel.hasRelaySetup = true
        }
        if (this.disableSelection) {
            this.selModel.locked = true
        }
        return this.selModel
    },
    getScrollTarget: function() {
        var a = this.getScrollerOwner(),
            c = a.query("tableview");
        return c[1] || c[0]
    },
    onHorizontalScroll: function(a, c) {
        this.syncHorizontalScroll(c.scrollLeft)
    },
    syncHorizontalScroll: function(e, c) {
        var d = this,
            a;
        c = c === true;
        if (d.rendered && (c || e !== d.scrollLeftPos)) {
            if (c) {
                a = d.getScrollTarget();
                a.el.dom.scrollLeft = e
            }
            d.headerCt.el.dom.scrollLeft = e;
            d.scrollLeftPos = e
        }
    },
    onStoreLoad: Ext.emptyFn,
    getEditorParent: function() {
        return this.body
    },
    bindStore: function(a) {
        var c = this;
        c.store = a;
        c.getView().bindStore(a)
    },
    beforeDestroy: function() {
        Ext.destroy(this.verticalScroller);
        this.callParent()
    },
    reconfigure: function(a, c) {
        var d = this,
            e = d.headerCt;
        if (d.lockable) {
            d.reconfigureLockable(a, c)
        } else {
            Ext.suspendLayouts();
            if (c) {
                delete d.scrollLeftPos;
                e.removeAll();
                e.add(c)
            }
            if (a) {
                a = Ext.StoreManager.lookup(a);
                d.bindStore(a)
            } else {
                d.getView().refresh()
            }
            e.setSortState();
            Ext.resumeLayouts(true)
        }
        d.fireEvent("reconfigure", d, a, c)
    }
});
Ext.define("Ext.view.TableLayout", {
    extend: "Ext.layout.component.Auto",
    alias: ["layout.tableview"],
    type: "tableview",
    beginLayout: function(c) {
        var a = this;
        a.callParent(arguments);
        if (a.owner.table.dom) {
            c.tableContext = c.getEl(a.owner.table);
            c.headerContext = c.context.getCmp(a.headerCt)
        }
    },
    calculate: function(c) {
        var a = this;
        a.callParent(arguments);
        if (c.tableContext) {
            if (c.state.columnWidthsSynced) {
                if (c.hasProp("columnWidthsFlushed")) {
                    c.tableContext.setHeight(c.tableContext.el.dom.offsetHeight, false)
                } else {
                    a.done = false
                }
            } else {
                if (c.headerContext.hasProp("columnWidthsDone")) {
                    c.context.queueFlush(a);
                    c.state.columnWidthsSynced = true
                }
                a.done = false
            }
        }
    },
    measureContentHeight: function(a) {
        if (!a.headerContext || a.hasProp("columnWidthsFlushed")) {
            return this.callParent(arguments)
        }
    },
    flush: function() {
        var l = this,
            g = l.ownerContext.context,
            e = l.headerCt.getGridColumns(),
            d = 0,
            c = e.length,
            k = l.owner.el,
            a = 0,
            j;
        g.currentLayout = l;
        for (d = 0; d < c; d++) {
            j = e[d].hidden ? 0 : g.getCmp(e[d]).props.width;
            a += j;
            k.select(l.getColumnSelector(e[d])).setWidth(j)
        }
        k.select("table." + Ext.baseCSSPrefix + "grid-table-resizer").setWidth(a);
        l.ownerContext.setProp("columnWidthsFlushed", true)
    },
    finishedLayout: function() {
        var a = this,
            c;
        a.callParent(arguments);
        if (Ext.isGecko) {
            c = a.headerCt.getGridColumns()[0];
            if (c) {
                c = a.owner.el.down(a.getColumnSelector(c));
                if (c) {
                    c.setStyle("display", "none");
                    c.dom.scrollWidth;
                    c.setStyle("display", "")
                }
            }
        }
    },
    getColumnSelector: function(a) {
        return "th." + Ext.baseCSSPrefix + "grid-col-resizer-" + a.id
    }
});
Ext.define("Ext.util.Bindable", {
    bindStore: function(a, c) {
        var d = this,
            e = d.store;
        if (!c && d.store) {
            d.onUnbindStore(e, c);
            if (a !== e && e.autoDestroy) {
                e.destroyStore()
            } else {
                d.unbindStoreListeners(e)
            }
        }
        if (a) {
            a = Ext.data.StoreManager.lookup(a);
            d.bindStoreListeners(a);
            d.onBindStore(a, c)
        }
        d.store = a || null;
        return d
    },
    getStore: function() {
        return this.store
    },
    unbindStoreListeners: function(a) {
        var c = this.storeListeners;
        if (c) {
            a.un(c)
        }
    },
    bindStoreListeners: function(a) {
        var d = this,
            c = Ext.apply({}, d.getStoreListeners());
        if (!c.scope) {
            c.scope = d
        }
        d.storeListeners = c;
        a.on(c)
    },
    getStoreListeners: Ext.emptyFn,
    onUnbindStore: Ext.emptyFn,
    onBindStore: Ext.emptyFn
});
Ext.define("Ext.LoadMask", {
    extend: "Ext.Component",
    alias: "widget.loadmask",
    mixins: {
        floating: "Ext.util.Floating",
        bindable: "Ext.util.Bindable"
    },
    uses: ["Ext.data.StoreManager"],
    msg: "Loading...",
    msgCls: Ext.baseCSSPrefix + "mask-loading",
    maskCls: Ext.baseCSSPrefix + "mask",
    useMsg: true,
    useTargetEl: false,
    baseCls: Ext.baseCSSPrefix + "mask-msg",
    childEls: ["msgEl"],
    renderTpl: '<div id="{id}-msgEl" style="position:relative" class="{[values.$comp.msgCls]}"></div>',
    floating: {
        shadow: "frame"
    },
    focusOnToFront: false,
    bringParentToFront: false,
    constructor: function(a, c) {
        var d = this;
        if (!a.isComponent) {
            a = Ext.get(a);
            this.isElement = true
        }
        d.ownerCt = a;
        if (!this.isElement) {
            d.bindComponent(a)
        }
        d.callParent([c]);
        if (d.store) {
            d.bindStore(d.store, true)
        }
    },
    bindComponent: function(a) {
        var d = this,
            c = {
                scope: this,
                resize: d.sizeMask,
                added: d.onComponentAdded,
                removed: d.onComponentRemoved
            },
            e = Ext.container.Container.hierarchyEventSource;
        if (a.floating) {
            c.move = d.sizeMask;
            d.activeOwner = a
        } else {
            if (a.ownerCt) {
                d.onComponentAdded(a.ownerCt)
            } else {
                d.preventBringToFront = true
            }
        }
        d.mon(a, c);
        d.mon(e, {
            show: d.onContainerShow,
            hide: d.onContainerHide,
            expand: d.onContainerExpand,
            collapse: d.onContainerCollapse,
            scope: d
        })
    },
    onComponentAdded: function(a) {
        var c = this;
        delete c.activeOwner;
        c.floatParent = a;
        if (!a.floating) {
            a = a.up("[floating]")
        }
        if (a) {
            c.activeOwner = a;
            c.mon(a, "move", c.sizeMask, c)
        }
        a = c.floatParent.ownerCt;
        if (c.rendered && c.isVisible() && a) {
            c.floatOwner = a;
            c.mon(a, "afterlayout", c.sizeMask, c, {
                single: true
            })
        }
    },
    onComponentRemoved: function(a) {
        var d = this,
            e = d.activeOwner,
            c = d.floatOwner;
        if (e) {
            d.mun(e, "move", d.sizeMask, d)
        }
        if (c) {
            d.mun(c, "afterlayout", d.sizeMask, d)
        }
        delete d.activeOwner;
        delete d.floatOwner
    },
    afterRender: function() {
        this.callParent(arguments);
        this.container = this.floatParent.getContentTarget()
    },
    onContainerShow: function(a) {
        if (this.isActiveContainer(a)) {
            this.onComponentShow()
        }
    },
    onContainerHide: function(a) {
        if (this.isActiveContainer(a)) {
            this.onComponentHide()
        }
    },
    onContainerExpand: function(a) {
        if (this.isActiveContainer(a)) {
            this.onComponentShow()
        }
    },
    onContainerCollapse: function(a) {
        if (this.isActiveContainer(a)) {
            this.onComponentHide()
        }
    },
    isActiveContainer: function(a) {
        return this.isDescendantOf(a)
    },
    onComponentHide: function() {
        var a = this;
        if (a.rendered && a.isVisible()) {
            a.hide();
            a.showNext = true
        }
    },
    onComponentShow: function() {
        if (this.showNext) {
            this.show()
        }
        delete this.showNext
    },
    sizeMask: function() {
        var a = this,
            c;
        if (a.rendered && a.isVisible()) {
            a.center();
            c = a.getMaskTarget();
            a.getMaskEl().show().setSize(c.getSize()).alignTo(c, "tl-tl")
        }
    },
    bindStore: function(a, c) {
        var d = this;
        d.mixins.bindable.bindStore.apply(d, arguments);
        a = d.store;
        if (a && a.isLoading()) {
            d.onBeforeLoad()
        }
    },
    getStoreListeners: function() {
        return {
            beforeload: this.onBeforeLoad,
            load: this.onLoad,
            exception: this.onLoad,
            cachemiss: this.onBeforeLoad,
            cachefilled: this.onLoad
        }
    },
    onDisable: function() {
        this.callParent(arguments);
        if (this.loading) {
            this.onLoad()
        }
    },
    getOwner: function() {
        return this.ownerCt || this.floatParent
    },
    getMaskTarget: function() {
        var a = this.getOwner();
        return this.useTargetEl ? a.getTargetEl() : a.getEl()
    },
    onBeforeLoad: function() {
        var d = this,
            a = d.getOwner(),
            c;
        if (!d.disabled) {
            d.loading = true;
            if (a.componentLayoutCounter) {
                d.maybeShow()
            } else {
                c = a.afterComponentLayout;
                a.afterComponentLayout = function() {
                    a.afterComponentLayout = c;
                    c.apply(a, arguments);
                    d.maybeShow()
                }
            }
        }
    },
    maybeShow: function() {
        var c = this,
            a = c.getOwner();
        if (!a.isVisible(true)) {
            c.showNext = true
        } else {
            if (c.loading && a.rendered) {
                c.show()
            }
        }
    },
    getMaskEl: function() {
        var a = this;
        return a.maskEl || (a.maskEl = a.el.insertSibling({
            cls: a.maskCls,
            style: {
                zIndex: a.el.getStyle("zIndex") - 2
            }
        }, "before"))
    },
    onShow: function() {
        var c = this,
            a = c.msgEl;
        c.callParent(arguments);
        c.loading = true;
        if (c.useMsg) {
            a.show().update(c.msg)
        } else {
            a.parent().hide()
        }
    },
    hide: function() {
        if (this.isElement) {
            this.ownerCt.unmask();
            this.fireEvent("hide", this);
            return
        }
        delete this.showNext;
        return this.callParent(arguments)
    },
    onHide: function() {
        this.callParent();
        this.getMaskEl().hide()
    },
    show: function() {
        if (this.isElement) {
            this.ownerCt.mask(this.useMsg ? this.msg : "", this.msgCls);
            this.fireEvent("show", this);
            return
        }
        return this.callParent(arguments)
    },
    afterShow: function() {
        this.callParent(arguments);
        this.sizeMask()
    },
    setZIndex: function(c) {
        var d = this,
            a = d.activeOwner;
        if (a) {
            c = parseInt(a.el.getStyle("zIndex"), 10) + 1
        }
        d.getMaskEl().setStyle("zIndex", c - 1);
        return d.mixins.floating.setZIndex.apply(d, arguments)
    },
    onLoad: function() {
        this.loading = false;
        this.hide()
    },
    onDestroy: function() {
        var a = this;
        if (a.isElement) {
            a.ownerCt.unmask()
        }
        Ext.destroy(a.maskEl);
        a.callParent()
    }
});
Ext.define("Ext.selection.Model", {
    extend: "Ext.util.Observable",
    alternateClassName: "Ext.AbstractSelectionModel",
    requires: ["Ext.data.StoreManager"],
    mixins: {
        bindable: "Ext.util.Bindable"
    },
    allowDeselect: false,
    selected: null,
    pruneRemoved: true,
    constructor: function(a) {
        var c = this;
        a = a || {};
        Ext.apply(c, a);
        c.addEvents("selectionchange", "focuschange");
        c.modes = {
            SINGLE: true,
            SIMPLE: true,
            MULTI: true
        };
        c.setSelectionMode(a.mode || c.mode);
        c.selected = new Ext.util.MixedCollection();
        c.callParent(arguments)
    },
    bindStore: function(a, c) {
        var d = this;
        d.mixins.bindable.bindStore.apply(d, arguments);
        if (d.store && !c) {
            d.refresh()
        }
    },
    getStoreListeners: function() {
        var a = this;
        return {
            add: a.onStoreAdd,
            clear: a.onStoreClear,
            remove: a.onStoreRemove,
            update: a.onStoreUpdate
        }
    },
    selectAll: function(c) {
        var g = this,
            e = g.store.getRange(),
            d = 0,
            a = e.length,
            j = g.getSelection().length;
        g.bulkChange = true;
        for (; d < a; d++) {
            g.doSelect(e[d], true, c)
        }
        delete g.bulkChange;
        g.maybeFireSelectionChange(g.getSelection().length !== j)
    },
    deselectAll: function(c) {
        var g = this,
            e = g.getSelection(),
            d = 0,
            a = e.length,
            j = g.getSelection().length;
        g.bulkChange = true;
        for (; d < a; d++) {
            g.doDeselect(e[d], c)
        }
        delete g.bulkChange;
        g.maybeFireSelectionChange(g.getSelection().length !== j)
    },
    selectWithEvent: function(a, g, d) {
        var c = this;
        switch (c.selectionMode) {
            case "MULTI":
                if (g.ctrlKey && c.isSelected(a)) {
                    c.doDeselect(a, false)
                } else {
                    if (g.shiftKey && c.lastFocused) {
                        c.selectRange(c.lastFocused, a, g.ctrlKey)
                    } else {
                        if (g.ctrlKey) {
                            c.doSelect(a, true, false)
                        } else {
                            if (c.isSelected(a) && !g.shiftKey && !g.ctrlKey && c.selected.getCount() > 1) {
                                c.doSelect(a, d, false)
                            } else {
                                c.doSelect(a, false)
                            }
                        }
                    }
                }
                break;
            case "SIMPLE":
                if (c.isSelected(a)) {
                    c.doDeselect(a)
                } else {
                    c.doSelect(a, true)
                }
                break;
            case "SINGLE":
                if (c.allowDeselect && c.isSelected(a)) {
                    c.doDeselect(a)
                } else {
                    c.doSelect(a, false)
                }
                break
        }
    },
    selectRange: function(n, g, o, d) {
        var l = this,
            m = l.store,
            e = 0,
            k, j, a, c = [];
        if (l.isLocked()) {
            return
        }
        if (!o) {
            l.deselectAll(true)
        }
        if (!Ext.isNumber(n)) {
            n = m.indexOf(n)
        }
        if (!Ext.isNumber(g)) {
            g = m.indexOf(g)
        }
        if (n > g) {
            j = g;
            g = n;
            n = j
        }
        for (k = n; k <= g; k++) {
            if (l.isSelected(m.getAt(k))) {
                e++
            }
        }
        if (!d) {
            a = -1
        } else {
            a = (d == "up") ? n : g
        }
        for (k = n; k <= g; k++) {
            if (e == (g - n + 1)) {
                if (k != a) {
                    l.doDeselect(k, true)
                }
            } else {
                c.push(m.getAt(k))
            }
        }
        l.doMultiSelect(c, true)
    },
    select: function(c, d, a) {
        if (Ext.isDefined(c)) {
            this.doSelect(c, d, a)
        }
    },
    deselect: function(c, a) {
        this.doDeselect(c, a)
    },
    doSelect: function(d, g, c) {
        var e = this,
            a;
        if (e.locked || !e.store) {
            return
        }
        if (typeof d === "number") {
            d = [e.store.getAt(d)]
        }
        if (e.selectionMode == "SINGLE" && d) {
            a = d.length ? d[0] : d;
            e.doSingleSelect(a, c)
        } else {
            e.doMultiSelect(d, g, c)
        }
    },
    doMultiSelect: function(a, n, m) {
        var k = this,
            c = k.selected,
            l = false,
            e = 0,
            j, g;
        if (k.locked) {
            return
        }
        a = !Ext.isArray(a) ? [a] : a;
        j = a.length;
        if (!n && c.getCount() > 0) {
            if (k.doDeselect(k.getSelection(), m) === false) {
                return
            }
        }

        function d() {
            c.add(g);
            l = true
        }
        for (; e < j; e++) {
            g = a[e];
            if (n && k.isSelected(g)) {
                continue
            }
            k.lastSelected = g;
            k.onSelectChange(g, true, m, d)
        }
        if (!k.preventFocus) {
            k.setLastFocused(g, m)
        }
        k.maybeFireSelectionChange(l && !m)
    },
    doDeselect: function(a, m) {
        var l = this,
            c = l.selected,
            e = 0,
            k, g, n = 0,
            j = 0;
        if (l.locked || !l.store) {
            return false
        }
        if (typeof a === "number") {
            a = [l.store.getAt(a)]
        } else {
            if (!Ext.isArray(a)) {
                a = [a]
            }
        }

        function d() {
            ++j;
            c.remove(g)
        }
        k = a.length;
        for (; e < k; e++) {
            g = a[e];
            if (l.isSelected(g)) {
                if (l.lastSelected == g) {
                    l.lastSelected = c.last()
                }++n;
                l.onSelectChange(g, false, m, d)
            }
        }
        l.maybeFireSelectionChange(j > 0 && !m);
        return j === n
    },
    doSingleSelect: function(a, c) {
        var e = this,
            i = false,
            d = e.selected;
        if (e.locked) {
            return
        }
        if (e.isSelected(a)) {
            return
        }

        function g() {
            e.bulkChange = true;
            if (d.getCount() > 0 && e.doDeselect(e.lastSelected, c) === false) {
                delete e.bulkChange;
                return false
            }
            delete e.bulkChange;
            d.add(a);
            e.lastSelected = a;
            i = true
        }
        e.onSelectChange(a, true, c, g);
        if (i) {
            if (!c) {
                e.setLastFocused(a)
            }
            e.maybeFireSelectionChange(!c)
        }
    },
    setLastFocused: function(d, c) {
        var e = this,
            a = e.lastFocused;
        e.lastFocused = d;
        if (d !== a) {
            e.onLastFocusChanged(a, d, c)
        }
    },
    isFocused: function(a) {
        return a === this.getLastFocused()
    },
    maybeFireSelectionChange: function(a) {
        var c = this;
        if (a && !c.bulkChange) {
            c.fireEvent("selectionchange", c, c.getSelection())
        }
    },
    getLastSelected: function() {
        return this.lastSelected
    },
    getLastFocused: function() {
        return this.lastFocused
    },
    getSelection: function() {
        return this.selected.getRange()
    },
    getSelectionMode: function() {
        return this.selectionMode
    },
    setSelectionMode: function(a) {
        a = a ? a.toUpperCase() : "SINGLE";
        this.selectionMode = this.modes[a] ? a : "SINGLE"
    },
    isLocked: function() {
        return this.locked
    },
    setLocked: function(a) {
        this.locked = !!a
    },
    isSelected: function(a) {
        a = Ext.isNumber(a) ? this.store.getAt(a) : a;
        return this.selected.indexOf(a) !== -1
    },
    hasSelection: function() {
        return this.selected.getCount() > 0
    },
    refresh: function() {
        var g = this,
            l = g.store,
            d = [],
            a = g.getSelection(),
            e = a.length,
            k, j, c = 0,
            m = g.getLastFocused();
        if (!l) {
            return
        }
        for (; c < e; c++) {
            k = a[c];
            if (!g.pruneRemoved || l.indexOf(k) !== -1) {
                d.push(k)
            }
        }
        if (g.selected.getCount() != d.length) {
            j = true
        }
        g.clearSelections();
        if (l.indexOf(m) !== -1) {
            g.setLastFocused(m, true)
        }
        if (d.length) {
            g.doSelect(d, false, true)
        }
        g.maybeFireSelectionChange(j)
    },
    clearSelections: function() {
        this.selected.clear();
        this.lastSelected = null;
        this.setLastFocused(null)
    },
    onStoreAdd: Ext.emptyFn,
    onStoreClear: function() {
        if (this.selected.getCount > 0) {
            this.clearSelections();
            this.maybeFireSelectionChange(true)
        }
    },
    onStoreRemove: function(c, a, d) {
        var g = this,
            e = g.selected;
        if (g.locked || !g.pruneRemoved) {
            return
        }
        if (e.remove(a)) {
            if (g.lastSelected == a) {
                g.lastSelected = null
            }
            if (g.getLastFocused() == a) {
                g.setLastFocused(null)
            }
            g.maybeFireSelectionChange(true)
        }
    },
    getCount: function() {
        return this.selected.getCount()
    },
    destroy: Ext.emptyFn,
    onStoreUpdate: Ext.emptyFn,
    onStoreLoad: Ext.emptyFn,
    onSelectChange: Ext.emptyFn,
    onLastFocusChanged: function(c, a) {
        this.fireEvent("focuschange", this, c, a)
    },
    onEditorKey: Ext.emptyFn,
    bindComponent: Ext.emptyFn,
    beforeViewRender: Ext.emptyFn
});
Ext.define("Ext.selection.DataViewModel", {
    extend: "Ext.selection.Model",
    requires: ["Ext.util.KeyNav"],
    deselectOnContainerClick: true,
    enableKeyNav: true,
    constructor: function(a) {
        this.addEvents("beforedeselect", "beforeselect", "deselect", "select");
        this.callParent(arguments)
    },
    bindComponent: function(a) {
        var c = this,
            d = {
                refresh: c.refresh,
                scope: c
            };
        c.view = a;
        c.bindStore(a.getStore());
        d[a.triggerEvent] = c.onItemClick;
        d[a.triggerCtEvent] = c.onContainerClick;
        a.on(d);
        if (c.enableKeyNav) {
            c.initKeyNav(a)
        }
    },
    onItemClick: function(c, a, g, d, i) {
        this.selectWithEvent(a, i)
    },
    onContainerClick: function() {
        if (this.deselectOnContainerClick) {
            this.deselectAll()
        }
    },
    initKeyNav: function(a) {
        var c = this;
        if (!a.rendered) {
            a.on({
                render: Ext.Function.bind(c.initKeyNav, c, [a]),
                single: true
            });
            return
        }
        a.el.set({
            tabIndex: -1
        });
        c.keyNav = new Ext.util.KeyNav({
            target: a.el,
            ignoreInputFields: true,
            down: Ext.pass(c.onNavKey, [1], c),
            right: Ext.pass(c.onNavKey, [1], c),
            left: Ext.pass(c.onNavKey, [-1], c),
            up: Ext.pass(c.onNavKey, [-1], c),
            scope: c
        })
    },
    onNavKey: function(i) {
        i = i || 1;
        var g = this,
            c = g.view,
            e = g.getSelection()[0],
            d = g.view.store.getCount(),
            a;
        if (e) {
            a = c.indexOf(c.getNode(e)) + i
        } else {
            a = 0
        }
        if (a < 0) {
            a = d - 1
        } else {
            if (a >= d) {
                a = 0
            }
        }
        g.select(a)
    },
    onSelectChange: function(c, g, e, j) {
        var i = this,
            a = i.view,
            d = g ? "select" : "deselect";
        if ((e || i.fireEvent("before" + d, i, c)) !== false && j() !== false) {
            if (a) {
                if (g) {
                    a.onItemSelect(c)
                } else {
                    a.onItemDeselect(c)
                }
            }
            if (!e) {
                i.fireEvent(d, i, c)
            }
        }
    },
    destroy: function() {
        Ext.destroy(this.keyNav);
        this.callParent()
    }
});
Ext.define("Ext.view.AbstractView", {
    extend: "Ext.Component",
    requires: ["Ext.LoadMask", "Ext.data.StoreManager", "Ext.CompositeElementLite", "Ext.DomQuery", "Ext.selection.DataViewModel"],
    mixins: {
        bindable: "Ext.util.Bindable"
    },
    inheritableStatics: {
        getRecord: function(a) {
            return this.getBoundView(a).getRecord(a)
        },
        getBoundView: function(a) {
            return Ext.getCmp(a.boundView)
        }
    },
    deferInitialRefresh: true,
    itemCls: Ext.baseCSSPrefix + "dataview-item",
    loadingText: "Loading...",
    loadMask: true,
    loadingUseMsg: true,
    selectedItemCls: Ext.baseCSSPrefix + "item-selected",
    emptyText: "",
    deferEmptyText: true,
    trackOver: false,
    blockRefresh: false,
    preserveScrollOnRefresh: false,
    last: false,
    triggerEvent: "itemclick",
    triggerCtEvent: "containerclick",
    addCmpEvents: function() {},
    initComponent: function() {
        var d = this,
            a = Ext.isDefined,
            e = d.itemTpl,
            c = {};
        if (e) {
            if (Ext.isArray(e)) {
                e = e.join("")
            } else {
                if (Ext.isObject(e)) {
                    c = Ext.apply(c, e.initialConfig);
                    e = e.html
                }
            }
            if (!d.itemSelector) {
                d.itemSelector = "." + d.itemCls
            }
            e = Ext.String.format('<tpl for="."><div class="{0}">{1}</div></tpl>', d.itemCls, e);
            d.tpl = new Ext.XTemplate(e, c)
        }
        d.callParent();
        if (Ext.isString(d.tpl) || Ext.isArray(d.tpl)) {
            d.tpl = new Ext.XTemplate(d.tpl)
        }
        d.addEvents("beforerefresh", "refresh", "viewready", "itemupdate", "itemadd", "itemremove");
        d.addCmpEvents();
        d.store = Ext.data.StoreManager.lookup(d.store || "ext-empty-store");
        d.bindStore(d.store, true);
        d.all = new Ext.CompositeElementLite();
        d.scrollState = {
            top: 0,
            left: 0
        };
        d.on({
            scroll: d.onViewScroll,
            element: "el",
            scope: d
        })
    },
    onRender: function() {
        var d = this,
            c = d.loadMask,
            a = {
                msg: d.loadingText,
                msgCls: d.loadingCls,
                useMsg: d.loadingUseMsg,
                store: d.getMaskStore()
            };
        d.callParent(arguments);
        if (c) {
            if (Ext.isObject(c)) {
                a = Ext.apply(a, c)
            }
            d.loadMask = new Ext.LoadMask(d, a);
            d.loadMask.on({
                scope: d,
                beforeshow: d.onMaskBeforeShow,
                hide: d.onMaskHide
            })
        }
    },
    finishRender: function() {
        var a = this;
        a.callParent(arguments);
        if (!a.up("[collapsed],[hidden]")) {
            a.doFirstRefresh(a.store)
        }
    },
    onBoxReady: function() {
        var a = this;
        a.callParent(arguments);
        if (!a.firstRefreshDone) {
            a.doFirstRefresh(a.store)
        }
    },
    getMaskStore: function() {
        return this.store
    },
    onMaskBeforeShow: function() {
        var c = this,
            a = c.loadingHeight;
        c.getSelectionModel().deselectAll();
        c.all.clear();
        if (a && a > c.getHeight()) {
            c.hasLoadingHeight = true;
            c.oldMinHeight = c.minHeight;
            c.minHeight = a;
            c.updateLayout()
        }
    },
    onMaskHide: function() {
        var a = this;
        if (!a.destroying && a.hasLoadingHeight) {
            a.minHeight = a.oldMinHeight;
            a.updateLayout();
            delete a.hasLoadingHeight
        }
    },
    beforeRender: function() {
        this.callParent(arguments);
        this.getSelectionModel().beforeViewRender(this)
    },
    afterRender: function() {
        this.callParent(arguments);
        this.getSelectionModel().bindComponent(this)
    },
    getSelectionModel: function() {
        var a = this,
            c = "SINGLE";
        if (!a.selModel) {
            a.selModel = {}
        }
        if (a.simpleSelect) {
            c = "SIMPLE"
        } else {
            if (a.multiSelect) {
                c = "MULTI"
            }
        }
        Ext.applyIf(a.selModel, {
            allowDeselect: a.allowDeselect,
            mode: c
        });
        if (!a.selModel.events) {
            a.selModel = new Ext.selection.DataViewModel(a.selModel)
        }
        if (!a.selModel.hasRelaySetup) {
            a.relayEvents(a.selModel, ["selectionchange", "beforeselect", "beforedeselect", "select", "deselect", "focuschange"]);
            a.selModel.hasRelaySetup = true
        }
        if (a.disableSelection) {
            a.selModel.locked = true
        }
        return a.selModel
    },
    refresh: function() {
        var d = this,
            j, c, g, e, i, a;
        if (!d.rendered || d.isDestroyed) {
            return
        }
        if (!d.hasListeners.beforerefresh || d.fireEvent("beforerefresh", d) !== false) {
            j = d.getTargetEl();
            a = d.store.getRange();
            i = j.dom;
            if (!d.preserveScrollOnRefresh) {
                c = i.parentNode;
                g = i.style.display;
                i.style.display = "none";
                e = i.nextSibling;
                c.removeChild(i)
            }
            if (d.refreshCounter) {
                d.clearViewEl()
            } else {
                d.fixedNodes = j.dom.childNodes.length;
                d.refreshCounter = 1
            }
            d.tpl.append(j, d.collectData(a, 0));
            if (a.length < 1) {
                if (!d.deferEmptyText || d.hasSkippedEmptyText) {
                    Ext.core.DomHelper.insertHtml("beforeEnd", j.dom, d.emptyText)
                }
                d.all.clear()
            } else {
                d.all.fill(Ext.query(d.getItemSelector(), j.dom));
                d.updateIndexes(0)
            }
            d.selModel.refresh();
            d.hasSkippedEmptyText = true;
            if (!d.preserveScrollOnRefresh) {
                c.insertBefore(i, e);
                i.style.display = g
            }
            this.refreshSize();
            d.fireEvent("refresh", d);
            if (!d.viewReady) {
                d.viewReady = true;
                d.fireEvent("viewready", d)
            }
        }
    },
    refreshSize: function() {
        var a = this.getSizeModel();
        if (a.height.shrinkWrap || a.width.shrinkWrap) {
            this.updateLayout()
        }
    },
    clearViewEl: function() {
        var c = this,
            a = c.getTargetEl();
        if (c.fixedNodes) {
            while (a.dom.childNodes[c.fixedNodes]) {
                a.dom.removeChild(a.dom.childNodes[c.fixedNodes])
            }
        } else {
            a.update("")
        }
        c.refreshCounter++
    },
    onViewScroll: Ext.emptyFn,
    saveScrollState: function() {
        if (this.rendered) {
            var c = this.el.dom,
                a = this.scrollState;
            a.left = c.scrollLeft;
            a.top = c.scrollTop
        }
    },
    restoreScrollState: function() {
        if (this.rendered) {
            var c = this.el.dom,
                a = this.scrollState;
            c.scrollLeft = a.left;
            c.scrollTop = a.top
        }
    },
    prepareData: function(g, e, d) {
        var c, a;
        if (d) {
            c = d.getAssociatedData();
            for (a in c) {
                if (c.hasOwnProperty(a)) {
                    g[a] = c[a]
                }
            }
        }
        return g
    },
    collectData: function(d, j) {
        var g = [],
            e = 0,
            a = d.length,
            c;
        for (; e < a; e++) {
            c = d[e];
            g[e] = this.prepareData(c.data, j + e, c)
        }
        return g
    },
    bufferRender: function(a, c) {
        var d = this,
            e = d.renderBuffer || (d.renderBuffer = document.createElement("div"));
        d.tpl.overwrite(e, d.collectData(a, c));
        return Ext.query(d.getItemSelector(), e)
    },
    onUpdate: function(g, a) {
        var e = this,
            c, d;
        if (e.viewReady) {
            c = e.store.indexOf(a);
            if (c > -1) {
                d = e.bufferRender([a], c)[0];
                if (e.getNode(a)) {
                    e.all.replaceElement(c, d, true);
                    e.updateIndexes(c, c);
                    e.selModel.refresh();
                    if (e.hasListeners.itemupdate) {
                        e.fireEvent("itemupdate", a, c, d)
                    }
                    return d
                }
            }
        }
    },
    onAdd: function(g, c, d) {
        var e = this,
            a;
        if (e.rendered) {
            if (e.all.getCount() === 0) {
                e.refresh();
                return
            }
            a = e.bufferRender(c, d);
            e.doAdd(a, c, d);
            e.selModel.refresh();
            e.updateIndexes(d);
            e.refreshSize();
            if (e.hasListeners.itemadd) {
                e.fireEvent("itemadd", c, d, a)
            }
        }
    },
    doAdd: function(c, a, d) {
        var e = this.all,
            g = e.getCount();
        if (g === 0) {
            this.clearViewEl();
            this.getTargetEl().appendChild(c)
        } else {
            if (d < g) {
                if (d === 0) {
                    e.item(d).insertSibling(c, "before", true)
                } else {
                    e.item(d - 1).insertSibling(c, "after", true)
                }
            } else {
                e.last().insertSibling(c, "after", true)
            }
        }
        Ext.Array.insert(e.elements, d, c)
    },
    onRemove: function(e, a, c) {
        var d = this;
        if (d.all.getCount()) {
            if (d.store.getCount() === 0) {
                d.refresh()
            } else {
                d.doRemove(a, c);
                if (d.selModel.refreshOnRemove) {
                    d.selModel.refresh()
                }
                d.updateIndexes(c)
            }
            this.refreshSize();
            if (d.hasListeners.itemremove) {
                d.fireEvent("itemremove", a, c)
            }
        }
    },
    doRemove: function(a, c) {
        this.all.removeElement(c, true)
    },
    refreshNode: function(a) {
        this.onUpdate(this.store, this.store.getAt(a))
    },
    updateIndexes: function(g, e) {
        var d = this.all.elements,
            a = this.store.getRange(),
            c;
        g = g || 0;
        e = e || ((e === 0) ? 0 : (d.length - 1));
        for (c = g; c <= e; c++) {
            d[c].viewIndex = c;
            d[c].viewRecordId = a[c].internalId;
            if (!d[c].boundView) {
                d[c].boundView = this.id
            }
        }
    },
    getStore: function() {
        return this.store
    },
    bindStore: function(a, c) {
        var d = this;
        d.mixins.bindable.bindStore.apply(d, arguments);
        if (!c) {
            d.getSelectionModel().bindStore(d.store)
        }
        if (d.componentLayoutCounter) {
            d.doFirstRefresh(a)
        }
    },
    doFirstRefresh: function(a) {
        var c = this;
        c.firstRefreshDone = true;
        if (a && !a.loading) {
            if (c.deferInitialRefresh) {
                c.applyFirstRefresh()
            } else {
                c.refresh()
            }
        }
    },
    applyFirstRefresh: function() {
        var a = this;
        if (a.isDestroyed) {
            return
        }
        if (a.up("[isCollapsingOrExpanding]")) {
            Ext.Function.defer(a.applyFirstRefresh, 100, a)
        } else {
            Ext.Function.defer(function() {
                if (!a.isDestroyed) {
                    a.refresh()
                }
            }, 1)
        }
    },
    onUnbindStore: function(a) {
        this.setMaskBind(null)
    },
    onBindStore: function(a) {
        this.setMaskBind(a)
    },
    setMaskBind: function(c) {
        var a = this.loadMask;
        if (a && a.bindStore) {
            a.bindStore(c)
        }
    },
    getStoreListeners: function() {
        var a = this;
        return {
            refresh: a.onDataRefresh,
            add: a.onAdd,
            remove: a.onRemove,
            update: a.onUpdate,
            clear: a.refresh
        }
    },
    onDataRefresh: function() {
        var a = this,
            c = !a.firstRefreshDone && (!a.rendered || a.up("[collapsed],[isCollapsingOrExpanding],[hidden]"));
        if (c) {
            a.deferInitialRefresh = false
        } else {
            if (a.blockRefresh !== true) {
                a.firstRefreshDone = true;
                a.refresh.apply(a, arguments)
            }
        }
    },
    findItemByChild: function(a) {
        return Ext.fly(a).findParent(this.getItemSelector(), this.getTargetEl())
    },
    findTargetByEvent: function(a) {
        return a.getTarget(this.getItemSelector(), this.getTargetEl())
    },
    getSelectedNodes: function() {
        var c = [],
            a = this.selModel.getSelection(),
            e = a.length,
            d = 0;
        for (; d < e; d++) {
            c.push(this.getNode(a[d]))
        }
        return c
    },
    getRecords: function(d) {
        var c = [],
            e = 0,
            a = d.length,
            g = this.store.data;
        for (; e < a; e++) {
            c[c.length] = g.getByKey(d[e].viewRecordId)
        }
        return c
    },
    getRecord: function(a) {
        return this.store.data.getByKey(Ext.getDom(a).viewRecordId)
    },
    isSelected: function(c) {
        var a = this.getRecord(c);
        return this.selModel.isSelected(a)
    },
    select: function(c, d, a) {
        this.selModel.select(c, d, a)
    },
    deselect: function(c, a) {
        this.selModel.deselect(c, a)
    },
    getNode: function(a) {
        if ((!a && a !== 0) || !this.rendered) {
            return null
        }
        if (Ext.isString(a)) {
            return document.getElementById(a)
        }
        if (Ext.isNumber(a)) {
            return this.all.elements[a]
        }
        if (a.isModel) {
            return this.getNodeByRecord(a)
        }
        return a
    },
    getNodeByRecord: function(a) {
        var d = this.all.elements,
            e = d.length,
            c = 0;
        for (; c < e; c++) {
            if (d[c].viewRecordId === a.internalId) {
                return d[c]
            }
        }
        return null
    },
    getNodes: function(d, a) {
        var c = this.all.elements;
        if (a === undefined) {
            a = c.length
        } else {
            a++
        }
        return this.all.elements.slice(d || 0, a)
    },
    indexOf: function(a) {
        a = this.getNode(a);
        if (!a && a !== 0) {
            return -1
        }
        if (Ext.isNumber(a.viewIndex)) {
            return a.viewIndex
        }
        return this.all.indexOf(a)
    },
    onDestroy: function() {
        var a = this;
        a.all.clear();
        a.callParent();
        a.bindStore(null);
        a.selModel.destroy()
    },
    onItemSelect: function(a) {
        var c = this.getNode(a);
        if (c) {
            Ext.fly(c).addCls(this.selectedItemCls)
        }
    },
    onItemDeselect: function(a) {
        var c = this.getNode(a);
        if (c) {
            Ext.fly(c).removeCls(this.selectedItemCls)
        }
    },
    getItemSelector: function() {
        return this.itemSelector
    }
}, function() {
    Ext.deprecate("extjs", "4.0", function() {
        Ext.view.AbstractView.override({
            getSelectionCount: function() {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: getSelectionCount will be removed, please interact with the Ext.selection.DataViewModel")
                }
                return this.selModel.getSelection().length
            },
            getSelectedRecords: function() {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: getSelectedRecords will be removed, please interact with the Ext.selection.DataViewModel")
                }
                return this.selModel.getSelection()
            },
            select: function(a, c, e) {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: select will be removed, please access select through a DataView's SelectionModel, ie: view.getSelectionModel().select()")
                }
                var d = this.getSelectionModel();
                return d.select.apply(d, arguments)
            },
            clearSelections: function() {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: clearSelections will be removed, please access deselectAll through DataView's SelectionModel, ie: view.getSelectionModel().deselectAll()")
                }
                var a = this.getSelectionModel();
                return a.deselectAll()
            }
        })
    })
});
Ext.define("Ext.view.View", {
    extend: "Ext.view.AbstractView",
    alternateClassName: "Ext.DataView",
    alias: "widget.dataview",
    deferHighlight: (Ext.isIE6 || Ext.isIE7) ? 100 : 0,
    inputTagRe: /^textarea$|^input$/i,
    inheritableStatics: {
        EventMap: {
            mousedown: "MouseDown",
            mouseup: "MouseUp",
            click: "Click",
            dblclick: "DblClick",
            contextmenu: "ContextMenu",
            mouseover: "MouseOver",
            mouseout: "MouseOut",
            mouseenter: "MouseEnter",
            mouseleave: "MouseLeave",
            keydown: "KeyDown",
            focus: "Focus"
        }
    },
    initComponent: function() {
        var a = this;
        a.callParent();
        if (a.deferHighlight) {
            a.setHighlightedItem = Ext.Function.createBuffered(a.setHighlightedItem, a.deferHighlight, a)
        }
    },
    addCmpEvents: function() {
        this.addEvents("beforeitemmousedown", "beforeitemmouseup", "beforeitemmouseenter", "beforeitemmouseleave", "beforeitemclick", "beforeitemdblclick", "beforeitemcontextmenu", "beforeitemkeydown", "itemmousedown", "itemmouseup", "itemmouseenter", "itemmouseleave", "itemclick", "itemdblclick", "itemcontextmenu", "itemkeydown", "beforecontainermousedown", "beforecontainermouseup", "beforecontainermouseover", "beforecontainermouseout", "beforecontainerclick", "beforecontainerdblclick", "beforecontainercontextmenu", "beforecontainerkeydown", "containermouseup", "containermouseover", "containermouseout", "containerclick", "containerdblclick", "containercontextmenu", "containerkeydown", "selectionchange", "beforeselect", "beforedeselect", "select", "deselect", "focuschange", "highlightitem", "unhighlightitem")
    },
    getFocusEl: function() {
        return this.getTargetEl()
    },
    afterRender: function() {
        var a = this;
        a.callParent();
        a.mon(a.getTargetEl(), {
            scope: a,
            freezeEvent: true,
            click: a.handleEvent,
            mousedown: a.handleEvent,
            mouseup: a.handleEvent,
            dblclick: a.handleEvent,
            contextmenu: a.handleEvent,
            mouseover: a.handleEvent,
            mouseout: a.handleEvent,
            keydown: a.handleEvent
        })
    },
    handleEvent: function(d) {
        var c = this,
            a = d.type == "keydown" && d.getKey();
        if (c.processUIEvent(d) !== false) {
            c.processSpecialEvent(d)
        }
        if (a === d.SPACE) {
            if (!c.inputTagRe.test(d.getTarget().tagName)) {
                d.stopEvent()
            }
        }
    },
    processItemEvent: Ext.emptyFn,
    processContainerEvent: Ext.emptyFn,
    processSpecialEvent: Ext.emptyFn,
    stillOverItem: function(c, a) {
        var d;
        if (a && typeof(a.offsetParent) === "object") {
            d = (c.type == "mouseout") ? c.getRelatedTarget() : c.getTarget();
            return Ext.fly(a).contains(d)
        }
        return false
    },
    processUIEvent: function(j) {
        var k = this,
            m = j.getTarget(k.getItemSelector(), k.getTargetEl()),
            a = this.statics().EventMap,
            i, d, l = j.type,
            g = k.mouseOverItem,
            c;
        if (!m) {
            if (l == "mouseover" && k.stillOverItem(j, g)) {
                m = g
            }
            if (l == "keydown") {
                d = k.getSelectionModel().getLastSelected();
                if (d) {
                    m = k.getNode(d)
                }
            }
        }
        if (m) {
            i = k.indexOf(m);
            if (!d) {
                d = k.getRecord(m)
            }
            if (!d || k.processItemEvent(d, m, i, j) === false) {
                return false
            }
            c = k.isNewItemEvent(m, j);
            if (c === false) {
                return false
            }
            if ((k["onBeforeItem" + a[c]](d, m, i, j) === false) || (k.fireEvent("beforeitem" + c, k, d, m, i, j) === false) || (k["onItem" + a[c]](d, m, i, j) === false)) {
                return false
            }
            k.fireEvent("item" + c, k, d, m, i, j)
        } else {
            if ((k.processContainerEvent(j) === false) || (k["onBeforeContainer" + a[l]](j) === false) || (k.fireEvent("beforecontainer" + l, k, j) === false) || (k["onContainer" + a[l]](j) === false)) {
                return false
            }
            k.fireEvent("container" + l, k, j)
        }
        return true
    },
    isNewItemEvent: function(g, i) {
        var d = this,
            a = d.mouseOverItem,
            c = i.type;
        switch (c) {
            case "mouseover":
                if (g === a) {
                    return false
                }
                d.mouseOverItem = g;
                return "mouseenter";
            case "mouseout":
                if (d.stillOverItem(i, a)) {
                    return false
                }
                d.mouseOverItem = null;
                return "mouseleave"
        }
        return c
    },
    onItemMouseEnter: function(a, d, c, g) {
        if (this.trackOver) {
            this.highlightItem(d)
        }
    },
    onItemMouseLeave: function(a, d, c, g) {
        if (this.trackOver) {
            this.clearHighlight()
        }
    },
    onItemMouseDown: Ext.emptyFn,
    onItemMouseUp: Ext.emptyFn,
    onItemFocus: Ext.emptyFn,
    onItemClick: Ext.emptyFn,
    onItemDblClick: Ext.emptyFn,
    onItemContextMenu: Ext.emptyFn,
    onItemKeyDown: Ext.emptyFn,
    onBeforeItemMouseDown: Ext.emptyFn,
    onBeforeItemMouseUp: Ext.emptyFn,
    onBeforeItemFocus: Ext.emptyFn,
    onBeforeItemMouseEnter: Ext.emptyFn,
    onBeforeItemMouseLeave: Ext.emptyFn,
    onBeforeItemClick: Ext.emptyFn,
    onBeforeItemDblClick: Ext.emptyFn,
    onBeforeItemContextMenu: Ext.emptyFn,
    onBeforeItemKeyDown: Ext.emptyFn,
    onContainerMouseDown: Ext.emptyFn,
    onContainerMouseUp: Ext.emptyFn,
    onContainerMouseOver: Ext.emptyFn,
    onContainerMouseOut: Ext.emptyFn,
    onContainerClick: Ext.emptyFn,
    onContainerDblClick: Ext.emptyFn,
    onContainerContextMenu: Ext.emptyFn,
    onContainerKeyDown: Ext.emptyFn,
    onBeforeContainerMouseDown: Ext.emptyFn,
    onBeforeContainerMouseUp: Ext.emptyFn,
    onBeforeContainerMouseOver: Ext.emptyFn,
    onBeforeContainerMouseOut: Ext.emptyFn,
    onBeforeContainerClick: Ext.emptyFn,
    onBeforeContainerDblClick: Ext.emptyFn,
    onBeforeContainerContextMenu: Ext.emptyFn,
    onBeforeContainerKeyDown: Ext.emptyFn,
    setHighlightedItem: function(d) {
        var c = this,
            a = c.highlightedItem;
        if (a != d) {
            if (a) {
                Ext.fly(a).removeCls(c.overItemCls);
                c.fireEvent("unhighlightitem", c, a)
            }
            c.highlightedItem = d;
            if (d) {
                Ext.fly(d).addCls(c.overItemCls);
                c.fireEvent("highlightitem", c, d)
            }
        }
    },
    highlightItem: function(a) {
        this.setHighlightedItem(a)
    },
    clearHighlight: function() {
        this.setHighlightedItem(undefined)
    },
    onUpdate: function(c, a) {
        var i = this,
            g, d, e;
        if (i.viewReady) {
            g = i.getNode(a);
            d = i.callParent(arguments);
            e = i.highlightedItem;
            if (e && e === g) {
                delete i.highlightedItem;
                if (d) {
                    i.highlightItem(d)
                }
            }
        }
    },
    refresh: function() {
        this.clearHighlight();
        this.callParent(arguments)
    }
});
Ext.define("Ext.view.Table", {
    extend: "Ext.view.View",
    alias: "widget.tableview",
    uses: ["Ext.view.TableLayout", "Ext.view.TableChunker", "Ext.util.DelayedTask", "Ext.util.MixedCollection"],
    componentLayout: "tableview",
    baseCls: Ext.baseCSSPrefix + "grid-view",
    itemSelector: "tr." + Ext.baseCSSPrefix + "grid-row",
    cellSelector: "td." + Ext.baseCSSPrefix + "grid-cell",
    rowSelector: "tr." + Ext.baseCSSPrefix + "grid-row",
    firstCls: Ext.baseCSSPrefix + "grid-cell-first",
    lastCls: Ext.baseCSSPrefix + "grid-cell-last",
    headerRowSelector: "tr." + Ext.baseCSSPrefix + "grid-header-row",
    selectedItemCls: Ext.baseCSSPrefix + "grid-row-selected",
    selectedCellCls: Ext.baseCSSPrefix + "grid-cell-selected",
    focusedItemCls: Ext.baseCSSPrefix + "grid-row-focused",
    overItemCls: Ext.baseCSSPrefix + "grid-row-over",
    altRowCls: Ext.baseCSSPrefix + "grid-row-alt",
    rowClsRe: new RegExp("(?:^|\\s*)" + Ext.baseCSSPrefix + "grid-row-(first|last|alt)(?:\\s+|$)", "g"),
    cellRe: new RegExp(Ext.baseCSSPrefix + "grid-cell-([^\\s]+) ", ""),
    trackOver: true,
    getRowClass: null,
    stripeRows: true,
    markDirty: true,
    initialTpl: "<div></div>",
    initComponent: function() {
        var c = this,
            a = c.scroll;
        c.table = new Ext.dom.Element.Fly();
        c.table.id = c.id + "gridTable";
        c.autoScroll = undefined;
        if (a === true || a === "both") {
            c.autoScroll = true
        } else {
            if (a === "horizontal") {
                c.overflowX = "auto"
            } else {
                if (a === "vertical") {
                    c.overflowY = "auto"
                }
            }
        }
        c.selModel.view = c;
        c.headerCt.view = c;
        c.headerCt.markDirty = c.markDirty;
        c.initFeatures(c.grid);
        delete c.grid;
        c.tpl = c.getTpl("initialTpl");
        c.callParent()
    },
    moveColumn: function(a, r, e) {
        var p = this,
            n = (e > 1) ? document.createDocumentFragment() : undefined,
            d = r,
            s = p.getGridColumns().length,
            q = s - 1,
            c = (p.firstCls || p.lastCls) && (r === 0 || r == s || a === 0 || a == q),
            k, g, t, m, o, l;
        if (p.rendered) {
            l = p.el.query(p.headerRowSelector);
            t = p.el.query(p.rowSelector);
            if (r > a && n) {
                d -= e
            }
            for (k = 0, m = l.length; k < m; ++k) {
                o = l[k];
                if (n) {
                    for (g = 0; g < e; g++) {
                        n.appendChild(o.cells[a])
                    }
                    o.insertBefore(n, o.cells[d] || null)
                } else {
                    o.insertBefore(o.cells[a], o.cells[d] || null)
                }
            }
            for (k = 0, m = t.length; k < m; k++) {
                o = t[k];
                if (c) {
                    if (a === 0) {
                        Ext.fly(o.cells[0]).removeCls(p.firstCls);
                        Ext.fly(o.cells[1]).addCls(p.firstCls)
                    } else {
                        if (a === q) {
                            Ext.fly(o.cells[q]).removeCls(p.lastCls);
                            Ext.fly(o.cells[q - 1]).addCls(p.lastCls)
                        }
                    }
                    if (r === 0) {
                        Ext.fly(o.cells[0]).removeCls(p.firstCls);
                        Ext.fly(o.cells[a]).addCls(p.firstCls)
                    } else {
                        if (r === s) {
                            Ext.fly(o.cells[q]).removeCls(p.lastCls);
                            Ext.fly(o.cells[a]).addCls(p.lastCls)
                        }
                    }
                }
                if (n) {
                    for (g = 0; g < e; g++) {
                        n.appendChild(o.cells[a])
                    }
                    o.insertBefore(n, o.cells[d] || null)
                } else {
                    o.insertBefore(o.cells[a], o.cells[d] || null)
                }
            }
            p.setNewTemplate()
        }
    },
    scrollToTop: Ext.emptyFn,
    addElListener: function(a, d, c) {
        this.mon(this, a, d, c, {
            element: "el"
        })
    },
    getGridColumns: function() {
        return this.headerCt.getGridColumns()
    },
    getHeaderAtIndex: function(a) {
        return this.headerCt.getHeaderAtIndex(a)
    },
    getCell: function(a, c) {
        var d = this.getNode(a);
        return Ext.fly(d).down(c.getCellSelector())
    },
    getFeature: function(c) {
        var a = this.featuresMC;
        if (a) {
            return a.get(c)
        }
    },
    initFeatures: function(e) {
        var j = this,
            d, g, c, a;
        j.featuresMC = new Ext.util.MixedCollection();
        g = j.features = j.constructFeatures();
        a = g ? g.length : 0;
        for (d = 0; d < a; d++) {
            c = g[d];
            c.view = j;
            c.grid = e;
            j.featuresMC.add(c);
            c.init()
        }
    },
    constructFeatures: function() {
        var j = this,
            g = j.features,
            e, c, d = 0,
            a;
        if (g) {
            c = [];
            a = g.length;
            for (; d < a; d++) {
                e = g[d];
                if (!e.isFeature) {
                    e = Ext.create("feature." + e.ftype, e)
                }
                c[d] = e
            }
        }
        return c
    },
    attachEventsForFeatures: function() {
        var c = this.features,
            d = c.length,
            a = 0;
        for (; a < d; a++) {
            if (c[a].isFeature) {
                c[a].attachEvents()
            }
        }
    },
    afterRender: function() {
        var a = this;
        a.callParent();
        if (!a.enableTextSelection) {
            a.el.unselectable()
        }
        a.attachEventsForFeatures()
    },
    onViewScroll: function(c, a) {
        this.callParent(arguments);
        this.fireEvent("bodyscroll", c, a)
    },
    prepareData: function(c, k, e) {
        var j = this,
            m = j.headerCt.prepareData(c, k, e, j, j.ownerCt),
            a = j.features,
            g = a.length,
            d = 0,
            l;
        for (; d < g; d++) {
            l = a[d];
            if (l.isFeature) {
                Ext.apply(m, l.getAdditionalData(c, k, e, m, j))
            }
        }
        return m
    },
    collectData: function(e, s) {
        var q = this,
            u = q.callParent(arguments),
            d = q.headerCt,
            r = d.getFullWidth(),
            c = q.features,
            n = c.length,
            a = {
                rows: u,
                fullWidth: r
            },
            l = 0,
            v, k = 0,
            p, m, g, t;
        p = u.length;
        if (q.getRowClass) {
            for (; k < p; k++) {
                m = {};
                g = u[k];
                t = g.rowCls || "";
                g.rowCls = this.getRowClass(e[k], k, m, q.store) + " " + t
            }
        }
        for (; l < n; l++) {
            v = c[l];
            if (v.isFeature && v.collectData && !v.disabled) {
                a = v.collectData(e, u, s, r, a);
                break
            }
        }
        return a
    },
    refreshSize: function() {
        var c = this,
            a;
        c.table.attach(c.el.child("table", true));
        if (!c.hasLoadingHeight) {
            a = c.up("tablepanel");
            Ext.suspendLayouts();
            c.callParent();
            if (a && Ext.getScrollbarSize().width && (c.autoScroll || c.overflowY)) {
                a.updateLayout()
            }
            Ext.resumeLayouts(true)
        }
    },
    setNewTemplate: function() {
        var c = this,
            a = c.headerCt.getColumnsForTpl(true);
        c.tpl = c.getTableChunker().getTableTpl({
            rowCount: c.store.getCount(),
            columns: a,
            features: c.features,
            enableTextSelection: c.enableTextSelection
        })
    },
    getTableChunker: function() {
        return this.chunker || Ext.view.TableChunker
    },
    addRowCls: function(c, a) {
        var d = this.getNode(c);
        if (d) {
            Ext.fly(d).addCls(a)
        }
    },
    removeRowCls: function(c, a) {
        var d = this.getNode(c);
        if (d) {
            Ext.fly(d).removeCls(a)
        }
    },
    onRowSelect: function(a) {
        this.addRowCls(a, this.selectedItemCls)
    },
    onRowDeselect: function(c) {
        var a = this;
        a.removeRowCls(c, a.selectedItemCls);
        a.removeRowCls(c, a.focusedItemCls)
    },
    onCellSelect: function(c) {
        var a = this.getCellByPosition(c, true);
        if (a) {
            Ext.fly(a).addCls(this.selectedCellCls)
        }
    },
    onCellDeselect: function(c) {
        var a = this.getCellByPosition(c, true);
        if (a) {
            Ext.fly(a).removeCls(this.selectedCellCls)
        }
    },
    onCellFocus: function(a) {
        this.focusCell(a)
    },
    getCellByPosition: function(a, c) {
        if (a) {
            var d = this.getNode(a.row),
                e = this.headerCt.getHeaderAtIndex(a.column);
            if (e && d) {
                return Ext.fly(d).down(e.getCellSelector(), c)
            }
        }
        return false
    },
    onRowFocus: function(e, c, a) {
        var d = this;
        if (c) {
            d.addRowCls(e, d.focusedItemCls);
            if (!a) {
                d.focusRow(e)
            }
        } else {
            d.removeRowCls(e, d.focusedItemCls)
        }
    },
    focusRow: function(c) {
        var i = this,
            m = i.getNode(c),
            d = i.el,
            k = 0,
            a = i.ownerCt,
            l, j, g, e;
        if (m && d) {
            j = d.getY();
            g = j + d.dom.clientHeight;
            l = Ext.fly(m).getRegion();
            if (l.top < j) {
                k = l.top - j
            } else {
                if (l.bottom > g) {
                    k = l.bottom - g
                }
            }
            e = i.getRecord(m);
            c = i.store.indexOf(e);
            if (k) {
                a.scrollByDeltaY(k)
            }
            i.fireEvent("rowfocus", e, m, c)
        }
    },
    focusCell: function(j) {
        var l = this,
            m = l.getCellByPosition(j),
            c = l.el,
            e = 0,
            g = 0,
            d = c.getRegion(),
            a = l.ownerCt,
            k, i;
        d.bottom = d.top + c.dom.clientHeight;
        d.right = d.left + c.dom.clientWidth;
        if (m) {
            k = m.getRegion();
            if (k.top < d.top) {
                e = k.top - d.top
            } else {
                if (k.bottom > d.bottom) {
                    e = k.bottom - d.bottom
                }
            }
            if (k.left < d.left) {
                g = k.left - d.left
            } else {
                if (k.right > d.right) {
                    g = k.right - d.right
                }
            }
            if (e) {
                a.scrollByDeltaY(e)
            }
            if (g) {
                a.scrollByDeltaX(g)
            }
            c.focus();
            l.fireEvent("cellfocus", i, m, j)
        }
    },
    scrollByDelta: function(d, c) {
        c = c || "scrollTop";
        var a = this.el.dom;
        a[c] = (a[c] += d)
    },
    onUpdate: function(j, g, m, r) {
        var y = this,
            l, e, n, u, t, x, s, c, d, z, v, t, a, p, o, k, q = y.editingPlugin && y.editingPlugin.editing;
        if (y.viewReady) {
            l = y.store.indexOf(g);
            a = y.headerCt.getGridColumns();
            p = y.overItemCls;
            if (a.length && l > -1) {
                e = y.bufferRender([g], l)[0];
                s = y.all.item(l);
                if (s) {
                    c = s.dom;
                    o = s.hasCls(p);
                    if (c.mergeAttributes) {
                        c.mergeAttributes(e, true)
                    } else {
                        n = e.attributes;
                        u = n.length;
                        for (t = 0; t < u; t++) {
                            x = n[t].name;
                            if (x !== "id") {
                                c.setAttribute(x, n[t].value)
                            }
                        }
                    }
                    if (o) {
                        s.addCls(p)
                    }
                    d = s.query(y.cellSelector);
                    z = Ext.fly(e).query(y.cellSelector);
                    v = z.length;
                    k = d[0].parentNode;
                    for (t = 0; t < v; t++) {
                        if (y.shouldUpdateCell(a[t], r)) {
                            if (q) {
                                Ext.fly(d[t]).syncContent(z[t])
                            } else {
                                k.insertBefore(z[t], d[t]);
                                k.removeChild(d[t])
                            }
                        }
                    }
                }
                y.fireEvent("itemupdate", g, l, e)
            }
        }
    },
    shouldUpdateCell: function(c, a) {
        if (c.hasCustomRenderer) {
            return true
        }
        return !a || Ext.Array.contains(a, c.dataIndex)
    },
    refresh: function() {
        var a = this;
        a.setNewTemplate();
        a.callParent(arguments);
        a.doStripeRows(0);
        a.headerCt.setSortState()
    },
    clearViewEl: function() {
        this.callParent();
        delete this.table.dom
    },
    processItemEvent: function(c, o, l, g) {
        var j = this,
            m = g.getTarget(j.cellSelector, o),
            k = m ? m.cellIndex : -1,
            a = j.statics().EventMap,
            d = j.getSelectionModel(),
            i = g.type,
            n;
        if (i == "keydown" && !m && d.getCurrentPosition) {
            m = j.getCellByPosition(d.getCurrentPosition());
            if (m) {
                m = m.dom;
                k = m.cellIndex
            }
        }
        n = j.fireEvent("uievent", i, j, m, l, k, g, c, o);
        if (n === false || j.callParent(arguments) === false) {
            return false
        }
        if (i == "mouseover" || i == "mouseout") {
            return true
        }
        if (!m) {
            return true
        }
        return !((j["onBeforeCell" + a[i]](m, k, c, o, l, g) === false) || (j.fireEvent("beforecell" + i, j, m, k, c, o, l, g) === false) || (j["onCell" + a[i]](m, k, c, o, l, g) === false) || (j.fireEvent("cell" + i, j, m, k, c, o, l, g) === false))
    },
    processSpecialEvent: function(m) {
        var p = this,
            c = p.statics().EventMap,
            g = p.features,
            o = g.length,
            q = m.type,
            j, r, k, l, d, n, a = p.ownerCt;
        p.callParent(arguments);
        if (q == "mouseover" || q == "mouseout") {
            return
        }
        for (j = 0; j < o; j++) {
            r = g[j];
            if (r.hasFeatureEvent) {
                l = m.getTarget(r.eventSelector, p.getTargetEl());
                if (l) {
                    k = r.eventPrefix;
                    d = r.getFireEventArgs("before" + k + q, p, l, m);
                    n = r.getFireEventArgs(k + q, p, l, m);
                    if ((p.fireEvent.apply(p, d) === false) || (a.fireEvent.apply(a, d) === false) || (p.fireEvent.apply(p, n) === false) || (a.fireEvent.apply(a, n) === false)) {
                        return false
                    }
                }
            }
        }
        return true
    },
    onCellMouseDown: Ext.emptyFn,
    onCellMouseUp: Ext.emptyFn,
    onCellClick: Ext.emptyFn,
    onCellDblClick: Ext.emptyFn,
    onCellContextMenu: Ext.emptyFn,
    onCellKeyDown: Ext.emptyFn,
    onBeforeCellMouseDown: Ext.emptyFn,
    onBeforeCellMouseUp: Ext.emptyFn,
    onBeforeCellClick: Ext.emptyFn,
    onBeforeCellDblClick: Ext.emptyFn,
    onBeforeCellContextMenu: Ext.emptyFn,
    onBeforeCellKeyDown: Ext.emptyFn,
    expandToFit: function(c) {
        if (c) {
            var a = this.getMaxContentWidth(c);
            delete c.flex;
            c.setWidth(a)
        }
    },
    getMaxContentWidth: function(k) {
        var a = k.getCellInnerSelector(),
            d = this.el.query(a),
            e = 0,
            j = d.length,
            g = k.el.dom.scrollWidth,
            c;
        for (; e < j; e++) {
            c = d[e].scrollWidth;
            if (c > g) {
                g = c
            }
        }
        return g
    },
    getPositionByEvent: function(i) {
        var g = this,
            c = i.getTarget(g.cellSelector),
            d = i.getTarget(g.itemSelector),
            a = g.getRecord(d),
            j = g.getHeaderByCell(c);
        return g.getPosition(a, j)
    },
    getHeaderByCell: function(c) {
        if (c) {
            var a = c.className.match(this.cellRe);
            if (a && a[1]) {
                return Ext.getCmp(a[1])
            }
        }
        return false
    },
    walkCells: function(n, o, j, p, a, q) {
        if (!n) {
            return
        }
        var l = this,
            r = n.row,
            g = n.column,
            m = l.store.getCount(),
            i = l.getFirstVisibleColumnIndex(),
            c = l.getLastVisibleColumnIndex(),
            k = {
                row: r,
                column: g
            },
            d = l.headerCt.getHeaderAtIndex(g);
        if (!d || d.hidden) {
            return false
        }
        j = j || {};
        o = o.toLowerCase();
        switch (o) {
            case "right":
                if (g === c) {
                    if (p || r === m - 1) {
                        return false
                    }
                    if (!j.ctrlKey) {
                        k.row = r + 1;
                        k.column = i
                    }
                } else {
                    if (!j.ctrlKey) {
                        k.column = g + l.getRightGap(d)
                    } else {
                        k.column = c
                    }
                }
                break;
            case "left":
                if (g === i) {
                    if (p || r === 0) {
                        return false
                    }
                    if (!j.ctrlKey) {
                        k.row = r - 1;
                        k.column = c
                    }
                } else {
                    if (!j.ctrlKey) {
                        k.column = g + l.getLeftGap(d)
                    } else {
                        k.column = i
                    }
                }
                break;
            case "up":
                if (r === 0) {
                    return false
                } else {
                    if (!j.ctrlKey) {
                        k.row = r - 1
                    } else {
                        k.row = 0
                    }
                }
                break;
            case "down":
                if (r === m - 1) {
                    return false
                } else {
                    if (!j.ctrlKey) {
                        k.row = r + 1
                    } else {
                        k.row = m - 1
                    }
                }
                break
        }
        if (a && a.call(q || window, k) !== true) {
            return false
        } else {
            return k
        }
    },
    getFirstVisibleColumnIndex: function() {
        var a = this.getHeaderCt().getVisibleGridColumns()[0];
        return a ? a.getIndex() : -1
    },
    getLastVisibleColumnIndex: function() {
        var c = this.getHeaderCt().getVisibleGridColumns(),
            a = c[c.length - 1];
        return a.getIndex()
    },
    getHeaderCt: function() {
        return this.headerCt
    },
    getPosition: function(a, g) {
        var e = this,
            c = e.store,
            d = e.headerCt.getGridColumns();
        return {
            row: c.indexOf(a),
            column: Ext.Array.indexOf(d, g)
        }
    },
    getRightGap: function(a) {
        var j = this.getHeaderCt(),
            g = j.getGridColumns(),
            c = Ext.Array.indexOf(g, a),
            d = c + 1,
            e;
        for (; d <= g.length; d++) {
            if (!g[d].hidden) {
                e = d;
                break
            }
        }
        return e - c
    },
    beforeDestroy: function() {
        if (this.rendered) {
            this.el.removeAllListeners()
        }
        this.callParent(arguments)
    },
    getLeftGap: function(a) {
        var j = this.getHeaderCt(),
            g = j.getGridColumns(),
            d = Ext.Array.indexOf(g, a),
            e = d - 1,
            c;
        for (; e >= 0; e--) {
            if (!g[e].hidden) {
                c = e;
                break
            }
        }
        return c - d
    },
    onAdd: function(d, a, c) {
        this.callParent(arguments);
        this.doStripeRows(c)
    },
    onRemove: function(d, a, c) {
        this.callParent(arguments);
        this.doStripeRows(c)
    },
    doStripeRows: function(c, a) {
        var e = this,
            g, k, d, j;
        if (e.rendered && e.stripeRows) {
            g = e.getNodes(c, a);
            for (d = 0, k = g.length; d < k; d++) {
                j = g[d];
                j.className = j.className.replace(e.rowClsRe, " ");
                c++;
                if (c % 2 === 0) {
                    j.className += (" " + e.altRowCls)
                }
            }
        }
    }
});
Ext.define("Ext.data.NodeStore", {
    extend: "Ext.data.Store",
    alias: "store.node",
    requires: ["Ext.data.NodeInterface"],
    node: null,
    recursive: false,
    rootVisible: false,
    constructor: function(a) {
        var d = this,
            c;
        a = a || {};
        Ext.apply(d, a);
        a.proxy = {
            type: "proxy"
        };
        d.callParent([a]);
        c = d.node;
        if (c) {
            d.node = null;
            d.setNode(c)
        }
    },
    setNode: function(c) {
        var a = this;
        if (a.node && a.node != c) {
            a.mun(a.node, {
                expand: a.onNodeExpand,
                collapse: a.onNodeCollapse,
                append: a.onNodeAppend,
                insert: a.onNodeInsert,
                remove: a.onNodeRemove,
                sort: a.onNodeSort,
                scope: a
            });
            a.node = null
        }
        if (c) {
            Ext.data.NodeInterface.decorate(c.self);
            a.removeAll();
            if (a.rootVisible) {
                a.add(c)
            } else {
                if (!c.isExpanded() && a.treeStore.autoLoad !== false) {
                    c.expand()
                }
            }
            a.mon(c, {
                expand: a.onNodeExpand,
                collapse: a.onNodeCollapse,
                append: a.onNodeAppend,
                insert: a.onNodeInsert,
                remove: a.onNodeRemove,
                sort: a.onNodeSort,
                scope: a
            });
            a.node = c;
            if (c.isExpanded() && c.isLoaded()) {
                a.onNodeExpand(c, c.childNodes, true)
            }
        }
    },
    onNodeSort: function(c, d) {
        var a = this;
        if ((a.indexOf(c) !== -1 || (c === a.node && !a.rootVisible) && c.isExpanded())) {
            a.onNodeCollapse(c, d, true);
            a.onNodeExpand(c, d, true)
        }
    },
    onNodeExpand: function(j, e, d) {
        var l = this,
            a = l.indexOf(j) + 1,
            k = e ? e.length : 0,
            g, c;
        if (!l.recursive && j !== l.node) {
            return
        }
        if (j !== this.node && !l.isVisible(j)) {
            return
        }
        if (!d && l.fireEvent("beforeexpand", j, e, a) === false) {
            return
        }
        if (k) {
            l.insert(a, e);
            for (g = 0; g < k; g++) {
                c = e[g];
                if (c.isExpanded()) {
                    if (c.isLoaded()) {
                        l.onNodeExpand(c, c.childNodes, true)
                    } else {
                        c.set("expanded", false);
                        c.expand()
                    }
                }
            }
        }
        if (!d) {
            l.fireEvent("expand", j, e)
        }
    },
    onNodeCollapse: function(j, d, c) {
        var l = this,
            k = d.length,
            g = l.indexOf(j) + 1,
            e, a;
        if (!l.recursive && j !== l.node) {
            return
        }
        if (!c && l.fireEvent("beforecollapse", j, d, g) === false) {
            return
        }
        for (e = 0; e < k; e++) {
            a = d[e];
            l.remove(a);
            if (a.isExpanded()) {
                l.onNodeCollapse(a, a.childNodes, true)
            }
        }
        if (!c) {
            l.fireEvent("collapse", j, d, g)
        }
    },
    onNodeAppend: function(e, i, c) {
        var g = this,
            a, d;
        if (g.isVisible(i)) {
            if (c === 0) {
                a = e
            } else {
                d = i.previousSibling;
                while (d.isExpanded() && d.lastChild) {
                    d = d.lastChild
                }
                a = d
            }
            g.insert(g.indexOf(a) + 1, i);
            if (!i.isLeaf() && i.isExpanded()) {
                if (i.isLoaded()) {
                    g.onNodeExpand(i, i.childNodes, true)
                } else {
                    i.set("expanded", false);
                    i.expand()
                }
            }
        }
    },
    onNodeInsert: function(d, g, a) {
        var e = this,
            c = this.indexOf(a);
        if (c != -1 && e.isVisible(g)) {
            e.insert(c, g);
            if (!g.isLeaf() && g.isExpanded()) {
                if (g.isLoaded()) {
                    e.onNodeExpand(g, g.childNodes, true)
                } else {
                    g.set("expanded", false);
                    g.expand()
                }
            }
        }
    },
    onNodeRemove: function(c, e, a) {
        var d = this;
        if (d.indexOf(e) != -1) {
            if (!e.isLeaf() && e.isExpanded()) {
                d.onNodeCollapse(e, e.childNodes, true)
            }
            d.remove(e)
        }
    },
    isVisible: function(c) {
        var a = c.parentNode;
        while (a) {
            if (a === this.node && !this.rootVisible && a.isExpanded()) {
                return true
            }
            if (this.indexOf(a) === -1 || !a.isExpanded()) {
                return false
            }
            a = a.parentNode
        }
        return true
    }
});
Ext.define("Ext.tree.View", {
    extend: "Ext.view.Table",
    alias: "widget.treeview",
    requires: ["Ext.data.NodeStore"],
    loadingCls: Ext.baseCSSPrefix + "grid-tree-loading",
    expandedCls: Ext.baseCSSPrefix + "grid-tree-node-expanded",
    leafCls: Ext.baseCSSPrefix + "grid-tree-node-leaf",
    expanderSelector: "." + Ext.baseCSSPrefix + "tree-expander",
    checkboxSelector: "." + Ext.baseCSSPrefix + "tree-checkbox",
    expanderIconOverCls: Ext.baseCSSPrefix + "tree-expander-over",
    nodeAnimWrapCls: Ext.baseCSSPrefix + "tree-animator-wrap",
    blockRefresh: true,
    loadMask: false,
    rootVisible: true,
    deferInitialRefresh: false,
    expandDuration: 250,
    collapseDuration: 250,
    toggleOnDblClick: true,
    stripeRows: false,
    uiFields: ["expanded", "loaded", "checked", "expandable", "leaf", "icon", "iconCls", "loading", "qtip", "qtitle"],
    initComponent: function() {
        var a = this,
            c = a.panel.getStore();
        if (a.initialConfig.animate === undefined) {
            a.animate = Ext.enableFx
        }
        a.store = new Ext.data.NodeStore({
            treeStore: c,
            recursive: true,
            rootVisible: a.rootVisible,
            listeners: {
                beforeexpand: a.onBeforeExpand,
                expand: a.onExpand,
                beforecollapse: a.onBeforeCollapse,
                collapse: a.onCollapse,
                write: a.onStoreWrite,
                datachanged: a.onStoreDataChanged,
                scope: a
            }
        });
        if (a.node) {
            a.setRootNode(a.node)
        }
        a.animQueue = {};
        a.animWraps = {};
        a.addEvents("afteritemexpand", "afteritemcollapse");
        a.callParent(arguments);
        a.on({
            element: "el",
            scope: a,
            delegate: a.expanderSelector,
            mouseover: a.onExpanderMouseOver,
            mouseout: a.onExpanderMouseOut
        });
        a.on({
            element: "el",
            scope: a,
            delegate: a.checkboxSelector,
            click: a.onCheckboxChange
        })
    },
    getMaskStore: function() {
        return this.panel.getStore()
    },
    afterComponentLayout: function() {
        this.callParent(arguments);
        var a = this.stretcher;
        if (a) {
            a.setWidth((this.getWidth() - Ext.getScrollbarSize().width))
        }
    },
    processUIEvent: function(a) {
        if (a.getTarget("." + this.nodeAnimWrapCls, this.el)) {
            return false
        }
        return this.callParent(arguments)
    },
    onClear: function() {
        this.store.removeAll()
    },
    setRootNode: function(c) {
        var a = this;
        a.store.setNode(c);
        a.node = c
    },
    onCheckboxChange: function(g, a) {
        var d = this,
            c = g.getTarget(d.getItemSelector(), d.getTargetEl());
        if (c) {
            d.onCheckChange(d.getRecord(c))
        }
    },
    onCheckChange: function(a) {
        var c = a.get("checked");
        if (Ext.isBoolean(c)) {
            c = !c;
            a.set("checked", c);
            this.fireEvent("checkchange", a, c)
        }
    },
    getChecked: function() {
        var a = [];
        this.node.cascadeBy(function(c) {
            if (c.get("checked")) {
                a.push(c)
            }
        });
        return a
    },
    isItemChecked: function(a) {
        return a.get("checked")
    },
    createAnimWrap: function(l, m) {
        var j = "",
            g = this.panel.headerCt,
            c = g.getGridColumns(),
            k = 0,
            n = c.length,
            o, e = this.getNode(l),
            a, d;
        for (; k < n; k++) {
            o = c[k];
            j += '<th style="width: ' + (o.hidden ? 0 : o.getDesiredWidth()) + 'px; height: 0px;"></th>'
        }
        d = Ext.get(e);
        a = d.insertSibling({
            tag: "tr",
            html: ['<td colspan="' + g.getColumnCount() + '">', '<div class="' + this.nodeAnimWrapCls + '">', '<table class="' + Ext.baseCSSPrefix + 'grid-table" style="width: ' + g.getFullWidth() + 'px;"><tbody>', j, "</tbody></table>", "</div>", "</td>"].join("")
        }, "after");
        return {
            record: l,
            node: e,
            el: a,
            expanding: false,
            collapsing: false,
            animating: false,
            animateEl: a.down("div"),
            targetEl: a.down("tbody")
        }
    },
    getAnimWrap: function(e, a) {
        if (!this.animate) {
            return null
        }
        var c = this.animWraps,
            d = c[e.internalId];
        if (a !== false) {
            while (!d && e) {
                e = e.parentNode;
                if (e) {
                    d = c[e.internalId]
                }
            }
        }
        return d
    },
    doAdd: function(c, e, k) {
        var l = this,
            i = e[0],
            n = i.parentNode,
            m = l.all.elements,
            p = 0,
            g = l.getAnimWrap(n),
            o, d, j;
        if (!g || !g.expanding) {
            return l.callParent(arguments)
        }
        n = g.record;
        o = g.targetEl;
        d = o.dom.childNodes;
        j = d.length - 1;
        p = k - l.indexOf(n) - 1;
        if (!j || p >= j) {
            o.appendChild(c)
        } else {
            Ext.fly(d[p + 1]).insertSibling(c, "before", true)
        }
        Ext.Array.insert(m, k, c);
        if (g.isAnimating) {
            l.onExpand(n)
        }
    },
    beginBulkUpdate: function() {
        this.bulkUpdate = true
    },
    endBulkUpdate: function() {
        this.bulkUpdate = false
    },
    onRemove: function(g, a, c) {
        var e = this,
            d = e.bulkUpdate;
        if (e.viewReady) {
            e.doRemove(a, c);
            if (!d) {
                e.updateIndexes(c)
            }
            if (e.store.getCount() === 0) {
                e.refresh()
            }
            if (!d) {
                e.fireEvent("itemremove", a, c)
            }
        }
    },
    doRemove: function(a, d) {
        var j = this,
            e = j.all,
            c = j.getAnimWrap(a),
            i = e.item(d),
            g = i ? i.dom : null;
        if (!g || !c || !c.collapsing) {
            return j.callParent(arguments)
        }
        c.targetEl.appendChild(g);
        e.removeElement(d)
    },
    onBeforeExpand: function(e, c, d) {
        var g = this,
            a;
        if (!g.rendered || !g.animate) {
            return
        }
        if (g.getNode(e)) {
            a = g.getAnimWrap(e, false);
            if (!a) {
                a = g.animWraps[e.internalId] = g.createAnimWrap(e);
                a.animateEl.setHeight(0)
            } else {
                if (a.collapsing) {
                    a.targetEl.select(g.itemSelector).remove()
                }
            }
            a.expanding = true;
            a.collapsing = false
        }
    },
    onExpand: function(k) {
        var j = this,
            g = j.animQueue,
            a = k.getId(),
            d = j.getNode(k),
            i = d ? j.indexOf(d) : -1,
            e, c, l;
        if (j.singleExpand) {
            j.ensureSingleExpand(k)
        }
        if (i === -1) {
            return
        }
        e = j.getAnimWrap(k, false);
        if (!e) {
            j.isExpandingOrCollapsing = false;
            j.fireEvent("afteritemexpand", k, i, d);
            return
        }
        c = e.animateEl;
        l = e.targetEl;
        c.stopAnimation();
        g[a] = true;
        c.slideIn("t", {
            duration: j.expandDuration,
            listeners: {
                scope: j,
                lastframe: function() {
                    e.el.insertSibling(l.query(j.itemSelector), "before");
                    e.el.remove();
                    j.refreshSize();
                    delete j.animWraps[e.record.internalId];
                    delete g[a]
                }
            },
            callback: function() {
                j.isExpandingOrCollapsing = false;
                j.fireEvent("afteritemexpand", k, i, d)
            }
        });
        e.isAnimating = true
    },
    onBeforeCollapse: function(e, c, d) {
        var g = this,
            a;
        if (!g.rendered || !g.animate) {
            return
        }
        if (g.getNode(e)) {
            a = g.getAnimWrap(e);
            if (!a) {
                a = g.animWraps[e.internalId] = g.createAnimWrap(e, d)
            } else {
                if (a.expanding) {
                    a.targetEl.select(this.itemSelector).remove()
                }
            }
            a.expanding = false;
            a.collapsing = true
        }
    },
    onCollapse: function(k) {
        var j = this,
            g = j.animQueue,
            a = k.getId(),
            d = j.getNode(k),
            i = d ? j.indexOf(d) : -1,
            e = j.getAnimWrap(k),
            c, l;
        if (i === -1) {
            return
        }
        if (!e) {
            j.isExpandingOrCollapsing = false;
            j.fireEvent("afteritemcollapse", k, i, d);
            return
        }
        c = e.animateEl;
        l = e.targetEl;
        g[a] = true;
        c.stopAnimation();
        c.slideOut("t", {
            duration: j.collapseDuration,
            listeners: {
                scope: j,
                lastframe: function() {
                    e.el.remove();
                    j.refreshSize();
                    delete j.animWraps[e.record.internalId];
                    delete g[a]
                }
            },
            callback: function() {
                j.isExpandingOrCollapsing = false;
                j.fireEvent("afteritemcollapse", k, i, d)
            }
        });
        e.isAnimating = true
    },
    isAnimating: function(a) {
        return !!this.animQueue[a.getId()]
    },
    collectData: function(d) {
        var j = this.callParent(arguments),
            g = j.rows,
            a = g.length,
            e = 0,
            k, c;
        for (; e < a; e++) {
            k = g[e];
            c = d[e];
            if (c.get("qtip")) {
                k.rowAttr = 'data-qtip="' + c.get("qtip") + '"';
                if (c.get("qtitle")) {
                    k.rowAttr += ' data-qtitle="' + c.get("qtitle") + '"'
                }
            }
            if (c.isExpanded()) {
                k.rowCls = (k.rowCls || "") + " " + this.expandedCls
            }
            if (c.isLeaf()) {
                k.rowCls = (k.rowCls || "") + " " + this.leafCls
            }
            if (c.isLoading()) {
                k.rowCls = (k.rowCls || "") + " " + this.loadingCls
            }
        }
        return j
    },
    expand: function(c, a, e, d) {
        return c.expand(a, e, d)
    },
    collapse: function(c, a, e, d) {
        return c.collapse(a, e, d)
    },
    toggle: function(d, c, i, e) {
        var g = this,
            a = !!this.animate;
        if (!a || !this.isExpandingOrCollapsing) {
            if (!d.isLeaf()) {
                this.isExpandingOrCollapsing = a
            }
            if (d.isExpanded()) {
                g.collapse(d, c, i, e)
            } else {
                g.expand(d, c, i, e)
            }
        }
    },
    onItemDblClick: function(a, g, d) {
        var e = this,
            c = e.editingPlugin;
        e.callParent(arguments);
        if (e.toggleOnDblClick && a.isExpandable() && !(c && c.clicksToEdit === 2)) {
            e.toggle(a)
        }
    },
    onBeforeItemMouseDown: function(a, d, c, g) {
        if (g.getTarget(this.expanderSelector, d)) {
            return false
        }
        return this.callParent(arguments)
    },
    onItemClick: function(a, d, c, g) {
        if (g.getTarget(this.expanderSelector, d) && a.isExpandable()) {
            this.toggle(a, g.ctrlKey);
            return false
        }
        return this.callParent(arguments)
    },
    onExpanderMouseOver: function(c, a) {
        c.getTarget(this.cellSelector, 10, true).addCls(this.expanderIconOverCls)
    },
    onExpanderMouseOut: function(c, a) {
        c.getTarget(this.cellSelector, 10, true).removeCls(this.expanderIconOverCls)
    },
    getTreeStore: function() {
        return this.panel.store
    },
    ensureSingleExpand: function(c) {
        var a = c.parentNode;
        if (a) {
            a.eachChild(function(d) {
                if (d !== c && d.isExpanded()) {
                    d.collapse()
                }
            })
        }
    },
    shouldUpdateCell: function(e, d) {
        if (d) {
            var c = 0,
                a = d.length;
            for (; c < a; ++c) {
                if (Ext.Array.contains(this.uiFields, d[c])) {
                    return true
                }
            }
        }
        return this.callParent(arguments)
    },
    onStoreWrite: function(c, a) {
        var d = this.panel.store;
        d.fireEvent("write", d, a)
    },
    onStoreDataChanged: function(c, a) {
        var d = this.panel.store;
        d.fireEvent("datachanged", d)
    }
});
Ext.define("Ext.selection.RowModel", {
    extend: "Ext.selection.Model",
    alias: "selection.rowmodel",
    requires: ["Ext.util.KeyNav"],
    deltaScroll: 5,
    enableKeyNav: true,
    ignoreRightMouseSelection: false,
    constructor: function() {
        this.addEvents("beforedeselect", "beforeselect", "deselect", "select");
        this.views = [];
        this.callParent(arguments)
    },
    bindComponent: function(a) {
        var c = this;
        c.views = c.views || [];
        c.views.push(a);
        c.bindStore(a.getStore(), true);
        a.on({
            itemmousedown: c.onRowMouseDown,
            scope: c
        });
        if (c.enableKeyNav) {
            c.initKeyNav(a)
        }
    },
    initKeyNav: function(a) {
        var c = this;
        if (!a.rendered) {
            a.on("render", Ext.Function.bind(c.initKeyNav, c, [a], 0), c, {
                single: true
            });
            return
        }
        a.el.set({
            tabIndex: -1
        });
        c.keyNav = new Ext.util.KeyNav({
            target: a,
            ignoreInputFields: true,
            eventName: "itemkeydown",
            processEvent: function(e, d, j, g, i) {
                i.record = d;
                i.recordIndex = g;
                return i
            },
            up: c.onKeyUp,
            down: c.onKeyDown,
            right: c.onKeyRight,
            left: c.onKeyLeft,
            pageDown: c.onKeyPageDown,
            pageUp: c.onKeyPageUp,
            home: c.onKeyHome,
            end: c.onKeyEnd,
            space: c.onKeySpace,
            enter: c.onKeyEnter,
            scope: c
        })
    },
    getRowsVisible: function() {
        var g = false,
            a = this.views[0],
            e = a.getNode(0),
            c, d;
        if (e) {
            c = Ext.fly(e).getHeight();
            d = a.el.getHeight();
            g = Math.floor(d / c)
        }
        return g
    },
    onKeyEnd: function(d) {
        var c = this,
            a = c.store.getAt(c.store.getCount() - 1);
        if (a) {
            if (d.shiftKey) {
                c.selectRange(a, c.lastFocused || 0);
                c.setLastFocused(a)
            } else {
                if (d.ctrlKey) {
                    c.setLastFocused(a)
                } else {
                    c.doSelect(a)
                }
            }
        }
    },
    onKeyHome: function(c) {
        var a = this,
            d = a.store.getAt(0);
        if (d) {
            if (c.shiftKey) {
                a.selectRange(d, a.lastFocused || 0);
                a.setLastFocused(d)
            } else {
                if (c.ctrlKey) {
                    a.setLastFocused(d)
                } else {
                    a.doSelect(d, false)
                }
            }
        }
    },
    onKeyPageUp: function(i) {
        var g = this,
            j = g.getRowsVisible(),
            c, d, a;
        if (j) {
            c = i.recordIndex;
            d = c - j;
            if (d < 0) {
                d = 0
            }
            a = g.store.getAt(d);
            if (i.shiftKey) {
                g.selectRange(a, i.record, i.ctrlKey, "up");
                g.setLastFocused(a)
            } else {
                if (i.ctrlKey) {
                    i.preventDefault();
                    g.setLastFocused(a)
                } else {
                    g.doSelect(a)
                }
            }
        }
    },
    onKeyPageDown: function(i) {
        var d = this,
            j = d.getRowsVisible(),
            a, g, c;
        if (j) {
            a = i.recordIndex;
            g = a + j;
            if (g >= d.store.getCount()) {
                g = d.store.getCount() - 1
            }
            c = d.store.getAt(g);
            if (i.shiftKey) {
                d.selectRange(c, i.record, i.ctrlKey, "down");
                d.setLastFocused(c)
            } else {
                if (i.ctrlKey) {
                    i.preventDefault();
                    d.setLastFocused(c)
                } else {
                    d.doSelect(c)
                }
            }
        }
    },
    onKeySpace: function(d) {
        var c = this,
            a = c.lastFocused;
        if (a) {
            if (c.isSelected(a)) {
                c.doDeselect(a, false)
            } else {
                c.doSelect(a, true)
            }
        }
    },
    onKeyEnter: Ext.emptyFn,
    onKeyUp: function(g) {
        var d = this,
            a = d.store.indexOf(d.lastFocused),
            c;
        if (a > 0) {
            c = d.store.getAt(a - 1);
            if (g.shiftKey && d.lastFocused) {
                if (d.isSelected(d.lastFocused) && d.isSelected(c)) {
                    d.doDeselect(d.lastFocused, true);
                    d.setLastFocused(c)
                } else {
                    if (!d.isSelected(d.lastFocused)) {
                        d.doSelect(d.lastFocused, true);
                        d.doSelect(c, true)
                    } else {
                        d.doSelect(c, true)
                    }
                }
            } else {
                if (g.ctrlKey) {
                    d.setLastFocused(c)
                } else {
                    d.doSelect(c)
                }
            }
        }
    },
    onKeyDown: function(g) {
        var d = this,
            a = d.store.indexOf(d.lastFocused),
            c;
        if (a + 1 < d.store.getCount()) {
            c = d.store.getAt(a + 1);
            if (d.selected.getCount() === 0) {
                if (!g.ctrlKey) {
                    d.doSelect(c)
                } else {
                    d.setLastFocused(c)
                }
            } else {
                if (g.shiftKey && d.lastFocused) {
                    if (d.isSelected(d.lastFocused) && d.isSelected(c)) {
                        d.doDeselect(d.lastFocused, true);
                        d.setLastFocused(c)
                    } else {
                        if (!d.isSelected(d.lastFocused)) {
                            d.doSelect(d.lastFocused, true);
                            d.doSelect(c, true)
                        } else {
                            d.doSelect(c, true)
                        }
                    }
                } else {
                    if (g.ctrlKey) {
                        d.setLastFocused(c)
                    } else {
                        d.doSelect(c)
                    }
                }
            }
        }
    },
    scrollByDeltaX: function(e) {
        var a = this.views[0],
            d = a.up(),
            c = d.horizontalScroller;
        if (c) {
            c.scrollByDeltaX(e)
        }
    },
    onKeyLeft: function(a) {
        this.scrollByDeltaX(-this.deltaScroll)
    },
    onKeyRight: function(a) {
        this.scrollByDeltaX(this.deltaScroll)
    },
    onRowMouseDown: function(c, a, g, d, i) {
        if (!this.allowRightMouseSelection(i)) {
            return
        }
        if (i.button === 0 || !this.isSelected(a)) {
            this.selectWithEvent(a, i)
        }
    },
    allowRightMouseSelection: function(a) {
        var c = this.ignoreRightMouseSelection && a.button !== 0;
        if (c) {
            c = this.hasSelection()
        }
        return !c
    },
    onSelectChange: function(j, d, n, a) {
        var l = this,
            o = l.views,
            e = o.length,
            m = l.store,
            c = m.indexOf(j),
            k = d ? "select" : "deselect",
            g = 0;
        if ((n || l.fireEvent("before" + k, l, j, c)) !== false && a() !== false) {
            for (; g < e; g++) {
                if (d) {
                    o[g].onRowSelect(c, n)
                } else {
                    o[g].onRowDeselect(c, n)
                }
            }
            if (!n) {
                l.fireEvent(k, l, j, c)
            }
        }
    },
    onLastFocusChanged: function(l, e, c) {
        var a = this.views,
            k = a.length,
            d = this.store,
            j, g = 0;
        if (l) {
            j = d.indexOf(l);
            if (j != -1) {
                for (; g < k; g++) {
                    a[g].onRowFocus(j, false)
                }
            }
        }
        if (e) {
            j = d.indexOf(e);
            if (j != -1) {
                for (g = 0; g < k; g++) {
                    a[g].onRowFocus(j, true, c)
                }
            }
        }
        this.callParent()
    },
    onEditorTab: function(g, k) {
        var i = this,
            d = i.views[0],
            c = g.getActiveRecord(),
            l = g.getActiveColumn(),
            a = d.getPosition(c, l),
            j = k.shiftKey ? "left" : "right";
        do {
            a = d.walkCells(a, j, k, i.preventWrap)
        } while (a && !d.headerCt.getHeaderAtIndex(a.column).getEditor());
        if (a) {
            g.startEditByPosition(a)
        }
    },
    getCurrentPosition: function() {
        var a = this.selected.items[0];
        if (a) {
            return {
                row: this.store.indexOf(a),
                column: 0
            }
        }
    },
    selectByPosition: function(a) {
        var c = this.store.getAt(a.row);
        this.select(c)
    },
    selectNext: function(j, d) {
        var i = this,
            c = i.store,
            g = i.getSelection(),
            a = g[g.length - 1],
            e = c.indexOf(a) + 1,
            k;
        if (e === c.getCount() || e === 0) {
            k = false
        } else {
            i.doSelect(e, j, d);
            k = true
        }
        return k
    },
    selectPrevious: function(i, c) {
        var g = this,
            e = g.getSelection(),
            a = e[0],
            d = g.store.indexOf(a) - 1,
            j;
        if (d < 0) {
            j = false
        } else {
            g.doSelect(d, i, c);
            j = true
        }
        return j
    }
});
Ext.define("Ext.selection.TreeModel", {
    extend: "Ext.selection.RowModel",
    alias: "selection.treemodel",
    pruneRemoved: false,
    onKeyRight: function(g, c) {
        var d = this.getLastFocused(),
            a = this.view;
        if (d) {
            if (d.isExpanded()) {
                this.onKeyDown(g, c)
            } else {
                if (d.isExpandable()) {
                    a.expand(d)
                }
            }
        }
    },
    onKeyLeft: function(k, g) {
        var j = this.getLastFocused(),
            d = this.view,
            c = d.getSelectionModel(),
            a, i;
        if (j) {
            a = j.parentNode;
            if (j.isExpanded()) {
                d.collapse(j)
            } else {
                if (a && !a.isRoot()) {
                    if (k.shiftKey) {
                        c.selectRange(a, j, k.ctrlKey, "up");
                        c.setLastFocused(a)
                    } else {
                        if (k.ctrlKey) {
                            c.setLastFocused(a)
                        } else {
                            c.select(a)
                        }
                    }
                }
            }
        }
    },
    onKeySpace: function(c, a) {
        this.toggleCheck(c)
    },
    onKeyEnter: function(c, a) {
        this.toggleCheck(c)
    },
    toggleCheck: function(c) {
        c.stopEvent();
        var a = this.getLastSelected();
        if (a) {
            this.view.onCheckChange(a)
        }
    }
});
Ext.define("Ext.tree.Panel", {
    extend: "Ext.panel.Table",
    alias: "widget.treepanel",
    alternateClassName: ["Ext.tree.TreePanel", "Ext.TreePanel"],
    requires: ["Ext.tree.View", "Ext.selection.TreeModel", "Ext.tree.Column", "Ext.data.TreeStore"],
    viewType: "treeview",
    selType: "treemodel",
    treeCls: Ext.baseCSSPrefix + "tree-panel",
    deferRowRender: false,
    rowLines: false,
    lines: true,
    useArrows: false,
    singleExpand: false,
    ddConfig: {
        enableDrag: true,
        enableDrop: true
    },
    rootVisible: true,
    displayField: "text",
    root: null,
    normalCfgCopy: ["displayField", "root", "singleExpand", "useArrows", "lines", "rootVisible", "scroll"],
    lockedCfgCopy: ["displayField", "root", "singleExpand", "useArrows", "lines", "rootVisible"],
    isTree: true,
    constructor: function(a) {
        a = a || {};
        if (a.animate === undefined) {
            a.animate = Ext.isDefined(this.animate) ? this.animate : Ext.enableFx
        }
        this.enableAnimations = a.animate;
        delete a.animate;
        this.callParent([a])
    },
    initComponent: function() {
        var d = this,
            c = [d.treeCls],
            a;
        if (d.useArrows) {
            c.push(Ext.baseCSSPrefix + "tree-arrows");
            d.lines = false
        }
        if (d.lines) {
            c.push(Ext.baseCSSPrefix + "tree-lines")
        } else {
            if (!d.useArrows) {
                c.push(Ext.baseCSSPrefix + "tree-no-lines")
            }
        }
        if (Ext.isString(d.store)) {
            d.store = Ext.StoreMgr.lookup(d.store)
        } else {
            if (!d.store || Ext.isObject(d.store) && !d.store.isStore) {
                d.store = new Ext.data.TreeStore(Ext.apply({}, d.store || {}, {
                    root: d.root,
                    fields: d.fields,
                    model: d.model,
                    folderSort: d.folderSort
                }))
            } else {
                if (d.root) {
                    d.store = Ext.data.StoreManager.lookup(d.store);
                    d.store.setRootNode(d.root);
                    if (d.folderSort !== undefined) {
                        d.store.folderSort = d.folderSort;
                        d.store.sort()
                    }
                }
            }
        }
        d.viewConfig = Ext.apply({}, d.viewConfig);
        d.viewConfig = Ext.applyIf(d.viewConfig, {
            rootVisible: d.rootVisible,
            animate: d.enableAnimations,
            singleExpand: d.singleExpand,
            node: d.store.getRootNode(),
            hideHeaders: d.hideHeaders
        });
        d.mon(d.store, {
            scope: d,
            rootchange: d.onRootChange,
            clear: d.onClear
        });
        d.relayEvents(d.store, ["beforeload", "load"]);
        d.mon(d.store, {
            append: d.createRelayer("itemappend"),
            remove: d.createRelayer("itemremove"),
            move: d.createRelayer("itemmove", [0, 4]),
            insert: d.createRelayer("iteminsert"),
            beforeappend: d.createRelayer("beforeitemappend"),
            beforeremove: d.createRelayer("beforeitemremove"),
            beforemove: d.createRelayer("beforeitemmove"),
            beforeinsert: d.createRelayer("beforeiteminsert"),
            expand: d.createRelayer("itemexpand", [0, 1]),
            collapse: d.createRelayer("itemcollapse", [0, 1]),
            beforeexpand: d.createRelayer("beforeitemexpand", [0, 1]),
            beforecollapse: d.createRelayer("beforeitemcollapse", [0, 1])
        });
        if (!d.columns) {
            if (d.initialConfig.hideHeaders === undefined) {
                d.hideHeaders = true
            }
            d.addCls(Ext.baseCSSPrefix + "autowidth-table");
            d.columns = [{
                xtype: "treecolumn",
                text: "Name",
                width: Ext.isIE6 ? null : 10000,
                dataIndex: d.displayField
            }]
        }
        if (d.cls) {
            c.push(d.cls)
        }
        d.cls = c.join(" ");
        d.callParent();
        a = d.getView();
        d.relayEvents(a, ["checkchange", "afteritemexpand", "afteritemcollapse"]);
        if (!a.rootVisible && !d.getRootNode()) {
            d.setRootNode({
                expanded: true
            })
        }
    },
    onClear: function() {
        this.view.onClear()
    },
    setRootNode: function() {
        return this.store.setRootNode.apply(this.store, arguments)
    },
    getRootNode: function() {
        return this.store.getRootNode()
    },
    onRootChange: function(a) {
        this.view.setRootNode(a)
    },
    getChecked: function() {
        return this.getView().getChecked()
    },
    isItemChecked: function(a) {
        return a.get("checked")
    },
    expandNode: function(c, a, e, d) {
        return this.getView().expand(c, a, e, d || this)
    },
    collapseNode: function(c, a, e, d) {
        return this.getView().collapse(c, a, e, d || this)
    },
    expandAll: function(i, e) {
        var g = this,
            c = g.getRootNode(),
            d = g.enableAnimations,
            a = g.getView();
        if (c) {
            if (!d) {
                a.beginBulkUpdate()
            }
            c.expand(true, i, e || g);
            if (!d) {
                a.endBulkUpdate()
            }
        }
    },
    collapseAll: function(i, e) {
        var g = this,
            c = g.getRootNode(),
            d = g.enableAnimations,
            a = g.getView();
        if (c) {
            if (!d) {
                a.beginBulkUpdate()
            }
            e = e || g;
            if (a.rootVisible) {
                c.collapse(true, i, e)
            } else {
                c.collapseChildren(true, i, e)
            }
            if (!d) {
                a.endBulkUpdate()
            }
        }
    },
    expandPath: function(n, i, a, j, m) {
        var e = this,
            d = e.getRootNode(),
            c = 1,
            g = e.getView(),
            l, k;
        i = i || e.getRootNode().idProperty;
        a = a || "/";
        if (Ext.isEmpty(n)) {
            Ext.callback(j, m || e, [false, null]);
            return
        }
        l = n.split(a);
        if (d.get(i) != l[1]) {
            Ext.callback(j, m || e, [false, d]);
            return
        }
        k = function() {
            if (++c === l.length) {
                Ext.callback(j, m || e, [true, d]);
                return
            }
            var o = d.findChild(i, l[c]);
            if (!o) {
                Ext.callback(j, m || e, [false, d]);
                return
            }
            d = o;
            d.expand(false, k)
        };
        d.expand(false, k)
    },
    selectPath: function(l, e, a, i, k) {
        var c = this,
            d, j, g;
        e = e || c.getRootNode().idProperty;
        a = a || "/";
        j = l.split(a);
        g = j.pop();
        if (j.length > 1) {
            c.expandPath(j.join(a), e, a, function(o, n) {
                var m = n;
                if (o && n) {
                    n = n.findChild(e, g);
                    if (n) {
                        c.getSelectionModel().select(n);
                        Ext.callback(i, k || c, [true, n]);
                        return
                    }
                }
                Ext.callback(i, k || c, [false, m])
            }, c)
        } else {
            d = c.getRootNode();
            if (d.getId() === g) {
                c.getSelectionModel().select(d);
                Ext.callback(i, k || c, [true, d])
            } else {
                Ext.callback(i, k || c, [false, null])
            }
        }
    }
});
Ext.define("DemoApp.view.JourneyNavigator", {
    extend: "Ext.tree.Panel",
    alias: "widget.journeyNavigator",
    rootVisible: false,
    useArrows: true,
    store: "PlanChunks",
    id: "journeyNavigator",
    columns: [{
        xtype: "treecolumn",
        text: "Activity",
        sortable: false,
        dataIndex: "label",
        flex: 1,
        height: 32
    }, {
        text: "Start",
        dataIndex: "start",
        xtype: "datecolumn",
        format: "h:i A",
        width: 60
    }, {
        text: "Dist.",
        dataIndex: "distance",
        align: "right",
        width: 50
    }]
});
Ext.define("DemoApp.view.MapOptionsView", {
    extend: "Ext.panel.Panel",
    alias: "widget.mapOptions",
    layout: {
        type: "hbox"
    },
    defaults: {
        margin: 1,
        padding: 0,
        border: 0,
        scale: "large",
        disabled: true
    },
    items: [{
        xtype: "button",
        action: "rematch",
        iconCls: "refresh-track",
        tooltip: "Run another track",
        margin: "4 1 1 1",
        disabled: false
    }, {
        xtype: "button",
        action: "resetview",
        iconCls: "gohome",
        tooltip: "Reset view",
        margin: "4 1 1 1"
    }, {
        xtype: "button",
        iconCls: "zoom-link",
        action: "autozoom",
        enableToggle: true,
        pressed: true,
        tooltip: "Auto zoom on focused street",
        border: 1,
        padding: 2
    }, {
        xtype: "button",
        id: "gpxswitch",
        iconCls: "gpspin",
        tooltip: "Toggle display of GPX points",
        action: "switchGPX",
        enableToggle: true,
        pressed: true,
        border: 1,
        padding: 2
    }, {
        xtype: "button",
        iconCls: "highway",
        tooltip: "Toggle display of matched road sections",
        action: "switchMM",
        enableToggle: true,
        pressed: true,
        border: 1,
        padding: 2
    }, {
        xtype: "button",
        id: "qualitysmile",
        iconCls: "smiley-happy",
        tooltip: "Matching quality",
        margin: "4 1 1 1"
    }, {
        xtype: "button",
        id: "showinfo",
        iconCls: "showinfo2",
        tooltip: "Matching process",
        margin: "4 1 1 1"
    }]
});
Ext.define("DemoApp.view.ResultView", {
    extend: "Ext.panel.Panel",
    requires: ["DemoApp.view.OSMMap", "DemoApp.view.JourneyNavigator", "DemoApp.view.MapOptionsView"],
    layout: "border",
    alias: "widget.result",
    initComponent: function() {
        this.items = [{
            xtype: "panel",
            layout: "vbox",
            width: "30%",
            region: "west",
            collapsible: false,
            split: true,
            title: '<A href="http://mapmatching.3scale.net" target="mm3">TrackMatching</A> demo',
            icon: "resources/css/icons/marker-ala-3scale.png",
            items: [{
                width: "100%",
                xtype: "mapOptions",
                flex: 0
            }, {
                title: "Journey",
                flex: 1,
                width: "100%",
                xtype: "journeyNavigator"
            }]
        }, {
            region: "center",
            xtype: "tabpanel",
            activeTab: 0,
            xtype: "gx_osmmap"
        }];
        this.callParent()
    }
});
Ext.define("DemoApp.view.Viewport", {
    renderTo: Ext.getBody(),
    extend: "Ext.container.Viewport",
    requires: ["DemoApp.view.ResultView"],
    layout: {
        type: "border"
    },
    items: [{
        region: "center",
        xtype: "result"
    }]
});
Ext.define("Ext.layout.container.Column", {
    extend: "Ext.layout.container.Container",
    alias: ["layout.column"],
    alternateClassName: "Ext.layout.ColumnLayout",
    type: "column",
    itemCls: Ext.baseCSSPrefix + "column",
    targetCls: Ext.baseCSSPrefix + "column-layout-ct",
    columnWidthSizePolicy: {
        setsWidth: 1,
        setsHeight: 0
    },
    childEls: ["innerCt"],
    manageOverflow: 2,
    renderTpl: ['<div id="{ownerId}-innerCt" class="', Ext.baseCSSPrefix, 'column-inner">', "{%this.renderBody(out,values)%}", '<div class="', Ext.baseCSSPrefix, 'clear"></div>', "</div>", "{%this.renderPadder(out,values)%}"],
    getItemSizePolicy: function(a) {
        if (a.columnWidth) {
            return this.columnWidthSizePolicy
        }
        return this.autoSizePolicy
    },
    beginLayout: function() {
        this.callParent(arguments);
        this.innerCt.dom.style.width = ""
    },
    calculate: function(d) {
        var a = this,
            e = a.getContainerSize(d),
            c = d.state;
        if (c.calculatedColumns || (c.calculatedColumns = a.calculateColumns(d))) {
            if (a.calculateHeights(d)) {
                a.calculateOverflow(d, e);
                return
            }
        }
        a.done = false
    },
    calculateColumns: function(e) {
        var o = this,
            a = o.getContainerSize(e),
            q = e.getEl("innerCt", o),
            n = e.childItems,
            l = n.length,
            c = 0,
            j, p, g, d, k, m;
        if (!e.heightModel.shrinkWrap && !e.targetContext.hasProp("height")) {
            return false
        }
        if (!a.gotWidth) {
            e.targetContext.block(o, "width");
            j = true
        } else {
            p = a.width;
            q.setWidth(p)
        }
        for (g = 0; g < l; ++g) {
            d = n[g];
            k = d.getMarginInfo().width;
            if (!d.widthModel.calculated) {
                m = d.getProp("width");
                if (typeof m != "number") {
                    d.block(o, "width");
                    j = true
                }
                c += m + k
            }
        }
        if (!j) {
            p = (p < c) ? 0 : p - c;
            for (g = 0; g < l; ++g) {
                d = n[g];
                if (d.widthModel.calculated) {
                    k = d.marginInfo.width;
                    m = d.target.columnWidth;
                    m = Math.floor(m * p) - k;
                    m = d.setWidth(m);
                    c += m + k
                }
            }
            e.setContentWidth(c)
        }
        return !j
    },
    calculateHeights: function(k) {
        var j = this,
            c = k.childItems,
            a = c.length,
            d, e, g;
        d = false;
        for (e = 0; e < a; ++e) {
            g = c[e];
            if (!g.hasDomProp("height")) {
                g.domBlock(j, "height");
                d = true
            }
        }
        if (!d) {
            k.setContentHeight(j.innerCt.getHeight() + k.targetContext.getPaddingInfo().height)
        }
        return !d
    },
    finishedLayout: function(a) {
        var c = a.bodyContext;
        if (c && (Ext.isIE6 || Ext.isIE7 || Ext.isIEQuirks)) {
            c.el.repaint()
        }
        this.callParent(arguments)
    },
    getRenderTarget: function() {
        return this.innerCt
    }
});
Ext.define("Ext.layout.component.field.Field", {
    extend: "Ext.layout.component.Auto",
    alias: "layout.field",
    uses: ["Ext.tip.QuickTip", "Ext.util.TextMetrics", "Ext.util.CSS"],
    type: "field",
    naturalSizingProp: "size",
    beginLayout: function(i) {
        var g = this,
            a = g.owner,
            d = i.widthModel,
            c = a[g.naturalSizingProp],
            e;
        g.callParent(arguments);
        i.labelStrategy = g.getLabelStrategy();
        i.errorStrategy = g.getErrorStrategy();
        i.labelContext = i.getEl("labelEl");
        i.bodyCellContext = i.getEl("bodyEl");
        i.inputContext = i.getEl("inputEl");
        i.errorContext = i.getEl("errorEl");
        if ((Ext.isIE6 || Ext.isIE7) && Ext.isStrict && i.inputContext) {
            g.ieInputWidthAdjustment = i.inputContext.getPaddingInfo().width + i.inputContext.getBorderInfo().width
        }
        i.labelStrategy.prepare(i, a);
        i.errorStrategy.prepare(i, a);
        if (d.shrinkWrap) {
            g.beginLayoutShrinkWrap(i)
        } else {
            if (d.natural) {
                if (typeof c == "number" && !a.inputWidth) {
                    g.beginLayoutFixed(i, (e = c * 6.5 + 20), "px")
                } else {
                    g.beginLayoutShrinkWrap(i)
                }
                i.setWidth(e, false)
            } else {
                g.beginLayoutFixed(i, "100", "%")
            }
        }
    },
    beginLayoutFixed: function(d, c, g) {
        var a = d.target,
            e = a.inputEl,
            i = a.inputWidth;
        a.el.setStyle("table-layout", "fixed");
        a.bodyEl.setStyle("width", c + g);
        if (e && i) {
            e.setStyle("width", i + "px")
        }
        d.isFixed = true
    },
    beginLayoutShrinkWrap: function(c) {
        var a = c.target,
            d = a.inputEl,
            e = a.inputWidth;
        if (d && d.dom) {
            d.dom.removeAttribute("size");
            if (e) {
                d.setStyle("width", e + "px")
            }
        }
        a.el.setStyle("table-layout", "auto");
        a.bodyEl.setStyle("width", "")
    },
    finishedLayout: function(c) {
        var a = this.owner;
        this.callParent(arguments);
        c.labelStrategy.finishedLayout(c, a);
        c.errorStrategy.finishedLayout(c, a)
    },
    calculateOwnerHeightFromContentHeight: function(c, a) {
        return a
    },
    measureContentHeight: function(a) {
        return a.el.getHeight()
    },
    measureContentWidth: function(a) {
        return a.el.getWidth()
    },
    measureLabelErrorHeight: function(a) {
        return a.labelStrategy.getHeight(a) + a.errorStrategy.getHeight(a)
    },
    onFocus: function() {
        this.getErrorStrategy().onFocus(this.owner)
    },
    getLabelStrategy: function() {
        var c = this,
            d = c.labelStrategies,
            a = c.owner.labelAlign;
        return d[a] || d.base
    },
    getErrorStrategy: function() {
        var d = this,
            a = d.owner,
            e = d.errorStrategies,
            c = a.msgTarget;
        return !a.preventMark && Ext.isString(c) ? (e[c] || e.elementId) : e.none
    },
    labelStrategies: (function() {
        var a = {
            prepare: function(g, c) {
                var d = c.labelCls + "-" + c.labelAlign,
                    e = c.labelEl;
                if (e) {
                    e.addCls(d)
                }
            },
            getHeight: function() {
                return 0
            },
            finishedLayout: Ext.emptyFn
        };
        return {
            base: a,
            top: Ext.applyIf({
                getHeight: function(g) {
                    var d = g.labelContext,
                        e = d.props,
                        c = e.height;
                    if (c === undefined) {
                        e.height = c = d.el.getHeight()
                    }
                    return c
                }
            }, a),
            left: a,
            right: a
        }
    }()),
    errorStrategies: (function() {
        function e(j) {
            var k = Ext.layout.component.field.Field.tip,
                l;
            if (k && k.isVisible()) {
                l = k.activeTarget;
                if (l && l.el === j.getActionEl().dom) {
                    k.toFront(true)
                }
            }
        }
        var d = Ext.applyIf,
            c = Ext.emptyFn,
            a = Ext.baseCSSPrefix + "form-invalid-icon",
            i, g = {
                prepare: function(l, j) {
                    var k = j.errorEl;
                    if (k) {
                        k.setDisplayed(false)
                    }
                },
                getHeight: function() {
                    return 0
                },
                onFocus: c,
                finishedLayout: c
            };
        return {
            none: g,
            side: d({
                prepare: function(m, k) {
                    var o = k.errorEl,
                        l = k.sideErrorCell,
                        j = k.hasActiveError(),
                        n;
                    if (!i) {
                        i = (n = Ext.getBody().createChild({
                            style: "position:absolute",
                            cls: a
                        })).getWidth();
                        n.remove()
                    }
                    o.addCls(a);
                    o.set({
                        "data-errorqtip": k.getActiveError() || ""
                    });
                    if (k.autoFitErrors) {
                        o.setDisplayed(j)
                    } else {
                        o.setVisible(j)
                    }
                    if (l && k.autoFitErrors) {
                        l.setDisplayed(j)
                    }
                    k.bodyEl.dom.colSpan = k.getBodyColspan();
                    Ext.layout.component.field.Field.initTip()
                },
                onFocus: e
            }, g),
            under: d({
                prepare: function(l, j) {
                    var m = j.errorEl,
                        k = Ext.baseCSSPrefix + "form-invalid-under";
                    m.addCls(k);
                    m.setDisplayed(j.hasActiveError())
                },
                getHeight: function(m) {
                    var j = 0,
                        k, l;
                    if (m.target.hasActiveError()) {
                        k = m.errorContext;
                        l = k.props;
                        j = l.height;
                        if (j === undefined) {
                            l.height = j = k.el.getHeight()
                        }
                    }
                    return j
                }
            }, g),
            qtip: d({
                prepare: function(k, j) {
                    Ext.layout.component.field.Field.initTip();
                    j.getActionEl().set({
                        "data-errorqtip": j.getActiveError() || ""
                    })
                },
                onFocus: e
            }, g),
            title: d({
                prepare: function(k, j) {
                    j.el.set({
                        title: j.getActiveError() || ""
                    })
                }
            }, g),
            elementId: d({
                prepare: function(k, j) {
                    var l = Ext.fly(j.msgTarget);
                    if (l) {
                        l.dom.innerHTML = j.getActiveError() || "";
                        l.setDisplayed(j.hasActiveError())
                    }
                }
            }, g)
        }
    }()),
    statics: {
        initTip: function() {
            var a = this.tip;
            if (!a) {
                a = this.tip = Ext.create("Ext.tip.QuickTip", {
                    baseCls: Ext.baseCSSPrefix + "form-invalid-tip"
                });
                a.tagConfig = Ext.apply({}, {
                    attribute: "errorqtip"
                }, a.tagConfig)
            }
        },
        destroyTip: function() {
            var a = this.tip;
            if (a) {
                a.destroy();
                delete this.tip
            }
        }
    }
});
Ext.define("Ext.layout.component.field.Trigger", {
    alias: "layout.triggerfield",
    extend: "Ext.layout.component.field.Field",
    type: "triggerfield",
    beginLayout: function(e) {
        var d = this,
            a = d.owner,
            c;
        e.triggerWrap = e.getEl("triggerWrap");
        d.callParent(arguments);
        c = a.getTriggerStateFlags();
        if (c != a.lastTriggerStateFlags) {
            a.lastTriggerStateFlags = c;
            d.updateEditState()
        }
    },
    beginLayoutFixed: function(i, d, j) {
        var e = this,
            a = i.target,
            g = e.ieInputWidthAdjustment || 0,
            k = "100%",
            c = a.triggerWrap;
        e.callParent(arguments);
        a.inputCell.setStyle("width", "100%");
        if (g) {
            a.inputCell.setStyle("padding-right", g + "px");
            if (j === "px") {
                if (a.inputWidth) {
                    k = a.inputWidth - a.getTriggerWidth()
                } else {
                    k = d - g - a.getTriggerWidth()
                }
                k += "px"
            }
        }
        a.inputEl.setStyle("width", k);
        k = a.inputWidth;
        if (k) {
            c.setStyle("width", k + (g) + "px")
        } else {
            c.setStyle("width", d + j)
        }
        c.setStyle("table-layout", "fixed")
    },
    beginLayoutShrinkWrap: function(e) {
        var a = e.target,
            i = "",
            g = a.inputWidth,
            c = a.triggerWrap,
            d = this.ieInputWidthAdjustment || 0;
        this.callParent(arguments);
        if (g) {
            c.setStyle("width", g + "px");
            g = (g - a.getTriggerWidth()) + "px";
            a.inputEl.setStyle("width", g);
            a.inputCell.setStyle("width", g)
        } else {
            a.inputCell.setStyle("width", i);
            a.inputEl.setStyle("width", i);
            c.setStyle("width", i);
            c.setStyle("table-layout", "auto")
        }
    },
    getTextWidth: function() {
        var c = this,
            a = c.owner,
            e = a.inputEl,
            d;
        d = (e.dom.value || (a.hasFocus ? "" : a.emptyText) || "") + a.growAppend;
        return e.getTextWidth(d)
    },
    measureContentWidth: function(j) {
        var i = this,
            c = i.owner,
            g = i.callParent(arguments),
            k = j.inputContext,
            e, a, d;
        if (c.grow && !j.state.growHandled) {
            e = i.getTextWidth() + j.inputContext.getFrameInfo().width;
            a = c.growMax;
            d = Math.min(a, g);
            a = Math.max(c.growMin, a, d);
            e = Ext.Number.constrain(e, c.growMin, a);
            k.setWidth(e);
            j.state.growHandled = true;
            k.domBlock(i, "width");
            g = NaN
        }
        return g
    },
    updateEditState: function() {
        var d = this,
            a = d.owner,
            g = a.inputEl,
            e = Ext.baseCSSPrefix + "trigger-noedit",
            c, i;
        if (d.owner.readOnly) {
            g.addCls(e);
            i = true;
            c = false
        } else {
            if (d.owner.editable) {
                g.removeCls(e);
                i = false
            } else {
                g.addCls(e);
                i = true
            }
            c = !d.owner.hideTrigger
        }
        a.triggerCell.setDisplayed(c);
        g.dom.readOnly = i
    }
});
Ext.define("Ext.layout.container.Anchor", {
    alias: "layout.anchor",
    extend: "Ext.layout.container.Container",
    alternateClassName: "Ext.layout.AnchorLayout",
    type: "anchor",
    manageOverflow: 2,
    renderTpl: ["{%this.renderBody(out,values);this.renderPadder(out,values)%}"],
    defaultAnchor: "100%",
    parseAnchorRE: /^(r|right|b|bottom)$/i,
    beginLayout: function(d) {
        var l = this,
            a = 0,
            j, m, g, e, c, k;
        l.callParent(arguments);
        g = d.childItems;
        c = g.length;
        for (e = 0; e < c; ++e) {
            m = g[e];
            j = m.target.anchorSpec;
            if (j) {
                if (m.widthModel.calculated && j.right) {
                    a |= 1
                }
                if (m.heightModel.calculated && j.bottom) {
                    a |= 2
                }
                if (a == 3) {
                    break
                }
            }
        }
        d.anchorDimensions = a;
        if (!Ext.supports.RightMargin && !l.rightMarginCleanerFn) {
            k = d.targetContext.el;
            l.rightMarginCleanerFn = Ext.Element.getRightMarginFixCleaner(k);
            k.addCls(Ext.baseCSSPrefix + "inline-children")
        }
    },
    calculate: function(c) {
        var a = this,
            d = a.getContainerSize(c);
        if (c.anchorDimensions !== c.state.calculatedAnchors) {
            a.calculateAnchors(c, d)
        }
        if (c.hasDomProp("containerChildrenDone")) {
            if (!d.gotAll) {
                a.done = false
            }
            a.calculateContentSize(c, c.anchorDimensions);
            if (a.done) {
                a.calculateOverflow(c, d, c.anchorDimensions);
                return
            }
        }
        a.done = false
    },
    calculateAnchors: function(k, a) {
        var r = this,
            n = k.childItems,
            j = n.length,
            q = a.gotHeight,
            l = a.gotWidth,
            g = a.height,
            d = a.width,
            c = k.state,
            s = (l ? 1 : 0) | (q ? 2 : 0),
            o, u, p, t, m, e;
        c.calculatedAnchors = (c.calculatedAnchors || 0) | s;
        for (m = 0; m < j; m++) {
            u = n[m];
            p = u.getMarginInfo();
            o = u.target.anchorSpec;
            if (l && u.widthModel.calculated) {
                e = o.right(d) - p.width;
                e = r.adjustWidthAnchor(e, u);
                u.setWidth(e)
            }
            if (q && u.heightModel.calculated) {
                t = o.bottom(g) - p.height;
                t = r.adjustHeightAnchor(t, u);
                u.setHeight(t)
            }
        }
    },
    finishedLayout: function(c) {
        var a = this.rightMarginCleanerFn;
        if (a) {
            delete this.rightMarginCleanerFn;
            c.targetContext.el.removeCls(Ext.baseCSSPrefix + "inline-children");
            a()
        }
    },
    anchorFactory: {
        offset: function(a) {
            return function(c) {
                return c + a
            }
        },
        ratio: function(a) {
            return function(c) {
                return Math.floor(c * a)
            }
        },
        standard: function(a) {
            return function(c) {
                return c - a
            }
        }
    },
    parseAnchor: function(d, i, c) {
        if (d && d != "none") {
            var e = this.anchorFactory,
                g;
            if (this.parseAnchorRE.test(d)) {
                return e.standard(c - i)
            }
            if (d.indexOf("%") != -1) {
                return e.ratio(parseFloat(d.replace("%", "")) * 0.01)
            }
            g = parseInt(d, 10);
            if (!isNaN(g)) {
                return e.offset(g)
            }
        }
        return null
    },
    adjustWidthAnchor: function(c, a) {
        return c
    },
    adjustHeightAnchor: function(c, a) {
        return c
    },
    configureItem: function(i) {
        var g = this,
            a = g.owner,
            e = i.anchor,
            c, d, j;
        g.callParent(arguments);
        if (!i.anchor && i.items && !Ext.isNumber(i.width) && !(Ext.isIE6 && Ext.isStrict)) {
            i.anchor = e = g.defaultAnchor
        }
        if (a.anchorSize) {
            if (typeof a.anchorSize == "number") {
                d = a.anchorSize
            } else {
                d = a.anchorSize.width;
                j = a.anchorSize.height
            }
        } else {
            d = a.initialConfig.width;
            j = a.initialConfig.height
        }
        if (e) {
            c = e.split(" ");
            i.anchorSpec = {
                right: g.parseAnchor(c[0], i.initialConfig.width, d),
                bottom: g.parseAnchor(c[1], i.initialConfig.height, j)
            }
        }
    },
    sizePolicy: {
        "": {
            setsWidth: 0,
            setsHeight: 0
        },
        b: {
            setsWidth: 0,
            setsHeight: 1
        },
        r: {
            "": {
                setsWidth: 1,
                setsHeight: 0
            },
            b: {
                setsWidth: 1,
                setsHeight: 1
            }
        }
    },
    getItemSizePolicy: function(d) {
        var g = d.anchorSpec,
            a = "",
            e = this.sizePolicy,
            c;
        if (g) {
            c = this.owner.getSizeModel();
            if (g.right && !c.width.shrinkWrap) {
                e = e.r
            }
            if (g.bottom && !c.height.shrinkWrap) {
                a = "b"
            }
        }
        return e[a]
    }
});
Ext.define("Ext.layout.component.field.Text", {
    extend: "Ext.layout.component.field.Field",
    alias: "layout.textfield",
    requires: ["Ext.util.TextMetrics"],
    type: "textfield",
    canGrowWidth: true,
    beginLayoutCycle: function(c) {
        var a = this;
        a.callParent(arguments);
        if (c.shrinkWrap) {
            c.inputContext.el.setStyle("height", "")
        }
    },
    measureContentWidth: function(d) {
        var j = this,
            c = j.owner,
            a = j.callParent(arguments),
            i = d.inputContext,
            m, l, e, k, g;
        if (c.grow && j.canGrowWidth && !d.state.growHandled) {
            m = c.inputEl;
            l = Ext.util.Format.htmlEncode(m.dom.value || (c.hasFocus ? "" : c.emptyText) || "");
            l += c.growAppend;
            e = m.getTextWidth(l) + i.getFrameInfo().width;
            k = c.growMax;
            g = Math.min(k, a);
            k = Math.max(c.growMin, k, g);
            e = Ext.Number.constrain(e, c.growMin, k);
            i.setWidth(e);
            d.state.growHandled = true;
            i.domBlock(j, "width");
            a = NaN
        }
        return a
    },
    publishInnerHeight: function(c, a) {
        c.inputContext.setHeight(a - this.measureLabelErrorHeight(c))
    },
    beginLayoutFixed: function(e, a, g) {
        var c = this,
            d = c.ieInputWidthAdjustment;
        if (d) {
            c.owner.bodyEl.setStyle("padding-right", d + "px");
            if (g === "px") {
                a -= d
            }
        }
        c.callParent(arguments)
    }
});
Ext.define("Ext.form.action.Action", {
    alternateClassName: "Ext.form.Action",
    submitEmptyText: true,
    constructor: function(a) {
        if (a) {
            Ext.apply(this, a)
        }
        var c = a.params;
        if (Ext.isString(c)) {
            this.params = Ext.Object.fromQueryString(c)
        }
    },
    run: Ext.emptyFn,
    onFailure: function(a) {
        this.response = a;
        this.failureType = Ext.form.action.Action.CONNECT_FAILURE;
        this.form.afterAction(this, false)
    },
    processResponse: function(a) {
        this.response = a;
        if (!a.responseText && !a.responseXML) {
            return true
        }
        return (this.result = this.handleResponse(a))
    },
    getUrl: function() {
        return this.url || this.form.url
    },
    getMethod: function() {
        return (this.method || this.form.method || "POST").toUpperCase()
    },
    getParams: function() {
        return Ext.apply({}, this.params, this.form.baseParams)
    },
    createCallback: function() {
        var d = this,
            a, c = d.form;
        return {
            success: d.onSuccess,
            failure: d.onFailure,
            scope: d,
            timeout: (this.timeout * 1000) || (c.timeout * 1000),
            upload: c.fileUpload ? d.onSuccess : a
        }
    },
    statics: {
        CLIENT_INVALID: "client",
        SERVER_INVALID: "server",
        CONNECT_FAILURE: "connect",
        LOAD_FAILURE: "load"
    }
});
Ext.define("Ext.form.action.Load", {
    extend: "Ext.form.action.Action",
    requires: ["Ext.data.Connection"],
    alternateClassName: "Ext.form.Action.Load",
    alias: "formaction.load",
    type: "load",
    run: function() {
        Ext.Ajax.request(Ext.apply(this.createCallback(), {
            method: this.getMethod(),
            url: this.getUrl(),
            headers: this.headers,
            params: this.getParams()
        }))
    },
    onSuccess: function(c) {
        var a = this.processResponse(c),
            d = this.form;
        if (a === true || !a.success || !a.data) {
            this.failureType = Ext.form.action.Action.LOAD_FAILURE;
            d.afterAction(this, false);
            return
        }
        d.clearInvalid();
        d.setValues(a.data);
        d.afterAction(this, true)
    },
    handleResponse: function(d) {
        var a = this.form.reader,
            c, e;
        if (a) {
            c = a.read(d);
            e = c.records && c.records[0] ? c.records[0].data : null;
            return {
                success: c.success,
                data: e
            }
        }
        return Ext.decode(d.responseText)
    }
});
Ext.define("Ext.form.action.Submit", {
    extend: "Ext.form.action.Action",
    alternateClassName: "Ext.form.Action.Submit",
    alias: "formaction.submit",
    type: "submit",
    run: function() {
        var a = this.form;
        if (this.clientValidation === false || a.isValid()) {
            this.doSubmit()
        } else {
            this.failureType = Ext.form.action.Action.CLIENT_INVALID;
            a.afterAction(this, false)
        }
    },
    doSubmit: function() {
        var c, a = Ext.apply(this.createCallback(), {
            url: this.getUrl(),
            method: this.getMethod(),
            headers: this.headers
        });
        if (this.form.hasUpload()) {
            c = a.form = this.buildForm();
            a.isUpload = true
        } else {
            a.params = this.getParams()
        }
        Ext.Ajax.request(a);
        if (c) {
            Ext.removeNode(c)
        }
    },
    getParams: function() {
        var d = false,
            c = this.callParent(),
            a = this.form.getValues(d, d, this.submitEmptyText !== d);
        return Ext.apply({}, a, c)
    },
    buildForm: function() {
        var m = [],
            k, s, g = this.form,
            e = this.getParams(),
            d = [],
            i = g.getFields().items,
            j, t = i.length,
            l, q, o, p, n, r, c;
        for (j = 0; j < t; j++) {
            l = i[j];
            if (l.isFileUpload()) {
                d.push(l)
            }
        }

        function a(u, v) {
            m.push({
                tag: "input",
                type: "hidden",
                name: u,
                value: Ext.String.htmlEncode(v)
            })
        }
        for (q in e) {
            if (e.hasOwnProperty(q)) {
                o = e[q];
                if (Ext.isArray(o)) {
                    n = o.length;
                    for (p = 0; p < n; p++) {
                        a(q, o[p])
                    }
                } else {
                    a(q, o)
                }
            }
        }
        k = {
            tag: "form",
            action: this.getUrl(),
            method: this.getMethod(),
            target: this.target || "_self",
            style: "display:none",
            cn: m
        };
        if (d.length) {
            k.encoding = k.enctype = "multipart/form-data"
        }
        s = Ext.DomHelper.append(Ext.getBody(), k);
        c = d.length;
        for (r = 0; r < c; r++) {
            l = d[r];
            if (l.rendered) {
                s.appendChild(l.extractFileInput())
            }
        }
        return s
    },
    onSuccess: function(c) {
        var d = this.form,
            e = true,
            a = this.processResponse(c);
        if (a !== true && !a.success) {
            if (a.errors) {
                d.markInvalid(a.errors)
            }
            this.failureType = Ext.form.action.Action.SERVER_INVALID;
            e = false
        }
        d.afterAction(this, e)
    },
    handleResponse: function(e) {
        var k = this.form,
            g = k.errorReader,
            d, l, j, a, c;
        if (g) {
            d = g.read(e);
            c = d.records;
            l = [];
            if (c) {
                for (j = 0, a = c.length; j < a; j++) {
                    l[j] = c[j].data
                }
            }
            if (l.length < 1) {
                l = null
            }
            return {
                success: d.success,
                errors: l
            }
        }
        return Ext.decode(e.responseText)
    }
});
Ext.define("Ext.util.ComponentDragger", {
    extend: "Ext.dd.DragTracker",
    autoStart: 500,
    constructor: function(a, c) {
        this.comp = a;
        this.initialConstrainTo = c.constrainTo;
        this.callParent([c])
    },
    onStart: function(d) {
        var c = this,
            a = c.comp;
        this.startPosition = a.el.getXY();
        if (a.ghost && !a.liveDrag) {
            c.proxy = a.ghost();
            c.dragTarget = c.proxy.header.el
        }
        if (c.constrain || c.constrainDelegate) {
            c.constrainTo = c.calculateConstrainRegion()
        }
        if (a.beginDrag) {
            a.beginDrag()
        }
    },
    calculateConstrainRegion: function() {
        var g = this,
            d = g.comp,
            k = g.initialConstrainTo,
            i, j, a = g.proxy ? g.proxy.el : d.el,
            e = (!g.constrainDelegate && a.shadow && !a.shadowDisabled) ? a.shadow.getShadowSize() : 0;
        if (!(k instanceof Ext.util.Region)) {
            k = Ext.fly(k).getViewRegion()
        }
        if (e) {
            k.adjust(e[0], -e[1], -e[2], e[3])
        }
        if (!g.constrainDelegate) {
            i = Ext.fly(g.dragTarget).getRegion();
            j = a.getRegion();
            k.adjust(i.top - j.top, i.right - j.right, i.bottom - j.bottom, i.left - j.left)
        }
        return k
    },
    onDrag: function(d) {
        var c = this,
            a = (c.proxy && !c.comp.liveDrag) ? c.proxy : c.comp,
            g = c.getOffset(c.constrain || c.constrainDelegate ? "dragTarget" : null);
        a.setPagePosition(c.startPosition[0] + g[0], c.startPosition[1] + g[1])
    },
    onEnd: function(c) {
        var a = this.comp;
        if (this.proxy && !a.liveDrag) {
            a.unghost()
        }
        if (a.endDrag) {
            a.endDrag()
        }
    }
});
Ext.define("Ext.window.Window", {
    extend: "Ext.panel.Panel",
    alternateClassName: "Ext.Window",
    requires: ["Ext.util.ComponentDragger", "Ext.util.Region", "Ext.EventManager"],
    alias: "widget.window",
    baseCls: Ext.baseCSSPrefix + "window",
    resizable: true,
    draggable: true,
    constrain: false,
    constrainHeader: false,
    plain: false,
    minimizable: false,
    maximizable: false,
    minHeight: 50,
    minWidth: 50,
    expandOnShow: true,
    collapsible: false,
    closable: true,
    hidden: true,
    autoRender: true,
    hideMode: "offsets",
    floating: true,
    ariaRole: "alertdialog",
    itemCls: Ext.baseCSSPrefix + "window-item",
    initialAlphaNum: /^[a-z0-9]/,
    overlapHeader: true,
    ignoreHeaderBorderManagement: true,
    alwaysFramed: true,
    isWindow: true,
    initComponent: function() {
        var a = this;
        a.frame = false;
        a.callParent();
        a.addEvents("resize", "maximize", "minimize", "restore");
        if (a.plain) {
            a.addClsWithUI("plain")
        }
        if (a.modal) {
            a.ariaRole = "dialog"
        }
        if (a.floating) {
            a.on({
                element: "el",
                mousedown: a.onMouseDown,
                scope: a
            })
        }
        a.addStateEvents(["maximize", "restore", "resize", "dragend"])
    },
    getElConfig: function() {
        var c = this,
            a;
        a = c.callParent();
        a.tabIndex = -1;
        return a
    },
    getState: function() {
        var c = this,
            d = c.callParent() || {},
            a = !!c.maximized;
        d.maximized = a;
        Ext.apply(d, {
            size: a ? c.restoreSize : c.getSize(),
            pos: a ? c.restorePos : c.getPosition()
        });
        return d
    },
    applyState: function(c) {
        var a = this;
        if (c) {
            a.maximized = c.maximized;
            if (a.maximized) {
                a.hasSavedRestore = true;
                a.restoreSize = c.size;
                a.restorePos = c.pos
            } else {
                Ext.apply(a, {
                    width: c.size.width,
                    height: c.size.height,
                    x: c.pos[0],
                    y: c.pos[1]
                })
            }
        }
    },
    onMouseDown: function(c) {
        var a;
        if (this.floating) {
            if (Ext.fly(c.getTarget()).focusable()) {
                a = true
            }
            this.toFront(a)
        }
    },
    onRender: function(c, a) {
        var d = this;
        d.callParent(arguments);
        d.focusEl = d.el;
        if (d.maximizable) {
            d.header.on({
                scope: d,
                dblclick: d.toggleMaximize
            })
        }
    },
    afterRender: function() {
        var a = this,
            c;
        a.callParent();
        if (a.maximized) {
            a.maximized = false;
            a.maximize()
        }
        if (a.closable) {
            c = a.getKeyMap();
            c.on(27, a.onEsc, a)
        } else {
            c = a.keyMap
        }
        if (c && a.hidden) {
            c.disable()
        }
    },
    initDraggable: function() {
        var c = this,
            a;
        if (!c.header) {
            c.updateHeader(true)
        }
        if (c.header) {
            a = Ext.applyIf({
                el: c.el,
                delegate: "#" + Ext.escapeId(c.header.id)
            }, c.draggable);
            if (c.constrain || c.constrainHeader) {
                a.constrain = c.constrain;
                a.constrainDelegate = c.constrainHeader;
                a.constrainTo = c.constrainTo || c.container
            }
            c.dd = new Ext.util.ComponentDragger(this, a);
            c.relayEvents(c.dd, ["dragstart", "drag", "dragend"])
        }
    },
    onEsc: function(a, c) {
        if (!Ext.FocusManager || !Ext.FocusManager.enabled || Ext.FocusManager.focusedCmp === this) {
            c.stopEvent();
            this.close()
        }
    },
    beforeDestroy: function() {
        var a = this;
        if (a.rendered) {
            delete this.animateTarget;
            a.hide();
            Ext.destroy(a.keyMap)
        }
        a.callParent()
    },
    addTools: function() {
        var a = this;
        a.callParent();
        if (a.minimizable) {
            a.addTool({
                type: "minimize",
                handler: Ext.Function.bind(a.minimize, a, [])
            })
        }
        if (a.maximizable) {
            a.addTool({
                type: "maximize",
                handler: Ext.Function.bind(a.maximize, a, [])
            });
            a.addTool({
                type: "restore",
                handler: Ext.Function.bind(a.restore, a, []),
                hidden: true
            })
        }
    },
    getFocusEl: function() {
        return this.getDefaultFocus()
    },
    getDefaultFocus: function() {
        var d = this,
            c, e = d.defaultButton || d.defaultFocus,
            a;
        if (e !== undefined) {
            if (Ext.isNumber(e)) {
                c = d.query("button")[e]
            } else {
                if (Ext.isString(e)) {
                    a = e;
                    if (a.match(d.initialAlphaNum)) {
                        c = d.down("#" + a)
                    }
                    if (!c) {
                        c = d.down(a)
                    }
                } else {
                    if (e.focus) {
                        c = e
                    }
                }
            }
        }
        return c || d.el
    },
    onFocus: function() {
        var c = this,
            a;
        if ((Ext.FocusManager && Ext.FocusManager.enabled) || ((a = c.getDefaultFocus()) === c)) {
            c.callParent(arguments)
        } else {
            a.focus()
        }
    },
    beforeLayout: function() {
        var a = this.el.shadow;
        this.callParent();
        if (a) {
            a.hide()
        }
    },
    onShow: function() {
        var a = this;
        a.callParent(arguments);
        if (a.expandOnShow) {
            a.expand(false)
        }
        a.syncMonitorWindowResize();
        if (a.keyMap) {
            a.keyMap.enable()
        }
    },
    doClose: function() {
        var a = this;
        if (a.hidden) {
            a.fireEvent("close", a);
            if (a.closeAction == "destroy") {
                this.destroy()
            }
        } else {
            a.hide(a.animateTarget, a.doClose, a)
        }
    },
    afterHide: function() {
        var a = this;
        a.syncMonitorWindowResize();
        if (a.keyMap) {
            a.keyMap.disable()
        }
        a.callParent(arguments)
    },
    onWindowResize: function() {
        var c = this,
            a;
        if (c.maximized) {
            c.fitContainer()
        } else {
            a = c.getSizeModel();
            if (a.width.natural || a.height.natural) {
                c.updateLayout()
            }
        }
        c.doConstrain()
    },
    minimize: function() {
        this.fireEvent("minimize", this);
        return this
    },
    afterCollapse: function() {
        var a = this;
        if (a.maximizable) {
            a.tools.maximize.hide();
            a.tools.restore.hide()
        }
        if (a.resizer) {
            a.resizer.disable()
        }
        a.callParent(arguments)
    },
    afterExpand: function() {
        var a = this;
        if (a.maximized) {
            a.tools.restore.show()
        } else {
            if (a.maximizable) {
                a.tools.maximize.show()
            }
        }
        if (a.resizer) {
            a.resizer.enable()
        }
        a.callParent(arguments)
    },
    maximize: function() {
        var a = this;
        if (!a.maximized) {
            a.expand(false);
            if (!a.hasSavedRestore) {
                a.restoreSize = a.getSize();
                a.restorePos = a.getPosition(true)
            }
            if (a.maximizable) {
                a.tools.maximize.hide();
                a.tools.restore.show()
            }
            a.maximized = true;
            a.el.disableShadow();
            if (a.dd) {
                a.dd.disable()
            }
            if (a.resizer) {
                a.resizer.disable()
            }
            if (a.collapseTool) {
                a.collapseTool.hide()
            }
            a.el.addCls(Ext.baseCSSPrefix + "window-maximized");
            a.container.addCls(Ext.baseCSSPrefix + "window-maximized-ct");
            a.syncMonitorWindowResize();
            a.fitContainer();
            a.fireEvent("maximize", a)
        }
        return a
    },
    restore: function() {
        var a = this,
            c = a.tools;
        if (a.maximized) {
            delete a.hasSavedRestore;
            a.removeCls(Ext.baseCSSPrefix + "window-maximized");
            if (c.restore) {
                c.restore.hide()
            }
            if (c.maximize) {
                c.maximize.show()
            }
            if (a.collapseTool) {
                a.collapseTool.show()
            }
            a.maximized = false;
            a.setPosition(a.restorePos);
            a.setSize(a.restoreSize);
            delete a.restorePos;
            delete a.restoreSize;
            a.el.enableShadow(true);
            if (a.dd) {
                a.dd.enable()
            }
            if (a.resizer) {
                a.resizer.enable()
            }
            a.container.removeCls(Ext.baseCSSPrefix + "window-maximized-ct");
            a.syncMonitorWindowResize();
            a.doConstrain();
            a.fireEvent("restore", a)
        }
        return a
    },
    syncMonitorWindowResize: function() {
        var c = this,
            d = c._monitoringResize,
            e = c.monitorResize || c.constrain || c.constrainHeader || c.maximized,
            a = c.hidden || c.destroying || c.isDestroyed;
        if (e && !a) {
            if (!d) {
                Ext.EventManager.onWindowResize(c.onWindowResize, c);
                c._monitoringResize = true
            }
        } else {
            if (d) {
                Ext.EventManager.removeResizeListener(c.onWindowResize, c);
                c._monitoringResize = false
            }
        }
    },
    toggleMaximize: function() {
        return this[this.maximized ? "restore" : "maximize"]()
    }
});
Ext.define("Ext.form.Labelable", {
    requires: ["Ext.XTemplate"],
    autoEl: {
        tag: "table",
        cellpadding: 0
    },
    childEls: ["labelCell", "labelEl", "bodyEl", "sideErrorCell", "errorEl", "inputRow", "bottomPlaceHolder"],
    labelableRenderTpl: ['<tr id="{id}-inputRow" <tpl if="inFormLayout">id="{id}"</tpl>>', '<tpl if="labelOnLeft">', '<td id="{id}-labelCell" style="{labelCellStyle}" {labelCellAttrs}>', "{beforeLabelTpl}", '<label id="{id}-labelEl" {labelAttrTpl}<tpl if="inputId"> for="{inputId}"</tpl> class="{labelCls}"', '<tpl if="labelStyle"> style="{labelStyle}"</tpl>>', "{beforeLabelTextTpl}", '<tpl if="fieldLabel">{fieldLabel}{labelSeparator}</tpl>', "{afterLabelTextTpl}", "</label>", "{afterLabelTpl}", "</td>", "</tpl>", '<td class="{baseBodyCls} {fieldBodyCls}" id="{id}-bodyEl" colspan="{bodyColspan}" role="presentation">', "{beforeBodyEl}", "<tpl if=\"labelAlign=='top'\">", "{beforeLabelTpl}", '<div id="{id}-labelCell" style="{labelCellStyle}">', '<label id="{id}-labelEl" {labelAttrTpl}<tpl if="inputId"> for="{inputId}"</tpl> class="{labelCls}"', '<tpl if="labelStyle"> style="{labelStyle}"</tpl>>', "{beforeLabelTextTpl}", '<tpl if="fieldLabel">{fieldLabel}{labelSeparator}</tpl>', "{afterLabelTextTpl}", "</label>", "</div>", "{afterLabelTpl}", "</tpl>", "{beforeSubTpl}", "{[values.$comp.getSubTplMarkup()]}", "{afterSubTpl}", "<tpl if=\"msgTarget==='side'\">", "{afterBodyEl}", "</td>", "<td id=\"{id}-sideErrorCell\" vAlign=\"{[values.labelAlign==='top' && !values.hideLabel ? 'bottom' : 'middle']}\" style=\"{[values.autoFitErrors ? 'display:none' : '']}\" width=\"{errorIconWidth}\">", '<div id="{id}-errorEl" class="{errorMsgCls}" style="display:none;width:{errorIconWidth}px"></div>', "</td>", "<tpl elseif=\"msgTarget=='under'\">", '<div id="{id}-errorEl" class="{errorMsgClass}" colspan="2" style="display:none"></div>', "{afterBodyEl}", "</td>", "</tpl>", "</tr>", {
        disableFormats: true
    }],
    activeErrorsTpl: ['<tpl if="errors && errors.length">', '<ul><tpl for="errors"><li>{.}</li></tpl></ul>', "</tpl>"],
    isFieldLabelable: true,
    formItemCls: Ext.baseCSSPrefix + "form-item",
    labelCls: Ext.baseCSSPrefix + "form-item-label",
    errorMsgCls: Ext.baseCSSPrefix + "form-error-msg",
    baseBodyCls: Ext.baseCSSPrefix + "form-item-body",
    fieldBodyCls: "",
    clearCls: Ext.baseCSSPrefix + "clear",
    invalidCls: Ext.baseCSSPrefix + "form-invalid",
    fieldLabel: undefined,
    labelAlign: "left",
    labelWidth: 100,
    labelPad: 5,
    labelSeparator: ":",
    hideLabel: false,
    hideEmptyLabel: true,
    preventMark: false,
    autoFitErrors: true,
    msgTarget: "qtip",
    noWrap: true,
    labelableInsertions: ["beforeBodyEl", "afterBodyEl", "beforeLabelTpl", "afterLabelTpl", "beforeSubTpl", "afterSubTpl", "beforeLabelTextTpl", "afterLabelTextTpl", "labelAttrTpl"],
    labelableRenderProps: ["allowBlank", "id", "labelAlign", "fieldBodyCls", "baseBodyCls", "clearCls", "labelSeparator", "msgTarget"],
    initLabelable: function() {
        var a = this,
            c = a.padding;
        if (c) {
            a.padding = undefined;
            a.extraMargins = Ext.Element.parseBox(c)
        }
        a.addCls(a.formItemCls);
        a.lastActiveError = "";
        a.addEvents("errorchange")
    },
    trimLabelSeparator: function() {
        var d = this,
            e = d.labelSeparator,
            a = d.fieldLabel || "",
            c = a.substr(a.length - 1);
        return c === e ? a.slice(0, -1) : a
    },
    getFieldLabel: function() {
        return this.trimLabelSeparator()
    },
    setFieldLabel: function(c) {
        c = c || "";
        var d = this,
            e = d.labelSeparator,
            a = d.labelEl;
        d.fieldLabel = c;
        if (d.rendered) {
            if (Ext.isEmpty(c) && d.hideEmptyLabel) {
                a.parent().setDisplayed("none")
            } else {
                if (e) {
                    c = d.trimLabelSeparator() + e
                }
                a.update(c);
                a.parent().setDisplayed("")
            }
            d.updateLayout()
        }
    },
    getInsertionRenderData: function(e, g) {
        var c = g.length,
            a, d;
        while (c--) {
            a = g[c];
            d = this[a];
            if (d) {
                if (typeof d != "string") {
                    if (!d.isTemplate) {
                        d = Ext.XTemplate.getTpl(this, a)
                    }
                    d = d.apply(e)
                }
            }
            e[a] = d || ""
        }
        return e
    },
    getLabelableRenderData: function() {
        var c = this,
            d, e, a = c.labelAlign === "top";
        if (!Ext.form.Labelable.errorIconWidth) {
            Ext.form.Labelable.errorIconWidth = (e = Ext.resetElement.createChild({
                style: "position:absolute",
                cls: Ext.baseCSSPrefix + "form-invalid-icon"
            })).getWidth();
            e.remove()
        }
        d = Ext.copyTo({
            inFormLayout: c.ownerLayout && c.ownerLayout.type === "form",
            inputId: c.getInputId(),
            labelOnLeft: !a,
            hideLabel: !c.hasVisibleLabel(),
            fieldLabel: c.getFieldLabel(),
            labelCellStyle: c.getLabelCellStyle(),
            labelCellAttrs: c.getLabelCellAttrs(),
            labelCls: c.getLabelCls(),
            labelStyle: c.getLabelStyle(),
            bodyColspan: c.getBodyColspan(),
            externalError: !c.autoFitErrors,
            errorMsgCls: c.getErrorMsgCls(),
            errorIconWidth: Ext.form.Labelable.errorIconWidth
        }, c, c.labelableRenderProps, true);
        c.getInsertionRenderData(d, c.labelableInsertions);
        return d
    },
    beforeLabelableRender: function() {
        var a = this;
        if (a.ownerLayout) {
            a.addCls(Ext.baseCSSPrefix + a.ownerLayout.type + "-form-item")
        }
    },
    onLabelableRender: function() {
        var d = this,
            e, a, c = {};
        if (d.extraMargins) {
            e = d.el.getMargin();
            for (a in e) {
                if (e.hasOwnProperty(a)) {
                    c["margin-" + a] = (e[a] + d.extraMargins[a]) + "px"
                }
            }
            d.el.setStyle(c)
        }
    },
    hasVisibleLabel: function() {
        if (this.hideLabel) {
            return false
        }
        return !(this.hideEmptyLabel && !this.getFieldLabel())
    },
    getBodyColspan: function() {
        var c = this,
            a;
        if (c.msgTarget === "side" && (!c.autoFitErrors || c.hasActiveError())) {
            a = 1
        } else {
            a = 2
        }
        if (c.labelAlign !== "top" && !c.hasVisibleLabel()) {
            a++
        }
        return a
    },
    getLabelCls: function() {
        var c = this.labelCls,
            a = this.labelClsExtra;
        if (this.labelAlign === "top") {
            c += "-top"
        }
        return a ? c + " " + a : c
    },
    getLabelCellStyle: function() {
        var c = this,
            a = c.hideLabel || (!c.fieldLabel && c.hideEmptyLabel);
        return a ? "display:none;" : ""
    },
    getErrorMsgCls: function() {
        var c = this,
            a = (c.hideLabel || (!c.fieldLabel && c.hideEmptyLabel));
        return c.errorMsgCls + (!a && c.labelAlign === "top" ? " " + Ext.baseCSSPrefix + "lbl-top-err-icon" : "")
    },
    getLabelCellAttrs: function() {
        var d = this,
            c = d.labelAlign,
            a = "";
        if (c !== "top") {
            a = 'valign="top" halign="' + c + '" width="' + (d.labelWidth + d.labelPad) + '"'
        }
        return a + ' class="' + Ext.baseCSSPrefix + 'field-label-cell"'
    },
    getLabelStyle: function() {
        var d = this,
            c = d.labelPad,
            a = "";
        if (d.labelAlign !== "top") {
            if (d.labelWidth) {
                a = "width:" + d.labelWidth + "px;"
            }
            a += "margin-right:" + c + "px;"
        }
        return a + (d.labelStyle || "")
    },
    getSubTplMarkup: function() {
        return ""
    },
    getInputId: function() {
        return ""
    },
    getActiveError: function() {
        return this.activeError || ""
    },
    hasActiveError: function() {
        return !!this.getActiveError()
    },
    setActiveError: function(a) {
        this.setActiveErrors(a)
    },
    getActiveErrors: function() {
        return this.activeErrors || []
    },
    setActiveErrors: function(a) {
        a = Ext.Array.from(a);
        this.activeError = a[0];
        this.activeErrors = a;
        this.activeError = this.getTpl("activeErrorsTpl").apply({
            errors: a
        });
        this.renderActiveError()
    },
    unsetActiveError: function() {
        delete this.activeError;
        delete this.activeErrors;
        this.renderActiveError()
    },
    renderActiveError: function() {
        var d = this,
            c = d.getActiveError(),
            a = !!c;
        if (c !== d.lastActiveError) {
            d.fireEvent("errorchange", d, c);
            d.lastActiveError = c
        }
        if (d.rendered && !d.isDestroyed && !d.preventMark) {
            d.el[a ? "addCls" : "removeCls"](d.invalidCls);
            d.getActionEl().dom.setAttribute("aria-invalid", a);
            if (d.errorEl) {
                d.errorEl.dom.innerHTML = c
            }
        }
    },
    setFieldDefaults: function(d) {
        var c = this,
            e, a;
        for (a in d) {
            if (d.hasOwnProperty(a)) {
                e = d[a];
                if (!c.hasOwnProperty(a)) {
                    c[a] = e
                }
            }
        }
    }
});
Ext.define("Ext.form.field.Field", {
    isFormField: true,
    disabled: false,
    submitValue: true,
    validateOnChange: true,
    suspendCheckChange: 0,
    initField: function() {
        this.addEvents("change", "validitychange", "dirtychange");
        this.initValue()
    },
    initValue: function() {
        var a = this;
        a.value = a.transformOriginalValue(a.value);
        a.originalValue = a.lastValue = a.value;
        a.suspendCheckChange++;
        a.setValue(a.value);
        a.suspendCheckChange--
    },
    transformOriginalValue: function(a) {
        return a
    },
    getName: function() {
        return this.name
    },
    getValue: function() {
        return this.value
    },
    setValue: function(c) {
        var a = this;
        a.value = c;
        a.checkChange();
        return a
    },
    isEqual: function(c, a) {
        return String(c) === String(a)
    },
    isEqualAsString: function(c, a) {
        return String(Ext.value(c, "")) === String(Ext.value(a, ""))
    },
    getSubmitData: function() {
        var a = this,
            c = null;
        if (!a.disabled && a.submitValue && !a.isFileUpload()) {
            c = {};
            c[a.getName()] = "" + a.getValue()
        }
        return c
    },
    getModelData: function() {
        var a = this,
            c = null;
        if (!a.disabled && !a.isFileUpload()) {
            c = {};
            c[a.getName()] = a.getValue()
        }
        return c
    },
    reset: function() {
        var a = this;
        a.beforeReset();
        a.setValue(a.originalValue);
        a.clearInvalid();
        delete a.wasValid
    },
    beforeReset: Ext.emptyFn,
    resetOriginalValue: function() {
        this.originalValue = this.getValue();
        this.checkDirty()
    },
    checkChange: function() {
        if (!this.suspendCheckChange) {
            var d = this,
                c = d.getValue(),
                a = d.lastValue;
            if (!d.isEqual(c, a) && !d.isDestroyed) {
                d.lastValue = c;
                d.fireEvent("change", d, c, a);
                d.onChange(c, a)
            }
        }
    },
    onChange: function(c, a) {
        if (this.validateOnChange) {
            this.validate()
        }
        this.checkDirty()
    },
    isDirty: function() {
        var a = this;
        return !a.disabled && !a.isEqual(a.getValue(), a.originalValue)
    },
    checkDirty: function() {
        var a = this,
            c = a.isDirty();
        if (c !== a.wasDirty) {
            a.fireEvent("dirtychange", a, c);
            a.onDirtyChange(c);
            a.wasDirty = c
        }
    },
    onDirtyChange: Ext.emptyFn,
    getErrors: function(a) {
        return []
    },
    isValid: function() {
        var a = this;
        return a.disabled || Ext.isEmpty(a.getErrors())
    },
    validate: function() {
        var a = this,
            c = a.isValid();
        if (c !== a.wasValid) {
            a.wasValid = c;
            a.fireEvent("validitychange", a, c)
        }
        return c
    },
    batchChanges: function(a) {
        try {
            this.suspendCheckChange++;
            a()
        } catch (c) {
            throw c
        } finally {
            this.suspendCheckChange--
        }
        this.checkChange()
    },
    isFileUpload: function() {
        return false
    },
    extractFileInput: function() {
        return null
    },
    markInvalid: Ext.emptyFn,
    clearInvalid: Ext.emptyFn
});
Ext.define("Ext.form.field.Base", {
    extend: "Ext.Component",
    mixins: {
        labelable: "Ext.form.Labelable",
        field: "Ext.form.field.Field"
    },
    alias: "widget.field",
    alternateClassName: ["Ext.form.Field", "Ext.form.BaseField"],
    requires: ["Ext.util.DelayedTask", "Ext.XTemplate", "Ext.layout.component.field.Field"],
    fieldSubTpl: ['<input id="{id}" type="{type}" {inputAttrTpl}', ' size="1"', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '{%if (values.maxLength !== undefined){%} maxlength="{maxLength}"{%}%}', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' class="{fieldCls} {typeCls} {editableCls}" autocomplete="off"/>', {
        disableFormats: true
    }],
    subTplInsertions: ["inputAttrTpl"],
    inputType: "text",
    invalidText: "The value in this field is invalid",
    fieldCls: Ext.baseCSSPrefix + "form-field",
    focusCls: "form-focus",
    dirtyCls: Ext.baseCSSPrefix + "form-dirty",
    checkChangeEvents: Ext.isIE && (!document.documentMode || document.documentMode < 9) ? ["change", "propertychange"] : ["change", "input", "textInput", "keyup", "dragdrop"],
    checkChangeBuffer: 50,
    componentLayout: "field",
    readOnly: false,
    readOnlyCls: Ext.baseCSSPrefix + "form-readonly",
    validateOnBlur: true,
    hasFocus: false,
    baseCls: Ext.baseCSSPrefix + "field",
    maskOnDisable: false,
    initComponent: function() {
        var a = this;
        a.callParent();
        a.subTplData = a.subTplData || {};
        a.addEvents("specialkey", "writeablechange");
        a.initLabelable();
        a.initField();
        if (!a.name) {
            a.name = a.getInputId()
        }
    },
    beforeRender: function() {
        var a = this;
        a.callParent(arguments);
        a.beforeLabelableRender(arguments);
        if (a.readOnly) {
            a.addCls(a.readOnlyCls)
        }
    },
    getInputId: function() {
        return this.inputId || (this.inputId = this.id + "-inputEl")
    },
    getSubTplData: function() {
        var d = this,
            c = d.inputType,
            a = d.getInputId(),
            e;
        e = Ext.apply({
            id: a,
            cmpId: d.id,
            name: d.name || a,
            disabled: d.disabled,
            readOnly: d.readOnly,
            value: d.getRawValue(),
            type: c,
            fieldCls: d.fieldCls,
            fieldStyle: d.getFieldStyle(),
            tabIdx: d.tabIndex,
            typeCls: Ext.baseCSSPrefix + "form-" + (c === "password" ? "text" : c)
        }, d.subTplData);
        d.getInsertionRenderData(e, d.subTplInsertions);
        return e
    },
    afterFirstLayout: function() {
        this.callParent();
        var a = this.inputEl;
        if (a) {
            a.selectable()
        }
    },
    applyRenderSelectors: function() {
        var a = this;
        a.callParent();
        a.inputEl = a.el.getById(a.getInputId())
    },
    getSubTplMarkup: function() {
        return this.getTpl("fieldSubTpl").apply(this.getSubTplData())
    },
    initRenderTpl: function() {
        var a = this;
        if (!a.hasOwnProperty("renderTpl")) {
            a.renderTpl = a.getTpl("labelableRenderTpl")
        }
        return a.callParent()
    },
    initRenderData: function() {
        return Ext.applyIf(this.callParent(), this.getLabelableRenderData())
    },
    setFieldStyle: function(a) {
        var c = this,
            d = c.inputEl;
        if (d) {
            d.applyStyles(a)
        }
        c.fieldStyle = a
    },
    getFieldStyle: function() {
        return "width:100%;" + (Ext.isObject(this.fieldStyle) ? Ext.DomHelper.generateStyles(this.fieldStyle) : this.fieldStyle || "")
    },
    onRender: function() {
        var a = this;
        a.callParent(arguments);
        a.onLabelableRender();
        a.renderActiveError()
    },
    getFocusEl: function() {
        return this.inputEl
    },
    isFileUpload: function() {
        return this.inputType === "file"
    },
    extractFileInput: function() {
        var c = this,
            a = c.isFileUpload() ? c.inputEl.dom : null,
            d;
        if (a) {
            d = a.cloneNode(true);
            a.parentNode.replaceChild(d, a);
            c.inputEl = Ext.get(d)
        }
        return a
    },
    getSubmitData: function() {
        var a = this,
            c = null,
            d;
        if (!a.disabled && a.submitValue && !a.isFileUpload()) {
            d = a.getSubmitValue();
            if (d !== null) {
                c = {};
                c[a.getName()] = d
            }
        }
        return c
    },
    getSubmitValue: function() {
        return this.processRawValue(this.getRawValue())
    },
    getRawValue: function() {
        var c = this,
            a = (c.inputEl ? c.inputEl.getValue() : Ext.value(c.rawValue, ""));
        c.rawValue = a;
        return a
    },
    setRawValue: function(c) {
        var a = this;
        c = Ext.value(a.transformRawValue(c), "");
        a.rawValue = c;
        if (a.inputEl) {
            a.inputEl.dom.value = c
        }
        return c
    },
    transformRawValue: function(a) {
        return a
    },
    valueToRaw: function(a) {
        return "" + Ext.value(a, "")
    },
    rawToValue: function(a) {
        return a
    },
    processRawValue: function(a) {
        return a
    },
    getValue: function() {
        var a = this,
            c = a.rawToValue(a.processRawValue(a.getRawValue()));
        a.value = c;
        return c
    },
    setValue: function(c) {
        var a = this;
        a.setRawValue(a.valueToRaw(c));
        return a.mixins.field.setValue.call(a, c)
    },
    onBoxReady: function() {
        var a = this;
        a.callParent();
        if (a.setReadOnlyOnBoxReady) {
            a.setReadOnly(a.readOnly)
        }
    },
    onDisable: function() {
        var a = this,
            c = a.inputEl;
        a.callParent();
        if (c) {
            c.dom.disabled = true;
            if (a.hasActiveError()) {
                a.clearInvalid();
                a.needsValidateOnEnable = true
            }
        }
    },
    onEnable: function() {
        var a = this,
            c = a.inputEl;
        a.callParent();
        if (c) {
            c.dom.disabled = false;
            if (a.needsValidateOnEnable) {
                delete a.needsValidateOnEnable;
                a.forceValidation = true;
                a.isValid();
                delete a.forceValidation
            }
        }
    },
    setReadOnly: function(d) {
        var a = this,
            c = a.inputEl;
        d = !!d;
        a[d ? "addCls" : "removeCls"](a.readOnlyCls);
        a.readOnly = d;
        if (c) {
            c.dom.readOnly = d
        } else {
            if (a.rendering) {
                a.setReadOnlyOnBoxReady = true
            }
        }
        a.fireEvent("writeablechange", a, d)
    },
    fireKey: function(a) {
        if (a.isSpecialKey()) {
            this.fireEvent("specialkey", this, new Ext.EventObjectImpl(a))
        }
    },
    initEvents: function() {
        var i = this,
            k = i.inputEl,
            c, l, d = i.checkChangeEvents,
            j, a = d.length,
            g;
        if (i.inEditor) {
            i.onBlur = Ext.Function.createBuffered(i.onBlur, 10)
        }
        if (k) {
            i.mon(k, Ext.EventManager.getKeyEvent(), i.fireKey, i);
            c = new Ext.util.DelayedTask(i.checkChange, i);
            i.onChangeEvent = l = function() {
                c.delay(i.checkChangeBuffer)
            };
            for (j = 0; j < a; j++) {
                g = d[j];
                if (g === "propertychange") {
                    i.usesPropertychange = true
                }
                i.mon(k, g, l)
            }
        }
        i.callParent()
    },
    doComponentLayout: function() {
        var d = this,
            e = d.inputEl,
            a = d.usesPropertychange,
            c = "propertychange",
            g = d.onChangeEvent;
        if (a) {
            d.mun(e, c, g)
        }
        d.callParent(arguments);
        if (a) {
            d.mon(e, c, g)
        }
    },
    onDirtyChange: function(a) {
        this[a ? "addCls" : "removeCls"](this.dirtyCls)
    },
    isValid: function() {
        var c = this,
            a = c.disabled,
            d = c.forceValidation || !a;
        return d ? c.validateValue(c.processRawValue(c.getRawValue())) : a
    },
    validateValue: function(c) {
        var a = this,
            e = a.getErrors(c),
            d = Ext.isEmpty(e);
        if (!a.preventMark) {
            if (d) {
                a.clearInvalid()
            } else {
                a.markInvalid(e)
            }
        }
        return d
    },
    markInvalid: function(d) {
        var c = this,
            a = c.getActiveError();
        c.setActiveErrors(Ext.Array.from(d));
        if (a !== c.getActiveError()) {
            c.updateLayout()
        }
    },
    clearInvalid: function() {
        var c = this,
            a = c.hasActiveError();
        c.unsetActiveError();
        if (a) {
            c.updateLayout()
        }
    },
    renderActiveError: function() {
        var c = this,
            a = c.hasActiveError();
        if (c.inputEl) {
            c.inputEl[a ? "addCls" : "removeCls"](c.invalidCls + "-field")
        }
        c.mixins.labelable.renderActiveError.call(c)
    },
    getActionEl: function() {
        return this.inputEl || this.el
    }
});
Ext.define("Ext.form.field.VTypes", (function() {
    var d = /^[a-zA-Z_]+$/,
        e = /^[a-zA-Z0-9_]+$/,
        c = /^(\w+)([\-+.][\w]+)*@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/,
        a = /(((^https?)|(^ftp)):\/\/([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i;
    return {
        singleton: true,
        alternateClassName: "Ext.form.VTypes",
        email: function(g) {
            return c.test(g)
        },
        emailText: 'This field should be an e-mail address in the format "user@example.com"',
        emailMask: /[a-z0-9_\.\-@\+]/i,
        url: function(g) {
            return a.test(g)
        },
        urlText: 'This field should be a URL in the format "http://www.example.com"',
        alpha: function(g) {
            return d.test(g)
        },
        alphaText: "This field should only contain letters and _",
        alphaMask: /[a-z_]/i,
        alphanum: function(g) {
            return e.test(g)
        },
        alphanumText: "This field should only contain letters, numbers and _",
        alphanumMask: /[a-z0-9_]/i
    }
}()));
Ext.define("Ext.form.field.Text", {
    extend: "Ext.form.field.Base",
    alias: "widget.textfield",
    requires: ["Ext.form.field.VTypes", "Ext.layout.component.field.Text"],
    alternateClassName: ["Ext.form.TextField", "Ext.form.Text"],
    size: 20,
    growMin: 30,
    growMax: 800,
    growAppend: "W",
    allowBlank: true,
    minLength: 0,
    maxLength: Number.MAX_VALUE,
    minLengthText: "The minimum length for this field is {0}",
    maxLengthText: "The maximum length for this field is {0}",
    blankText: "This field is required",
    regexText: "",
    emptyCls: Ext.baseCSSPrefix + "form-empty-field",
    requiredCls: Ext.baseCSSPrefix + "form-required-field",
    componentLayout: "textfield",
    valueContainsPlaceholder: false,
    initComponent: function() {
        var a = this;
        a.callParent();
        a.addEvents("autosize", "keydown", "keyup", "keypress");
        a.addStateEvents("change");
        a.setGrowSizePolicy()
    },
    setGrowSizePolicy: function() {
        if (this.grow) {
            this.shrinkWrap |= 1
        }
    },
    initEvents: function() {
        var c = this,
            a = c.inputEl;
        c.callParent();
        if (c.selectOnFocus || c.emptyText) {
            c.mon(a, "mousedown", c.onMouseDown, c)
        }
        if (c.maskRe || (c.vtype && c.disableKeyFilter !== true && (c.maskRe = Ext.form.field.VTypes[c.vtype + "Mask"]))) {
            c.mon(a, "keypress", c.filterKeys, c)
        }
        if (c.enableKeyEvents) {
            c.mon(a, {
                scope: c,
                keyup: c.onKeyUp,
                keydown: c.onKeyDown,
                keypress: c.onKeyPress
            })
        }
    },
    isEqual: function(c, a) {
        return this.isEqualAsString(c, a)
    },
    onChange: function() {
        this.callParent();
        this.autoSize()
    },
    getSubTplData: function() {
        var c = this,
            d = c.getRawValue(),
            g = c.emptyText && d.length < 1,
            a = c.maxLength,
            e;
        if (c.enforceMaxLength) {
            if (a === Number.MAX_VALUE) {
                a = undefined
            }
        } else {
            a = undefined
        }
        if (g) {
            if (Ext.supports.Placeholder) {
                e = c.emptyText
            } else {
                d = c.emptyText;
                c.valueContainsPlaceholder = true
            }
        }
        return Ext.apply(c.callParent(), {
            maxLength: a,
            readOnly: c.readOnly,
            placeholder: e,
            value: d,
            fieldCls: c.fieldCls + ((g && (e || d)) ? " " + c.emptyCls : "") + (c.allowBlank ? "" : " " + c.requiredCls)
        })
    },
    afterRender: function() {
        this.autoSize();
        this.callParent()
    },
    onMouseDown: function(c) {
        var a = this;
        if (!a.hasFocus) {
            a.mon(a.inputEl, "mouseup", Ext.emptyFn, a, {
                single: true,
                preventDefault: true
            })
        }
    },
    processRawValue: function(c) {
        var a = this,
            e = a.stripCharsRe,
            d;
        if (e) {
            d = c.replace(e, "");
            if (d !== c) {
                a.setRawValue(d);
                c = d
            }
        }
        return c
    },
    onDisable: function() {
        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = "on"
        }
    },
    onEnable: function() {
        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = ""
        }
    },
    onKeyDown: function(a) {
        this.fireEvent("keydown", this, a)
    },
    onKeyUp: function(a) {
        this.fireEvent("keyup", this, a)
    },
    onKeyPress: function(a) {
        this.fireEvent("keypress", this, a)
    },
    reset: function() {
        this.callParent();
        this.applyEmptyText()
    },
    applyEmptyText: function() {
        var c = this,
            a = c.emptyText,
            d;
        if (c.rendered && a) {
            d = c.getRawValue().length < 1 && !c.hasFocus;
            if (Ext.supports.Placeholder) {
                c.inputEl.dom.placeholder = a
            } else {
                if (d) {
                    c.setRawValue(a);
                    c.valueContainsPlaceholder = true
                }
            }
            if (d) {
                c.inputEl.addCls(c.emptyCls)
            }
            c.autoSize()
        }
    },
    afterFirstLayout: function() {
        this.callParent();
        if (Ext.isIE && this.disabled) {
            var a = this.inputEl;
            if (a) {
                a.dom.unselectable = "on"
            }
        }
    },
    preFocus: function() {
        var c = this,
            d = c.inputEl,
            a = c.emptyText,
            e;
        c.callParent(arguments);
        if ((a && !Ext.supports.Placeholder) && (d.dom.value === c.emptyText && c.valueContainsPlaceholder)) {
            c.setRawValue("");
            e = true;
            d.removeCls(c.emptyCls);
            c.valueContainsPlaceholder = false
        } else {
            if (Ext.supports.Placeholder) {
                c.inputEl.removeCls(c.emptyCls)
            }
        }
        if (c.selectOnFocus || e) {
            d.dom.select()
        }
    },
    onFocus: function() {
        var a = this;
        a.callParent(arguments);
        if (a.emptyText) {
            a.autoSize()
        }
    },
    postBlur: function() {
        this.callParent(arguments);
        this.applyEmptyText()
    },
    filterKeys: function(d) {
        if (d.ctrlKey && !d.altKey) {
            return
        }
        var c = d.getKey(),
            a = String.fromCharCode(d.getCharCode());
        if ((Ext.isGecko || Ext.isOpera) && (d.isNavKeyPress() || c === d.BACKSPACE || (c === d.DELETE && d.button === -1))) {
            return
        }
        if ((!Ext.isGecko && !Ext.isOpera) && d.isSpecialKey() && !a) {
            return
        }
        if (!this.maskRe.test(a)) {
            d.stopEvent()
        }
    },
    getState: function() {
        return this.addPropertyToState(this.callParent(), "value")
    },
    applyState: function(a) {
        this.callParent(arguments);
        if (a.hasOwnProperty("value")) {
            this.setValue(a.value)
        }
    },
    getRawValue: function() {
        var c = this,
            a = c.callParent();
        if (a === c.emptyText && c.valueContainsPlaceholder) {
            a = ""
        }
        return a
    },
    setValue: function(c) {
        var a = this,
            d = a.inputEl;
        if (d && a.emptyText && !Ext.isEmpty(c)) {
            d.removeCls(a.emptyCls);
            a.valueContainsPlaceholder = false
        }
        a.callParent(arguments);
        a.applyEmptyText();
        return a
    },
    getErrors: function(n) {
        var i = this,
            m = i.callParent(arguments),
            a = i.validator,
            e = i.emptyText,
            d = i.allowBlank,
            g = i.vtype,
            j = Ext.form.field.VTypes,
            k = i.regex,
            l = Ext.String.format,
            c;
        n = n || i.processRawValue(i.getRawValue());
        if (Ext.isFunction(a)) {
            c = a.call(i, n);
            if (c !== true) {
                m.push(c)
            }
        }
        if (n.length < 1 || (n === i.emptyText && i.valueContainsPlaceholder)) {
            if (!d) {
                m.push(i.blankText)
            }
            return m
        }
        if (n.length < i.minLength) {
            m.push(l(i.minLengthText, i.minLength))
        }
        if (n.length > i.maxLength) {
            m.push(l(i.maxLengthText, i.maxLength))
        }
        if (g) {
            if (!j[g](n, i)) {
                m.push(i.vtypeText || j[g + "Text"])
            }
        }
        if (k && !k.test(n)) {
            m.push(i.regexText || i.invalidText)
        }
        return m
    },
    selectText: function(k, a) {
        var j = this,
            d = j.getRawValue(),
            e = true,
            i = j.inputEl.dom,
            g, c;
        if (d.length > 0) {
            k = k === g ? 0 : k;
            a = a === g ? d.length : a;
            if (i.setSelectionRange) {
                i.setSelectionRange(k, a)
            } else {
                if (i.createTextRange) {
                    c = i.createTextRange();
                    c.moveStart("character", k);
                    c.moveEnd("character", a - d.length);
                    c.select()
                }
            }
            e = Ext.isGecko || Ext.isOpera
        }
        if (e) {
            j.focus()
        }
    },
    autoSize: function() {
        var a = this;
        if (a.grow && a.rendered) {
            a.autoSizing = true;
            a.updateLayout()
        }
    },
    afterComponentLayout: function() {
        var c = this,
            a;
        c.callParent(arguments);
        if (c.autoSizing) {
            a = c.inputEl.getWidth();
            if (a !== c.lastInputWidth) {
                c.fireEvent("autosize", c, a);
                c.lastInputWidth = a;
                delete c.autoSizing
            }
        }
    }
});
Ext.define("Ext.layout.component.field.TextArea", {
    extend: "Ext.layout.component.field.Text",
    alias: "layout.textareafield",
    type: "textareafield",
    canGrowWidth: false,
    naturalSizingProp: "cols",
    beginLayout: function(a) {
        this.callParent(arguments);
        a.target.inputEl.setStyle("height", "")
    },
    measureContentHeight: function(c) {
        var g = this,
            a = g.owner,
            m = g.callParent(arguments),
            d, k, j, i, e, l;
        if (a.grow && !c.state.growHandled) {
            d = c.inputContext;
            k = a.inputEl;
            e = k.getWidth(true);
            j = Ext.util.Format.htmlEncode(k.dom.value) || "&#160;";
            j += a.growAppend;
            j = j.replace(/\n/g, "<br/>");
            l = Ext.util.TextMetrics.measure(k, j, e).height + d.getBorderInfo().height + d.getPaddingInfo().height;
            l = Ext.Number.constrain(l, a.growMin, a.growMax);
            d.setHeight(l);
            c.state.growHandled = true;
            d.domBlock(g, "height");
            m = NaN
        }
        return m
    }
});
Ext.define("Ext.form.field.TextArea", {
    extend: "Ext.form.field.Text",
    alias: ["widget.textareafield", "widget.textarea"],
    alternateClassName: "Ext.form.TextArea",
    requires: ["Ext.XTemplate", "Ext.layout.component.field.TextArea", "Ext.util.DelayedTask"],
    fieldSubTpl: ['<textarea id="{id}" {inputAttrTpl}', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="rows"> rows="{rows}" </tpl>', '<tpl if="cols"> cols="{cols}" </tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '<tpl if="size"> size="{size}"</tpl>', '<tpl if="maxLength !== undefined"> maxlength="{maxLength}"</tpl>', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', ' class="{fieldCls} {typeCls}" ', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' autocomplete="off">\n', '<tpl if="value">{[Ext.util.Format.htmlEncode(values.value)]}</tpl>', "</textarea>", {
        disableFormats: true
    }],
    growMin: 60,
    growMax: 1000,
    growAppend: "\n-",
    cols: 20,
    rows: 4,
    enterIsSpecial: false,
    preventScrollbars: false,
    componentLayout: "textareafield",
    setGrowSizePolicy: Ext.emptyFn,
    returnRe: /\r/g,
    getSubTplData: function() {
        var d = this,
            c = d.getFieldStyle(),
            a = d.callParent();
        if (d.grow) {
            if (d.preventScrollbars) {
                a.fieldStyle = (c || "") + ";overflow:hidden;height:" + d.growMin + "px"
            }
        }
        Ext.applyIf(a, {
            cols: d.cols,
            rows: d.rows
        });
        return a
    },
    afterRender: function() {
        var a = this;
        a.callParent(arguments);
        a.needsMaxCheck = a.enforceMaxLength && a.maxLength !== Number.MAX_VALUE && !Ext.supports.TextAreaMaxLength;
        if (a.needsMaxCheck) {
            a.inputEl.on("paste", a.onPaste, a)
        }
    },
    transformRawValue: function(a) {
        return this.stripReturns(a)
    },
    transformOriginalValue: function(a) {
        return this.stripReturns(a)
    },
    valueToRaw: function(a) {
        a = this.stripReturns(a);
        return this.callParent([a])
    },
    stripReturns: function(a) {
        if (a) {
            a = a.replace(this.returnRe, "")
        }
        return a
    },
    onPaste: function(c) {
        var a = this;
        if (!a.pasteTask) {
            a.pasteTask = new Ext.util.DelayedTask(a.pasteCheck, a)
        }
        a.pasteTask.delay(1)
    },
    pasteCheck: function() {
        var c = this,
            d = c.getValue(),
            a = c.maxLength;
        if (d.length > a) {
            d = d.substr(0, a);
            c.setValue(d)
        }
    },
    fireKey: function(g) {
        var c = this,
            a = g.getKey(),
            d;
        if (g.isSpecialKey() && (c.enterIsSpecial || (a !== g.ENTER || g.hasModifier()))) {
            c.fireEvent("specialkey", c, g)
        }
        if (c.needsMaxCheck && a !== g.BACKSPACE && a !== g.DELETE && !g.isNavKeyPress() && !c.isCutCopyPasteSelectAll(g, a)) {
            d = c.getValue();
            if (d.length >= c.maxLength) {
                g.stopEvent()
            }
        }
    },
    isCutCopyPasteSelectAll: function(c, a) {
        if (c.CTRL) {
            return a === c.A || a === c.C || a === c.V || a === c.X
        }
        return false
    },
    autoSize: function() {
        var c = this,
            a;
        if (c.grow && c.rendered) {
            c.updateLayout();
            a = c.inputEl.getHeight();
            if (a !== c.lastInputHeight) {
                c.fireEvent("autosize", c, a);
                c.lastInputHeight = a
            }
        }
    },
    initAria: function() {
        this.callParent(arguments);
        this.getActionEl().dom.setAttribute("aria-multiline", true)
    },
    beforeDestroy: function() {
        var a = this.pasteTask;
        if (a) {
            a.delay()
        }
        this.callParent()
    }
});
Ext.define("Ext.form.field.Display", {
    extend: "Ext.form.field.Base",
    alias: "widget.displayfield",
    requires: ["Ext.util.Format", "Ext.XTemplate"],
    alternateClassName: ["Ext.form.DisplayField", "Ext.form.Display"],
    fieldSubTpl: ['<div id="{id}"', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' class="{fieldCls}">{value}</div>', {
        compiled: true,
        disableFormats: true
    }],
    fieldCls: Ext.baseCSSPrefix + "form-display-field",
    htmlEncode: false,
    validateOnChange: false,
    initEvents: Ext.emptyFn,
    submitValue: false,
    isDirty: function() {
        return false
    },
    isValid: function() {
        return true
    },
    validate: function() {
        return true
    },
    getRawValue: function() {
        return this.rawValue
    },
    setRawValue: function(c) {
        var a = this,
            d;
        c = Ext.value(c, "");
        a.rawValue = c;
        if (a.rendered) {
            a.inputEl.dom.innerHTML = a.getDisplayValue();
            a.updateLayout()
        }
        return c
    },
    getDisplayValue: function() {
        var a = this,
            c = this.getRawValue(),
            d;
        if (a.renderer) {
            d = a.renderer.call(a.scope || a, c, a)
        } else {
            d = a.htmlEncode ? Ext.util.Format.htmlEncode(c) : c
        }
        return d
    },
    getSubTplData: function() {
        var a = this.callParent(arguments);
        a.value = this.getDisplayValue();
        return a
    }
});
Ext.define("Ext.layout.component.ProgressBar", {
    alias: ["layout.progressbar"],
    extend: "Ext.layout.component.Auto",
    type: "progressbar",
    beginLayout: function(e) {
        var c = this,
            a, d;
        c.callParent(arguments);
        if (!e.textEls) {
            d = c.owner.textEl;
            if (d.isComposite) {
                e.textEls = [];
                d = d.elements;
                for (a = d.length; a--;) {
                    e.textEls[a] = e.getEl(Ext.get(d[a]))
                }
            } else {
                e.textEls = [e.getEl("textEl")]
            }
        }
    },
    calculate: function(g) {
        var d = this,
            a, e, c;
        d.callParent(arguments);
        if (Ext.isNumber(c = g.getProp("width"))) {
            c -= g.getBorderInfo().width;
            e = g.textEls;
            for (a = e.length; a--;) {
                e[a].setWidth(c)
            }
        } else {
            d.done = false
        }
    }
});
Ext.define("Ext.ProgressBar", {
    extend: "Ext.Component",
    alias: "widget.progressbar",
    requires: ["Ext.Template", "Ext.CompositeElement", "Ext.TaskManager", "Ext.layout.component.ProgressBar"],
    uses: ["Ext.fx.Anim"],
    baseCls: Ext.baseCSSPrefix + "progress",
    animate: false,
    text: "",
    waitTimer: null,
    childEls: ["bar"],
    renderTpl: ['<tpl if="internalText">', '<div class="{baseCls}-text {baseCls}-text-back">{text}</div>', "</tpl>", '<div id="{id}-bar" class="{baseCls}-bar" style="width:{percentage}%">', '<tpl if="internalText">', '<div class="{baseCls}-text">', "<div>{text}</div>", "</div>", "</tpl>", "</div>"],
    componentLayout: "progressbar",
    initComponent: function() {
        this.callParent();
        this.addEvents("update")
    },
    initRenderData: function() {
        var a = this;
        return Ext.apply(a.callParent(), {
            internalText: !a.hasOwnProperty("textEl"),
            text: a.text || "&#160;",
            percentage: a.value ? a.value * 100 : 0
        })
    },
    onRender: function() {
        var a = this;
        a.callParent(arguments);
        if (a.textEl) {
            a.textEl = Ext.get(a.textEl);
            a.updateText(a.text)
        } else {
            a.textEl = a.el.select("." + a.baseCls + "-text")
        }
    },
    updateProgress: function(e, g, a) {
        var d = this,
            c = d.value;
        d.value = e || 0;
        if (g) {
            d.updateText(g)
        }
        if (d.rendered && !d.isDestroyed) {
            if (a === true || (a !== false && d.animate)) {
                d.bar.stopAnimation();
                d.bar.animate(Ext.apply({
                    from: {
                        width: (c * 100) + "%"
                    },
                    to: {
                        width: (d.value * 100) + "%"
                    }
                }, d.animate))
            } else {
                d.bar.setStyle("width", (d.value * 100) + "%")
            }
        }
        d.fireEvent("update", d, d.value, g);
        return d
    },
    updateText: function(c) {
        var a = this;
        a.text = c;
        if (a.rendered) {
            a.textEl.update(a.text)
        }
        return a
    },
    applyText: function(a) {
        this.updateText(a)
    },
    getText: function() {
        return this.text
    },
    wait: function(d) {
        var c = this,
            a;
        if (!c.waitTimer) {
            a = c;
            d = d || {};
            c.updateText(d.text);
            c.waitTimer = Ext.TaskManager.start({
                run: function(e) {
                    var g = d.increment || 10;
                    e -= 1;
                    c.updateProgress(((((e + g) % g) + 1) * (100 / g)) * 0.01, null, d.animate)
                },
                interval: d.interval || 1000,
                duration: d.duration,
                onStop: function() {
                    if (d.fn) {
                        d.fn.apply(d.scope || c)
                    }
                    c.reset()
                },
                scope: a
            })
        }
        return c
    },
    isWaiting: function() {
        return this.waitTimer !== null
    },
    reset: function(a) {
        var c = this;
        c.updateProgress(0);
        c.clearTimer();
        if (a === true) {
            c.hide()
        }
        return c
    },
    clearTimer: function() {
        var a = this;
        if (a.waitTimer) {
            a.waitTimer.onStop = null;
            Ext.TaskManager.stop(a.waitTimer);
            a.waitTimer = null
        }
    },
    onDestroy: function() {
        var a = this;
        a.clearTimer();
        if (a.rendered) {
            if (a.textEl.isComposite) {
                a.textEl.clear()
            }
            Ext.destroyMembers(a, "textEl", "progressBar")
        }
        a.callParent()
    }
});
Ext.define("Ext.window.MessageBox", {
    extend: "Ext.window.Window",
    requires: ["Ext.toolbar.Toolbar", "Ext.form.field.Text", "Ext.form.field.TextArea", "Ext.form.field.Display", "Ext.button.Button", "Ext.layout.container.Anchor", "Ext.layout.container.HBox", "Ext.ProgressBar"],
    alias: "widget.messagebox",
    OK: 1,
    YES: 2,
    NO: 4,
    CANCEL: 8,
    OKCANCEL: 9,
    YESNO: 6,
    YESNOCANCEL: 14,
    INFO: Ext.baseCSSPrefix + "message-box-info",
    WARNING: Ext.baseCSSPrefix + "message-box-warning",
    QUESTION: Ext.baseCSSPrefix + "message-box-question",
    ERROR: Ext.baseCSSPrefix + "message-box-error",
    hideMode: "offsets",
    closeAction: "hide",
    resizable: false,
    title: "&#160;",
    width: 600,
    height: 500,
    minWidth: 250,
    maxWidth: 600,
    minHeight: 110,
    maxHeight: 500,
    constrain: true,
    cls: Ext.baseCSSPrefix + "message-box",
    layout: {
        type: "vbox",
        align: "stretch"
    },
    defaultTextHeight: 75,
    minProgressWidth: 250,
    minPromptWidth: 250,
    buttonText: {
        ok: "OK",
        yes: "Yes",
        no: "No",
        cancel: "Cancel"
    },
    buttonIds: ["ok", "yes", "no", "cancel"],
    titleText: {
        confirm: "Confirm",
        prompt: "Prompt",
        wait: "Loading...",
        alert: "Attention"
    },
    iconHeight: 35,
    makeButton: function(a) {
        var c = this.buttonIds[a];
        return new Ext.button.Button({
            handler: this.btnCallback,
            itemId: c,
            scope: this,
            text: this.buttonText[c],
            minWidth: 75
        })
    },
    btnCallback: function(a) {
        var c = this,
            d, e;
        if (c.cfg.prompt || c.cfg.multiline) {
            if (c.cfg.multiline) {
                e = c.textArea
            } else {
                e = c.textField
            }
            d = e.getValue();
            e.reset()
        }
        a.blur();
        c.hide();
        c.userCallback(a.itemId, d, c.cfg)
    },
    hide: function() {
        var a = this;
        a.dd.endDrag();
        a.progressBar.reset();
        a.removeCls(a.cfg.cls);
        a.callParent(arguments)
    },
    initComponent: function() {
        var g = this,
            a = g.id,
            d, c, e;
        g.title = "&#160;";
        g.topContainer = new Ext.container.Container({
            layout: "hbox",
            style: {
                padding: "10px",
                overflow: "hidden"
            },
            items: [g.iconComponent = new Ext.Component({
                cls: g.baseCls + "-icon",
                width: 50,
                height: g.iconHeight
            }), g.promptContainer = new Ext.container.Container({
                flex: 1,
                layout: {
                    type: "anchor"
                },
                items: [g.msg = new Ext.form.field.Display({
                    id: a + "-displayfield",
                    cls: g.baseCls + "-text"
                }), g.textField = new Ext.form.field.Text({
                    id: a + "-testfield",
                    anchor: "100%",
                    enableKeyEvents: true,
                    listeners: {
                        keydown: g.onPromptKey,
                        scope: g
                    }
                }), g.textArea = new Ext.form.field.TextArea({
                    id: a + "-textarea",
                    anchor: "100%",
                    height: 75
                })]
            })]
        });
        g.progressBar = new Ext.ProgressBar({
            id: a + "-progressbar",
            margins: "0 10 0 10"
        });
        g.items = [g.topContainer, g.progressBar];
        g.msgButtons = [];
        for (d = 0; d < 4; d++) {
            c = g.makeButton(d);
            g.msgButtons[c.itemId] = c;
            g.msgButtons.push(c)
        }
        g.bottomTb = new Ext.toolbar.Toolbar({
            id: a + "-toolbar",
            ui: "footer",
            dock: "bottom",
            layout: {
                pack: "center"
            },
            items: [g.msgButtons[0], g.msgButtons[1], g.msgButtons[2], g.msgButtons[3]]
        });
        g.dockedItems = [g.bottomTb];
        e = g.bottomTb.getLayout();
        e.finishedLayout = Ext.Function.createInterceptor(e.finishedLayout, function(i) {
            g.tbWidth = i.getProp("contentWidth")
        });
        g.on("close", g.onClose, g);
        g.callParent()
    },
    onClose: function() {
        var a = this.header.child("[type=close]");
        a.itemId = "cancel";
        this.btnCallback(a);
        delete a.itemId
    },
    onPromptKey: function(a, d) {
        var c = this,
            g;
        if (d.keyCode === Ext.EventObject.RETURN || d.keyCode === 10) {
            if (c.msgButtons.ok.isVisible()) {
                g = true;
                c.msgButtons.ok.handler.call(c, c.msgButtons.ok)
            } else {
                if (c.msgButtons.yes.isVisible()) {
                    c.msgButtons.yes.handler.call(c, c.msgButtons.yes);
                    g = true
                }
            }
            if (g) {
                c.textField.blur()
            }
        }
    },
    reconfigure: function(a) {
        var e = this,
            d = 0,
            k = true,
            j = e.maxWidth,
            g = e.buttonText,
            c;
        e.updateButtonText();
        a = a || {};
        e.cfg = a;
        if (a.width) {
            j = a.width
        }
        delete e.defaultFocus;
        e.animateTarget = a.animateTarget || undefined;
        e.modal = a.modal !== false;
        if (a.title) {
            e.setTitle(a.title || "&#160;")
        }
        if (Ext.isObject(a.buttons)) {
            e.buttonText = a.buttons;
            d = 0
        } else {
            e.buttonText = a.buttonText || e.buttonText;
            d = Ext.isNumber(a.buttons) ? a.buttons : 0
        }
        d = d | e.updateButtonText();
        e.buttonText = g;
        Ext.suspendLayouts();
        e.hidden = false;
        if (!e.rendered) {
            e.width = j;
            e.render(Ext.getBody())
        } else {
            e.setSize(j, e.maxHeight)
        }
        e.closable = a.closable && !a.wait;
        e.header.child("[type=close]").setVisible(a.closable !== false);
        if (!a.title && !e.closable) {
            e.header.hide()
        } else {
            e.header.show()
        }
        e.liveDrag = !a.proxyDrag;
        e.userCallback = Ext.Function.bind(a.callback || a.fn || Ext.emptyFn, a.scope || Ext.global);
        e.setIcon(a.icon);
        if (a.msg) {
            e.msg.setValue(a.msg);
            e.msg.show()
        } else {
            e.msg.hide()
        }
        Ext.resumeLayouts(true);
        Ext.suspendLayouts();
        if (a.prompt || a.multiline) {
            e.multiline = a.multiline;
            if (a.multiline) {
                e.textArea.setValue(a.value);
                e.textArea.setHeight(a.defaultTextHeight || e.defaultTextHeight);
                e.textArea.show();
                e.textField.hide();
                e.defaultFocus = e.textArea
            } else {
                e.textField.setValue(a.value);
                e.textArea.hide();
                e.textField.show();
                e.defaultFocus = e.textField
            }
        } else {
            e.textArea.hide();
            e.textField.hide()
        }
        if (a.progress || a.wait) {
            e.progressBar.show();
            e.updateProgress(0, a.progressText);
            if (a.wait === true) {
                e.progressBar.wait(a.waitConfig)
            }
        } else {
            e.progressBar.hide()
        }
        for (c = 0; c < 4; c++) {
            if (d & Math.pow(2, c)) {
                if (!e.defaultFocus) {
                    e.defaultFocus = e.msgButtons[c]
                }
                e.msgButtons[c].show();
                k = false
            } else {
                e.msgButtons[c].hide()
            }
        }
        if (k) {
            e.bottomTb.hide()
        } else {
            e.bottomTb.show()
        }
        Ext.resumeLayouts(true)
    },
    updateButtonText: function() {
        var e = this,
            d = e.buttonText,
            c = 0,
            g, a;
        for (g in d) {
            if (d.hasOwnProperty(g)) {
                a = e.msgButtons[g];
                if (a) {
                    if (e.cfg && e.cfg.buttonText) {
                        c = c | Math.pow(2, Ext.Array.indexOf(e.buttonIds, g))
                    }
                    if (a.text != d[g]) {
                        a.setText(d[g])
                    }
                }
            }
        }
        return c
    },
    show: function(a) {
        var c = this;
        c.reconfigure(a);
        c.addCls(a.cls);
        c.doAutoSize();
        c.hidden = true;
        c.callParent();
        return c
    },
    onShow: function() {
        this.callParent(arguments);
        this.center()
    },
    doAutoSize: function() {
        var e = this,
            g = e.header.rendered && e.header.isVisible(),
            d = e.bottomTb.rendered && e.bottomTb.isVisible(),
            c, a;
        if (!Ext.isDefined(e.frameWidth)) {
            e.frameWidth = e.el.getWidth() - e.body.getWidth()
        }
        e.minWidth = e.cfg.minWidth || Ext.getClass(this).prototype.minWidth;
        c = Math.max(g ? e.header.getMinWidth() : 0, e.cfg.width || e.msg.getWidth() + e.iconComponent.getWidth() + 25, (d ? e.tbWidth : 0));
        a = (g ? e.header.getHeight() : 0) + e.topContainer.getHeight() + e.progressBar.getHeight() + (d ? e.bottomTb.getHeight() + e.bottomTb.el.getMargin("tb") : 0);
        e.setSize(c + e.frameWidth, a + e.frameWidth);
        return e
    },
    updateText: function(a) {
        this.msg.setValue(a);
        return this.doAutoSize(true)
    },
    setIcon: function(a) {
        var c = this;
        c.iconComponent.removeCls(c.messageIconCls);
        if (a) {
            c.iconComponent.show();
            c.iconComponent.addCls(Ext.baseCSSPrefix + "dlg-icon");
            c.iconComponent.addCls(c.messageIconCls = a)
        } else {
            c.iconComponent.removeCls(Ext.baseCSSPrefix + "dlg-icon");
            c.iconComponent.hide()
        }
        return c
    },
    updateProgress: function(c, a, d) {
        this.progressBar.updateProgress(c, a);
        if (d) {
            this.updateText(d)
        }
        return this
    },
    onEsc: function() {
        if (this.closable !== false) {
            this.callParent(arguments)
        }
    },
    confirm: function(a, e, d, c) {
        if (Ext.isString(a)) {
            a = {
                title: a,
                icon: this.QUESTION,
                msg: e,
                buttons: this.YESNO,
                callback: d,
                scope: c
            }
        }
        return this.show(a)
    },
    prompt: function(c, i, e, d, a, g) {
        if (Ext.isString(c)) {
            c = {
                prompt: true,
                title: c,
                minWidth: this.minPromptWidth,
                msg: i,
                buttons: this.OKCANCEL,
                callback: e,
                scope: d,
                multiline: a,
                value: g
            }
        }
        return this.show(c)
    },
    wait: function(a, d, c) {
        if (Ext.isString(a)) {
            a = {
                title: d,
                msg: a,
                closable: false,
                wait: true,
                modal: true,
                minWidth: this.minProgressWidth,
                waitConfig: c
            }
        }
        return this.show(a)
    },
    alert: function(a, e, d, c) {
        if (Ext.isString(a)) {
            a = {
                title: a,
                msg: e,
                buttons: this.OK,
                fn: d,
                scope: c,
                minWidth: this.minWidth
            }
        }
        return this.show(a)
    },
    progress: function(a, d, c) {
        if (Ext.isString(a)) {
            a = {
                title: a,
                msg: d,
                progress: true,
                progressText: c
            }
        }
        return this.show(a)
    }
}, function() {
    Ext.MessageBox = Ext.Msg = new this()
});
Ext.define("Ext.form.Basic", {
    extend: "Ext.util.Observable",
    alternateClassName: "Ext.form.BasicForm",
    requires: ["Ext.util.MixedCollection", "Ext.form.action.Load", "Ext.form.action.Submit", "Ext.window.MessageBox", "Ext.data.Errors", "Ext.util.DelayedTask"],
    constructor: function(a, c) {
        var g = this,
            i = g.onItemAddOrRemove,
            e, d;
        g.owner = a;
        g.mon(a, {
            add: i,
            remove: i,
            scope: g
        });
        Ext.apply(g, c);
        if (Ext.isString(g.paramOrder)) {
            g.paramOrder = g.paramOrder.split(/[\s,|]/)
        }
        if (g.api) {
            e = g.api = Ext.apply({}, g.api);
            for (d in e) {
                if (e.hasOwnProperty(d)) {
                    e[d] = Ext.direct.Manager.parseMethod(e[d])
                }
            }
        }
        g.checkValidityTask = new Ext.util.DelayedTask(g.checkValidity, g);
        g.addEvents("beforeaction", "actionfailed", "actioncomplete", "validitychange", "dirtychange");
        g.callParent()
    },
    initialize: function() {
        var a = this;
        a.initialized = true;
        a.onValidityChange(!a.hasInvalidField())
    },
    timeout: 30,
    paramsAsHash: false,
    waitTitle: "Please Wait...",
    trackResetOnLoad: false,
    wasDirty: false,
    destroy: function() {
        this.clearListeners();
        this.checkValidityTask.cancel()
    },
    onItemAddOrRemove: function(d, i) {
        var e = this,
            g = !!i.ownerCt,
            c = i.isContainer;

        function a(j) {
            e[g ? "mon" : "mun"](j, {
                validitychange: e.checkValidity,
                dirtychange: e.checkDirty,
                scope: e,
                buffer: 100
            });
            delete e._fields
        }
        if (i.isFormField) {
            a(i)
        } else {
            if (c) {
                if (i.isDestroyed || i.destroying) {
                    delete e._fields
                } else {
                    Ext.Array.forEach(i.query("[isFormField]"), a)
                }
            }
        }
        delete this._boundItems;
        if (e.initialized) {
            e.checkValidityTask.delay(10)
        }
    },
    getFields: function() {
        var a = this._fields;
        if (!a) {
            a = this._fields = new Ext.util.MixedCollection();
            a.addAll(this.owner.query("[isFormField]"))
        }
        return a
    },
    getBoundItems: function() {
        var a = this._boundItems;
        if (!a || a.getCount() === 0) {
            a = this._boundItems = new Ext.util.MixedCollection();
            a.addAll(this.owner.query("[formBind]"))
        }
        return a
    },
    hasInvalidField: function() {
        return !!this.getFields().findBy(function(d) {
            var a = d.preventMark,
                c;
            d.preventMark = true;
            c = d.isValid();
            d.preventMark = a;
            return !c
        })
    },
    isValid: function() {
        var a = this,
            c;
        Ext.suspendLayouts();
        c = a.getFields().filterBy(function(d) {
            return !d.validate()
        });
        Ext.resumeLayouts(true);
        return c.length < 1
    },
    checkValidity: function() {
        var c = this,
            a = !c.hasInvalidField();
        if (a !== c.wasValid) {
            c.onValidityChange(a);
            c.fireEvent("validitychange", c, a);
            c.wasValid = a
        }
    },
    onValidityChange: function(j) {
        var e = this.getBoundItems(),
            c, d, a, g;
        if (e) {
            c = e.items;
            a = c.length;
            for (d = 0; d < a; d++) {
                g = c[d];
                if (g.disabled === j) {
                    g.setDisabled(!j)
                }
            }
        }
    },
    isDirty: function() {
        return !!this.getFields().findBy(function(a) {
            return a.isDirty()
        })
    },
    checkDirty: function() {
        var a = this.isDirty();
        if (a !== this.wasDirty) {
            this.fireEvent("dirtychange", this, a);
            this.wasDirty = a
        }
    },
    hasUpload: function() {
        return !!this.getFields().findBy(function(a) {
            return a.isFileUpload()
        })
    },
    doAction: function(c, a) {
        if (Ext.isString(c)) {
            c = Ext.ClassManager.instantiateByAlias("formaction." + c, Ext.apply({}, a, {
                form: this
            }))
        }
        if (this.fireEvent("beforeaction", this, c) !== false) {
            this.beforeAction(c);
            Ext.defer(c.run, 100, c)
        }
        return this
    },
    submit: function(a) {
        a = a || {};
        var c = this,
            d;
        if (a.standardSubmit || c.standardSubmit) {
            d = "standardsubmit"
        } else {
            d = c.api ? "directsubmit" : "submit"
        }
        return c.doAction(d, a)
    },
    load: function(a) {
        return this.doAction(this.api ? "directload" : "load", a)
    },
    updateRecord: function(d) {
        d = d || this._record;
        var c = d.fields.items,
            e = this.getFieldValues(),
            k = {},
            j = 0,
            a = c.length,
            g;
        for (; j < a; ++j) {
            g = c[j].name;
            if (e.hasOwnProperty(g)) {
                k[g] = e[g]
            }
        }
        d.beginEdit();
        d.set(k);
        d.endEdit();
        return this
    },
    loadRecord: function(a) {
        this._record = a;
        return this.setValues(a.data)
    },
    getRecord: function() {
        return this._record
    },
    beforeAction: function(g) {
        var c = g.waitMsg,
            e = Ext.baseCSSPrefix + "mask-loading",
            a = this.getFields().items,
            d, k = a.length,
            i, j;
        for (d = 0; d < k; d++) {
            i = a[d];
            if (i.isFormField && i.syncValue) {
                i.syncValue()
            }
        }
        if (c) {
            j = this.waitMsgTarget;
            if (j === true) {
                this.owner.el.mask(c, e)
            } else {
                if (j) {
                    j = this.waitMsgTarget = Ext.get(j);
                    j.mask(c, e)
                } else {
                    Ext.MessageBox.wait(c, g.waitTitle || this.waitTitle)
                }
            }
        }
    },
    afterAction: function(c, e) {
        if (c.waitMsg) {
            var a = Ext.MessageBox,
                d = this.waitMsgTarget;
            if (d === true) {
                this.owner.el.unmask()
            } else {
                if (d) {
                    d.unmask()
                } else {
                    a.suspendEvents();
                    a.hide();
                    a.resumeEvents()
                }
            }
        }
        if (e) {
            if (c.reset) {
                this.reset()
            }
            Ext.callback(c.success, c.scope || c, [this, c]);
            this.fireEvent("actioncomplete", this, c)
        } else {
            Ext.callback(c.failure, c.scope || c, [this, c]);
            this.fireEvent("actionfailed", this, c)
        }
    },
    findField: function(a) {
        return this.getFields().findBy(function(c) {
            return c.id === a || c.getName() === a
        })
    },
    markInvalid: function(l) {
        var g = this,
            j, a, c, i, d;

        function k(e, n) {
            var m = g.findField(e);
            if (m) {
                m.markInvalid(n)
            }
        }
        if (Ext.isArray(l)) {
            a = l.length;
            for (j = 0; j < a; j++) {
                c = l[j];
                k(c.id, c.msg)
            }
        } else {
            if (l instanceof Ext.data.Errors) {
                a = l.items.length;
                for (j = 0; j < a; j++) {
                    c = l.items[j];
                    k(c.field, c.message)
                }
            } else {
                for (d in l) {
                    if (l.hasOwnProperty(d)) {
                        i = l[d];
                        k(d, i, l)
                    }
                }
            }
        }
        return this
    },
    setValues: function(c) {
        var e = this,
            a, d, j, i;

        function g(k, m) {
            var l = e.findField(k);
            if (l) {
                l.setValue(m);
                if (e.trackResetOnLoad) {
                    l.resetOriginalValue()
                }
            }
        }
        if (Ext.isArray(c)) {
            d = c.length;
            for (a = 0; a < d; a++) {
                j = c[a];
                g(j.id, j.value)
            }
        } else {
            Ext.iterate(c, g)
        }
        return this
    },
    getValues: function(k, l, p, n) {
        var o = {},
            i = this.getFields().items,
            j, q = i.length,
            g = Ext.isArray,
            m, e, d, c, a;
        for (j = 0; j < q; j++) {
            m = i[j];
            if (!l || m.isDirty()) {
                e = m[n ? "getModelData" : "getSubmitData"](p);
                if (Ext.isObject(e)) {
                    for (a in e) {
                        if (e.hasOwnProperty(a)) {
                            d = e[a];
                            if (p && d === "") {
                                d = m.emptyText || ""
                            }
                            if (o.hasOwnProperty(a)) {
                                c = o[a];
                                if (!g(c)) {
                                    c = o[a] = [c]
                                }
                                if (g(d)) {
                                    o[a] = o[a] = c.concat(d)
                                } else {
                                    c.push(d)
                                }
                            } else {
                                o[a] = d
                            }
                        }
                    }
                }
            }
        }
        if (k) {
            o = Ext.Object.toQueryString(o)
        }
        return o
    },
    getFieldValues: function(a) {
        return this.getValues(false, a, false, true)
    },
    clearInvalid: function() {
        Ext.suspendLayouts();
        var c = this,
            a = c.getFields().items,
            d, e = a.length;
        for (d = 0; d < e; d++) {
            a[d].clearInvalid()
        }
        Ext.resumeLayouts(true);
        return c
    },
    reset: function() {
        Ext.suspendLayouts();
        var c = this,
            a = c.getFields().items,
            d, e = a.length;
        for (d = 0; d < e; d++) {
            a[d].reset()
        }
        Ext.resumeLayouts(true);
        return c
    },
    applyToFields: function(d) {
        var a = this.getFields().items,
            c, e = a.length;
        for (c = 0; c < e; c++) {
            Ext.apply(a[c], d)
        }
        return this
    },
    applyIfToFields: function(d) {
        var a = this.getFields().items,
            c, e = a.length;
        for (c = 0; c < e; c++) {
            Ext.applyIf(a[c], d)
        }
        return this
    }
});
Ext.define("Ext.form.FieldAncestor", {
    initFieldAncestor: function() {
        var a = this,
            c = a.onFieldAncestorSubtreeChange;
        a.addEvents("fieldvaliditychange", "fielderrorchange");
        a.on("add", c, a);
        a.on("remove", c, a);
        a.initFieldDefaults()
    },
    initFieldDefaults: function() {
        if (!this.fieldDefaults) {
            this.fieldDefaults = {}
        }
    },
    onFieldAncestorSubtreeChange: function(c, g) {
        var d = this,
            e = !!g.ownerCt;

        function a(i) {
            var j = i.isFieldLabelable,
                k = i.isFormField;
            if (j || k) {
                if (j) {
                    d["onLabelable" + (e ? "Added" : "Removed")](i)
                }
                if (k) {
                    d["onField" + (e ? "Added" : "Removed")](i)
                }
            } else {
                if (i.isContainer) {
                    Ext.Array.forEach(i.getRefItems(), a)
                }
            }
        }
        a(g)
    },
    onLabelableAdded: function(a) {
        var c = this;
        c.mon(a, "errorchange", c.handleFieldErrorChange, c, {
            buffer: 10
        });
        a.setFieldDefaults(c.fieldDefaults)
    },
    onFieldAdded: function(c) {
        var a = this;
        a.mon(c, "validitychange", a.handleFieldValidityChange, a)
    },
    onLabelableRemoved: function(a) {
        var c = this;
        c.mun(a, "errorchange", c.handleFieldErrorChange, c)
    },
    onFieldRemoved: function(c) {
        var a = this;
        a.mun(c, "validitychange", a.handleFieldValidityChange, a)
    },
    handleFieldValidityChange: function(d, c) {
        var a = this;
        a.fireEvent("fieldvaliditychange", a, d, c);
        a.onFieldValidityChange(d, c)
    },
    handleFieldErrorChange: function(c, a) {
        var d = this;
        d.fireEvent("fielderrorchange", d, c, a);
        d.onFieldErrorChange(c, a)
    },
    onFieldValidityChange: Ext.emptyFn,
    onFieldErrorChange: Ext.emptyFn
});
Ext.define("Ext.form.Panel", {
    extend: "Ext.panel.Panel",
    mixins: {
        fieldAncestor: "Ext.form.FieldAncestor"
    },
    alias: "widget.form",
    alternateClassName: ["Ext.FormPanel", "Ext.form.FormPanel"],
    requires: ["Ext.form.Basic", "Ext.util.TaskRunner"],
    layout: "anchor",
    ariaRole: "form",
    basicFormConfigs: ["api", "baseParams", "errorReader", "method", "paramOrder", "paramsAsHash", "reader", "standardSubmit", "timeout", "trackResetOnLoad", "url", "waitMsgTarget", "waitTitle"],
    initComponent: function() {
        var a = this;
        if (a.frame) {
            a.border = false
        }
        a.initFieldAncestor();
        a.callParent();
        a.relayEvents(a.form, ["beforeaction", "actionfailed", "actioncomplete", "validitychange", "dirtychange"]);
        if (a.pollForChanges) {
            a.startPolling(a.pollInterval || 500)
        }
    },
    initItems: function() {
        var a = this;
        a.form = a.createForm();
        a.callParent()
    },
    afterFirstLayout: function() {
        this.callParent();
        this.form.initialize()
    },
    createForm: function() {
        var c = {},
            e = this.basicFormConfigs,
            a = e.length,
            d = 0,
            g;
        for (; d < a; ++d) {
            g = e[d];
            c[g] = this[g]
        }
        return new Ext.form.Basic(this, c)
    },
    getForm: function() {
        return this.form
    },
    loadRecord: function(a) {
        return this.getForm().loadRecord(a)
    },
    getRecord: function() {
        return this.getForm().getRecord()
    },
    getValues: function(e, c, d, a) {
        return this.getForm().getValues(e, c, d, a)
    },
    beforeDestroy: function() {
        this.stopPolling();
        this.form.destroy();
        this.callParent()
    },
    load: function(a) {
        this.form.load(a)
    },
    submit: function(a) {
        this.form.submit(a)
    },
    startPolling: function(c) {
        this.stopPolling();
        var a = new Ext.util.TaskRunner(c);
        a.start({
            interval: 0,
            run: this.checkChange,
            scope: this
        });
        this.pollTask = a
    },
    stopPolling: function() {
        var a = this.pollTask;
        if (a) {
            a.stopAll();
            delete this.pollTask
        }
    },
    checkChange: function() {
        var a = this.form.getFields().items,
            c, e = a.length,
            d;
        for (c = 0; c < e; c++) {
            a[c].checkChange()
        }
    }
});
Ext.define("Ext.form.field.Trigger", {
    extend: "Ext.form.field.Text",
    alias: ["widget.triggerfield", "widget.trigger"],
    requires: ["Ext.DomHelper", "Ext.util.ClickRepeater", "Ext.layout.component.field.Trigger"],
    alternateClassName: ["Ext.form.TriggerField", "Ext.form.TwinTriggerField", "Ext.form.Trigger"],
    childEls: [{
        name: "triggerCell",
        select: "." + Ext.baseCSSPrefix + "trigger-cell"
    }, {
        name: "triggerEl",
        select: "." + Ext.baseCSSPrefix + "form-trigger"
    }, "triggerWrap", "inputCell"],
    triggerBaseCls: Ext.baseCSSPrefix + "form-trigger",
    triggerWrapCls: Ext.baseCSSPrefix + "form-trigger-wrap",
    triggerNoEditCls: Ext.baseCSSPrefix + "trigger-noedit",
    hideTrigger: false,
    editable: true,
    readOnly: false,
    repeatTriggerClick: false,
    autoSize: Ext.emptyFn,
    monitorTab: true,
    mimicing: false,
    triggerIndexRe: /trigger-index-(\d+)/,
    componentLayout: "triggerfield",
    initComponent: function() {
        this.wrapFocusCls = this.triggerWrapCls + "-focus";
        this.callParent(arguments)
    },
    getSubTplMarkup: function() {
        var a = this,
            c = a.callParent(arguments);
        return '<table id="' + a.id + '-triggerWrap" class="' + Ext.baseCSSPrefix + 'form-trigger-wrap" cellpadding="0" cellspacing="0"><tbody><tr><td id="' + a.id + '-inputCell" class="' + Ext.baseCSSPrefix + 'form-trigger-input-cell">' + c + "</td>" + a.getTriggerMarkup() + "</tr></tbody></table>"
    },
    getSubTplData: function() {
        var c = this,
            d = c.callParent(),
            e = c.readOnly === true,
            a = c.editable !== false;
        return Ext.apply(d, {
            editableCls: (e || !a) ? " " + c.triggerNoEditCls : "",
            readOnly: !a || e
        })
    },
    getLabelableRenderData: function() {
        var c = this,
            d = c.triggerWrapCls,
            a = c.callParent(arguments);
        return Ext.applyIf(a, {
            triggerWrapCls: d,
            triggerMarkup: c.getTriggerMarkup()
        })
    },
    getTriggerMarkup: function() {
        var d = this,
            c = 0,
            e = (d.readOnly || d.hideTrigger),
            j, g = d.triggerBaseCls,
            a = [];
        if (!d.trigger1Cls) {
            d.trigger1Cls = d.triggerCls
        }
        for (c = 0;
            (j = d["trigger" + (c + 1) + "Cls"]) || c < 1; c++) {
            a.push({
                tag: "td",
                valign: "top",
                cls: Ext.baseCSSPrefix + "trigger-cell",
                style: "width:" + d.triggerWidth + (e ? "px;display:none" : "px"),
                cn: {
                    cls: [Ext.baseCSSPrefix + "trigger-index-" + c, g, j].join(" "),
                    role: "button"
                }
            })
        }
        a[c - 1].cn.cls += " " + g + "-last";
        return Ext.DomHelper.markup(a)
    },
    disableCheck: function() {
        return !this.disabled
    },
    beforeRender: function() {
        var a = this,
            c = a.triggerBaseCls,
            d;
        if (!a.triggerWidth) {
            d = Ext.resetElement.createChild({
                style: "position: absolute;",
                cls: Ext.baseCSSPrefix + "form-trigger"
            });
            Ext.form.field.Trigger.prototype.triggerWidth = d.getWidth();
            d.remove()
        }
        a.callParent();
        if (c != Ext.baseCSSPrefix + "form-trigger") {
            a.addChildEls({
                name: "triggerEl",
                select: "." + c
            })
        }
        a.lastTriggerStateFlags = a.getTriggerStateFlags()
    },
    onRender: function() {
        var a = this;
        a.callParent(arguments);
        a.doc = Ext.getDoc();
        a.initTrigger();
        a.triggerEl.unselectable()
    },
    getTriggerWidth: function() {
        var c = this,
            a = 0;
        if (c.triggerWrap && !c.hideTrigger && !c.readOnly) {
            a = c.triggerEl.getCount() * c.triggerWidth
        }
        return a
    },
    setHideTrigger: function(a) {
        if (a != this.hideTrigger) {
            this.hideTrigger = a;
            this.updateLayout()
        }
    },
    setEditable: function(a) {
        if (a != this.editable) {
            this.editable = a;
            this.updateLayout()
        }
    },
    setReadOnly: function(a) {
        if (a != this.readOnly) {
            this.readOnly = a;
            this.updateLayout()
        }
    },
    initTrigger: function() {
        var j = this,
            k = j.triggerWrap,
            m = j.triggerEl,
            a = j.disableCheck,
            g, d, c, i, l;
        if (j.repeatTriggerClick) {
            j.triggerRepeater = new Ext.util.ClickRepeater(k, {
                preventDefault: true,
                handler: j.onTriggerWrapClick,
                listeners: {
                    mouseup: j.onTriggerWrapMouseup,
                    scope: j
                },
                scope: j
            })
        } else {
            j.mon(k, {
                click: j.onTriggerWrapClick,
                mouseup: j.onTriggerWrapMouseup,
                scope: j
            })
        }
        m.setVisibilityMode(Ext.Element.DISPLAY);
        m.addClsOnOver(j.triggerBaseCls + "-over", a, j);
        g = m.elements;
        d = g.length;
        for (i = 0; i < d; i++) {
            c = g[i];
            l = i + 1;
            c.addClsOnOver(j["trigger" + (l) + "Cls"] + "-over", a, j);
            c.addClsOnClick(j["trigger" + (l) + "Cls"] + "-click", a, j)
        }
        m.addClsOnClick(j.triggerBaseCls + "-click", a, j)
    },
    onDestroy: function() {
        var a = this;
        Ext.destroyMembers(a, "triggerRepeater", "triggerWrap", "triggerEl");
        delete a.doc;
        a.callParent()
    },
    onFocus: function() {
        var a = this;
        a.callParent(arguments);
        if (!a.mimicing) {
            a.bodyEl.addCls(a.wrapFocusCls);
            a.mimicing = true;
            a.mon(a.doc, "mousedown", a.mimicBlur, a, {
                delay: 10
            });
            if (a.monitorTab) {
                a.on("specialkey", a.checkTab, a)
            }
        }
    },
    checkTab: function(a, c) {
        if (!this.ignoreMonitorTab && c.getKey() == c.TAB) {
            this.triggerBlur()
        }
    },
    getTriggerStateFlags: function() {
        var a = this,
            c = 0;
        if (a.readOnly) {
            c += 1
        }
        if (a.editable) {
            c += 2
        }
        if (a.hideTrigger) {
            c += 4
        }
        return c
    },
    onBlur: Ext.emptyFn,
    mimicBlur: function(a) {
        if (!this.isDestroyed && !this.bodyEl.contains(a.target) && this.validateBlur(a)) {
            this.triggerBlur(a)
        }
    },
    triggerBlur: function(c) {
        var a = this;
        a.mimicing = false;
        a.mun(a.doc, "mousedown", a.mimicBlur, a);
        if (a.monitorTab && a.inputEl) {
            a.un("specialkey", a.checkTab, a)
        }
        Ext.form.field.Trigger.superclass.onBlur.call(a, c);
        if (a.bodyEl) {
            a.bodyEl.removeCls(a.wrapFocusCls)
        }
    },
    validateBlur: function(a) {
        return true
    },
    onTriggerWrapClick: function() {
        var e = this,
            g, c, a, d;
        d = arguments[e.triggerRepeater ? 1 : 0];
        if (d && !e.readOnly && !e.disabled) {
            g = d.getTarget("." + e.triggerBaseCls, null);
            c = g && g.className.match(e.triggerIndexRe);
            if (c) {
                a = e["onTrigger" + (parseInt(c[1], 10) + 1) + "Click"] || e.onTriggerClick;
                if (a) {
                    a.call(e, d)
                }
            }
        }
    },
    onTriggerWrapMouseup: Ext.emptyFn,
    onTriggerClick: Ext.emptyFn
});
Ext.define("Ext.form.field.File", {
    extend: "Ext.form.field.Trigger",
    alias: ["widget.filefield", "widget.fileuploadfield"],
    alternateClassName: ["Ext.form.FileUploadField", "Ext.ux.form.FileUploadField", "Ext.form.File"],
    uses: ["Ext.button.Button", "Ext.layout.component.field.Field"],
    buttonText: "Browse...",
    buttonOnly: false,
    buttonMargin: 3,
    fieldBodyCls: Ext.baseCSSPrefix + "form-file-wrap",
    readOnly: true,
    triggerNoEditCls: "",
    componentLayout: "triggerfield",
    childEls: ["fileInputEl", "buttonEl", "buttonEl-btnEl", "browseButtonWrap"],
    onRender: function() {
        var a = this,
            c;
        a.callParent(arguments);
        c = a.inputEl;
        c.dom.name = "";
        a.fileInputEl.dom.name = a.getName();
        a.fileInputEl.on({
            scope: a,
            change: a.onFileChange
        });
        if (a.buttonOnly) {
            a.inputCell.setDisplayed(false)
        }
        a.browseButtonWrap.dom.style.width = (a.browseButtonWrap.dom.lastChild.offsetWidth + a.buttonEl.getMargin("lr")) + "px";
        if (Ext.isIE) {
            a.buttonEl.repaint()
        }
    },
    getTriggerMarkup: function() {
        var e = this,
            a, d = Ext.widget("button", Ext.apply({
                id: e.id + "-buttonEl",
                ui: e.ui,
                disabled: e.disabled,
                text: e.buttonText,
                cls: Ext.baseCSSPrefix + "form-file-btn",
                preventDefault: false,
                style: e.buttonOnly ? "" : "margin-left:" + e.buttonMargin + "px"
            }, e.buttonConfig)),
            c = d.getRenderTree(),
            g = {
                id: e.id + "-fileInputEl",
                cls: Ext.baseCSSPrefix + "form-file-input",
                tag: "input",
                type: "file",
                size: 1
            };
        if (e.disabled) {
            g.disabled = true
        }
        c.cn = g;
        a = '<td id="' + e.id + '-browseButtonWrap">' + Ext.DomHelper.markup(c) + "</td>";
        d.destroy();
        return a
    },
    createFileInput: function() {
        var a = this;
        a.fileInputEl = a.buttonEl.createChild({
            name: a.getName(),
            id: a.id + "-fileInputEl",
            cls: Ext.baseCSSPrefix + "form-file-input",
            tag: "input",
            type: "file",
            size: 1
        });
        a.fileInputEl.on({
            scope: a,
            change: a.onFileChange
        })
    },
    onFileChange: function() {
        this.lastValue = null;
        Ext.form.field.File.superclass.setValue.call(this, this.fileInputEl.dom.value)
    },
    setValue: Ext.emptyFn,
    reset: function() {
        var a = this;
        if (a.rendered) {
            a.fileInputEl.remove();
            a.createFileInput();
            a.inputEl.dom.value = ""
        }
        a.callParent()
    },
    onDisable: function() {
        this.callParent();
        this.disableItems()
    },
    disableItems: function() {
        var a = this.fileInputEl;
        if (a) {
            a.dom.disabled = true
        }
        this["buttonEl-btnEl"].dom.disabled = true
    },
    onEnable: function() {
        var a = this;
        a.callParent();
        a.fileInputEl.dom.disabled = false;
        this["buttonEl-btnEl"].dom.disabled = false
    },
    isFileUpload: function() {
        return true
    },
    extractFileInput: function() {
        var a = this.fileInputEl.dom;
        this.reset();
        return a
    },
    onDestroy: function() {
        Ext.destroyMembers(this, "fileInputEl", "buttonEl");
        this.callParent()
    }
});

function privalert() {
    Ext.Msg.show({
        title: "About your privacy",
        msg: "Uploaded GPX logs are systematically deleted after map-matching.",
        buttons: Ext.Msg.OK,
        icon: Ext.Msg.INFO
    })
}

function someServerError() {
    Ext.Msg.show({
        title: "Error",
        msg: "Oops! Sorry, an error occurred",
        buttons: Ext.Msg.OK,
        icon: Ext.Msg.ERROR
    })
}

function someUserError(a) {
    Ext.Msg.show({
        title: "Please try again",
        msg: a,
        buttons: Ext.Msg.OK,
        icon: Ext.Msg.ERROR
    })
}
var mmTaskId;
var waitingDelay = 750;
var waitingMask;
var waitResultIntervalID;

function waitForResult() {
    window.clearInterval(waitResultIntervalID);
    Ext.Ajax.request({
        url: "../demo/getresults.do?taskId=" + mmTaskId,
        success: function(c) {
            var a = Ext.decode(c.responseText);
            if (a.success) {
                var d = a.payload;
                if (d.ready) {
                    waitingMask.hide();
                    DemoApp.app.fireEvent("resultready", d)
                } else {
                    waitResultIntervalID = window.setInterval(waitForResult, waitingDelay)
                }
            } else {
                waitingMask.hide();
                someUserError(a.errorMsg)
            }
        },
        failure: function(a) {
            waitingMask.setVisible(false);
            someServerError()
        }
    })
}

function showUploadForm() {
    var a = Ext.widget("form", {
        url: "../demo/uploadgpxlog.form",
        items: {
            xtype: "filefield",
            name: "gpxfile",
            fieldLabel: "Gpx logfile",
            msgTarget: "side",
            anchor: "100%",
            allowBlank: false,
            buttonText: "Select ..."
        },
        bodyPadding: 10,
        buttons: [{
            text: "Cancel",
            handler: function() {
                this.up("form").getForm().reset();
                this.up("window").hide()
            }
        }, {
            text: "Run map-matching",
            formBind: true,
            disabled: true,
            handler: function() {
                var c = this.up("form").getForm();
                if (c.isValid()) {
                    this.up("window").hide();
                    gpxChoiceWindow.hide();
                    vp = Ext.ComponentQuery.query("viewport")[0];
                    waitingMask = new Ext.LoadMask(vp, {
                        msg: "Uploading GPX file..."
                    });
                    waitingMask.show();
                    c.submit({
                        success: function(d, e) {
                            if (e.result.success) {
                                waitingMask.msg = "Map-matching...";
                                waitingMask.hide();
                                waitingMask.show();
                                mmTaskId = e.result.payload.id;
                                waitResultIntervalID = window.setInterval(waitForResult, waitingDelay)
                            } else {
                                waitingMask.setVisible(false);
                                someUserError(e.result.errorMsg)
                            }
                        },
                        failure: function(d, e) {
                            waitingMask.setVisible(false);
                            if (e.result) {
                                someUserError(e.result.errorMsg)
                            } else {
                                someServerError()
                            }
                        }
                    })
                }
            }
        }]
    });
    Ext.widget("window", {
        title: "Select a GPX file",
        closeAction: "hide",
        width: 400,
        height: 120,
        layout: "fit",
        resizable: true,
        modal: true,
        items: a
    }).show()
}

function showURLInputForm() {
    var a = Ext.widget("form", {
        xtype: "form",
        url: "../demo/linkgpxlog.form",
        items: [{
            xtype: "textfield",
            name: "gpxurl",
            fieldLabel: "URL of GPX data",
            msgTarget: "side",
            anchor: "100%",
            vtype: "url",
            allowBlank: false,
            buttonText: "Match"
        }],
        bodyPadding: 10,
        buttons: [{
            text: "Cancel",
            handler: function() {
                this.up("form").getForm().reset();
                this.up("window").hide()
            }
        }, {
            text: "Run map-matching",
            formBind: true,
            disabled: true,
            handler: function() {
                var c = this.up("form").getForm();
                if (c.isValid()) {
                    this.up("window").hide();
                    gpxChoiceWindow.hide();
                    vp = Ext.ComponentQuery.query("viewport")[0];
                    waitingMask = new Ext.LoadMask(vp, {
                        msg: "Fetching GPX from URL..."
                    });
                    waitingMask.show();
                    c.submit({
                        success: function(d, e) {
                            waitingMask.msg = "Map-matching...";
                            waitingMask.hide();
                            waitingMask.show();
                            mmTaskId = e.result.payload.id;
                            waitResultIntervalID = window.setInterval(waitForResult, waitingDelay)
                        },
                        failure: function(d, e) {
                            waitingMask.setVisible(false);
                            if (e.result) {
                                someUserError(e.result.errorMsg)
                            } else {
                                someServerError()
                            }
                        }
                    })
                }
            }
        }]
    });
    Ext.widget("window", {
        title: "Enter URL to GPX data",
        closeAction: "hide",
        width: 400,
        height: 120,
        layout: "fit",
        resizable: true,
        modal: true,
        items: a
    }).show()
}
Ext.define("DemoApp.view.GpxSubmissionForm", {
    extend: "Ext.Panel",
    alias: "widget.gpxForm",
    layout: {
        type: "column"
    },
    bodyPadding: 5,
    defaults: {
        columnWidth: 0.33,
        border: 0
    },
    items: [{
        layout: {
            type: "vbox",
            align: "center"
        },
        items: [{
            xtype: "button",
            style: {
                borderColor: "green",
                borderStyle: "solid"
            },
            iconCls: "gpxicon",
            iconAlign: "top",
            width: 136,
            height: 136,
            handler: showUploadForm
        }, {
            html: "<br>Upload your GPX logfile<br>(<a href=# onClick=privalert()>privacy policy</a>)",
            border: 0
        }]
    }, {
        layout: {
            type: "vbox",
            align: "center"
        },
        items: [{
            xtype: "button",
            style: {
                borderColor: "green",
                borderStyle: "solid"
            },
            iconCls: "weblink",
            iconAlign: "top",
            width: 136,
            height: 136,
            handler: showURLInputForm
        }, {
            html: "<br>Test with public GPX data",
            border: 0
        }]
    }, {
        layout: {
            type: "vbox",
            align: "center"
        },
        items: [{
            xtype: "button",
            style: {
                borderColor: "green",
                borderStyle: "solid"
            },
            iconCls: "osmlogo",
            iconAlign: "top",
            width: 136,
            height: 136,
            handler: function() {
                gpxChoiceWindow.hide();
                vp = Ext.ComponentQuery.query("viewport")[0];
                waitingMask = new Ext.LoadMask(vp, {
                    msg: "Fetching track from OSM..."
                });
                waitingMask.show();
                Ext.Ajax.request({
                    url: "../demo/randomtrace.do",
                    success: function(a) {
                        waitingMask.msg = "Map-matching...";
                        waitingMask.hide();
                        waitingMask.show();
                        var c = Ext.decode(a.responseText);
                        if (c.success == true) {
                            mmTaskId = c.payload.id;
                            waitResultIntervalID = window.setInterval(waitForResult, waitingDelay)
                        } else {
                            someUserError(c.errorMsg)
                        }
                    },
                    failure: function(a) {
                        waitingMask.setVisible(false);
                        someServerError()
                    }
                })
            }
        }, {
            html: "<br>Test with a random trace<br>from OpenStreetMap",
            border: 0
        }]
    }]
});
Ext.define("Ext.app.Controller", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    onClassExtended: function(l, d, k) {
        var j = Ext.getClassName(l),
            e = j.match(/^(.*)\.controller\./),
            c, i, m, a, g;
        if (e !== null) {
            c = Ext.Loader.getPrefix(j) || e[1];
            i = k.onBeforeCreated;
            m = [];
            a = ["model", "view", "store"];
            k.onBeforeCreated = function(v, p) {
                var q, s, n, t, o, r, u;
                for (q = 0, s = a.length; q < s; q++) {
                    n = a[q];
                    g = c + "." + n + ".";
                    t = Ext.Array.from(p[n + "s"]);
                    for (o = 0, r = t.length; o < r; o++) {
                        u = t[o];
                        if (u.indexOf(".") !== -1 && (Ext.ClassManager.isCreated(u) || Ext.Loader.isAClassNameWithAKnownPrefix(u))) {
                            m.push(u)
                        } else {
                            m.push(g + u)
                        }
                    }
                }
                Ext.require(m, Ext.Function.pass(i, arguments, this))
            }
        }
    },
    constructor: function(a) {
        this.mixins.observable.constructor.call(this, a);
        Ext.apply(this, a || {});
        this.createGetters("model", this.models);
        this.createGetters("store", this.stores);
        this.createGetters("view", this.views);
        if (this.refs) {
            this.ref(this.refs)
        }
    },
    init: Ext.emptyFn,
    onLaunch: Ext.emptyFn,
    createGetters: function(j, l) {
        j = Ext.String.capitalize(j);
        var g = 0,
            a = (l) ? l.length : 0,
            k, c, d, m, e;
        for (; g < a; g++) {
            k = "get";
            c = l[g];
            d = c.split(".");
            e = d.length;
            for (m = 0; m < e; m++) {
                k += Ext.String.capitalize(d[m])
            }
            k += j;
            if (!this[k]) {
                this[k] = Ext.Function.pass(this["get" + j], [c], this)
            }
            this[k](c)
        }
    },
    ref: function(a) {
        a = Ext.Array.from(a);
        var j = this,
            c = 0,
            g = a.length,
            k, e, d;
        j.references = j.references || [];
        for (; c < g; c++) {
            k = a[c];
            e = k.ref;
            d = "get" + Ext.String.capitalize(e);
            if (!j[d]) {
                j[d] = Ext.Function.pass(j.getRef, [e, k], j)
            }
            j.references.push(e.toLowerCase())
        }
    },
    addRef: function(a) {
        return this.ref([a])
    },
    getRef: function(e, g, a) {
        this.refCache = this.refCache || {};
        g = g || {};
        a = a || {};
        Ext.apply(g, a);
        if (g.forceCreate) {
            return Ext.ComponentManager.create(g, "component")
        }
        var d = this,
            c = d.refCache[e];
        if (!c) {
            d.refCache[e] = c = Ext.ComponentQuery.query(g.selector)[0];
            if (!c && g.autoCreate) {
                d.refCache[e] = c = Ext.ComponentManager.create(g, "component")
            }
            if (c) {
                c.on("beforedestroy", function() {
                    d.refCache[e] = null
                })
            }
        }
        return c
    },
    hasRef: function(a) {
        return this.references && this.references.indexOf(a.toLowerCase()) !== -1
    },
    control: function(a, c) {
        this.application.control(a, c, this)
    },
    getController: function(a) {
        return this.application.getController(a)
    },
    getStore: function(a) {
        return this.application.getStore(a)
    },
    getModel: function(a) {
        return this.application.getModel(a)
    },
    getView: function(a) {
        return this.application.getView(a)
    }
});
var gpxChoiceWindow;
Ext.define("DemoApp.controller.MainController", {
    extend: "Ext.app.Controller",
    views: ["Viewport", "JourneyNavigator", "GpxSubmissionForm"],
    stores: ["PlanChunks"],
    refs: [{
        selector: "journeyNavigator treeview",
        ref: "treeview"
    }, {
        selector: "#qualitysmile",
        ref: "qualitysmile"
    }, {
        selector: "#showinfo",
        ref: "showinfo"
    }],
    init: function() {
        this.control({
            "mapOptions button[action=rematch]": {
                click: this.rematch
            }
        });
        this.application.on({
            resultready: this.onResultready,
            scope: this
        });
        this.rematch()
    },
    rematch: function() {
        if (gpxChoiceWindow == undefined || gpxChoiceWindow == null) {
            gpxChoiceWindow = Ext.create("Ext.window.Window", {
                title: "Choose a source of GPS data",
                width: 580,
                height: 220,
                layout: "fit",
                id: "gpxFormWindow",
                closeAction: "hide",
                items: {
                    xtype: "gpxForm",
                    border: false
                }
            })
        }
        gpxChoiceWindow.show()
    },
    onResultready: function(a) {
        switch (a.quality) {
            case 3:
                this.getQualitysmile().setIconCls("smiley-happy");
                this.getQualitysmile().setTooltip("Accurate matching");
                break;
            case 2:
                this.getQualitysmile().setIconCls("smiley-neutral");
                this.getQualitysmile().setTooltip({
                    title: "Matching Quality",
                    text: 'Some data were hard to match accurately.<br><a href="https://mapmatching.3scale.net/faqs#quality" target="3scale">Read more</a>',
                    closable: true,
                    hideDelay: 20000
                });
                break;
            case 1:
                this.getQualitysmile().setIconCls("smiley-sad");
                this.getQualitysmile().setTooltip({
                    title: "Matching Quality",
                    text: 'Data could not be matched optimally.<br><a href="https://mapmatching.3scale.net/faqs#quality" target="3scale">Read more</a>',
                    closable: true,
                    hideDelay: 20000
                });
                break;
            default:
        }
        this.getShowinfo().setTooltip({
            title: "Performance",
            closable: true,
            hideDelay: 20000,
            text: a.processLog + '<br><a href="https://mapmatching.3scale.net/faqs#performance" target="3scale">Read more</a>'
        });
        this.getPlanChunksStore().setRootNode(a.rootNode);
        if (this.firstTime) {
            this.showballoon(this.getTreeview());
            this.firstTime = false
        }
    },
    firstTime: true,
    showballoon: function(d) {
        Ext.useShims = true;
        var c = new Ext.ToolTip({
            floating: {
                shim: true
            },
            title: "Start here",
            anchor: "left",
            html: "Expand trip legs to show GPX points<br>and matched streets",
            dismissDelay: 10000,
            hideDelay: 10000,
            closable: true
        });
        var a = d.el.getAnchorXY();
        c.showAt([a[0] + 45, a[1] + 5]);
        c.el.shadow.el.slideIn("r");
        c.el.slideIn("r")
    }
});
Ext.define("DemoApp.controller.MapController", {
    extend: "Ext.app.Controller",
    views: ["OSMMap", "JourneyNavigator"],
    stores: ["PlanChunks"],
    refs: [{
        selector: "viewport gx_osmmap",
        ref: "osmmap"
    }, {
        selector: "mapOptions",
        ref: "mapButtons"
    }, {
        selector: "#gpxswitch",
        ref: "gpxswitch"
    }, {
        selector: "journeyNavigator",
        ref: "navigator"
    }],
    autozoom: true,
    init: function() {
        this.control({
            "mapOptions button[action=resetview]": {
                click: this.resetview
            },
            "mapOptions button[action=autozoom]": {
                toggle: this.setAutoZoom
            },
            "mapOptions button[action=switchGPX]": {
                toggle: this.switchGPX
            },
            "mapOptions button[action=switchMM]": {
                toggle: this.switchMM
            },
            journeyNavigator: {
                select: this.onJourneySelect,
                deselect: this.onJourneyDeselect
            }
        });
        this.getPlanChunksStore().on({
            rootchange: this.onResultLoaded,
            scope: this
        });
        var a = new OpenLayers.Size(21, 25);
        var c = new OpenLayers.Pixel(-(a.w / 2), -a.h);
        this.markerIcon = new OpenLayers.Icon("resources/css/icons/marker-ala-3scale.png", a, c)
    },
    setAutoZoom: function(a, c) {
        this.autozoom = c
    },
    resetview: function() {
        this.getOsmmap().map.zoomToExtent(leg_layer.getDataExtent());
        this.selectControl.unselectAll();
        this.getNavigator().collapseAll();
        this.getNavigator().selectPath("/");
        link_layer.removeAllFeatures();
        proj_layer.removeAllFeatures();
        markers_layer.clearMarkers()
    },
    switchGPX: function(a, c) {
        markers_layer.setVisibility(c);
        proj_layer.setVisibility(c)
    },
    switchMM: function(a, c) {
        leg_layer.setVisibility(c);
        link_layer.setVisibility(c)
    },
    resetCenter: function(c, a) {
        fromProjection = new OpenLayers.Projection("EPSG:4326");
        toProjection = new OpenLayers.Projection("EPSG:900913");
        position = new OpenLayers.LonLat(c, a).transform(fromProjection, toProjection);
        this.getOsmmap().map.setCenter(position, 12)
    },
    getLargeBounds: function(a) {
        bounds = a.getBounds();
        w = bounds.getWidth();
        h = bounds.getHeight();
        b = new OpenLayers.Bounds();
        b.left = bounds.left - w;
        b.right = bounds.right + w;
        b.top = bounds.top + h;
        b.bottom = bounds.bottom - h;
        return b
    },
    onJourneySelect: function(c, a) {
        treeNode = a;
        markers_layer.clearMarkers();
        if (a.feature) {
            if (a.gpxMarkerPositions != undefined) {
                for (var d = 0; d < a.gpxMarkerPositions.length; d++) {
                    markers_layer.addMarker(new OpenLayers.Marker(a.gpxMarkerPositions[d], this.markerIcon.clone()))
                }
            }
            if (treeNode.getDepth() == 1) {
                this.selectControl.select(a.feature);
                if (this.autozoom) {
                    this.getOsmmap().map.zoomToExtent(a.feature.geometry.getBounds())
                }
            } else {
                if (treeNode.getDepth() == 2) {
                    if (this.autozoom) {
                        mb = this.getOsmmap().map.getExtent();
                        fb = a.feature.geometry.getBounds();
                        ratio = Math.max(fb.getWidth() / mb.getWidth(), fb.getHeight() / mb.getHeight());
                        if (ratio < 0.05 || ratio > 1) {
                            this.getOsmmap().map.zoomToExtent(this.getLargeBounds(a.feature.geometry))
                        } else {
                            if (!mb.containsBounds(fb)) {
                                this.getOsmmap().map.moveTo(fb.getCenterLonLat())
                            }
                        }
                    }
                    link_layer.addFeatures(a.feature);
                    proj_layer.addFeatures(a.projFeatures)
                }
            }
        }
    },
    onJourneyDeselect: function(c, a) {
        treeNode = a;
        markers_layer.clearMarkers();
        if (treeNode.feature) {
            if (treeNode.getDepth() == 1) {
                this.selectControl.unselect(treeNode.feature)
            } else {
                if (treeNode.getDepth() == 2) {
                    link_layer.removeAllFeatures();
                    proj_layer.removeAllFeatures()
                }
            }
        }
    },
    onResultLoaded: function(root) {
        map = this.getOsmmap().map;
        var bounds = new OpenLayers.Bounds();
        if (map.getNumLayers() > 1) {
            layers = map.getLayersByName("leg_layer");
            layers[0].removeAllFeatures();
            layers = map.getLayersByName("link_layer");
            layers[0].removeAllFeatures();
            layers = map.getLayersByName("proj_layer");
            layers[0].removeAllFeatures();
            layers = map.getLayersByName("Markers");
            layers[0].clearMarkers()
        } else {
            var legStyles = new OpenLayers.StyleMap({
                "default": new OpenLayers.Style({
                    strokeOpacity: 0.7,
                    strokeColor: "#8888EE",
                    strokeWidth: 6
                }),
                select: new OpenLayers.Style({
                    strokeOpacity: 1,
                    strokeColor: "#6666EE",
                    strokeWidth: 6
                })
            });
            var linkStyles = new OpenLayers.StyleMap({
                "default": new OpenLayers.Style({
                    strokeOpacity: 1,
                    strokeColor: "#3333FF",
                    strokeWidth: 12
                })
            });
            var projStyles = new OpenLayers.StyleMap({
                "default": new OpenLayers.Style({
                    strokeOpacity: 1,
                    strokeColor: "#FF0000",
                    strokeWidth: 2
                })
            });
            leg_layer = new OpenLayers.Layer.Vector("leg_layer", {
                styleMap: legStyles
            });
            link_layer = new OpenLayers.Layer.Vector("link_layer", {
                styleMap: linkStyles
            });
            proj_layer = new OpenLayers.Layer.Vector("proj_layer", {
                styleMap: projStyles
            });
            markers_layer = new OpenLayers.Layer.Markers("Markers", {
                projection: map.getProjection()
            })
        }
        var legFeatures = [];
        root.eachChild(function(child) {
            if (child.data.type == "leg") {
                leg = child;
                var legPoints = [];
                var legMarkerPositions = [];
                leg.eachChild(function(link) {
                    if (link.data.geometry != "") {
                        linkGeomString = link.data.geometry;
                        linkGeom = new OpenLayers.Format.GeoJSON().read(linkGeomString, "Geometry");
                        points = linkGeom.components;
                        if (legPoints.length == 0) {
                            legPoints = points
                        } else {
                            legPoints = legPoints.concat(points.slice(1, points.length))
                        }
                        linkFeature = new OpenLayers.Format.GeoJSON().read(linkGeomString)[0];
                        link.feature = linkFeature;
                        linkFeature.treenode = link;
                        bounds.extend(linkGeom.getBounds());
                        var gpxLines = [];
                        var linkMarkerPositions = [];
                        origgpx = eval(link.data.originalWpts);
                        projgpx = eval(link.data.projectedWpts);
                        if (origgpx != null) {
                            for (var i = 0; i < origgpx.length / 2; i++) {
                                p0 = new OpenLayers.Geometry.Point(origgpx[i * 2], origgpx[i * 2 + 1]);
                                p1 = new OpenLayers.Geometry.Point(projgpx[i * 2], projgpx[i * 2 + 1]);
                                line = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.LineString([p0, p1]));
                                gpxLines.push(line);
                                position = new OpenLayers.LonLat(origgpx[i * 2], origgpx[i * 2 + 1]);
                                linkMarkerPositions.push(position);
                                legMarkerPositions.push(position)
                            }
                        }
                        link.projFeatures = gpxLines;
                        link.gpxMarkerPositions = linkMarkerPositions
                    }
                });
                if (legMarkerPositions.length > 100) {
                    var arr = [];
                    for (var j = 0; j < legMarkerPositions.length; j++) {
                        if (arr.length * legMarkerPositions.length < (j + 1) * 100) {
                            arr.push(legMarkerPositions[j])
                        }
                    }
                    legMarkerPositions = arr
                }
                leg.gpxMarkerPositions = legMarkerPositions;
                legFeature = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.LineString(legPoints));
                legFeatures.push(legFeature);
                leg.feature = legFeature;
                legFeature.treenode = leg
            }
        });
        leg_layer.addFeatures(legFeatures);
        map.addLayers([leg_layer, link_layer, proj_layer, markers_layer]);
        this.selectControl = new OpenLayers.Control.SelectFeature([leg_layer], {
            onSelect: function(feature) {
                DemoApp.app.fireEvent("legSelected", feature.treenode)
            }
        });
        map.addControl(this.selectControl);
        this.selectControl.activate();
        this.link_layer = link_layer;
        this.leg_layer = leg_layer;
        this.proj_layer = proj_layer;
        map.zoomToExtent(bounds);
        var buttons = this.getMapButtons().items.items;
        for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].enableToggle) {
                buttons[i].toggle(true)
            }
            buttons[i].enable()
        }
    }
});
Ext.define("DemoApp.controller.Journey", {
    extend: "Ext.app.Controller",
    views: ["JourneyNavigator", "OSMMap"],
    stores: ["PlanChunks"],
    refs: [{
        selector: "viewport gx_osmmap",
        ref: "osmmap"
    }, {
        selector: "journeyNavigator",
        ref: "navigator"
    }],
    init: function() {
        this.application.on({
            legSelected: this.onLegSelected,
            scope: this
        })
    },
    onLaunch: function() {
        this.getPlanChunksStore().on({
            beforeappend: this.decorateNode
        })
    },
    decorateNode: function(d, c, a) {
        if (c.data.type == "leg") {
            if (c.data.mode == "c") {
                c.data.iconCls = "car"
            }
            if (c.data.mode == "w") {
                c.data.iconCls = "walk"
            }
        }
        if (c.data.type == "act") {
            if (c.data.mode == "home") {
                c.data.iconCls = "home"
            } else {
                if (c.data.mode == "work") {
                    c.data.iconCls = "office"
                } else {
                    if (c.data.mode == "shop") {
                        c.data.iconCls = "supermarket";
                        c.data.label = "Shopping at " + c.data.name
                    } else {
                        if (c.data.mode == "") {
                            c.data.iconCls = "unknown"
                        } else {
                            c.data.iconCls = "unqualified"
                        }
                    }
                }
            }
        }
        if (c.data.type == "link") {
            switch (c.data.quality) {
                case 1:
                    c.data.iconCls = "street_bad";
                    break;
                case 2:
                    c.data.iconCls = "street_fair";
                    break;
                default:
                    c.data.iconCls = "street_good";
                    break
            }
            c.data.label = c.data.name;
            c.data.qtitle = c.data.name;
            c.data.qtip = "Start: " + c.data.start + "<br>Distance: " + c.data.distance + "<br>Duration: " + c.data.duration
        }
    },
    onLegSelected: function(a) {
        if (!a.isVisible()) {
            a.parentNode.expand()
        }
        this.getNavigator().getSelectionModel().suspendEvents();
        this.getNavigator().getSelectionModel().select(a);
        this.getNavigator().getSelectionModel().resumeEvents()
    }
});
Ext.define("Ext.tip.Tip", {
    extend: "Ext.panel.Panel",
    alternateClassName: "Ext.Tip",
    minWidth: 40,
    maxWidth: 300,
    shadow: "sides",
    defaultAlign: "tl-bl?",
    constrainPosition: true,
    autoRender: true,
    hidden: true,
    baseCls: Ext.baseCSSPrefix + "tip",
    floating: {
        shadow: true,
        shim: true,
        constrain: true
    },
    focusOnToFront: false,
    closeAction: "hide",
    ariaRole: "tooltip",
    alwaysFramed: true,
    frameHeader: false,
    initComponent: function() {
        var a = this;
        a.floating = Ext.apply({}, {
            shadow: a.shadow
        }, a.self.prototype.floating);
        a.callParent(arguments);
        a.constrain = a.constrain || a.constrainPosition
    },
    showAt: function(c) {
        var a = this;
        this.callParent(arguments);
        if (a.isVisible()) {
            a.setPagePosition(c[0], c[1]);
            if (a.constrainPosition || a.constrain) {
                a.doConstrain()
            }
            a.toFront(true)
        }
    },
    showBy: function(a, c) {
        this.showAt(this.el.getAlignToXY(a, c || this.defaultAlign))
    },
    initDraggable: function() {
        var a = this;
        a.draggable = {
            el: a.getDragEl(),
            delegate: a.header.el,
            constrain: a,
            constrainTo: a.el.getScopeParent()
        };
        Ext.Component.prototype.initDraggable.call(a)
    },
    ghost: undefined,
    unghost: undefined
});
Ext.define("Ext.tip.ToolTip", {
    extend: "Ext.tip.Tip",
    alias: "widget.tooltip",
    alternateClassName: "Ext.ToolTip",
    autoHide: true,
    showDelay: 500,
    hideDelay: 200,
    dismissDelay: 5000,
    trackMouse: false,
    anchorToTarget: true,
    anchorOffset: 0,
    targetCounter: 0,
    quickShowInterval: 250,
    initComponent: function() {
        var a = this;
        a.callParent(arguments);
        a.lastActive = new Date();
        a.setTarget(a.target);
        a.origAnchor = a.anchor
    },
    onRender: function(c, a) {
        var d = this;
        d.callParent(arguments);
        d.anchorCls = Ext.baseCSSPrefix + "tip-anchor-" + d.getAnchorPosition();
        d.anchorEl = d.el.createChild({
            cls: Ext.baseCSSPrefix + "tip-anchor " + d.anchorCls
        })
    },
    setTarget: function(e) {
        var c = this,
            a = Ext.get(e),
            d;
        if (c.target) {
            d = Ext.get(c.target);
            c.mun(d, "mouseover", c.onTargetOver, c);
            c.mun(d, "mouseout", c.onTargetOut, c);
            c.mun(d, "mousemove", c.onMouseMove, c)
        }
        c.target = a;
        if (a) {
            c.mon(a, {
                freezeEvent: true,
                mouseover: c.onTargetOver,
                mouseout: c.onTargetOut,
                mousemove: c.onMouseMove,
                scope: c
            })
        }
        if (c.anchor) {
            c.anchorTarget = c.target
        }
    },
    onMouseMove: function(g) {
        var c = this,
            a = c.delegate ? g.getTarget(c.delegate) : c.triggerElement = true,
            d;
        if (a) {
            c.targetXY = g.getXY();
            if (a === c.triggerElement) {
                if (!c.hidden && c.trackMouse) {
                    d = c.getTargetXY();
                    if (c.constrainPosition) {
                        d = c.el.adjustForConstraints(d, c.el.getScopeParent())
                    }
                    c.setPagePosition(d)
                }
            } else {
                c.hide();
                c.lastActive = new Date(0);
                c.onTargetOver(g)
            }
        } else {
            if ((!c.closable && c.isVisible()) && c.autoHide !== false) {
                c.hide()
            }
        }
    },
    getTargetXY: function() {
        var l = this,
            e, d, p, a, k, n, g, o, m, c, j, i;
        if (l.delegate) {
            l.anchorTarget = l.triggerElement
        }
        if (l.anchor) {
            l.targetCounter++;
            d = l.getOffsets();
            p = (l.anchorToTarget && !l.trackMouse) ? l.el.getAlignToXY(l.anchorTarget, l.getAnchorAlign()) : l.targetXY;
            a = Ext.Element.getViewWidth() - 5;
            k = Ext.Element.getViewHeight() - 5;
            n = document.documentElement;
            g = document.body;
            o = (n.scrollLeft || g.scrollLeft || 0) + 5;
            m = (n.scrollTop || g.scrollTop || 0) + 5;
            c = [p[0] + d[0], p[1] + d[1]];
            j = l.getSize();
            i = l.constrainPosition;
            l.anchorEl.removeCls(l.anchorCls);
            if (l.targetCounter < 2 && i) {
                if (c[0] < o) {
                    if (l.anchorToTarget) {
                        l.defaultAlign = "l-r";
                        if (l.mouseOffset) {
                            l.mouseOffset[0] *= -1
                        }
                    }
                    l.anchor = "left";
                    return l.getTargetXY()
                }
                if (c[0] + j.width > a) {
                    if (l.anchorToTarget) {
                        l.defaultAlign = "r-l";
                        if (l.mouseOffset) {
                            l.mouseOffset[0] *= -1
                        }
                    }
                    l.anchor = "right";
                    return l.getTargetXY()
                }
                if (c[1] < m) {
                    if (l.anchorToTarget) {
                        l.defaultAlign = "t-b";
                        if (l.mouseOffset) {
                            l.mouseOffset[1] *= -1
                        }
                    }
                    l.anchor = "top";
                    return l.getTargetXY()
                }
                if (c[1] + j.height > k) {
                    if (l.anchorToTarget) {
                        l.defaultAlign = "b-t";
                        if (l.mouseOffset) {
                            l.mouseOffset[1] *= -1
                        }
                    }
                    l.anchor = "bottom";
                    return l.getTargetXY()
                }
            }
            l.anchorCls = Ext.baseCSSPrefix + "tip-anchor-" + l.getAnchorPosition();
            l.anchorEl.addCls(l.anchorCls);
            l.targetCounter = 0;
            return c
        } else {
            e = l.getMouseOffset();
            return (l.targetXY) ? [l.targetXY[0] + e[0], l.targetXY[1] + e[1]] : e
        }
    },
    getMouseOffset: function() {
        var a = this,
            c = a.anchor ? [0, 0] : [15, 18];
        if (a.mouseOffset) {
            c[0] += a.mouseOffset[0];
            c[1] += a.mouseOffset[1]
        }
        return c
    },
    getAnchorPosition: function() {
        var c = this,
            a;
        if (c.anchor) {
            c.tipAnchor = c.anchor.charAt(0)
        } else {
            a = c.defaultAlign.match(/^([a-z]+)-([a-z]+)(\?)?$/);
            c.tipAnchor = a[1].charAt(0)
        }
        switch (c.tipAnchor) {
            case "t":
                return "top";
            case "b":
                return "bottom";
            case "r":
                return "right"
        }
        return "left"
    },
    getAnchorAlign: function() {
        switch (this.anchor) {
            case "top":
                return "tl-bl";
            case "left":
                return "tl-tr";
            case "right":
                return "tr-tl";
            default:
                return "bl-tl"
        }
    },
    getOffsets: function() {
        var d = this,
            e, c, a = d.getAnchorPosition().charAt(0);
        if (d.anchorToTarget && !d.trackMouse) {
            switch (a) {
                case "t":
                    c = [0, 9];
                    break;
                case "b":
                    c = [0, -13];
                    break;
                case "r":
                    c = [-13, 0];
                    break;
                default:
                    c = [9, 0];
                    break
            }
        } else {
            switch (a) {
                case "t":
                    c = [-15 - d.anchorOffset, 30];
                    break;
                case "b":
                    c = [-19 - d.anchorOffset, -13 - d.el.dom.offsetHeight];
                    break;
                case "r":
                    c = [-15 - d.el.dom.offsetWidth, -13 - d.anchorOffset];
                    break;
                default:
                    c = [25, -13 - d.anchorOffset];
                    break
            }
        }
        e = d.getMouseOffset();
        c[0] += e[0];
        c[1] += e[1];
        return c
    },
    onTargetOver: function(d) {
        var c = this,
            a;
        if (c.disabled || d.within(c.target.dom, true)) {
            return
        }
        a = d.getTarget(c.delegate);
        if (a) {
            c.triggerElement = a;
            c.clearTimer("hide");
            c.targetXY = d.getXY();
            c.delayShow()
        }
    },
    delayShow: function() {
        var a = this;
        if (a.hidden && !a.showTimer) {
            if (Ext.Date.getElapsed(a.lastActive) < a.quickShowInterval) {
                a.show()
            } else {
                a.showTimer = Ext.defer(a.show, a.showDelay, a)
            }
        } else {
            if (!a.hidden && a.autoHide !== false) {
                a.show()
            }
        }
    },
    onShowVeto: function() {
        this.callParent();
        this.clearTimer("show")
    },
    onTargetOut: function(c) {
        var a = this;
        if (a.disabled || c.within(a.target.dom, true)) {
            return
        }
        a.clearTimer("show");
        if (a.autoHide !== false) {
            a.delayHide()
        }
    },
    delayHide: function() {
        var a = this;
        if (!a.hidden && !a.hideTimer) {
            a.hideTimer = Ext.defer(a.hide, a.hideDelay, a)
        }
    },
    hide: function() {
        var a = this;
        a.clearTimer("dismiss");
        a.lastActive = new Date();
        if (a.anchorEl) {
            a.anchorEl.hide()
        }
        a.callParent(arguments);
        delete a.triggerElement
    },
    show: function() {
        var a = this;
        this.callParent();
        if (this.hidden === false) {
            a.setPagePosition(-10000, -10000);
            if (a.anchor) {
                a.anchor = a.origAnchor
            }
            if (!a.calledFromShowAt) {
                a.showAt(a.getTargetXY())
            }
            if (a.anchor) {
                a.syncAnchor();
                a.anchorEl.show()
            } else {
                a.anchorEl.hide()
            }
        }
    },
    showAt: function(c) {
        var a = this;
        a.lastActive = new Date();
        a.clearTimers();
        a.calledFromShowAt = true;
        if (!a.isVisible()) {
            this.callParent(arguments)
        }
        if (a.isVisible()) {
            a.setPagePosition(c[0], c[1]);
            if (a.constrainPosition || a.constrain) {
                a.doConstrain()
            }
            a.toFront(true);
            a.el.sync(true);
            if (a.dismissDelay && a.autoHide !== false) {
                a.dismissTimer = Ext.defer(a.hide, a.dismissDelay, a)
            }
            if (a.anchor) {
                a.syncAnchor();
                if (!a.anchorEl.isVisible()) {
                    a.anchorEl.show()
                }
            } else {
                a.anchorEl.hide()
            }
        }
        delete a.calledFromShowAt
    },
    syncAnchor: function() {
        var d = this,
            a, c, e;
        switch (d.tipAnchor.charAt(0)) {
            case "t":
                a = "b";
                c = "tl";
                e = [20 + d.anchorOffset, 1];
                break;
            case "r":
                a = "l";
                c = "tr";
                e = [-1, 12 + d.anchorOffset];
                break;
            case "b":
                a = "t";
                c = "bl";
                e = [20 + d.anchorOffset, -1];
                break;
            default:
                a = "r";
                c = "tl";
                e = [1, 12 + d.anchorOffset];
                break
        }
        d.anchorEl.alignTo(d.el, a + "-" + c, e);
        d.anchorEl.setStyle("z-index", parseInt(d.el.getZIndex(), 10) || 0 + 1).setVisibilityMode(Ext.Element.DISPLAY)
    },
    setPagePosition: function(a, d) {
        var c = this;
        c.callParent(arguments);
        if (c.anchor) {
            c.syncAnchor()
        }
    },
    clearTimer: function(a) {
        a = a + "Timer";
        clearTimeout(this[a]);
        delete this[a]
    },
    clearTimers: function() {
        var a = this;
        a.clearTimer("show");
        a.clearTimer("dismiss");
        a.clearTimer("hide")
    },
    onShow: function() {
        var a = this;
        a.callParent();
        a.mon(Ext.getDoc(), "mousedown", a.onDocMouseDown, a)
    },
    onHide: function() {
        var a = this;
        a.callParent();
        a.mun(Ext.getDoc(), "mousedown", a.onDocMouseDown, a)
    },
    onDocMouseDown: function(c) {
        var a = this;
        if (!a.closable && !c.within(a.el.dom)) {
            a.disable();
            Ext.defer(a.doEnable, 100, a)
        }
    },
    doEnable: function() {
        if (!this.isDestroyed) {
            this.enable()
        }
    },
    onDisable: function() {
        this.callParent();
        this.clearTimers();
        this.hide()
    },
    beforeDestroy: function() {
        var a = this;
        a.clearTimers();
        Ext.destroy(a.anchorEl);
        delete a.anchorEl;
        delete a.target;
        delete a.anchorTarget;
        delete a.triggerElement;
        a.callParent()
    },
    onDestroy: function() {
        Ext.getDoc().un("mousedown", this.onDocMouseDown, this);
        this.callParent()
    }
});
Ext.define("Ext.tip.QuickTip", {
    extend: "Ext.tip.ToolTip",
    alias: "widget.quicktip",
    alternateClassName: "Ext.QuickTip",
    interceptTitles: false,
    title: "&#160;",
    tagConfig: {
        namespace: "data-",
        attribute: "qtip",
        width: "qwidth",
        target: "target",
        title: "qtitle",
        hide: "hide",
        cls: "qclass",
        align: "qalign",
        anchor: "anchor"
    },
    initComponent: function() {
        var a = this;
        a.target = a.target || Ext.getDoc();
        a.targets = a.targets || {};
        a.callParent()
    },
    register: function(d) {
        var l = Ext.isArray(d) ? d : arguments,
            e = 0,
            a = l.length,
            k, c, g;
        for (; e < a; e++) {
            d = l[e];
            k = d.target;
            if (k) {
                if (Ext.isArray(k)) {
                    for (c = 0, g = k.length; c < g; c++) {
                        this.targets[Ext.id(k[c])] = d
                    }
                } else {
                    this.targets[Ext.id(k)] = d
                }
            }
        }
    },
    unregister: function(a) {
        delete this.targets[Ext.id(a)]
    },
    cancelShow: function(a) {
        var c = this,
            d = c.activeTarget;
        a = Ext.get(a).dom;
        if (c.isVisible()) {
            if (d && d.el == a) {
                c.hide()
            }
        } else {
            if (d && d.el == a) {
                c.clearTimer("show")
            }
        }
    },
    getTipCfg: function(g) {
        var d = g.getTarget(),
            c = d.title,
            a;
        if (this.interceptTitles && c && Ext.isString(c)) {
            d.qtip = c;
            d.removeAttribute("title");
            g.preventDefault();
            return {
                text: c
            }
        } else {
            a = this.tagConfig;
            d = g.getTarget("[" + a.namespace + a.attribute + "]");
            if (d) {
                return {
                    target: d,
                    text: d.getAttribute(a.namespace + a.attribute)
                }
            }
        }
    },
    onTargetOver: function(k) {
        var m = this,
            l = k.getTarget(m.delegate),
            a, g, c, j, n, d, p, i, r, o, q;
        if (m.disabled) {
            return
        }
        m.targetXY = k.getXY();
        if (!l || l.nodeType !== 1 || l == document.documentElement || l == document.body) {
            return
        }
        if (m.activeTarget && ((l == m.activeTarget.el) || Ext.fly(m.activeTarget.el).contains(l))) {
            m.clearTimer("hide");
            m.show();
            return
        }
        if (l) {
            i = m.targets;
            for (q in i) {
                if (i.hasOwnProperty(q)) {
                    o = i[q];
                    r = Ext.fly(o.target);
                    if (r && (r.dom === l || r.contains(l))) {
                        c = r.dom;
                        break
                    }
                }
            }
            if (c) {
                m.activeTarget = m.targets[c.id];
                m.activeTarget.el = l;
                m.anchor = m.activeTarget.anchor;
                if (m.anchor) {
                    m.anchorTarget = l
                }
                a = Ext.isDefined(m.activeTarget.showDelay);
                if (a) {
                    g = m.showDelay;
                    m.showDelay = m.activeTarget.showDelay
                }
                m.delayShow();
                if (a) {
                    m.showDelay = g
                }
                return
            }
        }
        c = Ext.fly(l, "_quicktip-target");
        j = m.tagConfig;
        n = j.namespace;
        d = m.getTipCfg(k);
        if (d) {
            if (d.target) {
                l = d.target;
                c = Ext.fly(l, "_quicktip-target")
            }
            p = c.getAttribute(n + j.hide);
            m.activeTarget = {
                el: l,
                text: d.text,
                width: +c.getAttribute(n + j.width) || null,
                autoHide: p != "user" && p !== "false",
                title: c.getAttribute(n + j.title),
                cls: c.getAttribute(n + j.cls),
                align: c.getAttribute(n + j.align)
            };
            m.anchor = c.getAttribute(n + j.anchor);
            if (m.anchor) {
                m.anchorTarget = l
            }
            a = Ext.isDefined(m.activeTarget.showDelay);
            if (a) {
                g = m.showDelay;
                m.showDelay = m.activeTarget.showDelay
            }
            m.delayShow();
            if (a) {
                m.showDelay = g
            }
        }
    },
    onTargetOut: function(i) {
        var d = this,
            g = d.activeTarget,
            a, c;
        if (g && i.within(d.activeTarget.el) && !d.getTipCfg(i)) {
            return
        }
        d.clearTimer("show");
        delete d.activeTarget;
        if (d.autoHide !== false) {
            a = g && Ext.isDefined(g.hideDelay);
            if (a) {
                c = d.hideDelay;
                d.hideDelay = g.hideDelay
            }
            d.delayHide();
            if (a) {
                d.hideDelay = c
            }
        }
    },
    showAt: function(e) {
        var c = this,
            d = c.activeTarget,
            a;
        if (d) {
            if (!c.rendered) {
                c.render(Ext.getBody());
                c.activeTarget = d
            }
            c.suspendLayouts();
            if (d.title) {
                c.setTitle(d.title);
                c.header.show()
            } else {
                c.header.hide()
            }
            c.update(d.text);
            c.autoHide = d.autoHide;
            c.dismissDelay = d.dismissDelay || c.dismissDelay;
            if (d.mouseOffset) {
                e[0] += d.mouseOffset[0];
                e[1] += d.mouseOffset[1]
            }
            a = c.lastCls;
            if (a) {
                c.removeCls(a);
                delete c.lastCls
            }
            a = d.cls;
            if (a) {
                c.addCls(a);
                c.lastCls = a
            }
            c.setWidth(d.width);
            if (c.anchor) {
                c.constrainPosition = false
            } else {
                if (d.align) {
                    e = c.el.getAlignToXY(d.el, d.align);
                    c.constrainPosition = false
                } else {
                    c.constrainPosition = true
                }
            }
            c.resumeLayouts(true)
        }
        c.callParent([e])
    },
    hide: function() {
        delete this.activeTarget;
        this.callParent()
    }
});
Ext.define("Ext.tip.QuickTipManager", (function() {
    var c, a = false;
    return {
        requires: ["Ext.tip.QuickTip"],
        singleton: true,
        alternateClassName: "Ext.QuickTips",
        init: function(i, e) {
            if (!c) {
                if (!Ext.isReady) {
                    Ext.onReady(function() {
                        Ext.tip.QuickTipManager.init(i, e)
                    });
                    return
                }
                var d = Ext.apply({
                        disabled: a,
                        id: "ext-quicktips-tip"
                    }, e),
                    g = d.className,
                    j = d.xtype;
                if (g) {
                    delete d.className
                } else {
                    if (j) {
                        g = "widget." + j;
                        delete d.xtype
                    }
                }
                if (i !== false) {
                    d.renderTo = document.body
                }
                c = Ext.create(g || "Ext.tip.QuickTip", d)
            }
        },
        destroy: function() {
            if (c) {
                var d;
                c.destroy();
                c = d
            }
        },
        ddDisable: function() {
            if (c && !a) {
                c.disable()
            }
        },
        ddEnable: function() {
            if (c && !a) {
                c.enable()
            }
        },
        enable: function() {
            if (c) {
                c.enable()
            }
            a = false
        },
        disable: function() {
            if (c) {
                c.disable()
            }
            a = true
        },
        isEnabled: function() {
            return c !== undefined && !c.disabled
        },
        getQuickTip: function() {
            return c
        },
        register: function() {
            c.register.apply(c, arguments)
        },
        unregister: function() {
            c.unregister.apply(c, arguments)
        },
        tips: function() {
            c.register.apply(c, arguments)
        }
    }
}()));
Ext.define("Ext.app.EventBus", {
    requires: ["Ext.util.Event", "Ext.Component"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    constructor: function() {
        this.mixins.observable.constructor.call(this);
        this.bus = {};
        var a = this;
        Ext.override(Ext.Component, {
            fireEvent: function(c) {
                if (Ext.util.Observable.prototype.fireEvent.apply(this, arguments) !== false) {
                    return a.dispatch.call(a, c, this, arguments)
                }
                return false
            }
        })
    },
    dispatch: function(n, j, m) {
        var k = this.bus,
            o = k[n],
            e, d, c, p, a, g, l;
        if (o) {
            for (e in o) {
                if (o.hasOwnProperty(e) && j.is(e)) {
                    d = o[e];
                    for (c in d) {
                        if (d.hasOwnProperty(c)) {
                            p = d[c];
                            for (g = 0, l = p.length; g < l; g++) {
                                a = p[g];
                                if (a.fire.apply(a, Array.prototype.slice.call(m, 1)) === false) {
                                    return false
                                }
                            }
                        }
                    }
                }
            }
        }
        return true
    },
    control: function(n, l, g) {
        var j = this.bus,
            k, q, i, e, p, d, o, a, c, m;
        if (Ext.isString(n)) {
            e = n;
            n = {};
            n[e] = l;
            this.control(n, null, g);
            return
        }
        k = Ext.util.Observable.HasListeners.prototype;
        for (e in n) {
            if (n.hasOwnProperty(e)) {
                c = n[e] || {};
                for (m in c) {
                    if (c.hasOwnProperty(m)) {
                        p = {};
                        d = c[m];
                        o = g;
                        a = new Ext.util.Event(g, m);
                        if (Ext.isObject(d)) {
                            p = d;
                            d = p.fn;
                            o = p.scope || g;
                            delete p.fn;
                            delete p.scope
                        }
                        a.addListener(d, o, p);
                        k[m] = 1;
                        q = j[m] || (j[m] = {});
                        q = q[e] || (q[e] = {});
                        i = q[g.id] || (q[g.id] = []);
                        i.push(a)
                    }
                }
            }
        }
    }
});
Ext.define("Ext.app.Application", {
    extend: "Ext.app.Controller",
    requires: ["Ext.ModelManager", "Ext.data.Model", "Ext.data.StoreManager", "Ext.tip.QuickTipManager", "Ext.ComponentManager", "Ext.app.EventBus"],
    scope: undefined,
    enableQuickTips: true,
    appFolder: "app",
    autoCreateViewport: false,
    constructor: function(c) {
        c = c || {};
        Ext.apply(this, c);
        var j = this,
            n = c.requires || [],
            a, g, d, e, m, l, k;
        Ext.Loader.setPath(j.name, j.appFolder);
        if (j.paths) {
            m = j.paths;
            for (k in m) {
                if (m.hasOwnProperty(k)) {
                    l = m[k];
                    Ext.Loader.setPath(k, l)
                }
            }
        }
        j.callParent(arguments);
        j.eventbus = new Ext.app.EventBus;
        a = Ext.Array.from(j.controllers);
        g = a && a.length;
        j.controllers = new Ext.util.MixedCollection();
        if (j.autoCreateViewport) {
            n.push(j.getModuleClassName("Viewport", "view"))
        }
        for (d = 0; d < g; d++) {
            n.push(j.getModuleClassName(a[d], "controller"))
        }
        Ext.require(n);
        Ext.onReady(function() {
            j.init(j);
            for (d = 0; d < g; d++) {
                e = j.getController(a[d]);
                e.init(j)
            }
            j.onBeforeLaunch.call(j)
        }, j)
    },
    control: function(c, d, a) {
        this.eventbus.control(c, d, a)
    },
    launch: Ext.emptyFn,
    onBeforeLaunch: function() {
        var d = this,
            g, i, e, a;
        if (d.enableQuickTips) {
            Ext.tip.QuickTipManager.init()
        }
        if (d.autoCreateViewport) {
            d.getView("Viewport").create()
        }
        d.launch.call(this.scope || this);
        d.launched = true;
        d.fireEvent("launch", this);
        g = d.controllers.items;
        e = g.length;
        for (i = 0; i < e; i++) {
            a = g[i];
            a.onLaunch(this)
        }
    },
    getModuleClassName: function(a, c) {
        if (a.indexOf(".") !== -1 && (Ext.ClassManager.isCreated(a) || Ext.Loader.isAClassNameWithAKnownPrefix(a))) {
            return a
        } else {
            return this.name + "." + c + "." + a
        }
    },
    getController: function(c) {
        var a = this.controllers.get(c);
        if (!a) {
            a = Ext.create(this.getModuleClassName(c, "controller"), {
                application: this,
                id: c
            });
            this.controllers.add(a)
        }
        return a
    },
    getStore: function(c) {
        var a = Ext.StoreManager.get(c);
        if (!a) {
            a = Ext.create(this.getModuleClassName(c, "store"), {
                storeId: c
            })
        }
        return a
    },
    getModel: function(a) {
        a = this.getModuleClassName(a, "model");
        return Ext.ModelManager.getModel(a)
    },
    getView: function(a) {
        a = this.getModuleClassName(a, "view");
        return Ext.ClassManager.get(a)
    }
});
if (top === self) {}
Ext.application({
    models: ["PlanChunk", "LayerModel"],
    stores: ["PlanChunks", "LayerStore"],
    controllers: ["MainController", "MapController", "Journey"],
    name: "DemoApp",
    autoCreateViewport: true,
    launch: function() {
        DemoApp.app = this;
        if (this.mockup) {
            planStore = this.getPlanChunksStore();
            console.log("Loading mockup data");
            planStore.load({
                scope: this,
                callback: this.onMockupLoaded
            })
        }
    },
    onMockupLoaded: function() {
        console.log("Mockup loaded");
        planStore.setRootNode(planStore.getRootNode())
    }
});
Ext.define("Ext.ElementLoader", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    uses: ["Ext.data.Connection", "Ext.Ajax"],
    statics: {
        Renderer: {
            Html: function(a, c, d) {
                a.getTarget().update(c.responseText, d.scripts === true);
                return true
            }
        }
    },
    url: null,
    params: null,
    baseParams: null,
    autoLoad: false,
    target: null,
    loadMask: false,
    ajaxOptions: null,
    scripts: false,
    isLoader: true,
    constructor: function(c) {
        var d = this,
            a;
        c = c || {};
        Ext.apply(d, c);
        d.setTarget(d.target);
        d.addEvents("beforeload", "exception", "load");
        d.mixins.observable.constructor.call(d);
        if (d.autoLoad) {
            a = d.autoLoad;
            if (a === true) {
                a = {}
            }
            d.load(a)
        }
    },
    setTarget: function(c) {
        var a = this;
        c = Ext.get(c);
        if (a.target && a.target != c) {
            a.abort()
        }
        a.target = c
    },
    getTarget: function() {
        return this.target || null
    },
    abort: function() {
        var a = this.active;
        if (a !== undefined) {
            Ext.Ajax.abort(a.request);
            if (a.mask) {
                this.removeMask()
            }
            delete this.active
        }
    },
    removeMask: function() {
        this.target.unmask()
    },
    addMask: function(a) {
        this.target.mask(a === true ? null : a)
    },
    load: function(k) {
        k = Ext.apply({}, k);
        var g = this,
            e = g.target,
            l = Ext.isDefined(k.loadMask) ? k.loadMask : g.loadMask,
            c = Ext.apply({}, k.params),
            a = Ext.apply({}, k.ajaxOptions),
            i = k.callback || g.callback,
            j = k.scope || g.scope || g,
            d;
        Ext.applyIf(a, g.ajaxOptions);
        Ext.applyIf(k, a);
        Ext.applyIf(c, g.params);
        Ext.apply(c, g.baseParams);
        Ext.applyIf(k, {
            url: g.url
        });
        Ext.apply(k, {
            scope: g,
            params: c,
            callback: g.onComplete
        });
        if (g.fireEvent("beforeload", g, k) === false) {
            return
        }
        if (l) {
            g.addMask(l)
        }
        d = Ext.Ajax.request(k);
        g.active = {
            request: d,
            options: k,
            mask: l,
            scope: j,
            callback: i,
            success: k.success || g.success,
            failure: k.failure || g.failure,
            renderer: k.renderer || g.renderer,
            scripts: Ext.isDefined(k.scripts) ? k.scripts : g.scripts
        };
        g.setOptions(g.active, k)
    },
    setOptions: Ext.emptyFn,
    onComplete: function(c, j, a) {
        var e = this,
            i = e.active,
            d = i.scope,
            g = e.getRenderer(i.renderer);
        if (j) {
            j = g.call(e, e, a, i) !== false
        }
        if (j) {
            Ext.callback(i.success, d, [e, a, c]);
            e.fireEvent("load", e, a, c)
        } else {
            Ext.callback(i.failure, d, [e, a, c]);
            e.fireEvent("exception", e, a, c)
        }
        Ext.callback(i.callback, d, [e, j, a, c]);
        if (i.mask) {
            e.removeMask()
        }
        delete e.active
    },
    getRenderer: function(a) {
        if (Ext.isFunction(a)) {
            return a
        }
        return this.statics().Renderer.Html
    },
    startAutoRefresh: function(a, c) {
        var d = this;
        d.stopAutoRefresh();
        d.autoRefresh = setInterval(function() {
            d.load(c)
        }, a)
    },
    stopAutoRefresh: function() {
        clearInterval(this.autoRefresh);
        delete this.autoRefresh
    },
    isAutoRefreshing: function() {
        return Ext.isDefined(this.autoRefresh)
    },
    destroy: function() {
        var a = this;
        a.stopAutoRefresh();
        delete a.target;
        a.abort();
        a.clearListeners()
    }
});
Ext.define("Ext.ComponentLoader", {
    extend: "Ext.ElementLoader",
    statics: {
        Renderer: {
            Data: function(a, c, g) {
                var i = true;
                try {
                    a.getTarget().update(Ext.decode(c.responseText))
                } catch (d) {
                    i = false
                }
                return i
            },
            Component: function(a, d, j) {
                var k = true,
                    i = a.getTarget(),
                    c = [];
                try {
                    c = Ext.decode(d.responseText)
                } catch (g) {
                    k = false
                }
                if (k) {
                    i.suspendLayouts();
                    if (j.removeAll) {
                        i.removeAll()
                    }
                    i.add(c);
                    i.resumeLayouts(true)
                }
                return k
            }
        }
    },
    target: null,
    loadMask: false,
    renderer: "html",
    setTarget: function(c) {
        var a = this;
        if (Ext.isString(c)) {
            c = Ext.getCmp(c)
        }
        if (a.target && a.target != c) {
            a.abort()
        }
        a.target = c
    },
    removeMask: function() {
        this.target.setLoading(false)
    },
    addMask: function(a) {
        this.target.setLoading(a)
    },
    setOptions: function(c, a) {
        c.removeAll = Ext.isDefined(a.removeAll) ? a.removeAll : this.removeAll
    },
    getRenderer: function(c) {
        if (Ext.isFunction(c)) {
            return c
        }
        var a = this.statics().Renderer;
        switch (c) {
            case "component":
                return a.Component;
            case "data":
                return a.Data;
            default:
                return Ext.ElementLoader.Renderer.Html
        }
    }
});
Ext.define("Ext.FocusManager", {
    singleton: true,
    alternateClassName: ["Ext.FocusMgr"],
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.AbstractComponent", "Ext.Component", "Ext.ComponentManager", "Ext.ComponentQuery", "Ext.util.HashMap", "Ext.util.KeyNav"],
    enabled: false,
    focusElementCls: Ext.baseCSSPrefix + "focus-element",
    focusFrameCls: Ext.baseCSSPrefix + "focus-frame",
    whitelist: ["textfield"],
    constructor: function(a) {
        var c = this,
            d = Ext.ComponentQuery;
        c.mixins.observable.constructor.call(c, a);
        c.addEvents("beforecomponentfocus", "componentfocus", "disable", "enable");
        c.focusTask = new Ext.util.DelayedTask(c.handleComponentFocus, c);
        Ext.override(Ext.AbstractComponent, {
            onFocus: function() {
                this.callParent(arguments);
                if (c.enabled && this.hasFocus) {
                    Array.prototype.unshift.call(arguments, this);
                    c.onComponentFocus.apply(c, arguments)
                }
            },
            onBlur: function() {
                this.callParent(arguments);
                if (c.enabled && !this.hasFocus) {
                    Array.prototype.unshift.call(arguments, this);
                    c.onComponentBlur.apply(c, arguments)
                }
            },
            onDestroy: function() {
                this.callParent(arguments);
                if (c.enabled) {
                    Array.prototype.unshift.call(arguments, this);
                    c.onComponentDestroy.apply(c, arguments)
                }
            }
        });
        Ext.override(Ext.Component, {
            afterHide: function() {
                this.callParent(arguments);
                if (c.enabled) {
                    Array.prototype.unshift.call(arguments, this);
                    c.onComponentHide.apply(c, arguments)
                }
            }
        });
        c.keyNav = new Ext.util.KeyNav(Ext.getDoc(), {
            disabled: true,
            scope: c,
            backspace: c.focusLast,
            enter: c.navigateIn,
            esc: c.navigateOut,
            tab: c.navigateSiblings,
            space: c.navigateIn,
            del: c.focusLast,
            left: c.navigateSiblings,
            right: c.navigateSiblings,
            down: c.navigateSiblings,
            up: c.navigateSiblings
        });
        c.focusData = {};
        c.subscribers = new Ext.util.HashMap();
        c.focusChain = {};
        Ext.apply(d.pseudos, {
            focusable: function(g) {
                var e = g.length,
                    k = [],
                    j = 0,
                    l;
                for (; j < e; j++) {
                    l = g[j];
                    if (l.isFocusable()) {
                        k.push(l)
                    }
                }
                return k
            },
            nextFocus: function(j, g, l) {
                l = l || 1;
                g = parseInt(g, 10);
                var e = j.length,
                    k = g,
                    m;
                for (;;) {
                    if ((k += l) >= e) {
                        k = 0
                    } else {
                        if (k < 0) {
                            k = e - 1
                        }
                    }
                    if (k === g) {
                        return []
                    }
                    if ((m = j[k]).isFocusable()) {
                        return [m]
                    }
                }
                return []
            },
            prevFocus: function(g, e) {
                return this.nextFocus(g, e, -1)
            },
            root: function(g) {
                var e = g.length,
                    k = [],
                    j = 0,
                    l;
                for (; j < e; j++) {
                    l = g[j];
                    if (!l.ownerCt) {
                        k.push(l)
                    }
                }
                return k
            }
        })
    },
    addXTypeToWhitelist: function(c) {
        var a = this;
        if (Ext.isArray(c)) {
            Ext.Array.forEach(c, a.addXTypeToWhitelist, a);
            return
        }
        if (!Ext.Array.contains(a.whitelist, c)) {
            a.whitelist.push(c)
        }
    },
    clearComponent: function(a) {
        clearTimeout(this.cmpFocusDelay);
        if (!a.isDestroyed) {
            a.blur()
        }
    },
    disable: function() {
        var a = this;
        if (!a.enabled) {
            return
        }
        delete a.options;
        a.enabled = false;
        a.removeDOM();
        a.keyNav.disable();
        a.fireEvent("disable", a)
    },
    enable: function(a) {
        var c = this;
        if (a === true) {
            a = {
                focusFrame: true
            }
        }
        c.options = a = a || {};
        if (c.enabled) {
            return
        }
        c.enabled = true;
        c.initDOM(a);
        c.keyNav.enable();
        c.focusEl.focus();
        delete c.focusedCmp;
        c.fireEvent("enable", c)
    },
    focusLast: function(c) {
        var a = this;
        if (a.isWhitelisted(a.focusedCmp)) {
            return true
        }
        if (a.previousFocusedCmp) {
            a.previousFocusedCmp.focus()
        }
    },
    getRootComponents: function() {
        var a = this,
            d = Ext.ComponentQuery,
            c = d.query(":focusable:root:not([floating])"),
            e = d.query(":focusable:root[floating]");
        e.sort(function(i, g) {
            return i.el.getZIndex() > g.el.getZIndex()
        });
        return e.concat(c)
    },
    initDOM: function(d) {
        var j = this,
            c = j.focusFrameCls,
            g = Ext.ComponentQuery.query("{getFocusEl()}:not([focusListenerAdded])"),
            e = 0,
            a = g.length;
        if (!Ext.isReady) {
            return Ext.onReady(j.initDOM, j)
        }
        for (; e < a; e++) {
            g[e].addFocusListener()
        }
        if (!j.focusEl) {
            j.focusEl = Ext.getBody();
            j.focusEl.dom.tabIndex = -1
        }
        if (!j.focusFrame && d.focusFrame) {
            j.focusFrame = Ext.getBody().createChild({
                cls: c,
                children: [{
                    cls: c + "-top"
                }, {
                    cls: c + "-bottom"
                }, {
                    cls: c + "-left"
                }, {
                    cls: c + "-right"
                }],
                style: "top: -100px; left: -100px;"
            });
            j.focusFrame.setVisibilityMode(Ext.Element.DISPLAY);
            j.focusFrame.hide().setLeftTop(0, 0)
        }
    },
    isWhitelisted: function(a) {
        return a && Ext.Array.some(this.whitelist, function(c) {
            return a.isXType(c)
        })
    },
    navigateIn: function(i) {
        var d = this,
            a = d.focusedCmp,
            c, g;
        if (d.isWhitelisted(a)) {
            return true
        }
        if (!a) {
            c = d.getRootComponents()[0];
            if (c) {
                if (c.getFocusEl() === d.focusEl) {
                    d.focusEl.blur()
                }
                c.focus()
            }
        } else {
            g = a.hasFocus ? Ext.ComponentQuery.query(">:focusable", a)[0] : a;
            if (g) {
                g.focus()
            } else {
                if (Ext.isFunction(a.onClick)) {
                    i.button = 0;
                    a.onClick(i);
                    if (a.isVisible(true)) {
                        a.focus()
                    } else {
                        d.navigateOut()
                    }
                }
            }
        }
    },
    navigateOut: function(d) {
        var c = this,
            a;
        if (!c.focusedCmp || !(a = c.focusedCmp.up(":focusable"))) {
            c.focusEl.focus()
        } else {
            a.focus()
        }
        return true
    },
    navigateSiblings: function(k, c, q) {
        var l = this,
            a = c || l,
            r = k.getKey(),
            i = Ext.EventObject,
            m = k.shiftKey || r == i.LEFT || r == i.UP,
            d = r == i.LEFT || r == i.RIGHT || r == i.UP || r == i.DOWN,
            j = m ? "prev" : "next",
            p, g, o, n;
        o = (a.focusedCmp && a.focusedCmp.comp) || a.focusedCmp;
        if (!o && !q) {
            return true
        }
        if (d && l.isWhitelisted(o)) {
            return true
        }
        if (!o || o.is(":root")) {
            n = l.getRootComponents()
        } else {
            q = q || o.up();
            if (q) {
                n = q.getRefItems()
            }
        }
        if (n) {
            p = o ? Ext.Array.indexOf(n, o) : -1;
            g = Ext.ComponentQuery.query(":" + j + "Focus(" + p + ")", n)[0];
            if (g && o !== g) {
                g.focus();
                return g
            }
        }
    },
    onComponentBlur: function(c, d) {
        var a = this;
        if (a.focusedCmp === c) {
            a.previousFocusedCmp = c;
            delete a.focusedCmp
        }
        if (a.focusFrame) {
            a.focusFrame.hide()
        }
    },
    onComponentFocus: function(g, i) {
        var d = this,
            a = d.focusChain,
            c;
        if (!g.isFocusable()) {
            d.clearComponent(g);
            if (a[g.id]) {
                return
            }
            c = g.up();
            if (c) {
                a[g.id] = true;
                c.focus()
            }
            return
        }
        d.focusChain = {};
        d.focusTask.delay(10, null, null, [g, g.getFocusEl()])
    },
    handleComponentFocus: function(o, k) {
        var m = this,
            r, a, e, j, q, c, n, g, i, d, p, l;
        if (m.fireEvent("beforecomponentfocus", m, o, m.previousFocusedCmp) === false) {
            m.clearComponent(o);
            return
        }
        m.focusedCmp = o;
        if (m.shouldShowFocusFrame(o)) {
            r = "." + m.focusFrameCls + "-";
            a = m.focusFrame;
            j = k.getPageBox();
            q = j.top;
            c = j.left;
            n = j.width;
            g = j.height;
            i = a.child(r + "top");
            d = a.child(r + "bottom");
            p = a.child(r + "left");
            l = a.child(r + "right");
            i.setWidth(n).setLeftTop(c, q);
            d.setWidth(n).setLeftTop(c, q + g - 2);
            p.setHeight(g - 2).setLeftTop(c, q + 2);
            l.setHeight(g - 2).setLeftTop(c + n - 2, q + 2);
            a.show()
        }
        m.fireEvent("componentfocus", m, o, m.previousFocusedCmp)
    },
    onComponentHide: function(g) {
        var e = this,
            c = false,
            a = e.focusedCmp,
            d;
        if (a) {
            c = g.hasFocus || (g.isContainer && g.isAncestor(e.focusedCmp))
        }
        e.clearComponent(g);
        if (c && (d = g.up(":focusable"))) {
            d.focus()
        } else {
            e.focusEl.focus()
        }
    },
    onComponentDestroy: function() {},
    removeDOM: function() {
        var a = this;
        if (a.enabled || a.subscribers.length) {
            return
        }
        Ext.destroy(a.focusFrame);
        delete a.focusEl;
        delete a.focusFrame
    },
    removeXTypeFromWhitelist: function(c) {
        var a = this;
        if (Ext.isArray(c)) {
            Ext.Array.forEach(c, a.removeXTypeFromWhitelist, a);
            return
        }
        Ext.Array.remove(a.whitelist, c)
    },
    setupSubscriberKeys: function(a, i) {
        var g = this,
            e = a.getFocusEl(),
            d = i.scope,
            c = {
                backspace: g.focusLast,
                enter: g.navigateIn,
                esc: g.navigateOut,
                scope: g
            },
            j = function(k) {
                if (g.focusedCmp === a) {
                    return g.navigateSiblings(k, g, a)
                } else {
                    return g.navigateSiblings(k)
                }
            };
        Ext.iterate(i, function(l, k) {
            c[l] = function(n) {
                var m = j(n);
                if (Ext.isFunction(k) && k.call(d || a, n, m) === true) {
                    return true
                }
                return m
            }
        }, g);
        return new Ext.util.KeyNav(e, c)
    },
    shouldShowFocusFrame: function(d) {
        var c = this,
            a = c.options || {},
            g = d.getFocusEl(),
            e = Ext.getDom(g).tagName;
        if (!c.focusFrame || !d) {
            return false
        }
        if (a.focusFrame) {
            return true
        }
        if (c.focusData[d.id].focusFrame) {
            return true
        }
        return false
    }
});
Ext.define("Ext.Img", {
    extend: "Ext.Component",
    alias: ["widget.image", "widget.imagecomponent"],
    autoEl: "img",
    src: "",
    alt: "",
    imgCls: "",
    getElConfig: function() {
        var d = this,
            c = d.callParent(),
            a;
        if (d.autoEl == "img") {
            a = c
        } else {
            c.cn = [a = {
                tag: "img",
                id: d.id + "-img"
            }]
        }
        if (d.imgCls) {
            a.cls = (a.cls ? a.cls + " " : "") + d.imgCls
        }
        a.src = d.src || Ext.BLANK_IMAGE_URL;
        if (d.alt) {
            a.alt = d.alt
        }
        return c
    },
    onRender: function() {
        var c = this,
            a;
        c.callParent(arguments);
        a = c.el;
        c.imgEl = (c.autoEl == "img") ? a : a.getById(c.id + "-img")
    },
    onDestroy: function() {
        Ext.destroy(this.imgEl);
        this.imgEl = null;
        this.callParent()
    },
    setSrc: function(d) {
        var a = this,
            c = a.imgEl;
        a.src = d;
        if (c) {
            c.dom.src = d || Ext.BLANK_IMAGE_URL
        }
    }
});
Ext.define("Ext.Layer", {
    extend: "Ext.Element",
    uses: ["Ext.Shadow"],
    statics: {
        shims: []
    },
    isLayer: true,
    constructor: function(c, a) {
        c = c || {};
        var d = this,
            e = Ext.DomHelper,
            i = c.parentEl,
            g = i ? Ext.getDom(i) : document.body,
            j = c.hideMode;
        if (a) {
            d.dom = Ext.getDom(a)
        }
        if (!d.dom) {
            d.dom = e.append(g, c.dh || {
                tag: "div",
                cls: Ext.baseCSSPrefix + "layer"
            })
        } else {
            d.addCls(Ext.baseCSSPrefix + "layer");
            if (!d.dom.parentNode) {
                g.appendChild(d.dom)
            }
        }
        if (c.id) {
            d.id = d.dom.id = c.id
        } else {
            d.id = Ext.id(d.dom)
        }
        Ext.Element.addToCache(d);
        if (c.cls) {
            d.addCls(c.cls)
        }
        d.constrain = c.constrain !== false;
        if (j) {
            d.setVisibilityMode(Ext.Element[j.toUpperCase()]);
            if (d.visibilityMode == Ext.Element.ASCLASS) {
                d.visibilityCls = c.visibilityCls
            }
        } else {
            if (c.useDisplay) {
                d.setVisibilityMode(Ext.Element.DISPLAY)
            } else {
                d.setVisibilityMode(Ext.Element.VISIBILITY)
            }
        }
        if (c.shadow) {
            d.shadowOffset = c.shadowOffset || 4;
            d.shadow = new Ext.Shadow({
                offset: d.shadowOffset,
                mode: c.shadow
            });
            d.disableShadow()
        } else {
            d.shadowOffset = 0
        }
        d.useShim = c.shim !== false && Ext.useShims;
        if (c.hidden === true) {
            d.hide()
        } else {
            d.show()
        }
    },
    getZIndex: function() {
        return parseInt((this.getShim() || this).getStyle("z-index"), 10)
    },
    getShim: function() {
        var c = this,
            d, a;
        if (!c.useShim) {
            return null
        }
        if (!c.shim) {
            d = c.self.shims.shift();
            if (!d) {
                d = c.createShim();
                d.enableDisplayMode("block");
                d.hide()
            }
            a = c.dom.parentNode;
            if (d.dom.parentNode != a) {
                a.insertBefore(d.dom, c.dom)
            }
            c.shim = d
        }
        return c.shim
    },
    hideShim: function() {
        var a = this;
        if (a.shim) {
            a.shim.setDisplayed(false);
            a.self.shims.push(a.shim);
            delete a.shim
        }
    },
    disableShadow: function() {
        var a = this;
        if (a.shadow && !a.shadowDisabled) {
            a.shadowDisabled = true;
            a.shadow.hide();
            a.lastShadowOffset = a.shadowOffset;
            a.shadowOffset = 0
        }
    },
    enableShadow: function(a) {
        var c = this;
        if (c.shadow && c.shadowDisabled) {
            c.shadowDisabled = false;
            c.shadowOffset = c.lastShadowOffset;
            delete c.lastShadowOffset;
            if (a) {
                c.sync(true)
            }
        }
    },
    sync: function(c) {
        var k = this,
            o = k.shadow,
            j, g, a, e, d, p, n, i, m;
        if (!k.updating && k.isVisible() && (o || k.useShim)) {
            e = k.getShim();
            d = k.getLocalX();
            p = k.getLocalY();
            n = k.dom.offsetWidth;
            i = k.dom.offsetHeight;
            if (o && !k.shadowDisabled) {
                if (c && !o.isVisible()) {
                    o.show(k)
                } else {
                    o.realign(d, p, n, i)
                }
                if (e) {
                    m = e.getStyle("z-index");
                    if (m > k.zindex) {
                        k.shim.setStyle("z-index", k.zindex - 2)
                    }
                    e.show();
                    if (o.isVisible()) {
                        j = o.el.getXY();
                        g = e.dom.style;
                        a = o.el.getSize();
                        if (Ext.supports.CSS3BoxShadow) {
                            a.height += 6;
                            a.width += 4;
                            j[0] -= 2;
                            j[1] -= 4
                        }
                        g.left = (j[0]) + "px";
                        g.top = (j[1]) + "px";
                        g.width = (a.width) + "px";
                        g.height = (a.height) + "px"
                    } else {
                        e.setSize(n, i);
                        e.setLeftTop(d, p)
                    }
                }
            } else {
                if (e) {
                    m = e.getStyle("z-index");
                    if (m > k.zindex) {
                        k.shim.setStyle("z-index", k.zindex - 2)
                    }
                    e.show();
                    e.setSize(n, i);
                    e.setLeftTop(d, p)
                }
            }
        }
        return k
    },
    remove: function() {
        this.hideUnders();
        this.callParent()
    },
    beginUpdate: function() {
        this.updating = true
    },
    endUpdate: function() {
        this.updating = false;
        this.sync(true)
    },
    hideUnders: function() {
        if (this.shadow) {
            this.shadow.hide()
        }
        this.hideShim()
    },
    constrainXY: function() {
        if (this.constrain) {
            var i = Ext.Element.getViewWidth(),
                c = Ext.Element.getViewHeight(),
                m = Ext.getDoc().getScroll(),
                l = this.getXY(),
                j = l[0],
                g = l[1],
                a = this.shadowOffset,
                k = this.dom.offsetWidth + a,
                d = this.dom.offsetHeight + a,
                e = false;
            if ((j + k) > i + m.left) {
                j = i - k - a;
                e = true
            }
            if ((g + d) > c + m.top) {
                g = c - d - a;
                e = true
            }
            if (j < m.left) {
                j = m.left;
                e = true
            }
            if (g < m.top) {
                g = m.top;
                e = true
            }
            if (e) {
                Ext.Layer.superclass.setXY.call(this, [j, g]);
                this.sync()
            }
        }
        return this
    },
    getConstrainOffset: function() {
        return this.shadowOffset
    },
    setVisible: function(g, c, e, j, i) {
        var d = this,
            a;
        a = function() {
            if (g) {
                d.sync(true)
            }
            if (j) {
                j()
            }
        };
        if (!g) {
            d.hideUnders(true)
        }
        d.callParent([g, c, e, j, i]);
        if (!c) {
            a()
        }
        return d
    },
    beforeFx: function() {
        this.beforeAction();
        return this.callParent(arguments)
    },
    afterFx: function() {
        this.callParent(arguments);
        this.sync(this.isVisible())
    },
    beforeAction: function() {
        if (!this.updating && this.shadow) {
            this.shadow.hide()
        }
    },
    setLeft: function(a) {
        this.callParent(arguments);
        return this.sync()
    },
    setTop: function(a) {
        this.callParent(arguments);
        return this.sync()
    },
    setLeftTop: function(c, a) {
        this.callParent(arguments);
        return this.sync()
    },
    setXY: function(e, a, d, i, g) {
        var c = this;
        i = c.createCB(i);
        c.fixDisplay();
        c.beforeAction();
        c.callParent([e, a, d, i, g]);
        if (!a) {
            i()
        }
        return c
    },
    createCB: function(d) {
        var a = this,
            c = a.shadow && a.shadow.isVisible();
        return function() {
            a.constrainXY();
            a.sync(c);
            if (d) {
                d()
            }
        }
    },
    setX: function(a, c, d, g, e) {
        this.setXY([a, this.getY()], c, d, g, e);
        return this
    },
    setY: function(g, a, c, e, d) {
        this.setXY([this.getX(), g], a, c, e, d);
        return this
    },
    setSize: function(a, d, c, g, j, i) {
        var e = this;
        j = e.createCB(j);
        e.beforeAction();
        e.callParent([a, d, c, g, j, i]);
        if (!c) {
            j()
        }
        return e
    },
    setWidth: function(a, c, e, i, g) {
        var d = this;
        i = d.createCB(i);
        d.beforeAction();
        d.callParent([a, c, e, i, g]);
        if (!c) {
            i()
        }
        return d
    },
    setHeight: function(c, a, e, i, g) {
        var d = this;
        i = d.createCB(i);
        d.beforeAction();
        d.callParent([c, a, e, i, g]);
        if (!a) {
            i()
        }
        return d
    },
    setBounds: function(j, i, a, l, c, d, k, e) {
        var g = this;
        k = g.createCB(k);
        g.beforeAction();
        if (!c) {
            Ext.Layer.superclass.setXY.call(g, [j, i]);
            Ext.Layer.superclass.setSize.call(g, a, l);
            k()
        } else {
            g.callParent([j, i, a, l, c, d, k, e])
        }
        return g
    },
    setZIndex: function(a) {
        var c = this;
        c.zindex = a;
        if (c.getShim()) {
            c.shim.setStyle("z-index", a++)
        }
        if (c.shadow) {
            c.shadow.setZIndex(a++)
        }
        return c.setStyle("z-index", a)
    },
    onOpacitySet: function(a) {
        var c = this.shadow;
        if (c) {
            c.setOpacity(a)
        }
    }
});
Ext.define("Ext.PluginManager", {
    extend: "Ext.AbstractManager",
    alternateClassName: "Ext.PluginMgr",
    singleton: true,
    typeName: "ptype",
    create: function(a, c) {
        if (a.init) {
            return a
        } else {
            return Ext.createByAlias("plugin." + (a.ptype || c), a)
        }
    },
    findByType: function(d, i) {
        var g = [],
            c = this.types,
            a, e;
        for (a in c) {
            if (!c.hasOwnProperty(a)) {
                continue
            }
            e = c[a];
            if (e.type == d && (!i || (i === true && e.isDefault))) {
                g.push(e)
            }
        }
        return g
    }
}, function() {
    Ext.preg = function() {
        return Ext.PluginManager.registerType.apply(Ext.PluginManager, arguments)
    }
});
Ext.define("Ext.ShadowPool", {
    singleton: true,
    requires: ["Ext.DomHelper"],
    markup: (function() {
        return Ext.String.format('<div class="{0}{1}-shadow" role="presentation"></div>', Ext.baseCSSPrefix, Ext.isIE && !Ext.supports.CSS3BoxShadow ? "ie" : "css")
    }()),
    shadows: [],
    pull: function() {
        var a = this.shadows.shift();
        if (!a) {
            a = Ext.get(Ext.DomHelper.insertHtml("beforeBegin", document.body.firstChild, this.markup));
            a.autoBoxAdjust = false
        }
        return a
    },
    push: function(a) {
        this.shadows.push(a)
    },
    reset: function() {
        var d = [].concat(this.shadows),
            c, a = d.length;
        for (c = 0; c < a; c++) {
            d[c].remove()
        }
        this.shadows = []
    }
});
Ext.define("Ext.Shadow", {
    requires: ["Ext.ShadowPool"],
    constructor: function(c) {
        var d = this,
            e, g, a;
        Ext.apply(d, c);
        if (!Ext.isString(d.mode)) {
            d.mode = d.defaultMode
        }
        g = d.offset;
        a = Math.floor(g / 2);
        d.opacity = 50;
        switch (d.mode.toLowerCase()) {
            case "drop":
                if (Ext.supports.CSS3BoxShadow) {
                    e = {
                        t: g,
                        l: g,
                        h: -g,
                        w: -g
                    }
                } else {
                    e = {
                        t: -a,
                        l: -a,
                        h: -a,
                        w: -a
                    }
                }
                break;
            case "sides":
                if (Ext.supports.CSS3BoxShadow) {
                    e = {
                        t: g,
                        l: 0,
                        h: -g,
                        w: 0
                    }
                } else {
                    e = {
                        t: -(1 + a),
                        l: 1 + a - 2 * g,
                        h: -1,
                        w: a - 1
                    }
                }
                break;
            case "frame":
                if (Ext.supports.CSS3BoxShadow) {
                    e = {
                        t: 0,
                        l: 0,
                        h: 0,
                        w: 0
                    }
                } else {
                    e = {
                        t: 1 + a - 2 * g,
                        l: 1 + a - 2 * g,
                        h: g - a - 1,
                        w: g - a - 1
                    }
                }
                break
        }
        d.adjusts = e
    },
    getShadowSize: function() {
        var c = this,
            e = c.el ? c.offset : 0,
            a = [e, e, e, e],
            d = c.mode.toLowerCase();
        if (c.el && d !== "frame") {
            a[0] = 0;
            if (d == "drop") {
                a[3] = 0
            }
        }
        return a
    },
    offset: 4,
    defaultMode: "drop",
    boxShadowProperty: (function() {
        var c = "boxShadow",
            a = document.documentElement.style;
        if (!("boxShadow" in a)) {
            if ("WebkitBoxShadow" in a) {
                c = "WebkitBoxShadow"
            } else {
                if ("MozBoxShadow" in a) {
                    c = "MozBoxShadow"
                }
            }
        }
        return c
    }()),
    show: function(d) {
        var c = this,
            a;
        d = Ext.get(d);
        if (!c.el) {
            c.el = Ext.ShadowPool.pull();
            if (c.el.dom.nextSibling != d.dom) {
                c.el.insertBefore(d)
            }
        }
        a = (parseInt(d.getStyle("z-index"), 10) - 1) || 0;
        c.el.setStyle("z-index", c.zIndex || a);
        if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
            c.el.dom.style.filter = "progid:DXImageTransform.Microsoft.alpha(opacity=" + c.opacity + ") progid:DXImageTransform.Microsoft.Blur(pixelradius=" + (c.offset) + ")"
        }
        c.realign(d.getLocalX(), d.getLocalY(), d.dom.offsetWidth, d.dom.offsetHeight);
        c.el.dom.style.display = "block"
    },
    isVisible: function() {
        return this.el ? true : false
    },
    realign: function(c, p, n, i) {
        if (!this.el) {
            return
        }
        var a = this.adjusts,
            k = this.el.dom,
            m = k.style,
            e, g, j, o;
        m.left = (c + a.l) + "px";
        m.top = (p + a.t) + "px";
        e = Math.max(n + a.w, 0);
        g = Math.max(i + a.h, 0);
        j = e + "px";
        o = g + "px";
        if (m.width != j || m.height != o) {
            m.width = j;
            m.height = o;
            if (Ext.supports.CSS3BoxShadow) {
                m[this.boxShadowProperty] = "0 0 " + this.offset + "px #888"
            }
        }
    },
    hide: function() {
        var a = this;
        if (a.el) {
            a.el.dom.style.display = "none";
            Ext.ShadowPool.push(a.el);
            delete a.el
        }
    },
    setZIndex: function(a) {
        this.zIndex = a;
        if (this.el) {
            this.el.setStyle("z-index", a)
        }
    },
    setOpacity: function(a) {
        if (this.el) {
            if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
                a = Math.floor(a * 100 / 2) / 100
            }
            this.opacity = a;
            this.el.setOpacity(a)
        }
    }
});
Ext.define("Ext.layout.component.Draw", {
    alias: "layout.draw",
    extend: "Ext.layout.component.Auto",
    type: "draw",
    measureContentWidth: function(c) {
        var d = c.target,
            a = c.getPaddingInfo(),
            e = this.getBBox(c);
        if (!d.viewBox) {
            if (d.autoSize) {
                return e.width + a.width
            } else {
                return e.x + e.width + a.width
            }
        } else {
            if (c.heightModel.shrinkWrap) {
                return a.width
            } else {
                return e.width / e.height * (c.getProp("contentHeight") - a.height) + a.width
            }
        }
    },
    measureContentHeight: function(c) {
        var d = c.target,
            a = c.getPaddingInfo(),
            e = this.getBBox(c);
        if (!c.target.viewBox) {
            if (d.autoSize) {
                return e.height + a.height
            } else {
                return e.y + e.height + a.height
            }
        } else {
            if (c.widthModel.shrinkWrap) {
                return a.height
            } else {
                return e.height / e.width * (c.getProp("contentWidth") - a.width) + a.height
            }
        }
    },
    getBBox: function(a) {
        var c = a.surfaceBBox;
        if (!c) {
            c = a.target.surface.items.getBBox();
            if (c.width === -Infinity && c.height === -Infinity) {
                c.width = c.height = c.x = c.y = 0
            }
            a.surfaceBBox = c
        }
        return c
    },
    publishInnerWidth: function(c, a) {
        c.setContentWidth(a - c.getFrameInfo().width, true)
    },
    publishInnerHeight: function(c, a) {
        c.setContentHeight(a - c.getFrameInfo().height, true)
    },
    finishedLayout: function(d) {
        var c = d.props,
            a = d.getPaddingInfo();
        this.owner.setSurfaceSize(c.contentWidth - a.width, c.contentHeight - a.height);
        this.callParent(arguments)
    }
});
Ext.define("Ext.draw.CompositeSprite", {
    extend: "Ext.util.MixedCollection",
    mixins: {
        animate: "Ext.util.Animate"
    },
    autoDestroy: false,
    isCompositeSprite: true,
    constructor: function(a) {
        var c = this;
        a = a || {};
        Ext.apply(c, a);
        c.addEvents("mousedown", "mouseup", "mouseover", "mouseout", "click");
        c.id = Ext.id(null, "ext-sprite-group-");
        c.callParent()
    },
    onClick: function(a) {
        this.fireEvent("click", a)
    },
    onMouseUp: function(a) {
        this.fireEvent("mouseup", a)
    },
    onMouseDown: function(a) {
        this.fireEvent("mousedown", a)
    },
    onMouseOver: function(a) {
        this.fireEvent("mouseover", a)
    },
    onMouseOut: function(a) {
        this.fireEvent("mouseout", a)
    },
    attachEvents: function(c) {
        var a = this;
        c.on({
            scope: a,
            mousedown: a.onMouseDown,
            mouseup: a.onMouseUp,
            mouseover: a.onMouseOver,
            mouseout: a.onMouseOut,
            click: a.onClick
        })
    },
    add: function(c, d) {
        var a = this.callParent(arguments);
        this.attachEvents(a);
        return a
    },
    insert: function(a, c, d) {
        return this.callParent(arguments)
    },
    remove: function(c) {
        var a = this;
        c.un({
            scope: a,
            mousedown: a.onMouseDown,
            mouseup: a.onMouseUp,
            mouseover: a.onMouseOver,
            mouseout: a.onMouseOut,
            click: a.onClick
        });
        return a.callParent(arguments)
    },
    getBBox: function() {
        var g = 0,
            p, l, m = this.items,
            j = this.length,
            k = Infinity,
            d = k,
            o = -k,
            c = k,
            n = -k,
            e, a;
        for (; g < j; g++) {
            p = m[g];
            if (p.el && !p.bboxExcluded) {
                l = p.getBBox();
                d = Math.min(d, l.x);
                c = Math.min(c, l.y);
                o = Math.max(o, l.height + l.y);
                n = Math.max(n, l.width + l.x)
            }
        }
        return {
            x: d,
            y: c,
            height: o - c,
            width: n - d
        }
    },
    setAttributes: function(d, g) {
        var e = 0,
            c = this.items,
            a = this.length;
        for (; e < a; e++) {
            c[e].setAttributes(d, g)
        }
        return this
    },
    hide: function(e) {
        var d = 0,
            c = this.items,
            a = this.length;
        for (; d < a; d++) {
            c[d].hide(e)
        }
        return this
    },
    show: function(e) {
        var d = 0,
            c = this.items,
            a = this.length;
        for (; d < a; d++) {
            c[d].show(e)
        }
        return this
    },
    redraw: function() {
        var g = this,
            e = 0,
            d = g.items,
            c = g.getSurface(),
            a = g.length;
        if (c) {
            for (; e < a; e++) {
                c.renderItem(d[e])
            }
        }
        return g
    },
    setStyle: function(j) {
        var d = 0,
            c = this.items,
            a = this.length,
            g, e;
        for (; d < a; d++) {
            g = c[d];
            e = g.el;
            if (e) {
                e.setStyle(j)
            }
        }
    },
    addCls: function(g) {
        var e = 0,
            d = this.items,
            c = this.getSurface(),
            a = this.length;
        if (c) {
            for (; e < a; e++) {
                c.addCls(d[e], g)
            }
        }
    },
    removeCls: function(g) {
        var e = 0,
            d = this.items,
            c = this.getSurface(),
            a = this.length;
        if (c) {
            for (; e < a; e++) {
                c.removeCls(d[e], g)
            }
        }
    },
    getSurface: function() {
        var a = this.first();
        if (a) {
            return a.surface
        }
        return null
    },
    destroy: function() {
        var e = this,
            a = e.getSurface(),
            d = e.autoDestroy,
            c;
        if (a) {
            while (e.getCount() > 0) {
                c = e.first();
                e.remove(c);
                a.remove(c, d)
            }
        }
        e.clearListeners()
    }
});
Ext.define("Ext.draw.Surface", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.draw.CompositeSprite"],
    uses: ["Ext.draw.engine.Svg", "Ext.draw.engine.Vml", "Ext.draw.engine.SvgExporter", "Ext.draw.engine.ImageExporter"],
    separatorRe: /[, ]+/,
    statics: {
        create: function(c, e) {
            e = e || ["Svg", "Vml"];
            var d = 0,
                a = e.length,
                g;
            for (; d < a; d++) {
                if (Ext.supports[e[d]] !== false) {
                    return Ext.create("Ext.draw.engine." + e[d], c)
                }
            }
            return false
        },
        save: function(a, c) {
            c = c || {};
            var g = {
                    "image/png": "Image",
                    "image/jpeg": "Image",
                    "image/svg+xml": "Svg"
                },
                e = g[c.type] || "Svg",
                d = Ext.draw.engine[e + "Exporter"];
            return d.generate(a, c)
        }
    },
    availableAttrs: {
        blur: 0,
        "clip-rect": "0 0 1e9 1e9",
        cursor: "default",
        cx: 0,
        cy: 0,
        "dominant-baseline": "auto",
        fill: "none",
        "fill-opacity": 1,
        font: '10px "Arial"',
        "font-family": '"Arial"',
        "font-size": "10",
        "font-style": "normal",
        "font-weight": 400,
        gradient: "",
        height: 0,
        hidden: false,
        href: "http://sencha.com/",
        opacity: 1,
        path: "M0,0",
        radius: 0,
        rx: 0,
        ry: 0,
        scale: "1 1",
        src: "",
        stroke: "none",
        "stroke-dasharray": "",
        "stroke-linecap": "butt",
        "stroke-linejoin": "butt",
        "stroke-miterlimit": 0,
        "stroke-opacity": 1,
        "stroke-width": 1,
        target: "_blank",
        text: "",
        "text-anchor": "middle",
        title: "Ext Draw",
        width: 0,
        x: 0,
        y: 0,
        zIndex: 0
    },
    container: undefined,
    height: 352,
    width: 512,
    x: 0,
    y: 0,
    orderSpritesByZIndex: true,
    constructor: function(a) {
        var c = this;
        a = a || {};
        Ext.apply(c, a);
        c.domRef = Ext.getDoc().dom;
        c.customAttributes = {};
        c.addEvents("mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "click", "dblclick");
        c.mixins.observable.constructor.call(c);
        c.getId();
        c.initGradients();
        c.initItems();
        if (c.renderTo) {
            c.render(c.renderTo);
            delete c.renderTo
        }
        c.initBackground(a.background)
    },
    initSurface: Ext.emptyFn,
    renderItem: Ext.emptyFn,
    renderItems: Ext.emptyFn,
    setViewBox: function(c, e, d, a) {
        if (isFinite(c) && isFinite(e) && isFinite(d) && isFinite(a)) {
            this.viewBox = {
                x: c,
                y: e,
                width: d,
                height: a
            };
            this.applyViewBox()
        }
    },
    addCls: Ext.emptyFn,
    removeCls: Ext.emptyFn,
    setStyle: Ext.emptyFn,
    initGradients: function() {
        if (this.hasOwnProperty("gradients")) {
            var a = this.gradients,
                e = a.length,
                c = this.addGradient,
                d;
            if (a) {
                for (d = 0; d < e; d++) {
                    if (c.call(this, a[d], d, e) === false) {
                        break
                    }
                }
            }
        }
    },
    initItems: function() {
        var a = this.items;
        this.items = new Ext.draw.CompositeSprite();
        this.items.autoDestroy = true;
        this.groups = new Ext.draw.CompositeSprite();
        if (a) {
            this.add(a)
        }
    },
    initBackground: function(c) {
        var g = this,
            e = g.width,
            a = g.height,
            i, j, d;
        if (Ext.isString(c)) {
            c = {
                fill: c
            }
        }
        if (c) {
            if (c.gradient) {
                j = c.gradient;
                i = j.id;
                g.addGradient(j);
                g.background = g.add({
                    type: "rect",
                    x: 0,
                    y: 0,
                    width: e,
                    height: a,
                    fill: "url(#" + i + ")",
                    zIndex: -1
                })
            } else {
                if (c.fill) {
                    g.background = g.add({
                        type: "rect",
                        x: 0,
                        y: 0,
                        width: e,
                        height: a,
                        fill: c.fill,
                        zIndex: -1
                    })
                } else {
                    if (c.image) {
                        g.background = g.add({
                            type: "image",
                            x: 0,
                            y: 0,
                            width: e,
                            height: a,
                            src: c.image,
                            zIndex: -1
                        })
                    }
                }
            }
            g.background.bboxExcluded = true
        }
    },
    setSize: function(a, c) {
        this.applyViewBox()
    },
    scrubAttrs: function(e) {
        var d, c = {},
            a = {},
            g = e.attr;
        for (d in g) {
            if (this.translateAttrs.hasOwnProperty(d)) {
                c[this.translateAttrs[d]] = g[d];
                a[this.translateAttrs[d]] = true
            } else {
                if (this.availableAttrs.hasOwnProperty(d) && !a[d]) {
                    c[d] = g[d]
                }
            }
        }
        return c
    },
    onClick: function(a) {
        this.processEvent("click", a)
    },
    onDblClick: function(a) {
        this.processEvent("dblclick", a)
    },
    onMouseUp: function(a) {
        this.processEvent("mouseup", a)
    },
    onMouseDown: function(a) {
        this.processEvent("mousedown", a)
    },
    onMouseOver: function(a) {
        this.processEvent("mouseover", a)
    },
    onMouseOut: function(a) {
        this.processEvent("mouseout", a)
    },
    onMouseMove: function(a) {
        this.fireEvent("mousemove", a)
    },
    onMouseEnter: Ext.emptyFn,
    onMouseLeave: Ext.emptyFn,
    addGradient: Ext.emptyFn,
    add: function() {
        var j = Array.prototype.slice.call(arguments),
            l, e, a = j.length > 1,
            k, c, d, g, m;
        if (a || Ext.isArray(j[0])) {
            k = a ? j : j[0];
            c = [];
            for (d = 0, g = k.length; d < g; d++) {
                m = k[d];
                m = this.add(m);
                c.push(m)
            }
            return c
        }
        l = this.prepareItems(j[0], true)[0];
        this.insertByZIndex(l);
        this.onAdd(l);
        return l
    },
    insertByZIndex: function(l) {
        var i = this,
            e = i.items.items,
            d = e.length,
            m = Math.ceil,
            j = l.attr.zIndex,
            k = d,
            c = k - 1,
            g = 0,
            a;
        if (i.orderSpritesByZIndex && d && j < e[c].attr.zIndex) {
            while (g <= c) {
                k = m((g + c) / 2);
                a = e[k].attr.zIndex;
                if (a > j) {
                    c = k - 1
                } else {
                    if (a < j) {
                        g = k + 1
                    } else {
                        break
                    }
                }
            }
            while (k < d && e[k].attr.zIndex <= j) {
                k++
            }
        }
        i.items.insert(k, l);
        return k
    },
    onAdd: function(e) {
        var j = e.group,
            c = e.draggable,
            a, g, d;
        if (j) {
            a = [].concat(j);
            g = a.length;
            for (d = 0; d < g; d++) {
                j = a[d];
                this.getGroup(j).add(e)
            }
            delete e.group
        }
        if (c) {
            e.initDraggable()
        }
    },
    remove: function(c, i) {
        if (c) {
            this.items.remove(c);
            var a = [].concat(this.groups.items),
                e = a.length,
                d;
            for (d = 0; d < e; d++) {
                a[d].remove(c)
            }
            c.onRemove();
            if (i === true) {
                c.destroy()
            }
        }
    },
    removeAll: function(e) {
        var a = this.items.items,
            d = a.length,
            c;
        for (c = d - 1; c > -1; c--) {
            this.remove(a[c], e)
        }
    },
    onRemove: Ext.emptyFn,
    onDestroy: Ext.emptyFn,
    applyViewBox: function() {
        var e = this,
            n = e.viewBox,
            a = e.width || 1,
            j = e.height || 1,
            i, g, l, c, k, d, m;
        if (n && (a || j)) {
            i = n.x;
            g = n.y;
            l = n.width;
            c = n.height;
            k = j / c;
            d = a / l;
            m = Math.min(d, k);
            if (l * m < a) {
                i -= (a - l * m) / 2 / m
            }
            if (c * m < j) {
                g -= (j - c * m) / 2 / m
            }
            e.viewBoxShift = {
                dx: -i,
                dy: -g,
                scale: m
            };
            if (e.background) {
                e.background.setAttributes(Ext.apply({}, {
                    x: i,
                    y: g,
                    width: a / m,
                    height: j / m
                }, {
                    hidden: false
                }), true)
            }
        } else {
            if (e.background && a && j) {
                e.background.setAttributes(Ext.apply({
                    x: 0,
                    y: 0,
                    width: a,
                    height: j
                }, {
                    hidden: false
                }), true)
            }
        }
    },
    getBBox: function(a, c) {
        var d = this["getPath" + a.type](a);
        if (c) {
            a.bbox.plain = a.bbox.plain || Ext.draw.Draw.pathDimensions(d);
            return a.bbox.plain
        }
        if (a.dirtyTransform) {
            this.applyTransformations(a, true)
        }
        a.bbox.transform = a.bbox.transform || Ext.draw.Draw.pathDimensions(Ext.draw.Draw.mapPath(d, a.matrix));
        return a.bbox.transform
    },
    transformToViewBox: function(a, e) {
        if (this.viewBoxShift) {
            var d = this,
                c = d.viewBoxShift;
            return [a / c.scale - c.dx, e / c.scale - c.dy]
        } else {
            return [a, e]
        }
    },
    applyTransformations: function(c, e) {
        if (c.type == "text") {
            c.bbox.transform = 0;
            this.transform(c, false)
        }
        c.dirtyTransform = false;
        var d = this,
            a = c.attr;
        if (a.translation.x != null || a.translation.y != null) {
            d.translate(c)
        }
        if (a.scaling.x != null || a.scaling.y != null) {
            d.scale(c)
        }
        if (a.rotation.degrees != null) {
            d.rotate(c)
        }
        c.bbox.transform = 0;
        this.transform(c, e);
        c.transformations = []
    },
    rotate: function(a) {
        var g, c = a.attr.rotation.degrees,
            e = a.attr.rotation.x,
            d = a.attr.rotation.y;
        if (!Ext.isNumber(e) || !Ext.isNumber(d)) {
            g = this.getBBox(a, true);
            e = !Ext.isNumber(e) ? g.x + g.width / 2 : e;
            d = !Ext.isNumber(d) ? g.y + g.height / 2 : d
        }
        a.transformations.push({
            type: "rotate",
            degrees: c,
            x: e,
            y: d
        })
    },
    translate: function(c) {
        var a = c.attr.translation.x || 0,
            d = c.attr.translation.y || 0;
        c.transformations.push({
            type: "translate",
            x: a,
            y: d
        })
    },
    scale: function(c) {
        var g, a = c.attr.scaling.x || 1,
            i = c.attr.scaling.y || 1,
            e = c.attr.scaling.centerX,
            d = c.attr.scaling.centerY;
        if (!Ext.isNumber(e) || !Ext.isNumber(d)) {
            g = this.getBBox(c, true);
            e = !Ext.isNumber(e) ? g.x + g.width / 2 : e;
            d = !Ext.isNumber(d) ? g.y + g.height / 2 : d
        }
        c.transformations.push({
            type: "scale",
            x: a,
            y: i,
            centerX: e,
            centerY: d
        })
    },
    rectPath: function(a, g, c, d, e) {
        if (e) {
            return [
                ["M", a + e, g],
                ["l", c - e * 2, 0],
                ["a", e, e, 0, 0, 1, e, e],
                ["l", 0, d - e * 2],
                ["a", e, e, 0, 0, 1, -e, e],
                ["l", e * 2 - c, 0],
                ["a", e, e, 0, 0, 1, -e, -e],
                ["l", 0, e * 2 - d],
                ["a", e, e, 0, 0, 1, e, -e],
                ["z"]
            ]
        }
        return [
            ["M", a, g],
            ["l", c, 0],
            ["l", 0, d],
            ["l", -c, 0],
            ["z"]
        ]
    },
    ellipsePath: function(a, e, d, c) {
        if (c == null) {
            c = d
        }
        return [
            ["M", a, e],
            ["m", 0, -c],
            ["a", d, c, 0, 1, 1, 0, 2 * c],
            ["a", d, c, 0, 1, 1, 0, -2 * c],
            ["z"]
        ]
    },
    getPathpath: function(a) {
        return a.attr.path
    },
    getPathcircle: function(d) {
        var c = d.attr;
        return this.ellipsePath(c.x, c.y, c.radius, c.radius)
    },
    getPathellipse: function(d) {
        var c = d.attr;
        return this.ellipsePath(c.x, c.y, c.radiusX || (c.width / 2) || 0, c.radiusY || (c.height / 2) || 0)
    },
    getPathrect: function(d) {
        var c = d.attr;
        return this.rectPath(c.x || 0, c.y || 0, c.width || 0, c.height || 0, c.r || 0)
    },
    getPathimage: function(d) {
        var c = d.attr;
        return this.rectPath(c.x || 0, c.y || 0, c.width, c.height)
    },
    getPathtext: function(a) {
        var c = this.getBBoxText(a);
        return this.rectPath(c.x, c.y, c.width, c.height)
    },
    createGroup: function(c) {
        var a = this.groups.get(c);
        if (!a) {
            a = new Ext.draw.CompositeSprite({
                surface: this
            });
            a.id = c || Ext.id(null, "ext-surface-group-");
            this.groups.add(a)
        }
        return a
    },
    getGroup: function(c) {
        var a;
        if (typeof c == "string") {
            a = this.groups.get(c);
            if (!a) {
                a = this.createGroup(c)
            }
        } else {
            a = c
        }
        return a
    },
    prepareItems: function(a, d) {
        a = [].concat(a);
        var g, c, e;
        for (c = 0, e = a.length; c < e; c++) {
            g = a[c];
            if (!(g instanceof Ext.draw.Sprite)) {
                g.surface = this;
                a[c] = this.createItem(g)
            } else {
                g.surface = this
            }
        }
        return a
    },
    setText: Ext.emptyFn,
    createItem: Ext.emptyFn,
    getId: function() {
        return this.id || (this.id = Ext.id(null, "ext-surface-"))
    },
    destroy: function() {
        var a = this;
        delete a.domRef;
        if (a.background) {
            a.background.destroy()
        }
        a.removeAll(true);
        Ext.destroy(a.groups.items)
    }
});
Ext.define("Ext.draw.Component", {
    alias: "widget.draw",
    extend: "Ext.Component",
    requires: ["Ext.draw.Surface", "Ext.layout.component.Draw"],
    enginePriority: ["Svg", "Vml"],
    baseCls: Ext.baseCSSPrefix + "surface",
    componentLayout: "draw",
    viewBox: true,
    shrinkWrap: 3,
    autoSize: false,
    initComponent: function() {
        this.callParent(arguments);
        this.addEvents("mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "click", "dblclick")
    },
    onRender: function() {
        var e = this,
            l = e.viewBox,
            c = e.autoSize,
            j, d, a, k, i, g;
        e.callParent(arguments);
        if (e.createSurface() !== false) {
            d = e.surface.items;
            if (l || c) {
                j = d.getBBox();
                a = j.width;
                k = j.height;
                i = j.x;
                g = j.y;
                if (e.viewBox) {
                    e.surface.setViewBox(i, g, a, k)
                } else {
                    e.autoSizeSurface()
                }
            }
        }
    },
    autoSizeSurface: function() {
        var a = this.surface.items.getBBox();
        this.setSurfaceSize(a.width, a.height)
    },
    setSurfaceSize: function(c, a) {
        this.surface.setSize(c, a);
        if (this.autoSize) {
            var d = this.surface.items.getBBox();
            this.surface.setViewBox(d.x, d.y - (+Ext.isOpera), c, a)
        }
    },
    createSurface: function() {
        var e = this,
            c = Ext.applyIf({
                renderTo: e.el,
                height: e.height,
                width: e.width,
                items: e.items
            }, e.initialConfig),
            a;
        delete c.listeners;
        a = Ext.draw.Surface.create(c);
        if (!a) {
            return false
        }
        e.surface = a;

        function d(g) {
            return function(i) {
                e.fireEvent(g, i)
            }
        }
        a.on({
            scope: e,
            mouseup: d("mouseup"),
            mousedown: d("mousedown"),
            mousemove: d("mousemove"),
            mouseenter: d("mouseenter"),
            mouseleave: d("mouseleave"),
            click: d("click"),
            dblclick: d("dblclick")
        })
    },
    onDestroy: function() {
        Ext.destroy(this.surface);
        this.callParent(arguments)
    }
});
Ext.define("Ext.data.reader.Array", {
    extend: "Ext.data.reader.Json",
    alternateClassName: "Ext.data.ArrayReader",
    alias: "reader.array",
    totalProperty: undefined,
    successProperty: undefined,
    createFieldAccessExpression: function(g, d, c) {
        var e = (g.mapping == null) ? g.originalIndex : g.mapping,
            a;
        if (typeof e === "function") {
            a = d + ".mapping(" + c + ", this)"
        } else {
            if (isNaN(e)) {
                e = '"' + e + '"'
            }
            a = c + "[" + e + "]"
        }
        return a
    }
});
Ext.define("Ext.data.ArrayStore", {
    extend: "Ext.data.Store",
    alias: "store.array",
    requires: ["Ext.data.proxy.Memory", "Ext.data.reader.Array"],
    constructor: function(a) {
        a = Ext.apply({
            proxy: {
                type: "memory",
                reader: "array"
            }
        }, a);
        this.callParent([a])
    },
    loadData: function(g, a) {
        if (this.expandData === true) {
            var e = [],
                c = 0,
                d = g.length;
            for (; c < d; c++) {
                e[e.length] = [g[c]]
            }
            g = e
        }
        this.callParent([g, a])
    }
}, function() {
    Ext.data.SimpleStore = Ext.data.ArrayStore
});
Ext.define("Ext.data.Batch", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    autoStart: false,
    pauseOnException: false,
    current: -1,
    total: 0,
    isRunning: false,
    isComplete: false,
    hasException: false,
    constructor: function(a) {
        var c = this;
        c.mixins.observable.constructor.call(c, a);
        c.operations = [];
        c.exceptions = []
    },
    add: function(a) {
        this.total++;
        a.setBatch(this);
        this.operations.push(a);
        return this
    },
    start: function(a) {
        var c = this;
        if (c.isRunning) {
            return c
        }
        c.exceptions.length = 0;
        c.hasException = false;
        c.isRunning = true;
        return c.runOperation(Ext.isDefined(a) ? a : c.current + 1)
    },
    retry: function() {
        return this.start(this.current)
    },
    runNextOperation: function() {
        return this.runOperation(this.current + 1)
    },
    pause: function() {
        this.isRunning = false;
        return this
    },
    runOperation: function(e) {
        var g = this,
            d = g.operations,
            c = d[e],
            a;
        if (c === undefined) {
            g.isRunning = false;
            g.isComplete = true;
            g.fireEvent("complete", g, d[d.length - 1])
        } else {
            g.current = e;
            a = function(i) {
                var j = i.hasException();
                if (j) {
                    g.hasException = true;
                    g.exceptions.push(i);
                    g.fireEvent("exception", g, i)
                }
                if (j && g.pauseOnException) {
                    g.pause()
                } else {
                    i.setCompleted();
                    g.fireEvent("operationcomplete", g, i);
                    g.runNextOperation()
                }
            };
            c.setStarted();
            g.proxy[c.action](c, a, g)
        }
        return g
    }
});
Ext.define("Ext.direct.Manager", {
    singleton: true,
    mixins: {
        observable: "Ext.util.Observable"
    },
    requires: ["Ext.util.MixedCollection"],
    exceptions: {
        TRANSPORT: "xhr",
        PARSE: "parse",
        LOGIN: "login",
        SERVER: "exception"
    },
    constructor: function() {
        var a = this;
        a.addEvents("event", "exception");
        a.transactions = new Ext.util.MixedCollection();
        a.providers = new Ext.util.MixedCollection();
        a.mixins.observable.constructor.call(a)
    },
    addProvider: function(g) {
        var e = this,
            c = arguments,
            d = 0,
            a;
        if (c.length > 1) {
            for (a = c.length; d < a; ++d) {
                e.addProvider(c[d])
            }
            return
        }
        if (!g.isProvider) {
            g = Ext.create("direct." + g.type + "provider", g)
        }
        e.providers.add(g);
        g.on("data", e.onProviderData, e);
        if (!g.isConnected()) {
            g.connect()
        }
        return g
    },
    getProvider: function(a) {
        return a.isProvider ? a : this.providers.get(a)
    },
    removeProvider: function(d) {
        var c = this,
            a = c.providers;
        d = d.isProvider ? d : a.get(d);
        if (d) {
            d.un("data", c.onProviderData, c);
            a.remove(d);
            return d
        }
        return null
    },
    addTransaction: function(a) {
        this.transactions.add(a);
        return a
    },
    removeTransaction: function(a) {
        a = this.getTransaction(a);
        this.transactions.remove(a);
        return a
    },
    getTransaction: function(a) {
        return Ext.isObject(a) ? a : this.transactions.get(a)
    },
    onProviderData: function(g, e) {
        var d = this,
            c = 0,
            a;
        if (Ext.isArray(e)) {
            for (a = e.length; c < a; ++c) {
                d.onProviderData(g, e[c])
            }
            return
        }
        if (e.name && e.name != "event" && e.name != "exception") {
            d.fireEvent(e.name, e)
        } else {
            if (e.status === false) {
                d.fireEvent("exception", e)
            }
        }
        d.fireEvent("event", e, g)
    },
    parseMethod: function(d) {
        if (Ext.isString(d)) {
            var g = d.split("."),
                c = 0,
                a = g.length,
                e = window;
            while (e && c < a) {
                e = e[g[c]];
                ++c
            }
            d = Ext.isFunction(e) ? e : null
        }
        return d || null
    }
}, function() {
    Ext.Direct = Ext.direct.Manager
});
Ext.define("Ext.data.Request", {
    action: undefined,
    params: undefined,
    method: "GET",
    url: undefined,
    constructor: function(a) {
        Ext.apply(this, a)
    }
});
Ext.define("Ext.data.association.BelongsTo", {
    extend: "Ext.data.association.Association",
    alternateClassName: "Ext.data.BelongsToAssociation",
    alias: "association.belongsto",
    constructor: function(d) {
        this.callParent(arguments);
        var g = this,
            a = g.ownerModel.prototype,
            i = g.associatedName,
            e = g.getterName || "get" + i,
            c = g.setterName || "set" + i;
        Ext.applyIf(g, {
            name: i,
            foreignKey: i.toLowerCase() + "_id",
            instanceName: i + "BelongsToInstance",
            associationKey: i.toLowerCase()
        });
        a[e] = g.createGetter();
        a[c] = g.createSetter()
    },
    createSetter: function() {
        var c = this,
            a = c.foreignKey;
        return function(g, d, e) {
            if (g && g.isModel) {
                g = g.getId()
            }
            this.set(a, g);
            if (Ext.isFunction(d)) {
                d = {
                    callback: d,
                    scope: e || this
                }
            }
            if (Ext.isObject(d)) {
                return this.save(d)
            }
        }
    },
    createGetter: function() {
        var e = this,
            g = e.associatedName,
            i = e.associatedModel,
            d = e.foreignKey,
            c = e.primaryKey,
            a = e.instanceName;
        return function(m, n) {
            m = m || {};
            var l = this,
                o = l.get(d),
                p, j, k;
            if (m.reload === true || l[a] === undefined) {
                j = Ext.ModelManager.create({}, g);
                j.set(c, o);
                if (typeof m == "function") {
                    m = {
                        callback: m,
                        scope: n || l
                    }
                }
                p = m.success;
                m.success = function(q) {
                    l[a] = q;
                    if (p) {
                        p.apply(this, arguments)
                    }
                };
                i.load(o, m);
                l[a] = j;
                return j
            } else {
                j = l[a];
                k = [j];
                n = n || m.scope || l;
                Ext.callback(m, n, k);
                Ext.callback(m.success, n, k);
                Ext.callback(m.failure, n, k);
                Ext.callback(m.callback, n, k);
                return j
            }
        }
    },
    read: function(c, a, d) {
        c[this.instanceName] = a.read([d]).records[0]
    }
});
Ext.define("Ext.util.Inflector", {
    singleton: true,
    plurals: [
        [(/(quiz)$/i), "$1zes"],
        [(/^(ox)$/i), "$1en"],
        [(/([m|l])ouse$/i), "$1ice"],
        [(/(matr|vert|ind)ix|ex$/i), "$1ices"],
        [(/(x|ch|ss|sh)$/i), "$1es"],
        [(/([^aeiouy]|qu)y$/i), "$1ies"],
        [(/(hive)$/i), "$1s"],
        [(/(?:([^f])fe|([lr])f)$/i), "$1$2ves"],
        [(/sis$/i), "ses"],
        [(/([ti])um$/i), "$1a"],
        [(/(buffal|tomat|potat)o$/i), "$1oes"],
        [(/(bu)s$/i), "$1ses"],
        [(/(alias|status|sex)$/i), "$1es"],
        [(/(octop|vir)us$/i), "$1i"],
        [(/(ax|test)is$/i), "$1es"],
        [(/^person$/), "people"],
        [(/^man$/), "men"],
        [(/^(child)$/), "$1ren"],
        [(/s$/i), "s"],
        [(/$/), "s"]
    ],
    singulars: [
        [(/(quiz)zes$/i), "$1"],
        [(/(matr)ices$/i), "$1ix"],
        [(/(vert|ind)ices$/i), "$1ex"],
        [(/^(ox)en/i), "$1"],
        [(/(alias|status)es$/i), "$1"],
        [(/(octop|vir)i$/i), "$1us"],
        [(/(cris|ax|test)es$/i), "$1is"],
        [(/(shoe)s$/i), "$1"],
        [(/(o)es$/i), "$1"],
        [(/(bus)es$/i), "$1"],
        [(/([m|l])ice$/i), "$1ouse"],
        [(/(x|ch|ss|sh)es$/i), "$1"],
        [(/(m)ovies$/i), "$1ovie"],
        [(/(s)eries$/i), "$1eries"],
        [(/([^aeiouy]|qu)ies$/i), "$1y"],
        [(/([lr])ves$/i), "$1f"],
        [(/(tive)s$/i), "$1"],
        [(/(hive)s$/i), "$1"],
        [(/([^f])ves$/i), "$1fe"],
        [(/(^analy)ses$/i), "$1sis"],
        [(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i), "$1$2sis"],
        [(/([ti])a$/i), "$1um"],
        [(/(n)ews$/i), "$1ews"],
        [(/people$/i), "person"],
        [(/s$/i), ""]
    ],
    uncountable: ["sheep", "fish", "series", "species", "money", "rice", "information", "equipment", "grass", "mud", "offspring", "deer", "means"],
    singular: function(c, a) {
        this.singulars.unshift([c, a])
    },
    plural: function(c, a) {
        this.plurals.unshift([c, a])
    },
    clearSingulars: function() {
        this.singulars = []
    },
    clearPlurals: function() {
        this.plurals = []
    },
    isTransnumeral: function(a) {
        return Ext.Array.indexOf(this.uncountable, a) != -1
    },
    pluralize: function(j) {
        if (this.isTransnumeral(j)) {
            return j
        }
        var g = this.plurals,
            e = g.length,
            a, d, c;
        for (c = 0; c < e; c++) {
            a = g[c];
            d = a[0];
            if (d == j || (d.test && d.test(j))) {
                return j.replace(d, a[1])
            }
        }
        return j
    },
    singularize: function(j) {
        if (this.isTransnumeral(j)) {
            return j
        }
        var g = this.singulars,
            e = g.length,
            a, d, c;
        for (c = 0; c < e; c++) {
            a = g[c];
            d = a[0];
            if (d == j || (d.test && d.test(j))) {
                return j.replace(d, a[1])
            }
        }
        return j
    },
    classify: function(a) {
        return Ext.String.capitalize(this.singularize(a))
    },
    ordinalize: function(e) {
        var c = parseInt(e, 10),
            d = c % 10,
            a = c % 100;
        if (11 <= a && a <= 13) {
            return e + "th"
        } else {
            switch (d) {
                case 1:
                    return e + "st";
                case 2:
                    return e + "nd";
                case 3:
                    return e + "rd";
                default:
                    return e + "th"
            }
        }
    }
}, function() {
    var c = {
            alumnus: "alumni",
            cactus: "cacti",
            focus: "foci",
            nucleus: "nuclei",
            radius: "radii",
            stimulus: "stimuli",
            ellipsis: "ellipses",
            paralysis: "paralyses",
            oasis: "oases",
            appendix: "appendices",
            index: "indexes",
            beau: "beaux",
            bureau: "bureaux",
            tableau: "tableaux",
            woman: "women",
            child: "children",
            man: "men",
            corpus: "corpora",
            criterion: "criteria",
            curriculum: "curricula",
            genus: "genera",
            memorandum: "memoranda",
            phenomenon: "phenomena",
            foot: "feet",
            goose: "geese",
            tooth: "teeth",
            antenna: "antennae",
            formula: "formulae",
            nebula: "nebulae",
            vertebra: "vertebrae",
            vita: "vitae"
        },
        a;
    for (a in c) {
        this.plural(a, c[a]);
        this.singular(c[a], a)
    }
});
Ext.define("Ext.data.association.HasMany", {
    extend: "Ext.data.association.Association",
    alternateClassName: "Ext.data.HasManyAssociation",
    requires: ["Ext.util.Inflector"],
    alias: "association.hasmany",
    constructor: function(d) {
        var e = this,
            a, c;
        e.callParent(arguments);
        e.name = e.name || Ext.util.Inflector.pluralize(e.associatedName.toLowerCase());
        a = e.ownerModel.prototype;
        c = e.name;
        Ext.applyIf(e, {
            storeName: c + "Store",
            foreignKey: e.ownerName.toLowerCase() + "_id"
        });
        a[c] = e.createStore()
    },
    createStore: function() {
        var j = this,
            k = j.associatedModel,
            d = j.storeName,
            e = j.foreignKey,
            a = j.primaryKey,
            i = j.filterProperty,
            c = j.autoLoad,
            g = j.storeConfig || {};
        return function() {
            var o = this,
                m, n, l = {};
            if (o[d] === undefined) {
                if (i) {
                    n = {
                        property: i,
                        value: o.get(i),
                        exactMatch: true
                    }
                } else {
                    n = {
                        property: e,
                        value: o.get(a),
                        exactMatch: true
                    }
                }
                l[e] = o.get(a);
                m = Ext.apply({}, g, {
                    model: k,
                    filters: [n],
                    remoteFilter: false,
                    modelDefaults: l
                });
                o[d] = Ext.data.AbstractStore.create(m);
                if (c) {
                    o[d].load()
                }
            }
            return o[d]
        }
    },
    read: function(e, c, l) {
        var j = e[this.name](),
            d, g, a, k;
        j.add(c.read(l).records);
        d = this.associatedModel.prototype.associations.findBy(function(i) {
            return i.type === "belongsTo" && i.associatedName === e.$className
        });
        if (d) {
            g = j.data.items;
            a = g.length;
            for (k = 0; k < a; k++) {
                g[k][d.instanceName] = e
            }
        }
    }
});
Ext.define("Ext.data.association.HasOne", {
    extend: "Ext.data.association.Association",
    alternateClassName: "Ext.data.HasOneAssociation",
    alias: "association.hasone",
    constructor: function(d) {
        this.callParent(arguments);
        var g = this,
            a = g.ownerModel.prototype,
            i = g.associatedName,
            e = g.getterName || "get" + i,
            c = g.setterName || "set" + i;
        Ext.applyIf(g, {
            name: i,
            foreignKey: i.toLowerCase() + "_id",
            instanceName: i + "HasOneInstance",
            associationKey: i.toLowerCase()
        });
        a[e] = g.createGetter();
        a[c] = g.createSetter()
    },
    createSetter: function() {
        var c = this,
            d = c.ownerModel,
            a = c.foreignKey;
        return function(i, e, g) {
            if (i && i.isModel) {
                i = i.getId()
            }
            this.set(a, i);
            if (Ext.isFunction(e)) {
                e = {
                    callback: e,
                    scope: g || this
                }
            }
            if (Ext.isObject(e)) {
                return this.save(e)
            }
        }
    },
    createGetter: function() {
        var e = this,
            i = e.ownerModel,
            g = e.associatedName,
            j = e.associatedModel,
            d = e.foreignKey,
            c = e.primaryKey,
            a = e.instanceName;
        return function(n, o) {
            n = n || {};
            var m = this,
                p = m.get(d),
                q, k, l;
            if (n.reload === true || m[a] === undefined) {
                k = Ext.ModelManager.create({}, g);
                k.set(c, p);
                if (typeof n == "function") {
                    n = {
                        callback: n,
                        scope: o || m
                    }
                }
                q = n.success;
                n.success = function(r) {
                    m[a] = r;
                    if (q) {
                        q.apply(this, arguments)
                    }
                };
                j.load(p, n);
                m[a] = k;
                return k
            } else {
                k = m[a];
                l = [k];
                o = o || n.scope || m;
                Ext.callback(n, o, l);
                Ext.callback(n.success, o, l);
                Ext.callback(n.failure, o, l);
                Ext.callback(n.callback, o, l);
                return k
            }
        }
    },
    read: function(d, a, g) {
        var c = this.associatedModel.prototype.associations.findBy(function(i) {
                return i.type === "belongsTo" && i.associatedName === d.$className
            }),
            e = a.read([g]).records[0];
        d[this.instanceName] = e;
        if (c) {
            e[c.instanceName] = d
        }
    }
});
Ext.define("Ext.util.Queue", {
    constructor: function() {
        this.clear()
    },
    add: function(d) {
        var c = this,
            a = c.getKey(d);
        if (!c.map[a]) {
            ++c.length;
            c.items.push(d);
            c.map[a] = d
        }
        return d
    },
    clear: function() {
        var c = this,
            a = c.items;
        c.items = [];
        c.map = {};
        c.length = 0;
        return a
    },
    contains: function(c) {
        var a = this.getKey(c);
        return this.map.hasOwnProperty(a)
    },
    getCount: function() {
        return this.length
    },
    getKey: function(a) {
        return a.id
    },
    remove: function(g) {
        var e = this,
            d = e.getKey(g),
            a = e.items,
            c;
        if (e.map[d]) {
            c = Ext.Array.indexOf(a, g);
            Ext.Array.erase(a, c, 1);
            delete e.map[d];
            --e.length
        }
        return g
    }
});
Ext.define("Ext.layout.ClassList", (function() {
    var c = Ext.String.splitWords,
        a = Ext.Array.toMap;
    return {
        dirty: false,
        constructor: function(d) {
            this.owner = d;
            this.map = a(this.classes = c(d.el.className))
        },
        add: function(d) {
            var e = this;
            if (!e.map[d]) {
                e.map[d] = true;
                e.classes.push(d);
                if (!e.dirty) {
                    e.dirty = true;
                    e.owner.markDirty()
                }
            }
        },
        addMany: function(d) {
            Ext.each(c(d), this.add, this)
        },
        contains: function(d) {
            return this.map[d]
        },
        flush: function() {
            this.owner.el.className = this.classes.join(" ");
            this.dirty = false
        },
        remove: function(d) {
            var e = this;
            if (e.map[d]) {
                delete e.map[d];
                e.classes = Ext.Array.filter(e.classes, function(g) {
                    return g != d
                });
                if (!e.dirty) {
                    e.dirty = true;
                    e.owner.markDirty()
                }
            }
        },
        removeMany: function(e) {
            var g = this,
                d = a(c(e));
            g.classes = Ext.Array.filter(g.classes, function(i) {
                if (!d[i]) {
                    return true
                }
                delete g.map[i];
                if (!g.dirty) {
                    g.dirty = true;
                    g.owner.markDirty()
                }
                return false
            })
        }
    }
}()));
Ext.define("Ext.layout.ContextItem", {
    requires: ["Ext.layout.ClassList"],
    heightModel: null,
    widthModel: null,
    sizeModel: null,
    boxChildren: null,
    boxParent: null,
    children: [],
    dirty: null,
    dirtyCount: 0,
    hasRawContent: true,
    isContextItem: true,
    isTopLevel: false,
    consumersContentHeight: 0,
    consumersContentWidth: 0,
    consumersContainerHeight: 0,
    consumersContainerWidth: 0,
    consumersHeight: 0,
    consumersWidth: 0,
    ownerCtContext: null,
    remainingChildLayouts: 0,
    remainingComponentChildLayouts: 0,
    remainingContainerChildLayouts: 0,
    props: null,
    state: null,
    wrapsComponent: false,
    constructor: function(c) {
        var i = this,
            g, e, a, d, j;
        Ext.apply(i, c);
        g = i.el;
        i.id = g.id;
        i.lastBox = g.lastBox;
        i.flushedProps = {};
        i.props = {};
        i.styles = {};
        j = i.target;
        if (j.isComponent) {
            i.wrapsComponent = true;
            e = j.ownerCt;
            if (e && (a = i.context.items[e.el.id])) {
                i.ownerCtContext = a
            }
            i.sizeModel = d = j.getSizeModel(a && a.widthModel.pairsByHeightOrdinal[a.heightModel.ordinal]);
            i.widthModel = d.width;
            i.heightModel = d.height
        }
    },
    init: function(l, d) {
        var u = this,
            a = u.props,
            e = u.dirty,
            o = u.ownerCtContext,
            r = u.target.ownerLayout,
            k = !u.state,
            v = l || k,
            g, q, p, s, c, x, y = u.heightModel,
            j = u.widthModel,
            m, t;
        u.dirty = u.invalid = false;
        u.props = {};
        if (u.boxChildren) {
            u.boxChildren.length = 0
        }
        if (!k) {
            u.clearAllBlocks("blocks");
            u.clearAllBlocks("domBlocks")
        }
        if (!u.wrapsComponent) {
            return v
        }
        x = u.target;
        u.state = {};
        if (k) {
            if (x.beforeLayout) {
                x.beforeLayout()
            }
            if (!o && (s = x.ownerCt)) {
                o = u.context.items[s.el.id]
            }
            if (o) {
                u.ownerCtContext = o;
                u.isBoxParent = x.ownerLayout.isItemBoxParent(u)
            } else {
                u.isTopLevel = true
            }
            u.frameBodyContext = u.getEl("frameBody")
        } else {
            o = u.ownerCtContext;
            u.isTopLevel = !o;
            g = u.children;
            for (q = 0, p = g.length; q < p; ++q) {
                g[q].init(true)
            }
        }
        u.hasRawContent = !(x.isContainer && x.items.items.length > 0);
        if (l) {
            u.widthModel = u.heightModel = null;
            c = x.getSizeModel(o && o.widthModel.pairsByHeightOrdinal[o.heightModel.ordinal]);
            if (k) {
                u.sizeModel = c
            }
            u.widthModel = c.width;
            u.heightModel = c.height
        } else {
            if (a) {
                u.recoverProp("x", a, e);
                u.recoverProp("y", a, e);
                if (u.widthModel.calculated) {
                    u.recoverProp("width", a, e)
                }
                if (u.heightModel.calculated) {
                    u.recoverProp("height", a, e)
                }
            }
        }
        if (a && r && r.manageMargins) {
            u.recoverProp("margin-top", a, e);
            u.recoverProp("margin-right", a, e);
            u.recoverProp("margin-bottom", a, e);
            u.recoverProp("margin-left", a, e)
        }
        if (d) {
            m = d.heightModel;
            t = d.widthModel;
            if (t && m && j && y) {
                if (j.shrinkWrap && y.shrinkWrap) {
                    if (t.constrainedMax && m.constrainedMin) {
                        m = null
                    }
                }
            }
            if (t) {
                u.widthModel = t
            }
            if (m) {
                u.heightModel = m
            }
            if (d.state) {
                Ext.apply(u.state, d.state)
            }
        }
        return v
    },
    initContinue: function(e) {
        var g = this,
            d = g.ownerCtContext,
            c = g.widthModel,
            a;
        if (e) {
            if (d && c.shrinkWrap) {
                a = d.isBoxParent ? d : d.boxParent;
                if (a) {
                    a.addBoxChild(g)
                }
            } else {
                if (c.natural) {
                    g.boxParent = d
                }
            }
        }
        return e
    },
    initDone: function(c, i, a, j) {
        var e = this,
            d = e.props,
            g = e.state;
        if (i) {
            d.componentChildrenDone = true
        }
        if (a) {
            d.containerChildrenDone = true
        }
        if (j) {
            d.containerLayoutDone = true
        }
        if (e.boxChildren && e.boxChildren.length && e.widthModel.shrinkWrap) {
            e.el.setWidth(10000);
            g.blocks = (g.blocks || 0) + 1
        }
    },
    initAnimation: function() {
        var c = this,
            d = c.target,
            a = c.ownerCtContext;
        if (a && a.isTopLevel) {
            c.animatePolicy = d.ownerLayout.getAnimatePolicy(c)
        } else {
            if (!a && d.isCollapsingOrExpanding && d.animCollapse) {
                c.animatePolicy = d.componentLayout.getAnimatePolicy(c)
            }
        }
        if (c.animatePolicy) {
            c.context.queueAnimation(c)
        }
    },
    noFraming: {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: 0,
        height: 0
    },
    addCls: function(a) {
        this.getClassList().addMany(a)
    },
    removeCls: function(a) {
        this.getClassList().removeMany(a)
    },
    addBlock: function(c, e, g) {
        var d = this,
            i = d[c] || (d[c] = {}),
            a = i[g] || (i[g] = {});
        if (!a[e.id]) {
            a[e.id] = e;
            ++e.blockCount;
            ++d.context.blockCount
        }
    },
    addBoxChild: function(e) {
        var d = this,
            c, a = e.widthModel;
        e.boxParent = this;
        e.measuresBox = a.shrinkWrap ? e.hasRawContent : a.natural;
        if (e.measuresBox) {
            c = d.boxChildren;
            if (c) {
                c.push(e)
            } else {
                d.boxChildren = [e]
            }
        }
    },
    addTrigger: function(i, j) {
        var g = this,
            a = j ? "domTriggers" : "triggers",
            k = g[a] || (g[a] = {}),
            c = g.context,
            e = c.currentLayout,
            d = k[i] || (k[i] = {});
        if (!d[e.id]) {
            d[e.id] = e;
            ++e.triggerCount;
            d = c.triggers[j ? "dom" : "data"];
            (d[e.id] || (d[e.id] = [])).push({
                item: this,
                prop: i
            });
            if (g.props[i] !== undefined) {
                if (!j || !(g.dirty && (i in g.dirty))) {
                    ++e.firedTriggers
                }
            }
        }
    },
    boxChildMeasured: function() {
        var c = this,
            d = c.state,
            a = (d.boxesMeasured = (d.boxesMeasured || 0) + 1);
        if (a == c.boxChildren.length) {
            d.clearBoxWidth = 1;
            ++c.context.progressCount;
            c.markDirty()
        }
    },
    borderNames: ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"],
    marginNames: ["margin-top", "margin-right", "margin-bottom", "margin-left"],
    paddingNames: ["padding-top", "padding-right", "padding-bottom", "padding-left"],
    trblNames: ["top", "right", "bottom", "left"],
    cacheMissHandlers: {
        borderInfo: function(a) {
            var c = a.getStyles(a.borderNames, a.trblNames);
            c.width = c.left + c.right;
            c.height = c.top + c.bottom;
            return c
        },
        marginInfo: function(a) {
            var c = a.getStyles(a.marginNames, a.trblNames);
            c.width = c.left + c.right;
            c.height = c.top + c.bottom;
            return c
        },
        paddingInfo: function(c) {
            var a = c.frameBodyContext || c,
                d = a.getStyles(c.paddingNames, c.trblNames);
            d.width = d.left + d.right;
            d.height = d.top + d.bottom;
            return d
        }
    },
    checkCache: function(a) {
        return this.cacheMissHandlers[a](this)
    },
    clearAllBlocks: function(a) {
        var d = this[a],
            c;
        if (d) {
            for (c in d) {
                this.clearBlocks(a, c)
            }
        }
    },
    clearBlocks: function(d, i) {
        var j = this[d],
            c = j && j[i],
            e, g, a;
        if (c) {
            delete j[i];
            e = this.context;
            for (a in c) {
                g = c[a];
                --e.blockCount;
                if (!--g.blockCount && !g.pending && !g.done) {
                    e.queueLayout(g)
                }
            }
        }
    },
    block: function(a, c) {
        this.addBlock("blocks", a, c)
    },
    domBlock: function(a, c) {
        this.addBlock("domBlocks", a, c)
    },
    fireTriggers: function(c, i) {
        var j = this[c],
            e = j && j[i],
            d = this.context,
            g, a;
        if (e) {
            for (a in e) {
                g = e[a];
                ++g.firedTriggers;
                if (!g.done && !g.blockCount && !g.pending) {
                    d.queueLayout(g)
                }
            }
        }
    },
    flush: function() {
        var c = this,
            a = c.dirty,
            d = c.state,
            e = c.el;
        c.dirtyCount = 0;
        if (c.classList && c.classList.dirty) {
            c.classList.flush()
        }
        if ("attributes" in c) {
            e.set(c.attributes);
            delete c.attributes
        }
        if ("innerHTML" in c) {
            e.innerHTML = c.innerHTML;
            delete c.innerHTML
        }
        if (d && d.clearBoxWidth) {
            d.clearBoxWidth = 0;
            c.el.setStyle("width", null);
            if (!--d.blocks) {
                c.context.queueItemLayouts(c)
            }
        }
        if (a) {
            delete c.dirty;
            c.writeProps(a, true)
        }
    },
    flushAnimations: function() {
        var q = this,
            d = q.lastBox,
            n, p, g, k, i, e, l, o, m, a, c;
        if (d) {
            n = q.target;
            p = n.layout && n.layout.animate;
            if (p) {
                g = Ext.isNumber(p) ? p : p.duration
            }
            k = Ext.Object.getKeys(q.animatePolicy);
            i = Ext.apply({}, {
                from: {},
                to: {},
                duration: g || Ext.fx.Anim.prototype.duration
            }, p);
            for (e = 0, l = 0, o = k.length; l < o; l++) {
                m = k[l];
                a = d[m];
                c = q.peek(m);
                if (a != c) {
                    m = q.translateProps[m] || m;
                    i.from[m] = a;
                    i.to[m] = c;
                    ++e
                }
            }
            if (e) {
                if (q.isCollapsingOrExpanding === 1) {
                    n.componentLayout.undoLayout(q)
                } else {
                    q.writeProps(i.from)
                }
                q.el.animate(i);
                Ext.fx.Manager.getFxQueue(q.el.id)[0].on({
                    afteranimate: function() {
                        if (q.isCollapsingOrExpanding === 1) {
                            n.componentLayout.redoLayout(q);
                            n.afterCollapse(true)
                        } else {
                            if (q.isCollapsingOrExpanding === 2) {
                                n.afterExpand(true)
                            }
                        }
                    }
                })
            }
        }
    },
    getBorderInfo: function() {
        var a = this,
            c = a.borderInfo;
        if (!c) {
            a.borderInfo = c = a.checkCache("borderInfo")
        }
        return c
    },
    getClassList: function() {
        return this.classList || (this.classList = new Ext.layout.ClassList(this))
    },
    getEl: function(d, a) {
        var g = this,
            i, e, c;
        if (d) {
            if (d.dom) {
                e = d
            } else {
                i = g.target;
                if (a) {
                    i = a
                }
                e = i[d];
                if (typeof e == "function") {
                    e = e.call(i);
                    if (e === g.el) {
                        return this
                    }
                }
            }
            if (e) {
                c = g.context.getEl(g, e)
            }
        }
        return c || null
    },
    getFraming: function() {
        var a = this;
        if (!a.framingInfo) {
            a.framingInfo = a.target.frameSize || a.noFraming
        }
        return a.framingInfo
    },
    getFrameInfo: function() {
        var c = this,
            d = c.frameInfo,
            e, a;
        if (!d) {
            e = c.getFraming();
            a = c.getBorderInfo();
            c.frameInfo = d = {
                top: e.top + a.top,
                right: e.right + a.right,
                bottom: e.bottom + a.bottom,
                left: e.left + a.left,
                width: e.width + a.width,
                height: e.height + a.height
            }
        }
        return d
    },
    getMarginInfo: function() {
        var e = this,
            j = e.marginInfo,
            c, a, i, g, d;
        if (!j) {
            if (!e.wrapsComponent) {
                j = e.checkCache("marginInfo")
            } else {
                c = e.target;
                g = c.ownerLayout;
                d = g ? g.id : null;
                a = g && g.manageMargins;
                j = c.margin$;
                if (j && j.ownerId !== d) {
                    j = null
                }
                if (!j) {
                    j = e.parseMargins(c.margin) || e.checkCache("marginInfo");
                    if (a) {
                        i = e.parseMargins(c.margins, g.defaultMargins);
                        if (i) {
                            j = {
                                top: j.top + i.top,
                                right: j.right + i.right,
                                bottom: j.bottom + i.bottom,
                                left: j.left + i.left
                            }
                        }
                        e.setProp("margin-top", 0);
                        e.setProp("margin-right", 0);
                        e.setProp("margin-bottom", 0);
                        e.setProp("margin-left", 0)
                    }
                    j.ownerId = d;
                    c.margin$ = j
                }
                j.width = j.left + j.right;
                j.height = j.top + j.bottom
            }
            e.marginInfo = j
        }
        return j
    },
    clearMarginCache: function() {
        delete this.marginInfo;
        delete this.target.margin$
    },
    getPaddingInfo: function() {
        var a = this,
            c = a.paddingInfo;
        if (!c) {
            a.paddingInfo = c = a.checkCache("paddingInfo")
        }
        return c
    },
    getProp: function(d) {
        var c = this,
            a = c.props[d];
        c.addTrigger(d);
        return a
    },
    getDomProp: function(d) {
        var c = this,
            a = (c.dirty && (d in c.dirty)) ? undefined : c.props[d];
        c.addTrigger(d, true);
        return a
    },
    getStyle: function(a) {
        var d = this,
            c = d.styles,
            g, e;
        if (a in c) {
            e = c[a]
        } else {
            g = d.styleInfo[a];
            e = d.el.getStyle(a);
            if (g && g.parseInt) {
                e = parseInt(e, 10) || 0
            }
            c[a] = e
        }
        return e
    },
    getStyles: function(r, c) {
        var p = this,
            g = p.styles,
            s = {},
            j = 0,
            e = r.length,
            m, l, o, a, d, k, t, q;
        c = c || r;
        for (m = 0; m < e; ++m) {
            a = r[m];
            if (a in g) {
                s[c[m]] = g[a];
                ++j;
                if (m && j == 1) {
                    l = r.slice(0, m);
                    o = c.slice(0, m)
                }
            } else {
                if (j) {
                    (l || (l = [])).push(a);
                    (o || (o = [])).push(c[m])
                }
            }
        }
        if (j < e) {
            l = l || r;
            o = o || c;
            k = p.styleInfo;
            t = p.el.getStyle(l);
            for (m = l.length; m--;) {
                a = l[m];
                d = k[a];
                q = t[a];
                if (d && d.parseInt) {
                    q = parseInt(q, 10) || 0
                }
                s[o[m]] = q;
                g[a] = q
            }
        }
        return s
    },
    hasProp: function(c) {
        var a = this.getProp(c);
        return typeof a != "undefined"
    },
    hasDomProp: function(c) {
        var a = this.getDomProp(c);
        return typeof a != "undefined"
    },
    invalidate: function(a) {
        this.context.queueInvalidate(this, a)
    },
    markDirty: function() {
        if (++this.dirtyCount == 1) {
            this.context.queueFlush(this)
        }
    },
    onBoxMeasured: function() {
        var a = this.boxParent,
            c = this.state;
        if (a && a.widthModel.shrinkWrap && !c.boxMeasured && this.measuresBox) {
            c.boxMeasured = 1;
            a.boxChildMeasured()
        }
    },
    parseMargins: function(e, d) {
        if (e === true) {
            e = 5
        }
        var c = typeof e,
            a;
        if (c == "string" || c == "number") {
            a = Ext.util.Format.parseBox(e)
        } else {
            if (e || d) {
                a = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                };
                if (d) {
                    Ext.apply(a, this.parseMargins(d))
                }
                Ext.apply(a, e)
            }
        }
        return a
    },
    peek: function(a) {
        return this.props[a]
    },
    recoverProp: function(i, c, a) {
        var g = this,
            e = g.props,
            d;
        if (i in c) {
            e[i] = c[i];
            if (a && i in a) {
                d = g.dirty || (g.dirty = {});
                d[i] = a[i]
            }
        }
    },
    redo: function(c) {
        var g = this,
            d, a, e;
        g.revertProps(g.props);
        if (c && g.wrapsComponent) {
            if (g.childItems) {
                for (e = 0, d = g.childItems, a = d.length; e < a; e++) {
                    d[e].redo(c)
                }
            }
            for (e = 0, d = g.children, a = d.length; e < a; e++) {
                d[e].redo()
            }
        }
    },
    revertProps: function(e) {
        var a, c = this.flushedProps,
            d = {};
        for (a in e) {
            if (c.hasOwnProperty(a)) {
                d[a] = e[a]
            }
        }
        this.writeProps(d)
    },
    setAttribute: function(a, d) {
        var c = this;
        if (!c.attributes) {
            c.attributes = {}
        }
        c.attributes[a] = d;
        c.markDirty()
    },
    setBox: function(c) {
        var a = this;
        if ("left" in c) {
            a.setProp("x", c.left)
        }
        if ("top" in c) {
            a.setProp("y", c.top)
        }
        a.setSize(c.width, c.height)
    },
    setContentHeight: function(a, c) {
        if (!c && this.hasRawContent) {
            return 1
        }
        return this.setProp("contentHeight", a)
    },
    setContentWidth: function(c, a) {
        if (!a && this.hasRawContent) {
            return 1
        }
        return this.setProp("contentWidth", c)
    },
    setContentSize: function(d, a, c) {
        return this.setContentWidth(d, c) + this.setContentHeight(a, c) == 2
    },
    setProp: function(e, d, a) {
        var c = this,
            j = typeof d,
            i, g;
        if (j == "undefined" || (j === "number" && isNaN(d))) {
            return 0
        }
        if (c.props[e] === d) {
            return 1
        }
        c.props[e] = d;
        ++c.context.progressCount;
        if (a === false) {
            c.fireTriggers("domTriggers", e);
            c.clearBlocks("domBlocks", e)
        } else {
            g = c.styleInfo[e];
            if (g) {
                if (!c.dirty) {
                    c.dirty = {}
                }
                if (e == "width" || e == "height") {
                    i = c.isBorderBoxValue;
                    if (i == null) {
                        c.isBorderBoxValue = i = !!c.el.isBorderBox()
                    }
                    if (!i) {
                        c.borderInfo || c.getBorderInfo();
                        c.paddingInfo || c.getPaddingInfo()
                    }
                }
                c.dirty[e] = d;
                c.markDirty()
            }
        }
        c.fireTriggers("triggers", e);
        c.clearBlocks("blocks", e);
        return 1
    },
    setHeight: function(a, d) {
        var g = this,
            c = g.target,
            j, e, i;
        if (a < 0) {
            a = 0
        }
        if (!g.wrapsComponent) {
            if (!g.setProp("height", a, d)) {
                return NaN
            }
        } else {
            a = Ext.Number.constrain(a, c.minHeight || 0, c.maxHeight);
            if (!g.setProp("height", a, d)) {
                return NaN
            }
            j = g.frameBodyContext;
            if (j) {
                e = g.getFrameInfo();
                j.setHeight(a - e.height, d)
            }
        }
        return a
    },
    setWidth: function(d, c) {
        var g = this,
            a = g.target,
            j, e, i;
        if (d < 0) {
            d = 0
        }
        if (!g.wrapsComponent) {
            if (!g.setProp("width", d, c)) {
                return NaN
            }
        } else {
            d = Ext.Number.constrain(d, a.minWidth || 0, a.maxWidth);
            if (!g.setProp("width", d, c)) {
                return NaN
            }
            j = g.frameBodyContext;
            if (j) {
                e = g.getFrameInfo();
                j.setWidth(d - e.width, c)
            }
        }
        return d
    },
    setSize: function(d, a, c) {
        this.setWidth(d, c);
        this.setHeight(a, c)
    },
    translateProps: {
        x: "left",
        y: "top"
    },
    undo: function(c) {
        var g = this,
            d, a, e;
        g.revertProps(g.lastBox);
        if (c && g.wrapsComponent) {
            if (g.childItems) {
                for (e = 0, d = g.childItems, a = d.length; e < a; e++) {
                    d[e].undo(c)
                }
            }
            for (e = 0, d = g.children, a = d.length; e < a; e++) {
                d[e].undo()
            }
        }
    },
    unsetProp: function(c) {
        var a = this.dirty;
        delete this.props[c];
        if (a) {
            delete a[c]
        }
    },
    writeProps: function(g, e) {
        if (!(g && typeof g == "object")) {
            return
        }
        var F = this,
            d = F.el,
            k = {},
            j = 0,
            c = F.styleInfo,
            E, p, t, o = "x" in g,
            n = "y" in g,
            m = g.x,
            l = g.y,
            v = g.width,
            r = g.height,
            D = F.isBorderBoxValue,
            G = F.target,
            A = Math.max,
            C = 0,
            q = 0,
            i, a, u, z, B, s;
        if ("displayed" in g) {
            d.setDisplayed(g.displayed)
        }
        for (p in g) {
            if (e) {
                F.fireTriggers("domTriggers", p);
                F.clearBlocks("domBlocks", p);
                F.flushedProps[p] = 1
            }
            E = c[p];
            if (E && E.dom) {
                if (E.suffix && (t = parseInt(g[p], 10))) {
                    k[p] = t + E.suffix
                } else {
                    k[p] = g[p]
                }++j
            }
        }
        if (o || n) {
            if (G.isComponent) {
                G.setPosition(m || F.props.x, l || F.props.y)
            } else {
                if (o) {
                    k.left = m + "px";
                    ++j
                }
                if (n) {
                    k.top = l + "px";
                    ++j
                }
            }
        }
        if (!D && (v > 0 || r > 0)) {
            if (!F.frameBodyContext) {
                C = F.paddingInfo.width;
                q = F.paddingInfo.height
            }
            if (v) {
                v = A(parseInt(v, 10) - (F.borderInfo.width + C), 0);
                k.width = v + "px";
                ++j
            }
            if (r) {
                r = A(parseInt(r, 10) - (F.borderInfo.height + q), 0);
                k.height = r + "px";
                ++j
            }
        }
        if (F.wrapsComponent && Ext.isIE9 && Ext.isStrict) {
            if ((i = v !== undefined && F.hasOverflowY) || (a = r !== undefined && F.hasOverflowX)) {
                u = F.isAbsolute;
                if (u === undefined) {
                    u = false;
                    s = F.target.getTargetEl();
                    B = s.getStyle("position");
                    if (B == "absolute") {
                        B = s.getStyle("box-sizing");
                        u = (B == "border-box")
                    }
                    F.isAbsolute = u
                }
                if (u) {
                    z = Ext.getScrollbarSize();
                    if (i) {
                        v = parseInt(v, 10) + z.width;
                        k.width = v + "px";
                        ++j
                    }
                    if (a) {
                        r = parseInt(r, 10) + z.height;
                        k.height = r + "px";
                        ++j
                    }
                }
            }
        }
        if (j) {
            d.setStyle(k)
        }
    }
}, function() {
    var d = {
            dom: true,
            parseInt: true,
            suffix: "px"
        },
        c = {
            dom: true
        },
        a = {
            dom: false
        };
    this.prototype.styleInfo = {
        childrenDone: a,
        componentChildrenDone: a,
        containerChildrenDone: a,
        containerLayoutDone: a,
        displayed: a,
        done: a,
        x: a,
        y: a,
        columnWidthsDone: a,
        left: d,
        top: d,
        right: d,
        bottom: d,
        width: d,
        height: d,
        "border-top-width": d,
        "border-right-width": d,
        "border-bottom-width": d,
        "border-left-width": d,
        "margin-top": d,
        "margin-right": d,
        "margin-bottom": d,
        "margin-left": d,
        "padding-top": d,
        "padding-right": d,
        "padding-bottom": d,
        "padding-left": d,
        "line-height": c,
        display: c
    }
});
Ext.define("Ext.layout.Context", {
    requires: ["Ext.util.Queue", "Ext.layout.ContextItem", "Ext.layout.Layout", "Ext.fx.Anim", "Ext.fx.Manager"],
    remainingLayouts: 0,
    state: 0,
    constructor: function(a) {
        var c = this;
        Ext.apply(c, a);
        c.items = {};
        c.layouts = {};
        c.blockCount = 0;
        c.cycleCount = 0;
        c.flushCount = 0;
        c.calcCount = 0;
        c.animateQueue = c.newQueue();
        c.completionQueue = c.newQueue();
        c.finalizeQueue = c.newQueue();
        c.finishQueue = c.newQueue();
        c.flushQueue = c.newQueue();
        c.invalidateData = {};
        c.layoutQueue = c.newQueue();
        c.invalidQueue = [];
        c.triggers = {
            data: {},
            dom: {}
        }
    },
    callLayout: function(c, a) {
        this.currentLayout = c;
        c[a](this.getCmp(c.owner))
    },
    cancelComponent: function(m, a, o) {
        var r = this,
            l = m,
            n = !m.isComponent,
            c = n ? l.length : 1,
            e, d, q, p, j, u, s, t, v, g;
        for (e = 0; e < c; ++e) {
            if (n) {
                m = l[e]
            }
            if (o && m.ownerCt) {
                g = this.items[m.ownerCt.el.id];
                if (g) {
                    Ext.Array.remove(g.childItems, r.getCmp(m))
                }
            }
            if (!a) {
                s = r.invalidQueue;
                q = s.length;
                if (q) {
                    r.invalidQueue = u = [];
                    for (d = 0; d < q; ++d) {
                        t = s[d];
                        v = t.item.target;
                        if (v != m && !v.isDescendant(m)) {
                            u.push(t)
                        }
                    }
                }
            }
            j = m.componentLayout;
            r.cancelLayout(j);
            if (j.getLayoutItems) {
                p = j.getLayoutItems();
                if (p.length) {
                    r.cancelComponent(p, true)
                }
            }
            if (m.isContainer && !m.collapsed) {
                j = m.layout;
                r.cancelLayout(j);
                p = j.getVisibleItems();
                if (p.length) {
                    r.cancelComponent(p, true)
                }
            }
        }
    },
    cancelLayout: function(c) {
        var a = this;
        a.completionQueue.remove(c);
        a.finalizeQueue.remove(c);
        a.finishQueue.remove(c);
        a.layoutQueue.remove(c);
        if (c.running) {
            a.layoutDone(c)
        }
        c.ownerContext = null
    },
    clearTriggers: function(j, k) {
        var a = j.id,
            g = this.triggers[k ? "dom" : "data"],
            l = g && g[a],
            c = (l && l.length) || 0,
            g, e, m, d;
        for (e = 0; e < c; ++e) {
            d = l[e];
            m = d.item;
            g = k ? m.domTriggers : m.triggers;
            delete g[d.prop][a]
        }
    },
    flush: function() {
        var e = this,
            a = e.flushQueue.clear(),
            d = a.length,
            c;
        if (d) {
            ++e.flushCount;
            for (c = 0; c < d; ++c) {
                a[c].flush()
            }
        }
    },
    flushAnimations: function() {
        var e = this,
            c = e.animateQueue.clear(),
            a = c.length,
            d;
        if (a) {
            for (d = 0; d < a; d++) {
                if (c[d].target.animate !== false) {
                    c[d].flushAnimations()
                }
            }
            Ext.fx.Manager.runner()
        }
    },
    flushInvalidates: function() {
        var k = this,
            a = k.invalidQueue,
            j = a && a.length,
            c, g, e, d;
        k.invalidQueue = [];
        if (j) {
            g = [];
            for (d = 0; d < j; ++d) {
                c = (e = a[d]).item.target;
                if (!c.container.isDetachedBody) {
                    g.push(c);
                    if (e.options) {
                        k.invalidateData[c.id] = e.options
                    }
                }
            }
            k.invalidate(g, null)
        }
    },
    flushLayouts: function(k, a, d) {
        var j = this,
            l = d ? j[k].items : j[k].clear(),
            g = l.length,
            c, e;
        if (g) {
            for (c = 0; c < g; ++c) {
                e = l[c];
                if (!e.running) {
                    j.callLayout(e, a)
                }
            }
            j.currentLayout = null
        }
    },
    getCmp: function(a) {
        return this.getItem(a, a.el)
    },
    getEl: function(c, a) {
        var d = this.getItem(a, a);
        if (!d.parent) {
            d.parent = c;
            if (c.children.length) {
                c.children.push(d)
            } else {
                c.children = [d]
            }
        }
        return d
    },
    getItem: function(e, c) {
        var g = c.id,
            a = this.items,
            d = a[g] || (a[g] = new Ext.layout.ContextItem({
                context: this,
                target: e,
                el: c
            }));
        return d
    },
    handleFailure: function() {
        var d = this.layouts,
            c, a;
        Ext.failedLayouts = (Ext.failedLayouts || 0) + 1;
        for (a in d) {
            c = d[a];
            if (d.hasOwnProperty(a)) {
                c.running = false;
                c.ownerContext = null
            }
        }
    },
    invalidate: function(p, r) {
        var t = this,
            q = !p.isComponent,
            g, j, d, a, l, o, u, s, c, m, n, k, e;
        for (l = 0, c = q ? p.length : 1; l < c; ++l) {
            o = q ? p[l] : p;
            if (o.rendered && !o.hidden) {
                u = t.getCmp(o);
                m = o.componentLayout;
                a = !m.ownerContext;
                n = (o.isContainer && !o.collapsed) ? o.layout : null;
                k = t.invalidateData[u.id];
                delete t.invalidateData[u.id];
                e = u.init(r, k);
                if (k) {
                    t.processInvalidate(k, u, "before")
                }
                if (m.beforeLayoutCycle) {
                    m.beforeLayoutCycle(u)
                }
                e = u.initContinue(e);
                g = j = d = true;
                if (m.getLayoutItems) {
                    m.renderChildren();
                    s = m.getLayoutItems();
                    if (s.length) {
                        t.invalidate(s, true);
                        g = false
                    }
                }
                if (n) {
                    d = false;
                    n.renderChildren();
                    s = n.getVisibleItems();
                    if (s.length) {
                        t.invalidate(s, true);
                        j = false
                    }
                }
                u.initDone(e, g, j, d);
                t.resetLayout(m, u, a);
                if (n) {
                    t.resetLayout(n, u, a)
                }
                u.initAnimation();
                if (k) {
                    t.processInvalidate(k, u, "after")
                }
            }
        }
        t.currentLayout = null
    },
    layoutDone: function(c) {
        var d = c.ownerContext,
            a;
        c.running = false;
        if (c.isComponentLayout) {
            if (d.measuresBox) {
                d.onBoxMeasured()
            }
            d.setProp("done", true);
            a = d.ownerCtContext;
            if (a) {
                if (d.target.ownerLayout.isComponentLayout) {
                    if (!--a.remainingComponentChildLayouts) {
                        a.setProp("componentChildrenDone", true)
                    }
                } else {
                    if (!--a.remainingContainerChildLayouts) {
                        a.setProp("containerChildrenDone", true)
                    }
                }
                if (!--a.remainingChildLayouts) {
                    a.setProp("childrenDone", true)
                }
            }
        } else {
            d.setProp("containerLayoutDone", true)
        }--this.remainingLayouts;
        ++this.progressCount
    },
    newQueue: function() {
        return new Ext.util.Queue()
    },
    processInvalidate: function(c, g, a) {
        if (c[a]) {
            var e = this,
                d = e.currentLayout;
            e.currentLayout = c.layout || null;
            c[a](g, c);
            e.currentLayout = d
        }
    },
    queueAnimation: function(a) {
        this.animateQueue.add(a)
    },
    queueCompletion: function(a) {
        this.completionQueue.add(a)
    },
    queueFinalize: function(a) {
        this.finalizeQueue.add(a)
    },
    queueFlush: function(a) {
        this.flushQueue.add(a)
    },
    chainFns: function(a, k, i) {
        var e = this,
            d = a.layout,
            g = k.layout,
            c = a[i],
            j = k[i];
        return function(l) {
            var m = e.currentLayout;
            if (c) {
                e.currentLayout = d;
                c.call(a.scope || a, l, a)
            }
            e.currentLayout = g;
            j.call(k.scope || k, l, k);
            e.currentLayout = m
        }
    },
    queueInvalidate: function(m, n) {
        var j = this,
            l = [],
            k = j.invalidQueue,
            i = k.length,
            e, c, g, a, d;
        if (m.isComponent) {
            m = j.getCmp(e = m)
        } else {
            e = m.target
        }
        m.invalid = true;
        while (i--) {
            c = k[i];
            g = c.item.target;
            if (e.isDescendant(g)) {
                return
            }
            if (g == e) {
                if (!(a = c.options)) {
                    c.options = n
                } else {
                    if (n) {
                        if (n.widthModel) {
                            a.widthModel = n.widthModel
                        }
                        if (n.heightModel) {
                            a.heightModel = n.heightModel
                        }
                        if (!(d = a.state)) {
                            a.state = n.state
                        } else {
                            if (n.state) {
                                Ext.apply(d, n.state)
                            }
                        }
                        if (n.before) {
                            a.before = j.chainFns(a, n, "before")
                        }
                        if (n.after) {
                            a.after = j.chainFns(a, n, "after")
                        }
                    }
                }
                return
            }
            if (!g.isDescendant(e)) {
                l.push(c)
            }
        }
        l.push({
            item: m,
            options: n
        });
        j.invalidQueue = l
    },
    queueItemLayouts: function(d) {
        var a = d.isComponent ? d : d.target,
            c = a.componentLayout;
        if (!c.pending && !c.invalid && !c.done) {
            this.queueLayout(c)
        }
        c = a.layout;
        if (c && !c.pending && !c.invalid && !c.done) {
            this.queueLayout(c)
        }
    },
    queueLayout: function(a) {
        this.layoutQueue.add(a);
        a.pending = true
    },
    resetLayout: function(d, e, g) {
        var c = this,
            a;
        c.currentLayout = d;
        d.done = false;
        d.pending = true;
        d.firedTriggers = 0;
        c.layoutQueue.add(d);
        if (g) {
            c.layouts[d.id] = d;
            d.running = true;
            if (d.finishedLayout) {
                c.finishQueue.add(d)
            }++c.remainingLayouts;
            ++d.layoutCount;
            d.ownerContext = e;
            d.beginCount = 0;
            d.blockCount = 0;
            d.calcCount = 0;
            d.triggerCount = 0;
            if (d.isComponentLayout && (a = e.ownerCtContext)) {
                if (e.target.ownerLayout.isComponentLayout) {
                    ++a.remainingComponentChildLayouts
                } else {
                    ++a.remainingContainerChildLayouts
                }++a.remainingChildLayouts
            }
            if (!d.initialized) {
                d.initLayout()
            }
            d.beginLayout(e)
        } else {
            ++d.beginCount;
            if (!d.running) {
                ++c.remainingLayouts;
                d.running = true;
                if (d.isComponentLayout) {
                    e.unsetProp("done");
                    a = e.ownerCtContext;
                    if (a) {
                        if (e.target.ownerLayout.isComponentLayout) {
                            if (++a.remainingComponentChildLayouts == 1) {
                                a.unsetProp("componentChildrenDone")
                            }
                        } else {
                            if (++a.remainingContainerChildLayouts == 1) {
                                a.unsetProp("containerChildrenDone")
                            }
                        }
                        if (++a.remainingChildLayouts == 1) {
                            a.unsetProp("childrenDone")
                        }
                    }
                }
                c.completionQueue.remove(d);
                c.finalizeQueue.remove(d)
            }
        }
        d.beginLayoutCycle(e, g)
    },
    run: function() {
        var d = this,
            c = false,
            a = 100;
        d.flushInvalidates();
        d.state = 1;
        d.totalCount = d.layoutQueue.getCount();
        d.flush();
        while ((d.remainingLayouts || d.invalidQueue.length) && a--) {
            if (d.invalidQueue.length) {
                d.flushInvalidates()
            }
            if (d.runCycle()) {
                c = false
            } else {
                if (!c) {
                    d.flush();
                    c = true;
                    d.flushLayouts("completionQueue", "completeLayout")
                } else {
                    d.state = 2;
                    break
                }
            }
            if (!(d.remainingLayouts || d.invalidQueue.length)) {
                d.flush();
                d.flushLayouts("completionQueue", "completeLayout");
                d.flushLayouts("finalizeQueue", "finalizeLayout")
            }
        }
        return d.runComplete()
    },
    runComplete: function() {
        var a = this;
        a.state = 2;
        if (a.remainingLayouts) {
            a.handleFailure();
            return false
        }
        a.flush();
        a.flushLayouts("finishQueue", "finishedLayout", true);
        a.flushLayouts("finishQueue", "notifyOwner");
        a.flush();
        a.flushAnimations();
        return true
    },
    runCycle: function() {
        var d = this,
            e = d.layoutQueue.clear(),
            c = e.length,
            a;
        ++d.cycleCount;
        d.progressCount = 0;
        for (a = 0; a < c; ++a) {
            d.runLayout(d.currentLayout = e[a])
        }
        d.currentLayout = null;
        return d.progressCount > 0
    },
    runLayout: function(c) {
        var a = this,
            d = a.getCmp(c.owner);
        c.pending = false;
        if (d.state.blocks) {
            return
        }
        c.done = true;
        ++c.calcCount;
        ++a.calcCount;
        c.calculate(d);
        if (c.done) {
            a.layoutDone(c);
            if (c.completeLayout) {
                a.queueCompletion(c)
            }
            if (c.finalizeLayout) {
                a.queueFinalize(c)
            }
        } else {
            if (!c.pending && !c.invalid && !(c.blockCount + c.triggerCount - c.firedTriggers)) {
                a.queueLayout(c)
            }
        }
    },
    setItemSize: function(k, j, c) {
        var e = k,
            a = 1,
            d, g;
        if (k.isComposite) {
            e = k.elements;
            a = e.length;
            k = e[0]
        } else {
            if (!k.dom && !k.el) {
                a = e.length;
                k = e[0]
            }
        }
        for (g = 0; g < a;) {
            d = this.get(k);
            d.setSize(j, c);
            k = e[++g]
        }
    }
});
Ext.define("Ext.draw.Matrix", {
    requires: ["Ext.draw.Draw"],
    constructor: function(i, g, m, l, k, j) {
        if (i != null) {
            this.matrix = [
                [i, m, k],
                [g, l, j],
                [0, 0, 1]
            ]
        } else {
            this.matrix = [
                [1, 0, 0],
                [0, 1, 0],
                [0, 0, 1]
            ]
        }
    },
    add: function(t, q, n, l, j, i) {
        var o = this,
            g = [
                [],
                [],
                []
            ],
            s = [
                [t, n, j],
                [q, l, i],
                [0, 0, 1]
            ],
            r, p, m, k;
        for (r = 0; r < 3; r++) {
            for (p = 0; p < 3; p++) {
                k = 0;
                for (m = 0; m < 3; m++) {
                    k += o.matrix[r][m] * s[m][p]
                }
                g[r][p] = k
            }
        }
        o.matrix = g
    },
    prepend: function(t, q, n, l, j, i) {
        var o = this,
            g = [
                [],
                [],
                []
            ],
            s = [
                [t, n, j],
                [q, l, i],
                [0, 0, 1]
            ],
            r, p, m, k;
        for (r = 0; r < 3; r++) {
            for (p = 0; p < 3; p++) {
                k = 0;
                for (m = 0; m < 3; m++) {
                    k += s[r][m] * o.matrix[m][p]
                }
                g[r][p] = k
            }
        }
        o.matrix = g
    },
    invert: function() {
        var k = this.matrix,
            j = k[0][0],
            i = k[1][0],
            o = k[0][1],
            n = k[1][1],
            m = k[0][2],
            l = k[1][2],
            g = j * n - i * o;
        return new Ext.draw.Matrix(n / g, -i / g, -o / g, j / g, (o * l - n * m) / g, (i * m - j * l) / g)
    },
    clone: function() {
        var j = this.matrix,
            i = j[0][0],
            g = j[1][0],
            n = j[0][1],
            m = j[1][1],
            l = j[0][2],
            k = j[1][2];
        return new Ext.draw.Matrix(i, g, n, m, l, k)
    },
    translate: function(a, c) {
        this.prepend(1, 0, 0, 1, a, c)
    },
    scale: function(c, g, a, e) {
        var d = this;
        if (g == null) {
            g = c
        }
        d.add(c, 0, 0, g, a * (1 - c), e * (1 - g))
    },
    rotate: function(d, c, j) {
        d = Ext.draw.Draw.rad(d);
        var g = this,
            i = +Math.cos(d).toFixed(9),
            e = +Math.sin(d).toFixed(9);
        g.add(i, e, -e, i, c - i * c + e * j, -(e * c) + j - i * j)
    },
    x: function(a, d) {
        var c = this.matrix;
        return a * c[0][0] + d * c[0][1] + c[0][2]
    },
    y: function(a, d) {
        var c = this.matrix;
        return a * c[1][0] + d * c[1][1] + c[1][2]
    },
    get: function(c, a) {
        return +this.matrix[c][a].toFixed(4)
    },
    toString: function() {
        var a = this;
        return [a.get(0, 0), a.get(0, 1), a.get(1, 0), a.get(1, 1), 0, 0].join()
    },
    toSvg: function() {
        var a = this;
        return "matrix(" + [a.get(0, 0), a.get(1, 0), a.get(0, 1), a.get(1, 1), a.get(0, 2), a.get(1, 2)].join() + ")"
    },
    toFilter: function(c, a) {
        var d = this;
        c = c || 0;
        a = a || 0;
        return "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', filterType='bilinear', M11=" + d.get(0, 0) + ", M12=" + d.get(0, 1) + ", M21=" + d.get(1, 0) + ", M22=" + d.get(1, 1) + ", Dx=" + (d.get(0, 2) + c) + ", Dy=" + (d.get(1, 2) + a) + ")"
    },
    offset: function() {
        var a = this.matrix;
        return [(a[0][2] || 0).toFixed(4), (a[1][2] || 0).toFixed(4)]
    },
    split: function() {
        function e(i) {
            return i[0] * i[0] + i[1] * i[1]
        }

        function c(i) {
            var j = Math.sqrt(e(i));
            i[0] /= j;
            i[1] /= j
        }
        var a = this.matrix,
            d = {
                translateX: a[0][2],
                translateY: a[1][2]
            },
            g;
        g = [
            [a[0][0], a[0][1]],
            [a[1][1], a[1][1]]
        ];
        d.scaleX = Math.sqrt(e(g[0]));
        c(g[0]);
        d.shear = g[0][0] * g[1][0] + g[0][1] * g[1][1];
        g[1] = [g[1][0] - g[0][0] * d.shear, g[1][1] - g[0][1] * d.shear];
        d.scaleY = Math.sqrt(e(g[1]));
        c(g[1]);
        d.shear /= d.scaleY;
        d.rotate = Math.asin(-g[0][1]);
        d.isSimple = !+d.shear.toFixed(9) && (d.scaleX.toFixed(9) == d.scaleY.toFixed(9) || !d.rotate);
        return d
    }
});
Ext.define("Ext.draw.SpriteDD", {
    extend: "Ext.dd.DragSource",
    constructor: function(c, a) {
        var e = this,
            d = c.el;
        e.sprite = c;
        e.el = d;
        e.dragData = {
            el: d,
            sprite: c
        };
        e.callParent([d, a]);
        e.sprite.setStyle("cursor", "move")
    },
    showFrame: Ext.emptyFn,
    createFrame: Ext.emptyFn,
    getDragEl: function(a) {
        return this.el
    },
    getRegion: function() {
        var k = this,
            g = k.el,
            n, d, c, p, o, u, a, m, i, s, q;
        q = k.sprite;
        s = q.getBBox();
        try {
            n = Ext.Element.getXY(g)
        } catch (j) {}
        if (!n) {
            return null
        }
        d = n[0];
        c = d + s.width;
        p = n[1];
        o = p + s.height;
        return new Ext.util.Region(p, c, o, d)
    },
    startDrag: function(c, e) {
        var d = this,
            a = d.sprite.attr;
        d.prev = d.sprite.surface.transformToViewBox(c, e)
    },
    onDrag: function(k) {
        var j = k.getXY(),
            i = this,
            g = i.sprite,
            a = g.attr,
            d, c;
        j = i.sprite.surface.transformToViewBox(j[0], j[1]);
        d = j[0] - i.prev[0];
        c = j[1] - i.prev[1];
        g.setAttributes({
            translate: {
                x: a.translation.x + d,
                y: a.translation.y + c
            }
        }, true);
        i.prev = j
    },
    setDragElPos: function() {
        return false
    }
});
Ext.define("Ext.draw.Sprite", {
    mixins: {
        observable: "Ext.util.Observable",
        animate: "Ext.util.Animate"
    },
    requires: ["Ext.draw.SpriteDD"],
    dirty: false,
    dirtyHidden: false,
    dirtyTransform: false,
    dirtyPath: true,
    dirtyFont: true,
    zIndexDirty: true,
    isSprite: true,
    zIndex: 0,
    fontProperties: ["font", "font-size", "font-weight", "font-style", "font-family", "text-anchor", "text"],
    pathProperties: ["x", "y", "d", "path", "height", "width", "radius", "r", "rx", "ry", "cx", "cy"],
    constructor: function(a) {
        var c = this;
        a = Ext.merge({}, a || {});
        c.id = Ext.id(null, "ext-sprite-");
        c.transformations = [];
        Ext.copyTo(this, a, "surface,group,type,draggable");
        c.bbox = {};
        c.attr = {
            zIndex: 0,
            translation: {
                x: null,
                y: null
            },
            rotation: {
                degrees: null,
                x: null,
                y: null
            },
            scaling: {
                x: null,
                y: null,
                cx: null,
                cy: null
            }
        };
        delete a.surface;
        delete a.group;
        delete a.type;
        delete a.draggable;
        c.setAttributes(a);
        c.addEvents("beforedestroy", "destroy", "render", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "click");
        c.mixins.observable.constructor.apply(this, arguments)
    },
    initDraggable: function() {
        var a = this;
        a.draggable = true;
        if (!a.el) {
            a.surface.createSpriteElement(a)
        }
        a.dd = new Ext.draw.SpriteDD(a, Ext.isBoolean(a.draggable) ? null : a.draggable);
        a.on("beforedestroy", a.dd.destroy, a.dd)
    },
    setAttributes: function(n, q) {
        var v = this,
            l = v.fontProperties,
            s = l.length,
            k = v.pathProperties,
            j = k.length,
            t = !!v.surface,
            a = t && v.surface.customAttributes || {},
            d = v.attr,
            c = false,
            o, r, m, e, u, p, x, g;
        n = Ext.apply({}, n);
        for (o in a) {
            if (n.hasOwnProperty(o) && typeof a[o] == "function") {
                Ext.apply(n, a[o].apply(v, [].concat(n[o])))
            }
        }
        if (!!n.hidden !== !!d.hidden) {
            v.dirtyHidden = true
        }
        for (r = 0; r < j; r++) {
            o = k[r];
            if (o in n && n[o] !== d[o]) {
                v.dirtyPath = true;
                c = true;
                break
            }
        }
        if ("zIndex" in n) {
            v.zIndexDirty = true
        }
        if ("text" in n) {
            v.dirtyFont = true;
            c = true
        }
        for (r = 0; r < s; r++) {
            o = l[r];
            if (o in n && n[o] !== d[o]) {
                v.dirtyFont = true;
                c = true;
                break
            }
        }
        m = n.translation || n.translate;
        delete n.translate;
        delete n.translation;
        e = d.translation;
        if (m) {
            if (("x" in m && m.x !== e.x) || ("y" in m && m.y !== e.y)) {
                v.dirtyTransform = true;
                e.x = m.x;
                e.y = m.y
            }
        }
        u = n.rotation || n.rotate;
        p = d.rotation;
        delete n.rotate;
        delete n.rotation;
        if (u) {
            if (("x" in u && u.x !== p.x) || ("y" in u && u.y !== p.y) || ("degrees" in u && u.degrees !== p.degrees)) {
                v.dirtyTransform = true;
                p.x = u.x;
                p.y = u.y;
                p.degrees = u.degrees
            }
        }
        x = n.scaling || n.scale;
        g = d.scaling;
        delete n.scale;
        delete n.scaling;
        if (x) {
            if (("x" in x && x.x !== g.x) || ("y" in x && x.y !== g.y) || ("cx" in x && x.cx !== g.cx) || ("cy" in x && x.cy !== g.cy)) {
                v.dirtyTransform = true;
                g.x = x.x;
                g.y = x.y;
                g.cx = x.cx;
                g.cy = x.cy
            }
        }
        if (!v.dirtyTransform && c) {
            if (d.scaling.x === null || d.scaling.y === null || d.rotation.y === null || d.rotation.y === null) {
                v.dirtyTransform = true
            }
        }
        Ext.apply(d, n);
        v.dirty = true;
        if (q === true && t) {
            v.redraw()
        }
        return this
    },
    getBBox: function() {
        return this.surface.getBBox(this)
    },
    setText: function(a) {
        return this.surface.setText(this, a)
    },
    hide: function(a) {
        this.setAttributes({
            hidden: true
        }, a);
        return this
    },
    show: function(a) {
        this.setAttributes({
            hidden: false
        }, a);
        return this
    },
    remove: function() {
        if (this.surface) {
            this.surface.remove(this);
            return true
        }
        return false
    },
    onRemove: function() {
        this.surface.onRemove(this)
    },
    destroy: function() {
        var a = this;
        if (a.fireEvent("beforedestroy", a) !== false) {
            a.remove();
            a.surface.onDestroy(a);
            a.clearListeners();
            a.fireEvent("destroy")
        }
    },
    redraw: function() {
        this.surface.renderItem(this);
        return this
    },
    setStyle: function() {
        this.el.setStyle.apply(this.el, arguments);
        return this
    },
    addCls: function(a) {
        this.surface.addCls(this, a);
        return this
    },
    removeCls: function(a) {
        this.surface.removeCls(this, a);
        return this
    }
});
Ext.define("Ext.draw.engine.ImageExporter", {
    singleton: true,
    defaultUrl: "http://svg.sencha.io",
    supportedTypes: ["image/png", "image/jpeg"],
    widthParam: "width",
    heightParam: "height",
    typeParam: "type",
    svgParam: "svg",
    formCls: Ext.baseCSSPrefix + "hide-display",
    generate: function(a, c) {
        c = c || {};
        var g = this,
            d = c.type,
            e;
        if (Ext.Array.indexOf(g.supportedTypes, d) === -1) {
            return false
        }
        e = Ext.getBody().createChild({
            tag: "form",
            method: "POST",
            action: c.url || g.defaultUrl,
            cls: g.formCls,
            children: [{
                tag: "input",
                type: "hidden",
                name: c.widthParam || g.widthParam,
                value: c.width || a.width
            }, {
                tag: "input",
                type: "hidden",
                name: c.heightParam || g.heightParam,
                value: c.height || a.height
            }, {
                tag: "input",
                type: "hidden",
                name: c.typeParam || g.typeParam,
                value: d
            }, {
                tag: "input",
                type: "hidden",
                name: c.svgParam || g.svgParam
            }]
        });
        e.last(null, true).value = Ext.draw.engine.SvgExporter.generate(a);
        e.dom.submit();
        e.remove();
        return true
    }
});
Ext.define("Ext.draw.engine.Svg", {
    extend: "Ext.draw.Surface",
    requires: ["Ext.draw.Draw", "Ext.draw.Sprite", "Ext.draw.Matrix", "Ext.Element"],
    engine: "Svg",
    trimRe: /^\s+|\s+$/g,
    spacesRe: /\s+/,
    xlink: "http://www.w3.org/1999/xlink",
    translateAttrs: {
        radius: "r",
        radiusX: "rx",
        radiusY: "ry",
        path: "d",
        lineWidth: "stroke-width",
        fillOpacity: "fill-opacity",
        strokeOpacity: "stroke-opacity",
        strokeLinejoin: "stroke-linejoin"
    },
    parsers: {},
    minDefaults: {
        circle: {
            cx: 0,
            cy: 0,
            r: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        ellipse: {
            cx: 0,
            cy: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        rect: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        text: {
            x: 0,
            y: 0,
            "text-anchor": "start",
            "font-family": null,
            "font-size": null,
            "font-weight": null,
            "font-style": null,
            fill: "#000",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        path: {
            d: "M0,0",
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        image: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            preserveAspectRatio: "none",
            opacity: null
        }
    },
    createSvgElement: function(e, a) {
        var d = this.domRef.createElementNS("http://www.w3.org/2000/svg", e),
            c;
        if (a) {
            for (c in a) {
                d.setAttribute(c, String(a[c]))
            }
        }
        return d
    },
    createSpriteElement: function(a) {
        var c = this.createSvgElement(a.type);
        c.id = a.id;
        if (c.style) {
            c.style.webkitTapHighlightColor = "rgba(0,0,0,0)"
        }
        a.el = Ext.get(c);
        this.applyZIndex(a);
        a.matrix = new Ext.draw.Matrix();
        a.bbox = {
            plain: 0,
            transform: 0
        };
        this.applyAttrs(a);
        this.applyTransformations(a);
        a.fireEvent("render", a);
        return c
    },
    getBBoxText: function(l) {
        var m = {},
            j, n, a, d, k, c;
        if (l && l.el) {
            c = l.el.dom;
            try {
                m = c.getBBox();
                return m
            } catch (g) {}
            m = {
                x: m.x,
                y: Infinity,
                width: 0,
                height: 0
            };
            k = c.getNumberOfChars();
            for (d = 0; d < k; d++) {
                j = c.getExtentOfChar(d);
                m.y = Math.min(j.y, m.y);
                n = j.y + j.height - m.y;
                m.height = Math.max(m.height, n);
                a = j.x + j.width - m.x;
                m.width = Math.max(m.width, a)
            }
            return m
        }
    },
    hide: function() {
        Ext.get(this.el).hide()
    },
    show: function() {
        Ext.get(this.el).show()
    },
    hidePrim: function(a) {
        this.addCls(a, Ext.baseCSSPrefix + "hide-visibility")
    },
    showPrim: function(a) {
        this.removeCls(a, Ext.baseCSSPrefix + "hide-visibility")
    },
    getDefs: function() {
        return this._defs || (this._defs = this.createSvgElement("defs"))
    },
    transform: function(m, a) {
        var k = this,
            l = new Ext.draw.Matrix(),
            g = m.transformations,
            e = g.length,
            d = 0,
            c, j;
        for (; d < e; d++) {
            c = g[d];
            j = c.type;
            if (j == "translate") {
                l.translate(c.x, c.y)
            } else {
                if (j == "rotate") {
                    l.rotate(c.degrees, c.x, c.y)
                } else {
                    if (j == "scale") {
                        l.scale(c.x, c.y, c.centerX, c.centerY)
                    }
                }
            }
        }
        m.matrix = l;
        if (!a) {
            m.el.set({
                transform: l.toSvg()
            })
        }
    },
    setSize: function(d, a) {
        var e = this,
            c = e.el;
        d = +d || e.width;
        a = +a || e.height;
        e.width = d;
        e.height = a;
        c.setSize(d, a);
        c.set({
            width: d,
            height: a
        });
        e.callParent([d, a])
    },
    getRegion: function() {
        var g = this.el.getXY(),
            d = this.bgRect.getXY(),
            c = Math.max,
            a = c(g[0], d[0]),
            e = c(g[1], d[1]);
        return {
            left: a,
            top: e,
            right: a + this.width,
            bottom: e + this.height
        }
    },
    onRemove: function(a) {
        if (a.el) {
            a.el.destroy();
            delete a.el
        }
        this.callParent(arguments)
    },
    setViewBox: function(c, e, d, a) {
        if (isFinite(c) && isFinite(e) && isFinite(d) && isFinite(a)) {
            this.callParent(arguments);
            this.el.dom.setAttribute("viewBox", [c, e, d, a].join(" "))
        }
    },
    render: function(d) {
        var i = this,
            g, c, e, a, j, k;
        if (!i.el) {
            g = i.width || 0;
            c = i.height || 0;
            e = i.createSvgElement("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                version: 1.1,
                width: g,
                height: c
            });
            a = i.getDefs();
            j = i.createSvgElement("rect", {
                width: "100%",
                height: "100%",
                fill: "#000",
                stroke: "none",
                opacity: 0
            });
            if (Ext.isSafari3) {
                k = i.createSvgElement("rect", {
                    x: -10,
                    y: -10,
                    width: "110%",
                    height: "110%",
                    fill: "none",
                    stroke: "#000"
                })
            }
            e.appendChild(a);
            if (Ext.isSafari3) {
                e.appendChild(k)
            }
            e.appendChild(j);
            d.appendChild(e);
            i.el = Ext.get(e);
            i.bgRect = Ext.get(j);
            if (Ext.isSafari3) {
                i.webkitRect = Ext.get(k);
                i.webkitRect.hide()
            }
            i.el.on({
                scope: i,
                mouseup: i.onMouseUp,
                mousedown: i.onMouseDown,
                mouseover: i.onMouseOver,
                mouseout: i.onMouseOut,
                mousemove: i.onMouseMove,
                mouseenter: i.onMouseEnter,
                mouseleave: i.onMouseLeave,
                click: i.onClick,
                dblclick: i.onDblClick
            })
        }
        i.renderAll()
    },
    onMouseEnter: function(a) {
        if (this.el.parent().getRegion().contains(a.getPoint())) {
            this.fireEvent("mouseenter", a)
        }
    },
    onMouseLeave: function(a) {
        if (!this.el.parent().getRegion().contains(a.getPoint())) {
            this.fireEvent("mouseleave", a)
        }
    },
    processEvent: function(c, i) {
        var g = i.getTarget(),
            a = this.surface,
            d;
        this.fireEvent(c, i);
        if (g.nodeName == "tspan" && g.parentNode) {
            g = g.parentNode
        }
        d = this.items.get(g.id);
        if (d) {
            d.fireEvent(c, d, i)
        }
    },
    tuneText: function(m, n) {
        var a = m.el.dom,
            c = [],
            p, k, o, e, g, d, j, l;
        if (n.hasOwnProperty("text")) {
            o = m.tspans && Ext.Array.map(m.tspans, function(i) {
                return i.textContent
            }).join("");
            if (!m.tspans || n.text != o) {
                c = this.setText(m, n.text);
                m.tspans = c
            } else {
                c = m.tspans || []
            }
        }
        if (c.length) {
            p = this.getBBoxText(m).height;
            l = m.el.dom.getAttribute("x");
            for (e = 0, g = c.length; e < g; e++) {
                j = (Ext.isFF3_0 || Ext.isFF3_5) ? 2 : 4;
                c[e].setAttribute("x", l);
                c[e].setAttribute("dy", e ? p * 1.2 : p / j)
            }
            m.dirty = true
        }
    },
    setText: function(m, e) {
        var k = this,
            a = m.el.dom,
            c = [],
            o, l, n, g, j, d;
        while (a.firstChild) {
            a.removeChild(a.firstChild)
        }
        d = String(e).split("\n");
        for (g = 0, j = d.length; g < j; g++) {
            n = d[g];
            if (n) {
                l = k.createSvgElement("tspan");
                l.appendChild(document.createTextNode(Ext.htmlDecode(n)));
                a.appendChild(l);
                c[g] = l
            }
        }
        return c
    },
    renderAll: function() {
        this.items.each(this.renderItem, this)
    },
    renderItem: function(a) {
        if (!this.el) {
            return
        }
        if (!a.el) {
            this.createSpriteElement(a)
        }
        if (a.zIndexDirty) {
            this.applyZIndex(a)
        }
        if (a.dirty) {
            this.applyAttrs(a);
            if (a.dirtyTransform) {
                this.applyTransformations(a)
            }
        }
    },
    redraw: function(a) {
        a.dirty = a.zIndexDirty = true;
        this.renderItem(a)
    },
    applyAttrs: function(t) {
        var o = this,
            d = t.el,
            s = t.group,
            l = t.attr,
            u = o.parsers,
            j = o.gradientsMap || {},
            m = Ext.isSafari && !Ext.isStrict,
            g, k, n, r, e, q, c, a, p;
        if (s) {
            g = [].concat(s);
            n = g.length;
            for (k = 0; k < n; k++) {
                s = g[k];
                o.getGroup(s).add(t)
            }
            delete t.group
        }
        r = o.scrubAttrs(t) || {};
        t.bbox.plain = 0;
        t.bbox.transform = 0;
        if (t.type == "circle" || t.type == "ellipse") {
            r.cx = r.cx || r.x;
            r.cy = r.cy || r.y
        } else {
            if (t.type == "rect") {
                r.rx = r.ry = r.r
            } else {
                if (t.type == "path" && r.d) {
                    r.d = Ext.draw.Draw.pathToString(Ext.draw.Draw.pathToAbsolute(r.d))
                }
            }
        }
        t.dirtyPath = false;
        if (r["clip-rect"]) {
            o.setClip(t, r);
            delete r["clip-rect"]
        }
        if (t.type == "text" && r.font && t.dirtyFont) {
            d.set({
                style: "font: " + r.font
            })
        }
        if (t.type == "image") {
            d.dom.setAttributeNS(o.xlink, "href", r.src)
        }
        Ext.applyIf(r, o.minDefaults[t.type]);
        if (t.dirtyHidden) {
            (l.hidden) ? o.hidePrim(t): o.showPrim(t);
            t.dirtyHidden = false
        }
        for (q in r) {
            if (r.hasOwnProperty(q) && r[q] != null) {
                if (m && ("color|stroke|fill".indexOf(q) > -1) && (r[q] in j)) {
                    r[q] = j[r[q]]
                }
                if (q == "hidden" && t.type == "text") {
                    continue
                }
                if (q in u) {
                    d.dom.setAttribute(q, u[q](r[q], t, o))
                } else {
                    d.dom.setAttribute(q, r[q])
                }
            }
        }
        if (t.type == "text") {
            o.tuneText(t, r)
        }
        t.dirtyFont = false;
        c = l.style;
        if (c) {
            d.setStyle(c)
        }
        t.dirty = false;
        if (Ext.isSafari3) {
            o.webkitRect.show();
            setTimeout(function() {
                o.webkitRect.hide()
            })
        }
    },
    setClip: function(c, i) {
        var g = this,
            e = i["clip-rect"],
            a, d;
        if (e) {
            if (c.clip) {
                c.clip.parentNode.parentNode.removeChild(c.clip.parentNode)
            }
            a = g.createSvgElement("clipPath");
            d = g.createSvgElement("rect");
            a.id = Ext.id(null, "ext-clip-");
            d.setAttribute("x", e.x);
            d.setAttribute("y", e.y);
            d.setAttribute("width", e.width);
            d.setAttribute("height", e.height);
            a.appendChild(d);
            g.getDefs().appendChild(a);
            c.el.dom.setAttribute("clip-path", "url(#" + a.id + ")");
            c.clip = d
        }
    },
    applyZIndex: function(e) {
        var i = this,
            c = i.items,
            a = c.indexOf(e),
            g = e.el,
            d;
        if (i.el.dom.childNodes[a + 2] !== g.dom) {
            if (a > 0) {
                do {
                    d = c.getAt(--a).el
                } while (!d && a > 0)
            }
            g.insertAfter(d || i.bgRect)
        }
        e.zIndexDirty = false
    },
    createItem: function(a) {
        var c = new Ext.draw.Sprite(a);
        c.surface = this;
        return c
    },
    addGradient: function(k) {
        k = Ext.draw.Draw.parseGradient(k);
        var g = this,
            e = k.stops.length,
            a = k.vector,
            n = Ext.isSafari && !Ext.isStrict,
            l, j, m, d, c;
        c = g.gradientsMap || {};
        if (!n) {
            if (k.type == "linear") {
                l = g.createSvgElement("linearGradient");
                l.setAttribute("x1", a[0]);
                l.setAttribute("y1", a[1]);
                l.setAttribute("x2", a[2]);
                l.setAttribute("y2", a[3])
            } else {
                l = g.createSvgElement("radialGradient");
                l.setAttribute("cx", k.centerX);
                l.setAttribute("cy", k.centerY);
                l.setAttribute("r", k.radius);
                if (Ext.isNumber(k.focalX) && Ext.isNumber(k.focalY)) {
                    l.setAttribute("fx", k.focalX);
                    l.setAttribute("fy", k.focalY)
                }
            }
            l.id = k.id;
            g.getDefs().appendChild(l);
            for (d = 0; d < e; d++) {
                j = k.stops[d];
                m = g.createSvgElement("stop");
                m.setAttribute("offset", j.offset + "%");
                m.setAttribute("stop-color", j.color);
                m.setAttribute("stop-opacity", j.opacity);
                l.appendChild(m)
            }
        } else {
            c["url(#" + k.id + ")"] = k.stops[0].color
        }
        g.gradientsMap = c
    },
    hasCls: function(a, c) {
        return c && (" " + (a.el.dom.getAttribute("class") || "") + " ").indexOf(" " + c + " ") != -1
    },
    addCls: function(g, k) {
        var j = g.el,
            e, a, d, c = [],
            l = j.getAttribute("class") || "";
        if (!Ext.isArray(k)) {
            if (typeof k == "string" && !this.hasCls(g, k)) {
                j.set({
                    "class": l + " " + k
                })
            }
        } else {
            for (e = 0, a = k.length; e < a; e++) {
                d = k[e];
                if (typeof d == "string" && (" " + l + " ").indexOf(" " + d + " ") == -1) {
                    c.push(d)
                }
            }
            if (c.length) {
                j.set({
                    "class": " " + c.join(" ")
                })
            }
        }
    },
    removeCls: function(m, j) {
        var k = this,
            c = m.el,
            e = c.getAttribute("class") || "",
            d, l, g, n, a;
        if (!Ext.isArray(j)) {
            j = [j]
        }
        if (e) {
            a = e.replace(k.trimRe, " ").split(k.spacesRe);
            for (d = 0, g = j.length; d < g; d++) {
                n = j[d];
                if (typeof n == "string") {
                    n = n.replace(k.trimRe, "");
                    l = Ext.Array.indexOf(a, n);
                    if (l != -1) {
                        Ext.Array.erase(a, l, 1)
                    }
                }
            }
            c.set({
                "class": a.join(" ")
            })
        }
    },
    destroy: function() {
        var a = this;
        a.callParent();
        if (a.el) {
            a.el.remove()
        }
        if (a._defs) {
            Ext.get(a._defs).destroy()
        }
        if (a.bgRect) {
            Ext.get(a.bgRect).destroy()
        }
        if (a.webkitRect) {
            Ext.get(a.webkitRect).destroy()
        }
        delete a.el
    }
});
Ext.define("Ext.draw.engine.SvgExporter", function() {
    var c = /,/g,
        d = /(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)\s('*.*'*)/,
        l = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/g,
        j = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,([\d\.]+)\)/g,
        i, k, g, o, p = function(q) {
            i = q;
            k = i.length;
            g = i.width;
            o = i.height
        },
        m = {
            path: function(t) {
                var q = t.attr,
                    x = q.path,
                    s = "",
                    u, v, r;
                if (Ext.isArray(x[0])) {
                    r = x.length;
                    for (v = 0; v < r; v++) {
                        s += x[v].join(" ")
                    }
                } else {
                    if (Ext.isArray(x)) {
                        s = x.join(" ")
                    } else {
                        s = x.replace(c, " ")
                    }
                }
                u = e({
                    d: s,
                    fill: q.fill || "none",
                    stroke: q.stroke,
                    "fill-opacity": q.opacity,
                    "stroke-width": q["stroke-width"],
                    "stroke-opacity": q["stroke-opacity"],
                    "z-index": q.zIndex,
                    transform: t.matrix.toSvg()
                });
                return "<path " + u + "/>"
            },
            text: function(x) {
                var t = x.attr,
                    s = d.exec(t.font),
                    z = (s && s[1]) || "12",
                    r = (s && s[3]) || "Arial",
                    y = t.text,
                    v = (Ext.isFF3_0 || Ext.isFF3_5) ? 2 : 4,
                    q = "",
                    u;
                x.getBBox();
                q += '<tspan x="' + (t.x || "") + '" dy="';
                q += (z / v) + '">';
                q += Ext.htmlEncode(y) + "</tspan>";
                u = e({
                    x: t.x,
                    y: t.y,
                    "font-size": z,
                    "font-family": r,
                    "font-weight": t["font-weight"],
                    "text-anchor": t["text-anchor"],
                    fill: t.fill || "#000",
                    "fill-opacity": t.opacity,
                    transform: x.matrix.toSvg()
                });
                return "<text " + u + ">" + q + "</text>"
            },
            rect: function(r) {
                var q = r.attr,
                    s = e({
                        x: q.x,
                        y: q.y,
                        rx: q.rx,
                        ry: q.ry,
                        width: q.width,
                        height: q.height,
                        fill: q.fill || "none",
                        "fill-opacity": q.opacity,
                        stroke: q.stroke,
                        "stroke-opacity": q["stroke-opacity"],
                        "stroke-width": q["stroke-width"],
                        transform: r.matrix && r.matrix.toSvg()
                    });
                return "<rect " + s + "/>"
            },
            circle: function(r) {
                var q = r.attr,
                    s = e({
                        cx: q.x,
                        cy: q.y,
                        r: q.radius,
                        fill: q.translation.fill || q.fill || "none",
                        "fill-opacity": q.opacity,
                        stroke: q.stroke,
                        "stroke-opacity": q["stroke-opacity"],
                        "stroke-width": q["stroke-width"],
                        transform: r.matrix.toSvg()
                    });
                return "<circle " + s + " />"
            },
            image: function(r) {
                var q = r.attr,
                    s = e({
                        x: q.x - (q.width / 2 >> 0),
                        y: q.y - (q.height / 2 >> 0),
                        width: q.width,
                        height: q.height,
                        "xlink:href": q.src,
                        transform: r.matrix.toSvg()
                    });
                return "<image " + s + " />"
            }
        },
        a = function() {
            var q = '<?xml version="1.0" standalone="yes"?>';
            q += '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';
            return q
        },
        n = function() {
            var z = '<svg width="' + g + 'px" height="' + o + 'px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">',
                r = "",
                K, I, y, s, J, M, C, A, v, B, E, q, N, x, H, F, L, G, u, t;
            y = i.items.items;
            I = y.length;
            J = function(R) {
                var Y = R.childNodes,
                    V = Y.length,
                    U = 0,
                    S, T, O = "",
                    P, X, Q, W;
                for (; U < V; U++) {
                    P = Y[U];
                    X = P.attributes;
                    Q = P.tagName;
                    O += "<" + Q;
                    for (T = 0, S = X.length; T < S; T++) {
                        W = X.item(T);
                        O += " " + W.name + '="' + W.value + '"'
                    }
                    O += ">";
                    if (P.childNodes.length > 0) {
                        O += J(P)
                    }
                    O += "</" + Q + ">"
                }
                return O
            };
            if (i.getDefs) {
                r = J(i.getDefs())
            } else {
                A = i.gradientsColl;
                if (A) {
                    v = A.keys;
                    B = A.items;
                    E = 0;
                    q = v.length
                }
                for (; E < q; E++) {
                    N = v[E];
                    x = B[E];
                    s = i.gradientsColl.getByKey(N);
                    r += '<linearGradient id="' + N + '" x1="0" y1="0" x2="1" y2="1">';
                    var D = s.colors.replace(l, "rgb($1|$2|$3)");
                    D = D.replace(j, "rgba($1|$2|$3|$4)");
                    M = D.split(",");
                    for (H = 0, L = M.length; H < L; H++) {
                        C = M[H].split(" ");
                        D = Ext.draw.Color.fromString(C[1].replace(/\|/g, ","));
                        r += '<stop offset="' + C[0] + '" stop-color="' + D.toString() + '" stop-opacity="1"></stop>'
                    }
                    r += "</linearGradient>"
                }
            }
            z += "<defs>" + r + "</defs>";
            z += m.rect({
                attr: {
                    width: "100%",
                    height: "100%",
                    fill: "#fff",
                    stroke: "none",
                    opacity: "0"
                }
            });
            G = new Array(I);
            for (H = 0; H < I; H++) {
                G[H] = H
            }
            G.sort(function(P, O) {
                u = y[P].attr.zIndex || 0;
                t = y[O].attr.zIndex || 0;
                if (u == t) {
                    return P - O
                }
                return u - t
            });
            for (H = 0; H < I; H++) {
                K = y[G[H]];
                if (!K.attr.hidden) {
                    z += m[K.type](K)
                }
            }
            z += "</svg>";
            return z
        },
        e = function(s) {
            var r = "",
                q;
            for (q in s) {
                if (s.hasOwnProperty(q) && s[q] != null) {
                    r += q + '="' + s[q] + '" '
                }
            }
            return r
        };
    return {
        singleton: true,
        generate: function(q, r) {
            r = r || {};
            p(q);
            return a() + n()
        }
    }
});
Ext.define("Ext.draw.engine.Vml", {
    extend: "Ext.draw.Surface",
    requires: ["Ext.draw.Draw", "Ext.draw.Color", "Ext.draw.Sprite", "Ext.draw.Matrix", "Ext.Element"],
    engine: "Vml",
    map: {
        M: "m",
        L: "l",
        C: "c",
        Z: "x",
        m: "t",
        l: "r",
        c: "v",
        z: "x"
    },
    bitesRe: /([clmz]),?([^clmz]*)/gi,
    valRe: /-?[^,\s\-]+/g,
    fillUrlRe: /^url\(\s*['"]?([^\)]+?)['"]?\s*\)$/i,
    pathlike: /^(path|rect)$/,
    NonVmlPathRe: /[ahqstv]/ig,
    partialPathRe: /[clmz]/g,
    fontFamilyRe: /^['"]+|['"]+$/g,
    baseVmlCls: Ext.baseCSSPrefix + "vml-base",
    vmlGroupCls: Ext.baseCSSPrefix + "vml-group",
    spriteCls: Ext.baseCSSPrefix + "vml-sprite",
    measureSpanCls: Ext.baseCSSPrefix + "vml-measure-span",
    zoom: 21600,
    coordsize: 1000,
    coordorigin: "0 0",
    zIndexShift: 0,
    orderSpritesByZIndex: false,
    path2vml: function(v) {
        var q = this,
            x = q.NonVmlPathRe,
            c = q.map,
            g = q.valRe,
            u = q.zoom,
            e = q.bitesRe,
            k = Ext.Function.bind(Ext.draw.Draw.pathToAbsolute, Ext.draw.Draw),
            o, s, d, a, m, t, l, n;
        if (String(v).match(x)) {
            k = Ext.Function.bind(Ext.draw.Draw.path2curve, Ext.draw.Draw)
        } else {
            if (!String(v).match(q.partialPathRe)) {
                o = String(v).replace(e, function(r, z, j) {
                    var y = [],
                        i = z.toLowerCase() == "m",
                        p = c[z];
                    j.replace(g, function(A) {
                        if (i && y.length === 2) {
                            p += y + c[z == "m" ? "l" : "L"];
                            y = []
                        }
                        y.push(Math.round(A * u))
                    });
                    return p + y
                });
                return o
            }
        }
        s = k(v);
        o = [];
        for (m = 0, t = s.length; m < t; m++) {
            d = s[m];
            a = s[m][0].toLowerCase();
            if (a == "z") {
                a = "x"
            }
            for (l = 1, n = d.length; l < n; l++) {
                a += Math.round(d[l] * q.zoom) + (l != n - 1 ? "," : "")
            }
            o.push(a)
        }
        return o.join(" ")
    },
    translateAttrs: {
        radius: "r",
        radiusX: "rx",
        radiusY: "ry",
        lineWidth: "stroke-width",
        fillOpacity: "fill-opacity",
        strokeOpacity: "stroke-opacity",
        strokeLinejoin: "stroke-linejoin"
    },
    minDefaults: {
        circle: {
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        ellipse: {
            cx: 0,
            cy: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        rect: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            rx: 0,
            ry: 0,
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        text: {
            x: 0,
            y: 0,
            "text-anchor": "start",
            font: '10px "Arial"',
            fill: "#000",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        path: {
            d: "M0,0",
            fill: "none",
            stroke: null,
            "stroke-width": null,
            opacity: null,
            "fill-opacity": null,
            "stroke-opacity": null
        },
        image: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            preserveAspectRatio: "none",
            opacity: null
        }
    },
    onMouseEnter: function(a) {
        this.fireEvent("mouseenter", a)
    },
    onMouseLeave: function(a) {
        this.fireEvent("mouseleave", a)
    },
    processEvent: function(c, i) {
        var g = i.getTarget(),
            a = this.surface,
            d;
        this.fireEvent(c, i);
        d = this.items.get(g.id);
        if (d) {
            d.fireEvent(c, d, i)
        }
    },
    createSpriteElement: function(j) {
        var g = this,
            e = j.attr,
            i = j.type,
            l = g.zoom,
            c = j.vml || (j.vml = {}),
            m = Math.round,
            d = (i === "image") ? g.createNode("image") : g.createNode("shape"),
            n, k, a;
        d.coordsize = l + " " + l;
        d.coordorigin = e.coordorigin || "0 0";
        Ext.get(d).addCls(g.spriteCls);
        if (i == "text") {
            c.path = n = g.createNode("path");
            n.textpathok = true;
            c.textpath = a = g.createNode("textpath");
            a.on = true;
            d.appendChild(a);
            d.appendChild(n)
        }
        d.id = j.id;
        j.el = Ext.get(d);
        j.el.setStyle("zIndex", -g.zIndexShift);
        g.el.appendChild(d);
        if (i !== "image") {
            k = g.createNode("skew");
            k.on = true;
            d.appendChild(k);
            j.skew = k
        }
        j.matrix = new Ext.draw.Matrix();
        j.bbox = {
            plain: null,
            transform: null
        };
        this.applyAttrs(j);
        this.applyTransformations(j);
        j.fireEvent("render", j);
        return j.el
    },
    getBBoxText: function(c) {
        var a = c.vml;
        return {
            x: a.X + (a.bbx || 0) - a.W / 2,
            y: a.Y - a.H / 2,
            width: a.W,
            height: a.H
        }
    },
    applyAttrs: function(o) {
        var u = this,
            d = o.vml,
            l = o.group,
            a = o.attr,
            c = o.el,
            q = c.dom,
            r, x, t, p, m, s, n, v, g, e, k, j;
        if (l) {
            t = [].concat(l);
            m = t.length;
            for (p = 0; p < m; p++) {
                l = t[p];
                u.getGroup(l).add(o)
            }
            delete o.group
        }
        s = u.scrubAttrs(o) || {};
        if (o.zIndexDirty) {
            u.setZIndex(o)
        }
        Ext.applyIf(s, u.minDefaults[o.type]);
        if (o.type == "image") {
            Ext.apply(o.attr, {
                x: s.x,
                y: s.y,
                width: s.width,
                height: s.height
            });
            c.setStyle({
                width: s.width + "px",
                height: s.height + "px"
            });
            q.src = s.src
        }
        if (q.href) {
            q.href = s.href
        }
        if (q.title) {
            q.title = s.title
        }
        if (q.target) {
            q.target = s.target
        }
        if (q.cursor) {
            q.cursor = s.cursor
        }
        if (o.dirtyHidden) {
            (s.hidden) ? u.hidePrim(o): u.showPrim(o);
            o.dirtyHidden = false
        }
        if (o.dirtyPath) {
            if (o.type == "circle" || o.type == "ellipse") {
                g = s.x;
                e = s.y;
                k = s.rx || s.r || 0;
                j = s.ry || s.r || 0;
                q.path = Ext.String.format("ar{0},{1},{2},{3},{4},{1},{4},{1}", Math.round((g - k) * u.zoom), Math.round((e - j) * u.zoom), Math.round((g + k) * u.zoom), Math.round((e + j) * u.zoom), Math.round(g * u.zoom));
                o.dirtyPath = false
            } else {
                if (o.type !== "text" && o.type !== "image") {
                    o.attr.path = s.path = u.setPaths(o, s) || s.path;
                    q.path = u.path2vml(s.path);
                    o.dirtyPath = false
                }
            }
        }
        if ("clip-rect" in s) {
            u.setClip(o, s)
        }
        if (o.type == "text") {
            u.setTextAttributes(o, s)
        }
        if (s.opacity || s["stroke-opacity"] || s.fill) {
            u.setFill(o, s)
        }
        if (s.stroke || s["stroke-opacity"] || s.fill) {
            u.setStroke(o, s)
        }
        r = a.style;
        if (r) {
            c.setStyle(r)
        }
        o.dirty = false
    },
    setZIndex: function(g) {
        var k = this,
            l = g.attr.zIndex,
            c = k.zIndexShift,
            d, a, j, e;
        if (l < c) {
            d = k.items.items;
            a = d.length;
            for (e = 0; e < a; e++) {
                if ((l = d[e].attr.zIndex) && l < c) {
                    c = l
                }
            }
            k.zIndexShift = c;
            for (e = 0; e < a; e++) {
                j = d[e];
                if (j.el) {
                    j.el.setStyle("zIndex", j.attr.zIndex - c)
                }
                j.zIndexDirty = false
            }
        } else {
            if (g.el) {
                g.el.setStyle("zIndex", l - c);
                g.zIndexDirty = false
            }
        }
    },
    setPaths: function(d, e) {
        var a = d.attr,
            c = d.attr["stroke-width"] || 1;
        d.bbox.plain = null;
        d.bbox.transform = null;
        if (d.type == "circle") {
            a.rx = a.ry = e.r;
            return Ext.draw.Draw.ellipsePath(d)
        } else {
            if (d.type == "ellipse") {
                a.rx = e.rx;
                a.ry = e.ry;
                return Ext.draw.Draw.ellipsePath(d)
            } else {
                if (d.type == "rect") {
                    a.rx = a.ry = e.r;
                    return Ext.draw.Draw.rectPath(d)
                } else {
                    if (d.type == "path" && a.path) {
                        return Ext.draw.Draw.pathToAbsolute(a.path)
                    }
                }
            }
        }
        return false
    },
    setFill: function(m, g) {
        var j = this,
            d = m.el.dom,
            l = d.fill,
            c = false,
            i, k, a, n, e;
        if (!l) {
            l = d.fill = j.createNode("fill");
            c = true
        }
        if (Ext.isArray(g.fill)) {
            g.fill = g.fill[0]
        }
        if (g.fill == "none") {
            l.on = false
        } else {
            if (typeof g.opacity == "number") {
                l.opacity = g.opacity
            }
            if (typeof g["fill-opacity"] == "number") {
                l.opacity = g["fill-opacity"]
            }
            l.on = true;
            if (typeof g.fill == "string") {
                a = g.fill.match(j.fillUrlRe);
                if (a) {
                    a = a[1];
                    if (a.charAt(0) == "#") {
                        k = j.gradientsColl.getByKey(a.substring(1))
                    }
                    if (k) {
                        n = g.rotation;
                        e = -(k.angle + 270 + (n ? n.degrees : 0)) % 360;
                        if (e === 0) {
                            e = 180
                        }
                        l.angle = e;
                        l.type = "gradient";
                        l.method = "sigma";
                        if (l.colors) {
                            l.colors.value = k.colors
                        } else {
                            l.colors = k.colors
                        }
                    } else {
                        l.src = a;
                        l.type = "tile"
                    }
                } else {
                    l.color = Ext.draw.Color.toHex(g.fill);
                    l.src = "";
                    l.type = "solid"
                }
            }
        }
        if (c) {
            d.appendChild(l)
        }
    },
    setStroke: function(c, j) {
        var g = this,
            e = c.el.dom,
            k = c.strokeEl,
            i = false,
            d, a;
        if (!k) {
            k = c.strokeEl = g.createNode("stroke");
            i = true
        }
        if (Ext.isArray(j.stroke)) {
            j.stroke = j.stroke[0]
        }
        if (!j.stroke || j.stroke == "none" || j.stroke == 0 || j["stroke-width"] == 0) {
            k.on = false
        } else {
            k.on = true;
            if (j.stroke && !j.stroke.match(g.fillUrlRe)) {
                k.color = Ext.draw.Color.toHex(j.stroke)
            }
            k.dashstyle = j["stroke-dasharray"] ? "dash" : "solid";
            k.joinstyle = j["stroke-linejoin"];
            k.endcap = j["stroke-linecap"] || "round";
            k.miterlimit = j["stroke-miterlimit"] || 8;
            d = parseFloat(j["stroke-width"] || 1) * 0.75;
            a = j["stroke-opacity"] || 1;
            if (Ext.isNumber(d) && d < 1) {
                k.weight = 1;
                k.opacity = a * d
            } else {
                k.weight = d;
                k.opacity = a
            }
        }
        if (i) {
            e.appendChild(k)
        }
    },
    setClip: function(c, i) {
        var g = this,
            d = c.el,
            a = c.clipEl,
            e = String(i["clip-rect"]).split(g.separatorRe);
        if (!a) {
            a = c.clipEl = g.el.insertFirst(Ext.getDoc().dom.createElement("div"));
            a.addCls(Ext.baseCSSPrefix + "vml-sprite")
        }
        if (e.length == 4) {
            e[2] = +e[2] + (+e[0]);
            e[3] = +e[3] + (+e[1]);
            a.setStyle("clip", Ext.String.format("rect({1}px {2}px {3}px {0}px)", e[0], e[1], e[2], e[3]));
            a.setSize(g.el.width, g.el.height)
        } else {
            a.setStyle("clip", "")
        }
    },
    setTextAttributes: function(k, d) {
        var j = this,
            a = k.vml,
            g = a.textpath.style,
            i = j.span.style,
            l = j.zoom,
            m = Math.round,
            n = {
                fontSize: "font-size",
                fontWeight: "font-weight",
                fontStyle: "font-style"
            },
            c, e;
        if (k.dirtyFont) {
            if (d.font) {
                g.font = i.font = d.font
            }
            if (d["font-family"]) {
                g.fontFamily = '"' + d["font-family"].split(",")[0].replace(j.fontFamilyRe, "") + '"';
                i.fontFamily = d["font-family"]
            }
            for (c in n) {
                e = d[n[c]];
                if (e) {
                    g[c] = i[c] = e
                }
            }
            j.setText(k, d.text);
            if (a.textpath.string) {
                j.span.innerHTML = String(a.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br/>")
            }
            a.W = j.span.offsetWidth;
            a.H = j.span.offsetHeight + 2;
            if (d["text-anchor"] == "middle") {
                g["v-text-align"] = "center"
            } else {
                if (d["text-anchor"] == "end") {
                    g["v-text-align"] = "right";
                    a.bbx = -Math.round(a.W / 2)
                } else {
                    g["v-text-align"] = "left";
                    a.bbx = Math.round(a.W / 2)
                }
            }
        }
        a.X = d.x;
        a.Y = d.y;
        a.path.v = Ext.String.format("m{0},{1}l{2},{1}", Math.round(a.X * l), Math.round(a.Y * l), Math.round(a.X * l) + 1);
        k.bbox.plain = null;
        k.bbox.transform = null;
        k.dirtyFont = false
    },
    setText: function(a, c) {
        a.vml.textpath.string = Ext.htmlDecode(c)
    },
    hide: function() {
        this.el.hide()
    },
    show: function() {
        this.el.show()
    },
    hidePrim: function(a) {
        a.el.addCls(Ext.baseCSSPrefix + "hide-visibility")
    },
    showPrim: function(a) {
        a.el.removeCls(Ext.baseCSSPrefix + "hide-visibility")
    },
    setSize: function(c, a) {
        var d = this;
        c = c || d.width;
        a = a || d.height;
        d.width = c;
        d.height = a;
        if (d.el) {
            if (c != undefined) {
                d.el.setWidth(c)
            }
            if (a != undefined) {
                d.el.setHeight(a)
            }
        }
        d.callParent(arguments)
    },
    applyViewBox: function() {
        var j = this,
            k = j.viewBox,
            g = j.width,
            c = j.height,
            d, a, e;
        j.callParent();
        if (k && (g || c)) {
            d = j.items.items;
            a = d.length;
            for (e = 0; e < a; e++) {
                j.applyTransformations(d[e])
            }
        }
    },
    onAdd: function(a) {
        this.callParent(arguments);
        if (this.el) {
            this.renderItem(a)
        }
    },
    onRemove: function(a) {
        if (a.el) {
            a.el.remove();
            delete a.el
        }
        this.callParent(arguments)
    },
    render: function(a) {
        var d = this,
            i = Ext.getDoc().dom,
            c;
        if (!d.createNode) {
            try {
                if (!i.namespaces.rvml) {
                    i.namespaces.add("rvml", "urn:schemas-microsoft-com:vml")
                }
                d.createNode = function(e) {
                    return i.createElement("<rvml:" + e + ' class="rvml">')
                }
            } catch (g) {
                d.createNode = function(e) {
                    return i.createElement("<" + e + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">')
                }
            }
        }
        if (!d.el) {
            c = i.createElement("div");
            d.el = Ext.get(c);
            d.el.addCls(d.baseVmlCls);
            d.span = i.createElement("span");
            Ext.get(d.span).addCls(d.measureSpanCls);
            c.appendChild(d.span);
            d.el.setSize(d.width || 0, d.height || 0);
            a.appendChild(c);
            d.el.on({
                scope: d,
                mouseup: d.onMouseUp,
                mousedown: d.onMouseDown,
                mouseover: d.onMouseOver,
                mouseout: d.onMouseOut,
                mousemove: d.onMouseMove,
                mouseenter: d.onMouseEnter,
                mouseleave: d.onMouseLeave,
                click: d.onClick,
                dblclick: d.onDblClick
            })
        }
        d.renderAll()
    },
    renderAll: function() {
        this.items.each(this.renderItem, this)
    },
    redraw: function(a) {
        a.dirty = true;
        this.renderItem(a)
    },
    renderItem: function(a) {
        if (!this.el) {
            return
        }
        if (!a.el) {
            this.createSpriteElement(a)
        }
        if (a.dirty) {
            this.applyAttrs(a);
            if (a.dirtyTransform) {
                this.applyTransformations(a)
            }
        }
    },
    rotationCompensation: function(e, d, a) {
        var c = new Ext.draw.Matrix();
        c.rotate(-e, 0.5, 0.5);
        return {
            x: c.x(d, a),
            y: c.y(d, a)
        }
    },
    transform: function(B, L) {
        var K = this,
            c = K.getBBox(B, true),
            l = c.x + c.width * 0.5,
            k = c.y + c.height * 0.5,
            E = new Ext.draw.Matrix(),
            s = B.transformations,
            z = s.length,
            F = 0,
            q = 0,
            e = 1,
            d = 1,
            p = "",
            j = B.el,
            H = j.dom,
            C = H.style,
            a = K.zoom,
            m = B.skew,
            G = K.viewBoxShift,
            J, I, u, n, t, r, D, A, x, v, g, o;
        for (; F < z; F++) {
            u = s[F];
            n = u.type;
            if (n == "translate") {
                E.translate(u.x, u.y)
            } else {
                if (n == "rotate") {
                    E.rotate(u.degrees, u.x, u.y);
                    q += u.degrees
                } else {
                    if (n == "scale") {
                        E.scale(u.x, u.y, u.centerX, u.centerY);
                        e *= u.x;
                        d *= u.y
                    }
                }
            }
        }
        B.matrix = E.clone();
        if (L) {
            return
        }
        if (G) {
            E.prepend(G.scale, 0, 0, G.scale, G.dx * G.scale, G.dy * G.scale)
        }
        if (B.type != "image" && m) {
            m.origin = "0,0";
            m.matrix = E.toString();
            o = E.offset();
            if (o[0] > 32767) {
                o[0] = 32767
            } else {
                if (o[0] < -32768) {
                    o[0] = -32768
                }
            }
            if (o[1] > 32767) {
                o[1] = 32767
            } else {
                if (o[1] < -32768) {
                    o[1] = -32768
                }
            }
            m.offset = o
        } else {
            C.filter = E.toFilter();
            C.left = Math.min(E.x(c.x, c.y), E.x(c.x + c.width, c.y), E.x(c.x, c.y + c.height), E.x(c.x + c.width, c.y + c.height)) + "px";
            C.top = Math.min(E.y(c.x, c.y), E.y(c.x + c.width, c.y), E.y(c.x, c.y + c.height), E.y(c.x + c.width, c.y + c.height)) + "px"
        }
    },
    createItem: function(a) {
        return Ext.create("Ext.draw.Sprite", a)
    },
    getRegion: function() {
        return this.el.getRegion()
    },
    addCls: function(a, c) {
        if (a && a.el) {
            a.el.addCls(c)
        }
    },
    removeCls: function(a, c) {
        if (a && a.el) {
            a.el.removeCls(c)
        }
    },
    addGradient: function(j) {
        var e = this.gradientsColl || (this.gradientsColl = Ext.create("Ext.util.MixedCollection")),
            a = [],
            l = Ext.create("Ext.util.MixedCollection"),
            n, g, c, k, m, d;
        l.addAll(j.stops);
        l.sortByKey("ASC", function(o, i) {
            o = parseInt(o, 10);
            i = parseInt(i, 10);
            return o > i ? 1 : (o < i ? -1 : 0)
        });
        n = l.keys;
        g = l.items;
        c = n.length;
        for (d = 0; d < c; d++) {
            k = n[d];
            m = g[d];
            a.push(k + "% " + m.color)
        }
        e.add(j.id, {
            colors: a.join(","),
            angle: j.angle
        })
    },
    destroy: function() {
        var a = this;
        a.callParent(arguments);
        if (a.el) {
            a.el.remove()
        }
        delete a.el
    }
});
Ext.define("Ext.toolbar.TextItem", {
    extend: "Ext.toolbar.Item",
    requires: ["Ext.XTemplate"],
    alias: "widget.tbtext",
    alternateClassName: "Ext.Toolbar.TextItem",
    text: "",
    renderTpl: "{text}",
    baseCls: Ext.baseCSSPrefix + "toolbar-text",
    beforeRender: function() {
        var a = this;
        a.callParent();
        Ext.apply(a.renderData, {
            text: a.text
        })
    },
    setText: function(c) {
        var a = this;
        if (a.rendered) {
            a.el.update(c);
            a.updateLayout()
        } else {
            this.text = c
        }
    }
});
Ext.define("Ext.grid.LockingView", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    eventRelayRe: /^(beforeitem|beforecontainer|item|container|cell)/,
    constructor: function(d) {
        var i = this,
            k = [],
            a = i.eventRelayRe,
            c = d.locked.getView(),
            j = d.normal.getView(),
            e, g;
        Ext.apply(i, {
            lockedView: c,
            normalView: j,
            lockedGrid: d.locked,
            normalGrid: d.normal,
            panel: d.panel
        });
        i.mixins.observable.constructor.call(i, d);
        e = c.events;
        for (g in e) {
            if (e.hasOwnProperty(g) && a.test(g)) {
                k.push(g)
            }
        }
        i.relayEvents(c, k);
        i.relayEvents(j, k);
        j.on({
            scope: i,
            itemmouseleave: i.onItemMouseLeave,
            itemmouseenter: i.onItemMouseEnter
        });
        c.on({
            scope: i,
            itemmouseleave: i.onItemMouseLeave,
            itemmouseenter: i.onItemMouseEnter
        })
    },
    getGridColumns: function() {
        var a = this.lockedGrid.headerCt.getGridColumns();
        return a.concat(this.normalGrid.headerCt.getGridColumns())
    },
    getEl: function(a) {
        return this.getViewForColumn(a).getEl()
    },
    getViewForColumn: function(c) {
        var a = this.lockedView,
            d;
        a.headerCt.cascade(function(e) {
            if (e === c) {
                d = true;
                return false
            }
        });
        return d ? a : this.normalView
    },
    onItemMouseEnter: function(d, c) {
        var i = this,
            e = i.lockedView,
            a = i.normalView,
            g;
        if (d.trackOver) {
            if (d !== e) {
                a = e
            }
            g = a.getNode(c);
            a.highlightItem(g)
        }
    },
    onItemMouseLeave: function(d, c) {
        var g = this,
            e = g.lockedView,
            a = g.normalView;
        if (d.trackOver) {
            if (d !== e) {
                a = e
            }
            a.clearHighlight()
        }
    },
    relayFn: function(d, c) {
        c = c || [];
        var a = this.lockedView;
        a[d].apply(a, c || []);
        a = this.normalView;
        a[d].apply(a, c || [])
    },
    getSelectionModel: function() {
        return this.panel.getSelectionModel()
    },
    getStore: function() {
        return this.panel.store
    },
    getNode: function(a) {
        return this.normalView.getNode(a)
    },
    getCell: function(c, d) {
        var a = this.getViewForColumn(d),
            e;
        e = a.getNode(c);
        return Ext.fly(e).down(d.getCellSelector())
    },
    getRecord: function(c) {
        var a = this.lockedView.getRecord(c);
        if (!c) {
            a = this.normalView.getRecord(c)
        }
        return a
    },
    addElListener: function(a, d, c) {
        this.relayFn("addElListener", arguments)
    },
    refreshNode: function() {
        this.relayFn("refreshNode", arguments)
    },
    refresh: function() {
        this.relayFn("refresh", arguments)
    },
    bindStore: function() {
        this.relayFn("bindStore", arguments)
    },
    addRowCls: function() {
        this.relayFn("addRowCls", arguments)
    },
    removeRowCls: function() {
        this.relayFn("removeRowCls", arguments)
    }
});
Ext.define("Ext.grid.Lockable", {
    requires: ["Ext.grid.LockingView", "Ext.view.Table"],
    syncRowHeight: true,
    headerCounter: 0,
    scrollDelta: 40,
    unlockText: "Unlock",
    lockText: "Lock",
    determineXTypeToCreate: function() {
        var d = this,
            i, e, c, g, a;
        if (d.subGridXType) {
            i = d.subGridXType
        } else {
            e = this.getXTypes().split("/");
            c = e.length;
            g = e[c - 1];
            a = e[c - 2];
            if (a !== "tablepanel") {
                i = a
            } else {
                i = g
            }
        }
        return i
    },
    injectLockable: function() {
        this.lockable = true;
        this.hasView = true;
        var v = this,
            c = Ext.getScrollbarSize().width === 0,
            e = v.store = Ext.StoreManager.lookup(v.store),
            d = v.determineXTypeToCreate(),
            l = v.getSelectionModel(),
            n, r, s, q, u, k, o, p, a, g, t, j, x, m;
        n = v.constructFeatures();
        v.cloneFeatures();
        r = v.constructFeatures();
        s = v.constructPlugins();
        v.clonePlugins();
        q = v.constructPlugins();
        delete v.features;
        delete v.plugins;
        for (o = 0, p = (n ? n.length : 0); o < p; o++) {
            n[o].lockingPartner = r[o];
            r[o].lockingPartner = n[o]
        }
        u = Ext.apply({
            xtype: d,
            store: e,
            scrollerOwner: false,
            enableAnimations: false,
            scroll: c ? "vertical" : false,
            selModel: l,
            border: false,
            cls: Ext.baseCSSPrefix + "grid-inner-locked",
            isLayoutRoot: function() {
                return false
            },
            features: n,
            plugins: s
        }, v.lockedGridConfig);
        k = Ext.apply({
            xtype: d,
            store: e,
            scrollerOwner: false,
            enableAnimations: false,
            selModel: l,
            border: false,
            isLayoutRoot: function() {
                return false
            },
            features: r,
            plugins: q
        }, v.normalGridConfig);
        v.addCls(Ext.baseCSSPrefix + "grid-locked");
        Ext.copyTo(k, v, v.bothCfgCopy);
        Ext.copyTo(u, v, v.bothCfgCopy);
        Ext.copyTo(k, v, v.normalCfgCopy);
        Ext.copyTo(u, v, v.lockedCfgCopy);
        for (o = 0; o < v.normalCfgCopy.length; o++) {
            delete v[v.normalCfgCopy[o]]
        }
        for (o = 0; o < v.lockedCfgCopy.length; o++) {
            delete v[v.lockedCfgCopy[o]]
        }
        v.addEvents("lockcolumn", "unlockcolumn");
        v.addStateEvents(["lockcolumn", "unlockcolumn"]);
        v.lockedHeights = [];
        v.normalHeights = [];
        a = v.processColumns(v.columns);
        u.width = a.lockedWidth + Ext.num(l.headerWidth, 0);
        u.columns = a.locked;
        k.columns = a.normal;
        k.flex = 1;
        u.viewConfig = v.lockedViewConfig || {};
        u.viewConfig.loadingUseMsg = false;
        k.viewConfig = v.normalViewConfig || {};
        Ext.applyIf(u.viewConfig, v.viewConfig);
        Ext.applyIf(k.viewConfig, v.viewConfig);
        v.lockedGrid = Ext.ComponentManager.create(u);
        j = v.lockedGrid.getView();
        k.viewConfig.lockingPartner = j;
        v.normalGrid = Ext.ComponentManager.create(k);
        x = v.normalGrid.getView();
        v.view = new Ext.grid.LockingView({
            locked: v.lockedGrid,
            normal: v.normalGrid,
            panel: v
        });
        m = {
            scroll: {
                fn: v.onLockedViewScroll,
                element: "el",
                scope: v
            }
        };
        if (!c) {
            m.mousewheel = {
                fn: v.onLockedViewMouseWheel,
                element: "el",
                scope: v
            }
        }
        if (v.syncRowHeight) {
            m.refresh = v.onLockedViewRefresh;
            m.itemupdate = v.onLockedViewItemUpdate;
            m.scope = v
        }
        j.on(m);
        m = {
            scroll: {
                fn: v.onNormalViewScroll,
                element: "el",
                scope: v
            },
            refresh: v.syncRowHeight ? v.onNormalViewRefresh : v.updateSpacer,
            scope: v
        };
        x.on(m);
        g = v.lockedGrid.headerCt;
        t = v.normalGrid.headerCt;
        g.lockedCt = true;
        g.lockableInjected = true;
        t.lockableInjected = true;
        g.on({
            columnshow: v.onLockedHeaderShow,
            columnhide: v.onLockedHeaderHide,
            columnmove: v.onLockedHeaderMove,
            sortchange: v.onLockedHeaderSortChange,
            columnresize: v.onLockedHeaderResize,
            scope: v
        });
        t.on({
            columnmove: v.onNormalHeaderMove,
            sortchange: v.onNormalHeaderSortChange,
            scope: v
        });
        v.modifyHeaderCt();
        v.items = [v.lockedGrid, v.normalGrid];
        v.relayHeaderCtEvents(g);
        v.relayHeaderCtEvents(t);
        v.layout = {
            type: "hbox",
            align: "stretch"
        }
    },
    processColumns: function(j) {
        var g = 0,
            a = j.length,
            c = 0,
            e = [],
            d = [],
            k;
        for (; g < a; ++g) {
            k = j[g];
            if (!k.isComponent) {
                k = Ext.apply({}, j[g])
            }
            k.processed = true;
            if (k.locked) {
                if (!k.hidden) {
                    c += k.width || Ext.grid.header.Container.prototype.defaultWidth
                }
                e.push(k)
            } else {
                d.push(k)
            }
            if (!k.headerId) {
                k.headerId = (k.initialConfig || k).id || ("L" + (++this.headerCounter))
            }
        }
        return {
            lockedWidth: c,
            locked: {
                items: e,
                itemId: "lockedHeaderCt",
                stretchMaxPartner: "^^>>#normalHeaderCt"
            },
            normal: {
                items: d,
                itemId: "normalHeaderCt",
                stretchMaxPartner: "^^>>#lockedHeaderCt"
            }
        }
    },
    onLockedViewMouseWheel: function(k) {
        var g = this,
            j = -g.scrollDelta,
            a = j * k.getWheelDeltas().y,
            c = g.lockedGrid.getView().el.dom,
            d, i;
        if (c) {
            d = c.scrollTop !== c.scrollHeight - c.clientHeight;
            i = c.scrollTop !== 0
        }
        if ((a < 0 && i) || (a > 0 && d)) {
            k.stopEvent();
            g.scrolling = true;
            c.scrollTop += a;
            g.normalGrid.getView().el.dom.scrollTop = c.scrollTop;
            g.scrolling = false;
            g.onNormalViewScroll()
        }
    },
    onLockedViewScroll: function() {
        var g = this,
            e = g.lockedGrid.getView(),
            d = g.normalGrid.getView(),
            a, c;
        if (!g.scrolling) {
            g.scrolling = true;
            d.el.dom.scrollTop = e.el.dom.scrollTop;
            if (g.store.buffered) {
                c = e.el.child("table", true);
                a = d.el.child("table", true);
                c.style.position = "absolute"
            }
            g.scrolling = false
        }
    },
    onNormalViewScroll: function() {
        var g = this,
            e = g.lockedGrid.getView(),
            d = g.normalGrid.getView(),
            a, c;
        if (!g.scrolling) {
            g.scrolling = true;
            e.el.dom.scrollTop = d.el.dom.scrollTop;
            if (g.store.buffered) {
                c = e.el.child("table", true);
                a = d.el.child("table", true);
                c.style.position = "absolute";
                c.style.top = a.style.top
            }
            g.scrolling = false
        }
    },
    onLockedHeaderMove: function() {
        if (this.syncRowHeight) {
            this.onNormalViewRefresh()
        }
    },
    onNormalHeaderMove: function() {
        if (this.syncRowHeight) {
            this.onLockedViewRefresh()
        }
    },
    updateSpacer: function() {
        var e = this,
            c = e.lockedGrid.getView().el,
            d = e.normalGrid.getView().el.dom,
            a = c.dom.id + "-spacer",
            g = (d.offsetHeight - d.clientHeight) + "px";
        e.spacerEl = Ext.getDom(a);
        if (e.spacerEl) {
            e.spacerEl.style.height = g
        } else {
            Ext.core.DomHelper.append(c, {
                id: a,
                style: "height: " + g
            })
        }
    },
    onLockedViewRefresh: function() {
        if (this.normalGrid.headerCt.getGridColumns().length) {
            var g = this,
                a = g.lockedGrid.getView(),
                d = a.el,
                j = d.query(a.getItemSelector()),
                e = j.length,
                c = 0;
            g.lockedHeights = [];
            for (; c < e; c++) {
                g.lockedHeights[c] = j[c].offsetHeight
            }
            g.syncRowHeights();
            g.updateSpacer()
        }
    },
    onNormalViewRefresh: function() {
        if (this.lockedGrid.headerCt.getGridColumns().length) {
            var g = this,
                a = g.normalGrid.getView(),
                d = a.el,
                j = d.query(a.getItemSelector()),
                e = j.length,
                c = 0;
            g.normalHeights = [];
            for (; c < e; c++) {
                g.normalHeights[c] = j[c].offsetHeight
            }
            g.syncRowHeights();
            g.updateSpacer()
        }
    },
    onLockedViewItemUpdate: function(a, c, d) {
        if (this.normalGrid.headerCt.getGridColumns().length) {
            this.lockedHeights[c] = d.offsetHeight;
            this.syncRowHeights()
        }
    },
    onNormalViewItemUpdate: function(a, c, d) {
        if (this.lockedGrid.headerCt.getGridColumns().length) {
            this.normalHeights[c] = d.offsetHeight;
            this.syncRowHeights()
        }
    },
    syncRowHeights: function() {
        var l = this,
            a = l.lockedHeights,
            m = l.normalHeights,
            k = a.length,
            g = 0,
            n, d, e, j, c;
        if (a.length && m.length) {
            n = l.lockedGrid.getView();
            d = l.normalGrid.getView();
            e = n.el.query(n.getItemSelector());
            j = d.el.query(d.getItemSelector());
            for (; g < k; g++) {
                if (!isNaN(a[g]) && !isNaN(m[g])) {
                    if (a[g] > m[g]) {
                        Ext.fly(j[g]).setHeight(a[g])
                    } else {
                        if (a[g] < m[g]) {
                            Ext.fly(e[g]).setHeight(m[g])
                        }
                    }
                }
            }
            c = d.el.dom.scrollTop;
            d.el.dom.scrollTop = c;
            n.el.dom.scrollTop = c;
            l.lockedHeights = [];
            l.normalHeights = []
        }
    },
    modifyHeaderCt: function() {
        var a = this;
        a.lockedGrid.headerCt.getMenuItems = a.getMenuItems(a.lockedGrid.headerCt.getMenuItems, true);
        a.normalGrid.headerCt.getMenuItems = a.getMenuItems(a.normalGrid.headerCt.getMenuItems, false)
    },
    onUnlockMenuClick: function() {
        this.unlock()
    },
    onLockMenuClick: function() {
        this.lock()
    },
    getMenuItems: function(i, d) {
        var j = this,
            k = j.unlockText,
            a = j.lockText,
            l = Ext.baseCSSPrefix + "hmenu-unlock",
            c = Ext.baseCSSPrefix + "hmenu-lock",
            g = Ext.Function.bind(j.onUnlockMenuClick, j),
            e = Ext.Function.bind(j.onLockMenuClick, j);
        return function() {
            var m = i.call(this);
            m.push("-", {
                cls: l,
                text: k,
                handler: g,
                disabled: !d
            });
            m.push({
                cls: c,
                text: a,
                handler: e,
                disabled: d
            });
            return m
        }
    },
    lock: function(a, e) {
        var d = this,
            g = d.normalGrid,
            j = d.lockedGrid,
            i = g.headerCt,
            c = j.headerCt;
        a = a || i.getMenu().activeHeader;
        if (a.flex) {
            a.width = a.getWidth();
            delete a.flex
        }
        Ext.suspendLayouts();
        a.ownerCt.remove(a, false);
        a.locked = true;
        if (Ext.isDefined(e)) {
            c.insert(e, a)
        } else {
            c.add(a)
        }
        d.syncLockedSection();
        Ext.resumeLayouts(true);
        d.updateSpacer();
        d.fireEvent("lockcolumn", d, a)
    },
    syncLockedSection: function() {
        var a = this;
        a.syncLockedWidth();
        a.lockedGrid.getView().refresh();
        a.normalGrid.getView().refresh()
    },
    syncLockedWidth: function() {
        var d = this,
            a = d.lockedGrid,
            c = a.headerCt.getFullWidth(true);
        Ext.suspendLayouts();
        if (c > 0) {
            a.setWidth(c);
            a.show()
        } else {
            a.hide()
        }
        Ext.resumeLayouts(true);
        return c > 0
    },
    onLockedHeaderResize: function() {
        this.syncLockedWidth()
    },
    onLockedHeaderHide: function() {
        this.syncLockedWidth()
    },
    onLockedHeaderShow: function() {
        this.syncLockedWidth()
    },
    onLockedHeaderSortChange: function(c, d, a) {
        if (a) {
            this.normalGrid.headerCt.clearOtherSortStates(null, true)
        }
    },
    onNormalHeaderSortChange: function(c, d, a) {
        if (a) {
            this.lockedGrid.headerCt.clearOtherSortStates(null, true)
        }
    },
    unlock: function(a, g) {
        var e = this,
            i = e.normalGrid,
            k = e.lockedGrid,
            j = i.headerCt,
            d = k.headerCt,
            c = false;
        if (!Ext.isDefined(g)) {
            g = 0
        }
        a = a || d.getMenu().activeHeader;
        Ext.suspendLayouts();
        a.ownerCt.remove(a, false);
        if (e.syncLockedWidth()) {
            c = true
        }
        a.locked = false;
        j.insert(g, a);
        e.normalGrid.getView().refresh();
        if (c) {
            e.lockedGrid.getView().refresh()
        }
        Ext.resumeLayouts(true);
        e.fireEvent("unlockcolumn", e, a)
    },
    applyColumnsState: function(k) {
        var r = this,
            g = r.lockedGrid,
            j = g.headerCt,
            p = r.normalGrid.headerCt,
            s = Ext.Array.toMap(j.items, "headerId"),
            l = Ext.Array.toMap(p.items, "headerId"),
            o = [],
            q = [],
            n = 1,
            c = k.length,
            m, a, e, d;
        for (m = 0; m < c; m++) {
            d = k[m];
            e = s[d.id];
            a = e || l[d.id];
            if (a) {
                if (a.applyColumnState) {
                    a.applyColumnState(d)
                }
                if (a.locked === undefined) {
                    a.locked = !!e
                }
                if (a.locked) {
                    o.push(a);
                    if (!a.hidden && typeof a.width == "number") {
                        n += a.width
                    }
                } else {
                    q.push(a)
                }
            }
        }
        if (o.length + q.length == j.items.getCount() + p.items.getCount()) {
            j.removeAll(false);
            p.removeAll(false);
            j.add(o);
            p.add(q);
            g.setWidth(n)
        }
    },
    getColumnsState: function() {
        var c = this,
            a = c.lockedGrid.headerCt.getColumnsState(),
            d = c.normalGrid.headerCt.getColumnsState();
        return a.concat(d)
    },
    reconfigureLockable: function(a, c) {
        var d = this,
            g = d.lockedGrid,
            e = d.normalGrid;
        if (c) {
            Ext.suspendLayouts();
            g.headerCt.removeAll();
            e.headerCt.removeAll();
            c = d.processColumns(c);
            g.setWidth(c.lockedWidth);
            g.headerCt.add(c.locked.items);
            e.headerCt.add(c.normal.items);
            Ext.resumeLayouts(true)
        }
        if (a) {
            a = Ext.data.StoreManager.lookup(a);
            d.store = a;
            g.bindStore(a);
            e.bindStore(a)
        } else {
            g.getView().refresh();
            e.getView().refresh()
        }
    },
    cloneFeatures: function() {
        var g = this,
            e = g.features,
            d, c = 0,
            a;
        if (e) {
            a = e.length;
            for (; c < a; c++) {
                d = e[c];
                if (d.isFeature) {
                    e[c] = d.clone()
                }
            }
        }
    },
    clonePlugins: function() {
        var g = this,
            c = g.plugins,
            e, d = 0,
            a;
        if (c) {
            a = c.length;
            for (; d < a; d++) {
                e = c[d];
                if (typeof e.init === "function") {
                    c[d] = e.clone()
                }
            }
        }
    }
}, function() {
    this.borrow(Ext.view.Table, ["constructFeatures"]);
    this.borrow(Ext.AbstractComponent, ["constructPlugins", "constructPlugin"])
});
Ext.define("Ext.grid.PagingScroller", {
    percentageFromEdge: 0.35,
    numFromEdge: 2,
    trailingBufferZone: 5,
    leadingBufferZone: 15,
    scrollToLoadBuffer: 200,
    viewSize: 0,
    rowHeight: 21,
    tableStart: 0,
    tableEnd: 0,
    constructor: function(a) {
        var c = this;
        c.variableRowHeight = a.variableRowHeight;
        c.bindView(a.view);
        Ext.apply(c, a);
        c.callParent(arguments)
    },
    bindView: function(c) {
        var i = this,
            e = {
                scroll: {
                    fn: i.onViewScroll,
                    element: "el",
                    scope: i
                },
                render: i.onViewRender,
                resize: i.onViewResize,
                boxready: {
                    fn: i.onViewResize,
                    scope: i,
                    single: true
                },
                beforerefresh: i.beforeViewRefresh,
                refresh: i.onViewRefresh,
                scope: i
            },
            a = {
                guaranteedrange: i.onGuaranteedRange,
                scope: i
            },
            d = {
                reconfigure: i.onGridReconfigure,
                scope: i
            },
            g;
        if (i.view) {
            if (i.view.el) {
                i.view.el.un("scroll", i.onViewScroll, i)
            }
            g = c.lockingPartner;
            if (g) {
                g.un("refresh", i.onLockRefresh, i)
            }
            i.view.un(e);
            i.store.un(a);
            if (i.grid) {
                i.grid.un(d)
            }
            delete i.view.refreshSize
        }
        i.view = c;
        i.grid = i.view.up("tablepanel");
        i.store = c.store;
        if (c.rendered) {
            i.viewSize = i.store.viewSize = Math.ceil(c.getHeight() / i.rowHeight) + i.trailingBufferZone + (i.numFromEdge * 2) + i.leadingBufferZone
        }
        g = c.lockingPartner;
        if (g) {
            g.on("refresh", i.onLockRefresh, i)
        }
        i.view.mon(i.store.pageMap, {
            scope: i,
            clear: i.onCacheClear
        });
        i.view.refreshSize = Ext.Function.createInterceptor(i.view.refreshSize, i.beforeViewrefreshSize, i);
        i.position = 0;
        if (i.grid) {
            i.grid.on(d)
        } else {
            i.view.on({
                added: function() {
                    i.grid = i.view.up("tablepanel");
                    i.grid.on(d)
                },
                single: true
            })
        }
        i.view.on(i.viewListeners = e);
        i.store.on(a)
    },
    onCacheClear: function() {
        var a = this;
        if (a.view.rendered && !a.store.isDestroyed) {
            a.ignoreNextScrollEvent = a.view.el.dom.scrollTop !== 0;
            a.view.el.dom.scrollTop = 0;
            delete a.lastScrollDirection;
            delete a.scrollOffset;
            delete a.scrollProportion
        }
    },
    onGridReconfigure: function(a) {
        this.bindView(a.view)
    },
    onViewRender: function() {
        var e = this,
            a = e.view,
            d = e.view.el,
            c;
        e.stretcher = e.createStretcher(a);
        a = a.lockingPartner;
        if (a) {
            c = e.stretcher;
            e.stretcher = new Ext.CompositeElement(c);
            e.stretcher.add(e.createStretcher(a))
        }
    },
    createStretcher: function(a) {
        var c = a.el;
        c.setStyle("position", "relative");
        return c.createChild({
            style: {
                position: "absolute",
                width: "1px",
                height: 0,
                top: 0,
                left: 0
            }
        }, c.dom.firstChild)
    },
    onViewResize: function(c, e, a) {
        var g = this,
            d;
        d = Math.ceil(a / g.rowHeight) + g.trailingBufferZone + (g.numFromEdge * 2) + g.leadingBufferZone;
        if (d > g.viewSize) {
            g.viewSize = g.store.viewSize = d;
            g.handleViewScroll(g.lastScrollDirection || 1)
        }
    },
    beforeViewRefresh: function() {
        var c = this,
            a = c.view,
            d, e;
        c.focusOnRefresh = Ext.Element.getActiveElement === a.el.dom;
        if (c.variableRowHeight) {
            e = c.lastScrollDirection;
            c.commonRecordIndex = undefined;
            if (e && (c.previousStart !== undefined) && (c.scrollProportion === undefined) && (d = a.getNodes()).length) {
                if (e === 1) {
                    if (c.tableStart <= c.previousEnd) {
                        c.commonRecordIndex = d.length - 1
                    }
                } else {
                    if (e === -1) {
                        if (c.tableEnd >= c.previousStart) {
                            c.commonRecordIndex = 0
                        }
                    }
                }
                c.scrollOffset = -a.el.getOffsetsTo(d[c.commonRecordIndex])[1];
                c.commonRecordIndex -= (c.tableStart - c.previousStart)
            } else {
                c.scrollOffset = undefined
            }
        }
    },
    onLockRefresh: function(a) {
        a.table.dom.style.position = "absolute"
    },
    onViewRefresh: function() {
        var e = this,
            i = e.store,
            d, g = e.view,
            l = g.el,
            m = l.dom,
            o, k, c, n = g.table.dom,
            j, a;
        if (e.focusOnRefresh) {
            l.focus();
            e.focusOnRefresh = false
        }
        e.disabled = true;
        if (i.getCount() === i.getTotalCount() || (i.isFiltered() && !i.remoteFilter)) {
            e.stretcher.setHeight(0);
            e.position = m.scrollTop = 0;
            e.setTablePosition("absolute");
            return
        }
        e.stretcher.setHeight(d = e.getScrollHeight());
        a = m.scrollTop;
        e.isScrollRefresh = (a > 0);
        if (e.scrollProportion !== undefined) {
            e.setTablePosition("absolute");
            e.setTableTop((e.scrollProportion ? (d * e.scrollProportion) - (n.offsetHeight * e.scrollProportion) : 0) + "px")
        } else {
            e.setTablePosition("absolute");
            e.setTableTop((j = (e.tableStart || 0) * e.rowHeight) + "px");
            if (e.scrollOffset) {
                o = g.getNodes();
                k = -l.getOffsetsTo(o[e.commonRecordIndex])[1];
                c = k - e.scrollOffset;
                e.position = (m.scrollTop += c)
            } else {
                if ((j > a) || ((j + n.offsetHeight) < a + m.clientHeight)) {
                    e.lastScrollDirection = -1;
                    e.position = m.scrollTop = j
                }
            }
        }
        e.disabled = false
    },
    setTablePosition: function(a) {
        this.setViewTableStyle(this.view, "position", a)
    },
    setTableTop: function(a) {
        this.setViewTableStyle(this.view, "top", a)
    },
    setViewTableStyle: function(a, d, c) {
        a.el.child("table", true).style[d] = c;
        a = a.lockingPartner;
        if (a) {
            a.el.child("table", true).style[d] = c
        }
    },
    beforeViewrefreshSize: function() {
        if (this.isScrollRefresh) {
            this.view.table.attach(this.view.el.child("table", true));
            return (this.isScrollRefresh = false)
        }
    },
    onGuaranteedRange: function(c, g, a) {
        var d = this,
            e = d.store;
        if (c.length && d.visibleStart < c[0].index) {
            return
        }
        d.previousStart = d.tableStart;
        d.previousEnd = d.tableEnd;
        d.tableStart = g;
        d.tableEnd = a;
        e.loadRecords(c, {
            start: g
        })
    },
    onViewScroll: function(i, d) {
        var g = this,
            a = g.view,
            c = g.position;
        g.position = a.el.dom.scrollTop;
        if (g.ignoreNextScrollEvent) {
            g.ignoreNextScrollEvent = false;
            return
        }
        if (!g.disabled) {
            g.lastScrollDirection = g.position > c ? 1 : -1;
            if (c !== g.position) {
                g.handleViewScroll(g.lastScrollDirection)
            }
        }
    },
    handleViewScroll: function(k) {
        var g = this,
            m = g.store,
            j = g.view,
            i = g.viewSize,
            n = m.getTotalCount(),
            e = n - i,
            d = g.getFirstVisibleRowIndex(),
            l = g.getLastVisibleRowIndex(),
            a = j.el.dom,
            c, o;
        if (n >= i) {
            g.scrollProportion = undefined;
            if (k == -1) {
                if (g.tableStart) {
                    if (d !== undefined) {
                        if (d < (g.tableStart + g.numFromEdge)) {
                            c = Math.max(0, l + g.trailingBufferZone - i)
                        }
                    } else {
                        g.scrollProportion = a.scrollTop / (a.scrollHeight - a.clientHeight);
                        c = Math.max(0, n * g.scrollProportion - (i / 2) - g.numFromEdge - ((g.leadingBufferZone + g.trailingBufferZone) / 2))
                    }
                }
            } else {
                if (d !== undefined) {
                    if (l > (g.tableEnd - g.numFromEdge)) {
                        c = Math.max(0, d - g.trailingBufferZone)
                    }
                } else {
                    g.scrollProportion = a.scrollTop / (a.scrollHeight - a.clientHeight);
                    c = n * g.scrollProportion - (i / 2) - g.numFromEdge - ((g.leadingBufferZone + g.trailingBufferZone) / 2)
                }
            }
            if (c !== undefined) {
                if (c > e) {
                    c = e & ~1;
                    o = n - 1
                } else {
                    c = c & ~1;
                    o = c + i - 1
                }
                if (m.rangeCached(c, o)) {
                    g.cancelLoad();
                    m.guaranteeRange(c, o)
                } else {
                    g.attemptLoad(c, o)
                }
            }
        }
    },
    getFirstVisibleRowIndex: function() {
        var e = this,
            a = e.view,
            k = a.el.dom.scrollTop,
            g, d, c, j;
        if (e.variableRowHeight) {
            g = a.getNodes();
            d = g.length;
            if (!d) {
                return
            }
            j = Ext.fly(g[0]).getOffsetsTo(a.el)[1];
            for (c = 0; c < d; c++) {
                j += g[c].offsetHeight;
                if (j > a.el.dom.clientHeight) {
                    return
                }
                if (j > 0) {
                    return a.getRecord(g[c]).index
                }
            }
        } else {
            return Math.floor(k / e.rowHeight)
        }
    },
    getLastVisibleRowIndex: function() {
        var k = this,
            d = k.store,
            a = k.view,
            c = a.el.dom.clientHeight,
            l, j, g, e;
        if (k.variableRowHeight) {
            l = a.getNodes();
            if (!l.length) {
                return
            }
            j = d.getCount() - 1;
            e = Ext.fly(l[j]).getOffsetsTo(a.el)[1] + l[j].offsetHeight;
            for (g = j; g >= 0; g--) {
                e -= l[g].offsetHeight;
                if (e < 0) {
                    return
                }
                if (e < c) {
                    return a.getRecord(l[g]).index
                }
            }
        } else {
            return k.getFirstVisibleRowIndex() + Math.ceil(c / k.rowHeight) + 1
        }
    },
    getScrollHeight: function() {
        var g = this,
            a = g.view,
            e, j, c = g.store,
            i = 0,
            d = !g.hasOwnProperty("rowHeight");
        if (g.variableRowHeight) {
            e = g.view.table.dom;
            if (d) {
                g.initialTableHeight = e.offsetHeight;
                g.rowHeight = g.initialTableHeight / g.store.getCount()
            } else {
                i = e.offsetHeight - g.initialTableHeight;
                if (c.getCount() > g.viewSize) {
                    i -= g.rowHeight
                }
            }
        } else {
            if (d) {
                j = a.el.down(a.getItemSelector());
                if (j) {
                    g.rowHeight = j.getHeight(false, true)
                }
            }
        }
        return Math.floor(c.getTotalCount() * g.rowHeight) + i
    },
    attemptLoad: function(d, a) {
        var c = this;
        if (c.scrollToLoadBuffer) {
            if (!c.loadTask) {
                c.loadTask = new Ext.util.DelayedTask(c.doAttemptLoad, c, [])
            }
            c.loadTask.delay(c.scrollToLoadBuffer, c.doAttemptLoad, c, [d, a])
        } else {
            c.store.guaranteeRange(d, a)
        }
    },
    cancelLoad: function() {
        if (this.loadTask) {
            this.loadTask.cancel()
        }
    },
    doAttemptLoad: function(c, a) {
        this.store.guaranteeRange(c, a)
    },
    destroy: function() {
        var c = this,
            a = c.viewListeners.scroll;
        c.store.un({
            guaranteedrange: c.onGuaranteedRange,
            scope: c
        });
        c.view.un(c.viewListeners);
        if (c.view.rendered) {
            c.stretcher.remove();
            c.view.el.un("scroll", a.fn, a.scope)
        }
    }
});
Ext.define("Ext.layout.component.Tab", {
    extend: "Ext.layout.component.Button",
    alias: "layout.tab",
    beginLayout: function(d) {
        var c = this,
            a = c.owner.closable;
        if (c.lastClosable !== a) {
            c.lastClosable = a;
            c.clearTargetCache()
        }
        c.callParent(arguments)
    }
});
Ext.define("Ext.layout.container.Card", {
    extend: "Ext.layout.container.Fit",
    alternateClassName: "Ext.layout.CardLayout",
    alias: "layout.card",
    type: "card",
    hideInactive: true,
    deferredRender: false,
    getRenderTree: function() {
        var a = this,
            c = a.getActiveItem();
        if (c) {
            if (c.hasListeners.beforeactivate && c.fireEvent("beforeactivate", c) === false) {
                c = a.activeItem = a.owner.activeItem = null
            } else {
                if (c.hasListeners.activate) {
                    c.on({
                        boxready: function() {
                            c.fireEvent("activate", c)
                        },
                        single: true
                    })
                }
            }
            if (a.deferredRender) {
                if (c) {
                    return a.getItemsRenderTree([c])
                }
            } else {
                return a.callParent(arguments)
            }
        }
    },
    renderChildren: function() {
        var a = this,
            c = a.getActiveItem();
        if (!a.deferredRender) {
            a.callParent()
        } else {
            if (c) {
                a.renderItems([c], a.getRenderTarget())
            }
        }
    },
    isValidParent: function(d, e, a) {
        var c = d.el ? d.el.dom : Ext.getDom(d);
        return (c && c.parentNode === (e.dom || e)) || false
    },
    getActiveItem: function() {
        var c = this,
            a = c.parseActiveItem(c.activeItem || (c.owner && c.owner.activeItem));
        if (a && c.owner.items.indexOf(a) != -1) {
            c.activeItem = a
        } else {
            c.activeItem = null
        }
        return c.activeItem
    },
    parseActiveItem: function(a) {
        if (a && a.isComponent) {
            return a
        } else {
            if (typeof a == "number" || a === undefined) {
                return this.getLayoutItems()[a || 0]
            } else {
                return this.owner.getComponent(a)
            }
        }
    },
    configureItem: function(a) {
        if (a === this.getActiveItem()) {
            a.hidden = false
        } else {
            a.hidden = true
        }
        this.callParent(arguments)
    },
    onRemove: function(a) {
        var c = this;
        if (a === c.activeItem) {
            c.activeItem = null
        }
    },
    getAnimation: function(c, a) {
        var d = (c || {}).cardSwitchAnimation;
        if (d === false) {
            return false
        }
        return d || a.cardSwitchAnimation
    },
    getNext: function() {
        var d = arguments[0],
            a = this.getLayoutItems(),
            c = Ext.Array.indexOf(a, this.activeItem);
        return a[c + 1] || (d ? a[0] : false)
    },
    next: function() {
        var c = arguments[0],
            a = arguments[1];
        return this.setActiveItem(this.getNext(a), c)
    },
    getPrev: function() {
        var d = arguments[0],
            a = this.getLayoutItems(),
            c = Ext.Array.indexOf(a, this.activeItem);
        return a[c - 1] || (d ? a[a.length - 1] : false)
    },
    prev: function() {
        var c = arguments[0],
            a = arguments[1];
        return this.setActiveItem(this.getPrev(a), c)
    },
    setActiveItem: function(c) {
        var g = this,
            a = g.owner,
            e = g.activeItem,
            i = a.rendered,
            d;
        c = g.parseActiveItem(c);
        d = a.items.indexOf(c);
        if (d == -1) {
            d = a.items.items.length;
            Ext.suspendLayouts();
            c = a.add(c);
            Ext.resumeLayouts()
        }
        if (c && e != c) {
            if (c.fireEvent("beforeactivate", c, e) === false) {
                return false
            }
            if (e && e.fireEvent("beforedeactivate", e, c) === false) {
                return false
            }
            if (i) {
                Ext.suspendLayouts();
                if (!c.rendered) {
                    g.renderItem(c, g.getRenderTarget(), a.items.length)
                }
                if (e) {
                    if (g.hideInactive) {
                        e.hide();
                        e.hiddenByLayout = true
                    }
                    e.fireEvent("deactivate", e, c)
                }
                if (c.hidden) {
                    c.show()
                }
                if (!c.hidden) {
                    g.activeItem = c
                }
                Ext.resumeLayouts(true)
            } else {
                g.activeItem = c
            }
            c.fireEvent("activate", c, e);
            return g.activeItem
        }
        return false
    }
});
Ext.define("Ext.menu.Item", {
    extend: "Ext.Component",
    alias: "widget.menuitem",
    alternateClassName: "Ext.menu.TextItem",
    activeCls: Ext.baseCSSPrefix + "menu-item-active",
    ariaRole: "menuitem",
    canActivate: true,
    clickHideDelay: 1,
    destroyMenu: true,
    disabledCls: Ext.baseCSSPrefix + "menu-item-disabled",
    hideOnClick: true,
    isMenuItem: true,
    menuAlign: "tl-tr?",
    menuExpandDelay: 200,
    menuHideDelay: 200,
    tooltipType: "qtip",
    arrowCls: Ext.baseCSSPrefix + "menu-item-arrow",
    childEls: ["itemEl", "iconEl", "textEl", "arrowEl"],
    renderTpl: ['<tpl if="plain">', "{text}", "<tpl else>", '<a id="{id}-itemEl" class="' + Ext.baseCSSPrefix + 'menu-item-link" href="{href}" <tpl if="hrefTarget">target="{hrefTarget}"</tpl> hidefocus="true" unselectable="on">', '<img id="{id}-iconEl" src="{icon}" class="' + Ext.baseCSSPrefix + 'menu-item-icon {iconCls}" />', '<span id="{id}-textEl" class="' + Ext.baseCSSPrefix + 'menu-item-text" <tpl if="arrowCls">style="margin-right: 17px;"</tpl> >{text}</span>', '<img id="{id}-arrowEl" src="{blank}" class="{arrowCls}" />', "</a>", "</tpl>"],
    maskOnDisable: false,
    activate: function() {
        var a = this;
        if (!a.activated && a.canActivate && a.rendered && !a.isDisabled() && a.isVisible()) {
            a.el.addCls(a.activeCls);
            a.focus();
            a.activated = true;
            a.fireEvent("activate", a)
        }
    },
    getFocusEl: function() {
        return this.itemEl
    },
    deactivate: function() {
        var a = this;
        if (a.activated) {
            a.el.removeCls(a.activeCls);
            a.blur();
            a.hideMenu();
            a.activated = false;
            a.fireEvent("deactivate", a)
        }
    },
    deferExpandMenu: function() {
        var a = this;
        if (a.activated && (!a.menu.rendered || !a.menu.isVisible())) {
            a.parentMenu.activeChild = a.menu;
            a.menu.parentItem = a;
            a.menu.parentMenu = a.menu.ownerCt = a.parentMenu;
            a.menu.showBy(a, a.menuAlign)
        }
    },
    deferHideMenu: function() {
        if (this.menu.isVisible()) {
            this.menu.hide()
        }
    },
    cancelDeferHide: function() {
        clearTimeout(this.hideMenuTimer)
    },
    deferHideParentMenus: function() {
        var a;
        Ext.menu.Manager.hideAll();
        if (!Ext.Element.getActiveElement()) {
            a = this.up(":not([hidden])");
            if (a) {
                a.focus()
            }
        }
    },
    expandMenu: function(a) {
        var c = this;
        if (c.menu) {
            c.cancelDeferHide();
            if (a === 0) {
                c.deferExpandMenu()
            } else {
                c.expandMenuTimer = Ext.defer(c.deferExpandMenu, Ext.isNumber(a) ? a : c.menuExpandDelay, c)
            }
        }
    },
    getRefItems: function(a) {
        var d = this.menu,
            c;
        if (d) {
            c = d.getRefItems(a);
            c.unshift(d)
        }
        return c || []
    },
    hideMenu: function(a) {
        var c = this;
        if (c.menu) {
            clearTimeout(c.expandMenuTimer);
            c.hideMenuTimer = Ext.defer(c.deferHideMenu, Ext.isNumber(a) ? a : c.menuHideDelay, c)
        }
    },
    initComponent: function() {
        var c = this,
            d = Ext.baseCSSPrefix,
            a = [d + "menu-item"],
            e;
        c.addEvents("activate", "click", "deactivate");
        if (c.plain) {
            a.push(d + "menu-item-plain")
        }
        if (c.cls) {
            a.push(c.cls)
        }
        c.cls = a.join(" ");
        if (c.menu) {
            e = c.menu;
            delete c.menu;
            c.setMenu(e)
        }
        c.callParent(arguments)
    },
    onClick: function(c) {
        var a = this;
        if (!a.href) {
            c.stopEvent()
        }
        if (a.disabled) {
            return
        }
        if (a.hideOnClick) {
            a.deferHideParentMenusTimer = Ext.defer(a.deferHideParentMenus, a.clickHideDelay, a)
        }
        Ext.callback(a.handler, a.scope || a, [a, c]);
        a.fireEvent("click", a, c);
        if (!a.hideOnClick) {
            a.focus()
        }
    },
    onRemoved: function() {
        var a = this;
        if (a.activated && a.parentMenu.activeItem === a) {
            a.parentMenu.deactivateActiveItem()
        }
        a.callParent(arguments);
        delete a.parentMenu;
        delete a.ownerButton
    },
    beforeDestroy: function() {
        var a = this;
        if (a.rendered) {
            a.clearTip()
        }
        a.callParent()
    },
    onDestroy: function() {
        var a = this;
        clearTimeout(a.expandMenuTimer);
        a.cancelDeferHide();
        clearTimeout(a.deferHideParentMenusTimer);
        a.setMenu(null);
        a.callParent(arguments)
    },
    beforeRender: function() {
        var c = this,
            e = Ext.BLANK_IMAGE_URL,
            a, d;
        c.callParent();
        if (c.iconAlign === "right") {
            a = c.checkChangeDisabled ? c.disabledCls : "";
            d = Ext.baseCSSPrefix + "menu-item-icon-right " + c.iconCls
        } else {
            a = c.iconCls + (c.checkChangeDisabled ? " " + c.disabledCls : "");
            d = c.menu ? c.arrowCls : ""
        }
        Ext.applyIf(c.renderData, {
            href: c.href || "#",
            hrefTarget: c.hrefTarget,
            icon: c.icon || e,
            iconCls: a,
            plain: c.plain,
            text: c.text,
            arrowCls: d,
            blank: e
        })
    },
    onRender: function() {
        var a = this;
        a.callParent(arguments);
        if (a.tooltip) {
            a.setTooltip(a.tooltip, true)
        }
    },
    setMenu: function(g, e) {
        var d = this,
            c = d.menu,
            a = d.arrowEl;
        if (c) {
            delete c.parentItem;
            delete c.parentMenu;
            delete c.ownerCt;
            delete c.ownerItem;
            if (e === true || (e !== false && d.destroyMenu)) {
                Ext.destroy(c)
            }
        }
        if (g) {
            d.menu = Ext.menu.Manager.get(g);
            d.menu.ownerItem = d
        } else {
            d.menu = null
        }
        if (d.rendered && !d.destroying && a) {
            a[d.menu ? "addCls" : "removeCls"](d.arrowCls)
        }
    },
    setHandler: function(c, a) {
        this.handler = c || null;
        this.scope = a
    },
    setIcon: function(c) {
        var a = this.iconEl;
        if (a) {
            a.src = c || Ext.BLANK_IMAGE_URL
        }
        this.icon = c
    },
    setIconCls: function(c) {
        var d = this,
            a = d.iconEl;
        if (a) {
            if (d.iconCls) {
                a.removeCls(d.iconCls)
            }
            if (c) {
                a.addCls(c)
            }
        }
        d.iconCls = c
    },
    setText: function(d) {
        var c = this,
            a = c.textEl || c.el;
        c.text = d;
        if (c.rendered) {
            a.update(d || "");
            c.ownerCt.updateLayout()
        }
    },
    getTipAttr: function() {
        return this.tooltipType == "qtip" ? "data-qtip" : "title"
    },
    clearTip: function() {
        if (Ext.isObject(this.tooltip)) {
            Ext.tip.QuickTipManager.unregister(this.itemEl)
        }
    },
    setTooltip: function(d, a) {
        var c = this;
        if (c.rendered) {
            if (!a) {
                c.clearTip()
            }
            if (Ext.isObject(d)) {
                Ext.tip.QuickTipManager.register(Ext.apply({
                    target: c.itemEl.id
                }, d));
                c.tooltip = d
            } else {
                c.itemEl.dom.setAttribute(c.getTipAttr(), d)
            }
        } else {
            c.tooltip = d
        }
        return c
    }
});
Ext.define("Ext.menu.CheckItem", {
    extend: "Ext.menu.Item",
    alias: "widget.menucheckitem",
    checkedCls: Ext.baseCSSPrefix + "menu-item-checked",
    uncheckedCls: Ext.baseCSSPrefix + "menu-item-unchecked",
    groupCls: Ext.baseCSSPrefix + "menu-group-icon",
    hideOnClick: false,
    checkChangeDisabled: false,
    afterRender: function() {
        var a = this;
        a.callParent();
        a.checked = !a.checked;
        a.setChecked(!a.checked, true);
        if (a.checkChangeDisabled) {
            a.disableCheckChange()
        }
    },
    initComponent: function() {
        var a = this;
        a.addEvents("beforecheckchange", "checkchange");
        a.callParent(arguments);
        Ext.menu.Manager.registerCheckable(a);
        if (a.group) {
            if (!a.iconCls) {
                a.iconCls = a.groupCls
            }
            if (a.initialConfig.hideOnClick !== false) {
                a.hideOnClick = true
            }
        }
    },
    disableCheckChange: function() {
        var c = this,
            a = c.iconEl;
        if (a) {
            a.addCls(c.disabledCls)
        }
        if (!(Ext.isIE9 && Ext.isStrict) && c.rendered) {
            c.el.repaint()
        }
        c.checkChangeDisabled = true
    },
    enableCheckChange: function() {
        var c = this,
            a = c.iconEl;
        if (a) {
            a.removeCls(c.disabledCls)
        }
        c.checkChangeDisabled = false
    },
    onClick: function(c) {
        var a = this;
        if (!a.disabled && !a.checkChangeDisabled && !(a.checked && a.group)) {
            a.setChecked(!a.checked)
        }
        this.callParent([c])
    },
    onDestroy: function() {
        Ext.menu.Manager.unregisterCheckable(this);
        this.callParent(arguments)
    },
    setChecked: function(d, a) {
        var c = this;
        if (c.checked !== d && (a || c.fireEvent("beforecheckchange", c, d) !== false)) {
            if (c.el) {
                c.el[d ? "addCls" : "removeCls"](c.checkedCls)[!d ? "addCls" : "removeCls"](c.uncheckedCls)
            }
            c.checked = d;
            Ext.menu.Manager.onCheckChange(c, d);
            if (!a) {
                Ext.callback(c.checkHandler, c.scope, [c, d]);
                c.fireEvent("checkchange", c, d)
            }
        }
    }
});
Ext.define("Ext.menu.KeyNav", {
    extend: "Ext.util.KeyNav",
    requires: ["Ext.FocusManager"],
    constructor: function(c) {
        var a = this;
        a.menu = c;
        a.callParent([c.el, {
            down: a.down,
            enter: a.enter,
            esc: a.escape,
            left: a.left,
            right: a.right,
            space: a.enter,
            tab: a.tab,
            up: a.up
        }])
    },
    down: function(c) {
        var a = this,
            d = a.menu.focusedItem;
        if (d && c.getKey() == Ext.EventObject.DOWN && a.isWhitelisted(d)) {
            return true
        }
        a.focusNextItem(1)
    },
    enter: function(c) {
        var d = this.menu,
            a = d.focusedItem;
        if (d.activeItem) {
            d.onClick(c)
        } else {
            if (a && a.isFormField) {
                return true
            }
        }
    },
    escape: function(a) {
        Ext.menu.Manager.hideAll()
    },
    focusNextItem: function(i) {
        var j = this.menu,
            c = j.items,
            e = j.focusedItem,
            d = e ? c.indexOf(e) : -1,
            a = d + i,
            g;
        while (a != d) {
            if (a < 0) {
                a = c.length - 1
            } else {
                if (a >= c.length) {
                    a = 0
                }
            }
            g = c.getAt(a);
            if (j.canActivateItem(g)) {
                j.setActiveItem(g);
                break
            }
            a += i
        }
    },
    isWhitelisted: function(a) {
        return Ext.FocusManager.isWhitelisted(a)
    },
    left: function(c) {
        var d = this.menu,
            g = d.focusedItem,
            a = d.activeItem;
        if (g && this.isWhitelisted(g)) {
            return true
        }
        d.hide();
        if (d.parentMenu) {
            d.parentMenu.focus()
        }
    },
    right: function(d) {
        var g = this.menu,
            i = g.focusedItem,
            a = g.activeItem,
            c;
        if (i && this.isWhitelisted(i)) {
            return true
        }
        if (a) {
            c = g.activeItem.menu;
            if (c) {
                a.expandMenu(0);
                Ext.defer(function() {
                    c.setActiveItem(c.items.getAt(0))
                }, 25)
            }
        }
    },
    tab: function(c) {
        var a = this;
        if (c.shiftKey) {
            a.up(c)
        } else {
            a.down(c)
        }
    },
    up: function(c) {
        var a = this,
            d = a.menu.focusedItem;
        if (d && c.getKey() == Ext.EventObject.UP && a.isWhitelisted(d)) {
            return true
        }
        a.focusNextItem(-1)
    }
});
Ext.define("Ext.menu.Separator", {
    extend: "Ext.menu.Item",
    alias: "widget.menuseparator",
    canActivate: false,
    focusable: false,
    hideOnClick: false,
    plain: true,
    separatorCls: Ext.baseCSSPrefix + "menu-item-separator",
    text: "&#160;",
    beforeRender: function(a, d) {
        var c = this;
        c.callParent();
        c.addCls(c.separatorCls)
    }
});
Ext.define("Ext.menu.Menu", {
    extend: "Ext.panel.Panel",
    alias: "widget.menu",
    requires: ["Ext.layout.container.Fit", "Ext.layout.container.VBox", "Ext.menu.CheckItem", "Ext.menu.Item", "Ext.menu.KeyNav", "Ext.menu.Manager", "Ext.menu.Separator"],
    enableKeyNav: true,
    allowOtherMenus: false,
    ariaRole: "menu",
    defaultAlign: "tl-bl?",
    floating: true,
    constrain: true,
    hidden: true,
    hideMode: "visibility",
    ignoreParentClicks: false,
    isMenu: true,
    showSeparator: true,
    minWidth: undefined,
    defaultMinWidth: 120,
    initComponent: function() {
        var c = this,
            e = Ext.baseCSSPrefix,
            a = [e + "menu"],
            d = c.bodyCls ? [c.bodyCls] : [],
            g = c.floating !== false;
        c.addEvents("click", "mouseenter", "mouseleave", "mouseover");
        Ext.menu.Manager.register(c);
        if (c.plain) {
            a.push(e + "menu-plain")
        }
        c.cls = a.join(" ");
        d.unshift(e + "menu-body");
        c.bodyCls = d.join(" ");
        if (!c.layout) {
            c.layout = {
                type: "vbox",
                align: "stretchmax",
                overflowHandler: "Scroller"
            }
        }
        if (g && c.minWidth === undefined) {
            c.minWidth = c.defaultMinWidth
        }
        if (!g && c.initialConfig.hidden !== true) {
            c.hidden = false
        }
        c.callParent(arguments);
        c.on("beforeshow", function() {
            var i = !!c.items.length;
            if (i && c.rendered) {
                c.el.setStyle("visibility", null)
            }
            return i
        })
    },
    beforeRender: function() {
        this.callParent(arguments);
        if (!this.getSizeModel().width.shrinkWrap) {
            this.layout.align = "stretch"
        }
    },
    onBoxReady: function() {
        var a = this,
            c;
        a.callParent(arguments);
        if (a.showSeparator) {
            c = {
                cls: Ext.baseCSSPrefix + "menu-icon-separator",
                html: "&#160;"
            };
            if ((!Ext.isStrict && Ext.isIE) || Ext.isIE6) {
                c.style = "height:" + a.el.getHeight() + "px"
            }
            a.iconSepEl = a.layout.getElementTarget().insertFirst(c)
        }
        a.mon(a.el, {
            click: a.onClick,
            mouseover: a.onMouseOver,
            scope: a
        });
        a.mouseMonitor = a.el.monitorMouseLeave(100, a.onMouseLeave, a);
        if (a.enableKeyNav) {
            a.keyNav = new Ext.menu.KeyNav(a)
        }
    },
    getBubbleTarget: function() {
        return this.parentMenu || this.ownerButton || this.callParent(arguments)
    },
    canActivateItem: function(a) {
        return a && !a.isDisabled() && a.isVisible() && (a.canActivate || a.getXTypes().indexOf("menuitem") < 0)
    },
    deactivateActiveItem: function(c) {
        var d = this,
            e = d.activeItem,
            a = d.focusedItem;
        if (e) {
            e.deactivate();
            if (!e.activated) {
                delete d.activeItem
            }
        }
        if (a && c) {
            a.blur();
            delete d.focusedItem
        }
    },
    getFocusEl: function() {
        return this.focusedItem || this.el
    },
    hide: function() {
        this.deactivateActiveItem(true);
        this.callParent(arguments)
    },
    getItemFromEvent: function(a) {
        return this.getChildByElement(a.getTarget())
    },
    lookupComponent: function(c) {
        var a = this;
        if (typeof c == "string") {
            c = a.lookupItemFromString(c)
        } else {
            if (Ext.isObject(c)) {
                c = a.lookupItemFromObject(c)
            }
        }
        c.minWidth = c.minWidth || a.minWidth;
        return c
    },
    lookupItemFromObject: function(d) {
        var c = this,
            e = Ext.baseCSSPrefix,
            a;
        if (!d.isComponent) {
            if (!d.xtype) {
                d = Ext.create("Ext.menu." + (Ext.isBoolean(d.checked) ? "Check" : "") + "Item", d)
            } else {
                d = Ext.ComponentManager.create(d, d.xtype)
            }
        }
        if (d.isMenuItem) {
            d.parentMenu = c
        }
        if (!d.isMenuItem && !d.dock) {
            a = [e + "menu-item", e + "menu-item-cmp"];
            if (!c.plain && (d.indent === true || d.iconCls === "no-icon")) {
                a.push(e + "menu-item-indent")
            }
            if (d.rendered) {
                d.el.addCls(a)
            } else {
                d.cls = (d.cls ? d.cls : "") + " " + a.join(" ")
            }
        }
        return d
    },
    lookupItemFromString: function(a) {
        return (a == "separator" || a == "-") ? new Ext.menu.Separator() : new Ext.menu.Item({
            canActivate: false,
            hideOnClick: false,
            plain: true,
            text: a
        })
    },
    onClick: function(d) {
        var c = this,
            a;
        if (c.disabled) {
            d.stopEvent();
            return
        }
        a = (d.type === "click") ? c.getItemFromEvent(d) : c.activeItem;
        if (a && a.isMenuItem) {
            if (!a.menu || !c.ignoreParentClicks) {
                a.onClick(d)
            } else {
                d.stopEvent()
            }
        }
        if (!a || a.disabled) {
            a = undefined
        }
        c.fireEvent("click", c, a, d)
    },
    onDestroy: function() {
        var a = this;
        Ext.menu.Manager.unregister(a);
        delete a.parentMenu;
        delete a.ownerButton;
        if (a.rendered) {
            a.el.un(a.mouseMonitor);
            Ext.destroy(a.keyNav);
            delete a.keyNav
        }
        a.callParent(arguments)
    },
    onMouseLeave: function(c) {
        var a = this;
        a.deactivateActiveItem();
        if (a.disabled) {
            return
        }
        a.fireEvent("mouseleave", a, c)
    },
    onMouseOver: function(j) {
        var i = this,
            k = j.getRelatedTarget(),
            c = !i.el.contains(k),
            g = i.getItemFromEvent(j),
            d = i.parentMenu,
            a = i.parentItem;
        if (c && d) {
            d.setActiveItem(a);
            a.cancelDeferHide();
            d.mouseMonitor.mouseenter()
        }
        if (i.disabled) {
            return
        }
        if (g && !g.activated) {
            i.setActiveItem(g);
            if (g.activated && g.expandMenu) {
                g.expandMenu()
            }
        }
        if (c) {
            i.fireEvent("mouseenter", i, j)
        }
        i.fireEvent("mouseover", i, g, j)
    },
    setActiveItem: function(c) {
        var a = this;
        if (c && (c != a.activeItem)) {
            a.deactivateActiveItem();
            if (a.canActivateItem(c)) {
                if (c.activate) {
                    c.activate();
                    if (c.activated) {
                        a.activeItem = c;
                        a.focusedItem = c;
                        a.focus()
                    }
                } else {
                    c.focus();
                    a.focusedItem = c
                }
            }
            c.el.scrollIntoView(a.layout.getRenderTarget())
        }
    },
    showBy: function(c, e, d) {
        var a = this;
        if (a.floating && c) {
            a.show();
            a.setPagePosition(a.el.getAlignToXY(c.el || c, e || a.defaultAlign, d));
            a.setVerticalPosition()
        }
        return a
    },
    show: function() {
        var e = this,
            d, c, a, g = e.maxHeight;
        if (!e.rendered) {
            e.doAutoRender()
        }
        if (e.floating) {
            d = Ext.fly(e.el.getScopeParent());
            c = d.getViewSize().height;
            e.maxHeight = Math.min(g || c, c)
        }
        a = e.callParent(arguments);
        e.maxHeight = g;
        return a
    },
    afterComponentLayout: function(d, a, c, g) {
        var e = this;
        e.callParent(arguments);
        if (e.showSeparator) {
            e.iconSepEl.setHeight(e.componentLayout.lastComponentSize.contentHeight)
        }
    },
    setVerticalPosition: function() {
        var e = this,
            i, g = e.el.getY(),
            j = g,
            l = e.getHeight(),
            c = Ext.Element.getViewportHeight().height,
            d = Ext.fly(e.el.getScopeParent()),
            a = d.getViewSize().height,
            k = g - d.getScroll().top;
        d = null;
        if (e.floating) {
            i = e.maxHeight ? e.maxHeight : a - k;
            if (l > a) {
                j = g - k
            } else {
                if (i < l) {
                    j = g - (l - i)
                } else {
                    if ((g + l) > c) {
                        j = c - l
                    }
                }
            }
        }
        e.el.setY(j)
    }
});
Ext.define("Ext.panel.Tool", {
    extend: "Ext.Component",
    requires: ["Ext.tip.QuickTipManager"],
    alias: "widget.tool",
    baseCls: Ext.baseCSSPrefix + "tool",
    disabledCls: Ext.baseCSSPrefix + "tool-disabled",
    toolPressedCls: Ext.baseCSSPrefix + "tool-pressed",
    toolOverCls: Ext.baseCSSPrefix + "tool-over",
    ariaRole: "button",
    childEls: ["toolEl"],
    renderTpl: ['<img id="{id}-toolEl" src="{blank}" class="{baseCls}-{type}" role="presentation"/>'],
    tooltipType: "qtip",
    stopEvent: true,
    height: 15,
    width: 15,
    initComponent: function() {
        var a = this;
        a.addEvents("click");
        a.type = a.type || a.id;
        Ext.applyIf(a.renderData, {
            baseCls: a.baseCls,
            blank: Ext.BLANK_IMAGE_URL,
            type: a.type
        });
        a.tooltip = a.tooltip || a.qtip;
        a.callParent();
        a.on({
            element: "toolEl",
            click: a.onClick,
            mousedown: a.onMouseDown,
            mouseover: a.onMouseOver,
            mouseout: a.onMouseOut,
            scope: a
        })
    },
    afterRender: function() {
        var c = this,
            a;
        c.callParent(arguments);
        if (c.tooltip) {
            if (Ext.isObject(c.tooltip)) {
                Ext.tip.QuickTipManager.register(Ext.apply({
                    target: c.id
                }, c.tooltip))
            } else {
                a = c.tooltipType == "qtip" ? "data-qtip" : "title";
                c.toolEl.dom.setAttribute(a, c.tooltip)
            }
        }
    },
    getFocusEl: function() {
        return this.el
    },
    setType: function(a) {
        var c = this;
        c.type = a;
        if (c.rendered) {
            c.toolEl.dom.className = c.baseCls + "-" + a
        }
        return c
    },
    bindTo: function(a) {
        this.owner = a
    },
    onClick: function(g, d) {
        var c = this,
            a;
        if (c.disabled) {
            return false
        }
        a = c.owner || c.ownerCt;
        c.el.removeCls(c.toolPressedCls);
        c.el.removeCls(c.toolOverCls);
        if (c.stopEvent !== false) {
            g.stopEvent()
        }
        Ext.callback(c.handler, c.scope || c, [g, d, a, c]);
        c.fireEvent("click", c, g);
        return true
    },
    onDestroy: function() {
        if (Ext.isObject(this.tooltip)) {
            Ext.tip.QuickTipManager.unregister(this.id)
        }
        this.callParent()
    },
    onMouseDown: function() {
        if (this.disabled) {
            return false
        }
        this.el.addCls(this.toolPressedCls)
    },
    onMouseOver: function() {
        if (this.disabled) {
            return false
        }
        this.el.addCls(this.toolOverCls)
    },
    onMouseOut: function() {
        this.el.removeCls(this.toolOverCls)
    }
});
Ext.define("Ext.resizer.SplitterTracker", {
    extend: "Ext.dd.DragTracker",
    requires: ["Ext.util.Region"],
    enabled: true,
    overlayCls: Ext.baseCSSPrefix + "resizable-overlay",
    createDragOverlay: function() {
        var a;
        a = this.overlay = Ext.getBody().createChild({
            cls: this.overlayCls,
            html: "&#160;"
        });
        a.unselectable();
        a.setSize(Ext.Element.getViewWidth(true), Ext.Element.getViewHeight(true));
        a.show()
    },
    getPrevCmp: function() {
        var a = this.getSplitter();
        return a.previousSibling()
    },
    getNextCmp: function() {
        var a = this.getSplitter();
        return a.nextSibling()
    },
    onBeforeStart: function(k) {
        var g = this,
            i = g.getPrevCmp(),
            a = g.getNextCmp(),
            d = g.getSplitter().collapseEl,
            j = k.getTarget(),
            c;
        if (d && j === g.getSplitter().collapseEl.dom) {
            return false
        }
        if (a.collapsed || i.collapsed) {
            return false
        }
        g.prevBox = i.getEl().getBox();
        g.nextBox = a.getEl().getBox();
        g.constrainTo = c = g.calculateConstrainRegion();
        if (!c) {
            return false
        }
        g.createDragOverlay();
        return c
    },
    onStart: function(c) {
        var a = this.getSplitter();
        a.addCls(a.baseCls + "-active")
    },
    calculateConstrainRegion: function() {
        var i = this,
            a = i.getSplitter(),
            j = a.getWidth(),
            k = a.defaultSplitMin,
            c = a.orientation,
            e = i.prevBox,
            l = i.getPrevCmp(),
            d = i.nextBox,
            g = i.getNextCmp(),
            n, m;
        if (c === "vertical") {
            n = new Ext.util.Region(e.y, (l.maxWidth ? e.x + l.maxWidth : d.right - (g.minWidth || k)) + j, e.bottom, e.x + (l.minWidth || k));
            m = new Ext.util.Region(d.y, d.right - (g.minWidth || k), d.bottom, (g.maxWidth ? d.right - g.maxWidth : e.x + (e.minWidth || k)) - j)
        } else {
            n = new Ext.util.Region(e.y + (l.minHeight || k), e.right, (l.maxHeight ? e.y + l.maxHeight : d.bottom - (g.minHeight || k)) + j, e.x);
            m = new Ext.util.Region((g.maxHeight ? d.bottom - g.maxHeight : e.y + (l.minHeight || k)) - j, d.right, d.bottom - (g.minHeight || k), d.x)
        }
        return n.intersect(m)
    },
    performResize: function(o, j) {
        var q = this,
            a = q.getSplitter(),
            k = a.orientation,
            r = q.getPrevCmp(),
            p = q.getNextCmp(),
            c = a.ownerCt,
            m = c.query(">[flex]"),
            n = m.length,
            l = 0,
            g, s, d = 0;
        for (; l < n; l++) {
            s = m[l].getWidth();
            d += s;
            m[l].flex = s
        }
        j = j || q.getOffset("dragTarget");
        if (k === "vertical") {
            j = j[0];
            g = "width"
        } else {
            g = "height";
            j = j[1]
        }
        if (r) {
            s = q.prevBox[g] + j;
            if (r.flex) {
                r.flex = s
            } else {
                r[g] = s
            }
        }
        if (p) {
            s = q.nextBox[g] - j;
            if (p.flex) {
                p.flex = s
            } else {
                p[g] = s
            }
        }
        c.updateLayout()
    },
    endDrag: function() {
        var a = this;
        if (a.overlay) {
            a.overlay.remove();
            delete a.overlay
        }
        a.callParent(arguments)
    },
    onEnd: function(d) {
        var a = this,
            c = a.getSplitter();
        c.removeCls(c.baseCls + "-active");
        a.performResize(d, a.getOffset("dragTarget"))
    },
    onDrag: function(i) {
        var d = this,
            j = d.getOffset("dragTarget"),
            g = d.getSplitter(),
            c = g.getEl(),
            a = g.orientation;
        if (a === "vertical") {
            c.setX(d.startRegion.left + j[0])
        } else {
            c.setY(d.startRegion.top + j[1])
        }
    },
    getSplitter: function() {
        return this.splitter
    }
});
Ext.define("Ext.resizer.BorderSplitterTracker", {
    extend: "Ext.resizer.SplitterTracker",
    requires: ["Ext.util.Region"],
    getPrevCmp: null,
    getNextCmp: null,
    calculateConstrainRegion: function() {
        var B = this,
            a = B.splitter,
            q = a.collapseTarget,
            e = a.defaultSplitMin,
            k = a.vertical ? "Width" : "Height",
            d = "min" + k,
            x = "max" + k,
            l = "get" + k,
            v = a.neighbors,
            g = v.length,
            p = q.el.getBox(),
            j = p.x,
            r = p.y,
            A = p.right,
            m = p.bottom,
            t = a.vertical ? (A - j) : (m - r),
            z, n, o, y, u, s, c;
        o = (q[d] || Math.min(t, e)) - t;
        y = q[x];
        if (!y) {
            y = 1000000000
        } else {
            y -= t
        }
        c = t;
        for (z = 0; z < g; ++z) {
            n = v[z];
            t = n[l]();
            u = t - n[x];
            s = t - (n[d] || Math.min(t, e));
            if (!isNaN(u)) {
                if (o < u) {
                    o = u
                }
            }
            if (y > s) {
                y = s
            }
        }
        if (y - o < 2) {
            return null
        }
        p = new Ext.util.Region(r, A, m, j);
        B.constraintAdjusters[a.collapseDirection](p, o, y, a);
        B.dragInfo = {
            minRange: o,
            maxRange: y,
            targetSize: c
        };
        return p
    },
    constraintAdjusters: {
        left: function(d, a, c, e) {
            d[0] = d.x = d.left = d.right + a;
            d.right += c + e.getWidth()
        },
        top: function(d, a, c, e) {
            d[1] = d.y = d.top = d.bottom + a;
            d.bottom += c + e.getHeight()
        },
        bottom: function(d, a, c, e) {
            d.bottom = d.top - a;
            d.top -= c + e.getHeight()
        },
        right: function(d, a, c, e) {
            d.right = d.left - a;
            d.left -= c + e.getWidth()
        }
    },
    onBeforeStart: function(k) {
        var m = this,
            c = m.splitter,
            a = c.collapseTarget,
            o = c.neighbors,
            g = m.getSplitter().collapseEl,
            l = k.getTarget(),
            d = o.length,
            j, n;
        if (g && l === c.collapseEl.dom) {
            return false
        }
        if (a.collapsed) {
            return false
        }
        for (j = 0; j < d; ++j) {
            n = o[j];
            if (n.collapsed && n.isHorz === a.isHorz) {
                return false
            }
        }
        if (!(m.constrainTo = m.calculateConstrainRegion())) {
            return false
        }
        m.createDragOverlay();
        return true
    },
    performResize: function(l, k) {
        var m = this,
            c = m.splitter,
            j = c.collapseDirection,
            a = c.collapseTarget,
            i = m.splitAdjusters[c.vertical ? "horz" : "vert"],
            n = k[i.index],
            g = m.dragInfo,
            d;
        if (j == "right" || j == "bottom") {
            n = -n
        }
        n = Math.min(Math.max(g.minRange, n), g.maxRange);
        if (n) {
            (d = c.ownerCt).suspendLayouts();
            i.adjustTarget(a, g.targetSize, n);
            d.resumeLayouts(true)
        }
    },
    splitAdjusters: {
        horz: {
            index: 0,
            adjustTarget: function(c, a, d) {
                c.flex = null;
                c.setSize(a + d)
            }
        },
        vert: {
            index: 1,
            adjustTarget: function(c, a, d) {
                c.flex = null;
                c.setSize(undefined, a + d)
            }
        }
    }
});
Ext.define("Ext.resizer.ResizeTracker", {
    extend: "Ext.dd.DragTracker",
    dynamic: true,
    preserveRatio: false,
    constrainTo: null,
    proxyCls: Ext.baseCSSPrefix + "resizable-proxy",
    constructor: function(c) {
        var e = this,
            d, a, g;
        if (!c.el) {
            if (c.target.isComponent) {
                e.el = c.target.getEl()
            } else {
                e.el = c.target
            }
        }
        this.callParent(arguments);
        if (e.preserveRatio && e.minWidth && e.minHeight) {
            d = e.minWidth / e.el.getWidth();
            a = e.minHeight / e.el.getHeight();
            if (a > d) {
                e.minWidth = e.el.getWidth() * a
            } else {
                e.minHeight = e.el.getHeight() * d
            }
        }
        if (e.throttle) {
            g = Ext.Function.createThrottled(function() {
                Ext.resizer.ResizeTracker.prototype.resize.apply(e, arguments)
            }, e.throttle);
            e.resize = function(j, k, i) {
                if (i) {
                    Ext.resizer.ResizeTracker.prototype.resize.apply(e, arguments)
                } else {
                    g.apply(null, arguments)
                }
            }
        }
    },
    onBeforeStart: function(a) {
        this.startBox = this.el.getBox()
    },
    getDynamicTarget: function() {
        var a = this,
            c = a.target;
        if (a.dynamic) {
            return c
        } else {
            if (!a.proxy) {
                a.proxy = a.createProxy(c)
            }
        }
        a.proxy.show();
        return a.proxy
    },
    createProxy: function(d) {
        var c, a = this.proxyCls,
            e;
        if (d.isComponent) {
            c = d.getProxy().addCls(a)
        } else {
            e = Ext.getBody();
            if (Ext.scopeResetCSS) {
                e = Ext.getBody().createChild({
                    cls: Ext.resetCls
                })
            }
            c = d.createProxy({
                tag: "div",
                cls: a,
                id: d.id + "-rzproxy"
            }, e)
        }
        c.removeCls(Ext.baseCSSPrefix + "proxy-el");
        return c
    },
    onStart: function(a) {
        this.activeResizeHandle = Ext.get(this.getDragTarget().id);
        if (!this.dynamic) {
            this.resize(this.startBox, {
                horizontal: "none",
                vertical: "none"
            })
        }
    },
    onDrag: function(a) {
        if (this.dynamic || this.proxy) {
            this.updateDimensions(a)
        }
    },
    updateDimensions: function(u, o) {
        var v = this,
            d = v.activeResizeHandle.region,
            i = v.getOffset(v.constrainTo ? "dragTarget" : null),
            m = v.startBox,
            j, r = 0,
            x = 0,
            l, s, a = 0,
            z = 0,
            y, p = i[0] < 0 ? "right" : "left",
            t = i[1] < 0 ? "down" : "up",
            k, c, g, q, n;
        switch (d) {
            case "south":
                x = i[1];
                c = 2;
                break;
            case "north":
                x = -i[1];
                z = -x;
                c = 2;
                break;
            case "east":
                r = i[0];
                c = 1;
                break;
            case "west":
                r = -i[0];
                a = -r;
                c = 1;
                break;
            case "northeast":
                x = -i[1];
                z = -x;
                r = i[0];
                k = [m.x, m.y + m.height];
                c = 3;
                break;
            case "southeast":
                x = i[1];
                r = i[0];
                k = [m.x, m.y];
                c = 3;
                break;
            case "southwest":
                r = -i[0];
                a = -r;
                x = i[1];
                k = [m.x + m.width, m.y];
                c = 3;
                break;
            case "northwest":
                x = -i[1];
                z = -x;
                r = -i[0];
                a = -r;
                k = [m.x + m.width, m.y + m.height];
                c = 3;
                break
        }
        g = {
            width: m.width + r,
            height: m.height + x,
            x: m.x + a,
            y: m.y + z
        };
        l = Ext.Number.snap(g.width, v.widthIncrement);
        s = Ext.Number.snap(g.height, v.heightIncrement);
        if (l != g.width || s != g.height) {
            switch (d) {
                case "northeast":
                    g.y -= s - g.height;
                    break;
                case "north":
                    g.y -= s - g.height;
                    break;
                case "southwest":
                    g.x -= l - g.width;
                    break;
                case "west":
                    g.x -= l - g.width;
                    break;
                case "northwest":
                    g.x -= l - g.width;
                    g.y -= s - g.height
            }
            g.width = l;
            g.height = s
        }
        if (g.width < v.minWidth || g.width > v.maxWidth) {
            g.width = Ext.Number.constrain(g.width, v.minWidth, v.maxWidth);
            if (a) {
                g.x = m.x + (m.width - g.width)
            }
        } else {
            v.lastX = g.x
        }
        if (g.height < v.minHeight || g.height > v.maxHeight) {
            g.height = Ext.Number.constrain(g.height, v.minHeight, v.maxHeight);
            if (z) {
                g.y = m.y + (m.height - g.height)
            }
        } else {
            v.lastY = g.y
        }
        if (v.preserveRatio || u.shiftKey) {
            j = v.startBox.width / v.startBox.height;
            q = Math.min(Math.max(v.minHeight, g.width / j), v.maxHeight);
            n = Math.min(Math.max(v.minWidth, g.height * j), v.maxWidth);
            if (c == 1) {
                g.height = q
            } else {
                if (c == 2) {
                    g.width = n
                } else {
                    y = Math.abs(k[0] - this.lastXY[0]) / Math.abs(k[1] - this.lastXY[1]);
                    if (y > j) {
                        g.height = q
                    } else {
                        g.width = n
                    }
                    if (d == "northeast") {
                        g.y = m.y - (g.height - m.height)
                    } else {
                        if (d == "northwest") {
                            g.y = m.y - (g.height - m.height);
                            g.x = m.x - (g.width - m.width)
                        } else {
                            if (d == "southwest") {
                                g.x = m.x - (g.width - m.width)
                            }
                        }
                    }
                }
            }
        }
        if (x === 0) {
            t = "none"
        }
        if (r === 0) {
            p = "none"
        }
        v.resize(g, {
            horizontal: p,
            vertical: t
        }, o)
    },
    getResizeTarget: function(a) {
        return a ? this.target : this.getDynamicTarget()
    },
    resize: function(c, e, a) {
        var d = this.getResizeTarget(a);
        if (d.isComponent) {
            d.setSize(c.width, c.height);
            if (d.floating) {
                d.setPagePosition(c.x, c.y)
            }
        } else {
            d.setBox(c)
        }
        d = this.originalTarget;
        if (d && (this.dynamic || a)) {
            if (d.isComponent) {
                d.setSize(c.width, c.height);
                if (d.floating) {
                    d.setPagePosition(c.x, c.y)
                }
            } else {
                d.setBox(c)
            }
        }
    },
    onEnd: function(a) {
        this.updateDimensions(a, true);
        if (this.proxy) {
            this.proxy.hide()
        }
    }
});
Ext.define("Ext.resizer.Resizer", {
    mixins: {
        observable: "Ext.util.Observable"
    },
    uses: ["Ext.resizer.ResizeTracker", "Ext.Component"],
    alternateClassName: "Ext.Resizable",
    handleCls: Ext.baseCSSPrefix + "resizable-handle",
    pinnedCls: Ext.baseCSSPrefix + "resizable-pinned",
    overCls: Ext.baseCSSPrefix + "resizable-over",
    wrapCls: Ext.baseCSSPrefix + "resizable-wrap",
    dynamic: true,
    handles: "s e se",
    height: null,
    width: null,
    heightIncrement: 0,
    widthIncrement: 0,
    minHeight: 20,
    minWidth: 20,
    maxHeight: 10000,
    maxWidth: 10000,
    pinned: false,
    preserveRatio: false,
    transparent: false,
    possiblePositions: {
        n: "north",
        s: "south",
        e: "east",
        w: "west",
        se: "southeast",
        sw: "southwest",
        nw: "northwest",
        ne: "northeast"
    },
    constructor: function(c) {
        var m = this,
            l, q, s, r = m.handles,
            d, p, j, e = 0,
            o, n = [],
            k, a, g;
        m.addEvents("beforeresize", "resizedrag", "resize");
        if (Ext.isString(c) || Ext.isElement(c) || c.dom) {
            l = c;
            c = arguments[1] || {};
            c.target = l
        }
        m.mixins.observable.constructor.call(m, c);
        l = m.target;
        if (l) {
            if (l.isComponent) {
                m.el = l.getEl();
                if (l.minWidth) {
                    m.minWidth = l.minWidth
                }
                if (l.minHeight) {
                    m.minHeight = l.minHeight
                }
                if (l.maxWidth) {
                    m.maxWidth = l.maxWidth
                }
                if (l.maxHeight) {
                    m.maxHeight = l.maxHeight
                }
                if (l.floating) {
                    if (!m.hasOwnProperty("handles")) {
                        m.handles = "n ne e se s sw w nw"
                    }
                }
            } else {
                m.el = m.target = Ext.get(l)
            }
        } else {
            m.target = m.el = Ext.get(m.el)
        }
        s = m.el.dom.tagName.toUpperCase();
        if (s == "TEXTAREA" || s == "IMG" || s == "TABLE") {
            m.originalTarget = m.target;
            q = m.el;
            g = q.getBox();
            m.target = m.el = m.el.wrap({
                cls: m.wrapCls,
                id: m.el.id + "-rzwrap",
                style: q.getStyles("margin-top", "margin-bottom")
            });
            m.el.setPositioning(q.getPositioning());
            q.clearPositioning();
            m.el.setBox(g);
            q.setStyle("position", "absolute")
        }
        m.el.position();
        if (m.pinned) {
            m.el.addCls(m.pinnedCls)
        }
        m.resizeTracker = new Ext.resizer.ResizeTracker({
            disabled: m.disabled,
            target: m.target,
            constrainTo: m.constrainTo,
            overCls: m.overCls,
            throttle: m.throttle,
            originalTarget: m.originalTarget,
            delegate: "." + m.handleCls,
            dynamic: m.dynamic,
            preserveRatio: m.preserveRatio,
            heightIncrement: m.heightIncrement,
            widthIncrement: m.widthIncrement,
            minHeight: m.minHeight,
            maxHeight: m.maxHeight,
            minWidth: m.minWidth,
            maxWidth: m.maxWidth
        });
        m.resizeTracker.on({
            mousedown: m.onBeforeResize,
            drag: m.onResize,
            dragend: m.onResizeEnd,
            scope: m
        });
        if (m.handles == "all") {
            m.handles = "n s e w ne nw se sw"
        }
        r = m.handles = m.handles.split(/ |\s*?[,;]\s*?/);
        p = m.possiblePositions;
        j = r.length;
        d = m.handleCls + " " + (m.target.isComponent ? (m.target.baseCls + "-handle ") : "") + m.handleCls + "-";
        k = Ext.isIE6 ? ' style="height:' + m.el.getHeight() + 'px"' : "";
        for (; e < j; e++) {
            if (r[e] && p[r[e]]) {
                o = p[r[e]];
                if (o === "east" || o === "west") {
                    a = k
                } else {
                    a = ""
                }
                n.push('<div id="' + m.el.id + "-" + o + '-handle" class="' + d + o + " " + Ext.baseCSSPrefix + 'unselectable"' + a + "></div>")
            }
        }
        Ext.DomHelper.append(m.el, n.join(""));
        for (e = 0; e < j; e++) {
            if (r[e] && p[r[e]]) {
                o = p[r[e]];
                m[o] = m.el.getById(m.el.id + "-" + o + "-handle");
                m[o].region = o;
                m[o].unselectable();
                if (m.transparent) {
                    m[o].setOpacity(0)
                }
            }
        }
        if (Ext.isNumber(m.width)) {
            m.width = Ext.Number.constrain(m.width, m.minWidth, m.maxWidth)
        }
        if (Ext.isNumber(m.height)) {
            m.height = Ext.Number.constrain(m.height, m.minHeight, m.maxHeight)
        }
        if (m.width !== null || m.height !== null) {
            if (m.originalTarget) {
                m.originalTarget.setWidth(m.width);
                m.originalTarget.setHeight(m.height)
            }
            m.resizeTo(m.width, m.height)
        }
        m.forceHandlesHeight()
    },
    disable: function() {
        this.resizeTracker.disable()
    },
    enable: function() {
        this.resizeTracker.enable()
    },
    onBeforeResize: function(c, d) {
        var a = this.el.getBox();
        return this.fireEvent("beforeresize", this, a.width, a.height, d)
    },
    onResize: function(d, g) {
        var c = this,
            a = c.el.getBox();
        c.forceHandlesHeight();
        return c.fireEvent("resizedrag", c, a.width, a.height, g)
    },
    onResizeEnd: function(d, g) {
        var c = this,
            a = c.el.getBox();
        c.forceHandlesHeight();
        return c.fireEvent("resize", c, a.width, a.height, g)
    },
    resizeTo: function(c, a) {
        var d = this;
        d.target.setSize(c, a);
        d.fireEvent("resize", d, c, a, null)
    },
    getEl: function() {
        return this.el
    },
    getTarget: function() {
        return this.target
    },
    destroy: function() {
        var e = 0,
            d = this.handles,
            a = d.length,
            c = this.possiblePositions;
        for (; e < a; e++) {
            this[c[d[e]]].remove()
        }
    },
    forceHandlesHeight: function() {
        var a = this,
            c;
        if (Ext.isIE6) {
            c = a.east;
            if (c) {
                c.setHeight(a.el.getHeight())
            }
            c = a.west;
            if (c) {
                c.setHeight(a.el.getHeight())
            }
            a.el.repaint()
        }
    }
});
Ext.define("Ext.selection.CellModel", {
    extend: "Ext.selection.Model",
    alias: "selection.cellmodel",
    requires: ["Ext.util.KeyNav"],
    isCellModel: true,
    enableKeyNav: true,
    preventWrap: false,
    noSelection: {
        row: -1,
        column: -1
    },
    constructor: function() {
        this.addEvents("deselect", "select");
        this.callParent(arguments)
    },
    bindComponent: function(a) {
        var d = this,
            c = a.ownerCt;
        d.primaryView = a;
        d.views = d.views || [];
        d.views.push(a);
        d.bindStore(a.getStore(), true);
        a.on({
            cellmousedown: d.onMouseDown,
            refresh: d.onViewRefresh,
            scope: d
        });
        if (c.optimizedColumnMove !== false) {
            c.on("columnmove", d.onColumnMove, d)
        }
        if (d.enableKeyNav) {
            d.initKeyNav(a)
        }
    },
    initKeyNav: function(a) {
        var c = this;
        if (!a.rendered) {
            a.on("render", Ext.Function.bind(c.initKeyNav, c, [a], 0), c, {
                single: true
            });
            return
        }
        a.el.set({
            tabIndex: -1
        });
        c.keyNav = new Ext.util.KeyNav({
            target: a.el,
            ignoreInputFields: true,
            up: c.onKeyUp,
            down: c.onKeyDown,
            right: c.onKeyRight,
            left: c.onKeyLeft,
            tab: c.onKeyTab,
            scope: c
        })
    },
    getHeaderCt: function() {
        var c = this.getCurrentPosition(),
            a = c ? c.view : this.primaryView;
        return a.headerCt
    },
    onKeyUp: function(c, a) {
        this.keyNavigation = true;
        this.move("up", c);
        this.keyNavigation = false
    },
    onKeyDown: function(c, a) {
        this.keyNavigation = true;
        this.move("down", c);
        this.keyNavigation = false
    },
    onKeyLeft: function(c, a) {
        this.keyNavigation = true;
        this.move("left", c);
        this.keyNavigation = false
    },
    onKeyRight: function(c, a) {
        this.keyNavigation = true;
        this.move("right", c);
        this.keyNavigation = false
    },
    move: function(a, g) {
        var d = this,
            i = d.getCurrentPosition(),
            c = i.view.walkCells(i, a, g, d.preventWrap);
        if (c) {
            c.view = i.view;
            return d.setCurrentPosition(c)
        }
    },
    getCurrentPosition: function() {
        return this.selection
    },
    setCurrentPosition: function(c) {
        var a = this;
        a.lastSelection = a.selection;
        if (a.selection) {
            a.onCellDeselect(a.selection)
        }
        if (c) {
            a.nextSelection = new a.Selection(a);
            a.nextSelection.setPosition(c);
            a.onCellSelect(a.nextSelection);
            return a.selection = a.nextSelection
        }
    },
    onStoreRemove: function(c, a, d) {
        var e = this,
            g = e.getCurrentPosition();
        e.callParent(arguments);
        if (g) {
            if (g.row == d) {
                if (d < c.getCount() - 1) {
                    g.setPosition(d, g.column);
                    e.setCurrentPosition(g)
                } else {
                    delete e.selection
                }
            } else {
                if (d < g.row) {
                    g.setPosition(g.row - 1, g.column);
                    e.setCurrentPosition(g)
                }
            }
        }
    },
    onMouseDown: function(d, a, g, c, j, k, i) {
        this.setCurrentPosition({
            view: d,
            row: k,
            column: g
        })
    },
    onCellSelect: function(a, c) {
        if (a && a.row !== undefined && a.row > -1) {
            this.doSelect(a.view.getStore().getAt(a.row), false, c)
        }
    },
    onCellDeselect: function(a, c) {
        if (a && a.row !== undefined) {
            this.doDeselect(a.view.getStore().getAt(a.row), c)
        }
    },
    onSelectChange: function(c, g, e, j) {
        var i = this,
            k, d, a;
        if (g) {
            k = i.nextSelection;
            d = "select"
        } else {
            k = i.lastSelection || i.noSelection;
            d = "deselect"
        }
        a = k.view || i.primaryView;
        if ((e || i.fireEvent("before" + d, i, c, k.row, k.column)) !== false && j() !== false) {
            if (g) {
                a.onCellSelect(k);
                a.onCellFocus(k)
            } else {
                a.onCellDeselect(k);
                delete i.selection
            }
            if (!e) {
                i.fireEvent(d, i, c, k.row, k.column)
            }
        }
    },
    onKeyTab: function(g, c) {
        var d = this,
            a = d.getCurrentPosition().view.editingPlugin;
        if (a && d.wasEditing) {
            d.onEditorTab(a, g)
        } else {
            d.move(g.shiftKey ? "left" : "right", g)
        }
    },
    onEditorTab: function(c, i) {
        var d = this,
            g = i.shiftKey ? "left" : "right",
            a = d.move(g, i);
        if (a) {
            if (c.startEditByPosition(a)) {
                d.wasEditing = false
            } else {
                d.wasEditing = true;
                if (!a.columnHeader.dataIndex) {
                    d.onEditorTab(c, i)
                }
            }
        }
    },
    refresh: function() {
        var c = this.getCurrentPosition(),
            a;
        if (c && (a = this.store.indexOf(this.selected.last())) !== -1) {
            c.row = a
        }
    },
    onColumnMove: function(e, g, c, d) {
        var a = e.up("tablepanel");
        if (a) {
            this.onViewRefresh(a.view)
        }
    },
    onViewRefresh: function(c) {
        var d = this,
            i = d.getCurrentPosition(),
            g = c.headerCt,
            a, e;
        if (i && i.view === c) {
            a = i.record;
            e = i.columnHeader;
            if (!e.isDescendantOf(g)) {
                e = g.queryById(e.id) || g.down('[text="' + e.text + '"]') || g.down('[dataIndex="' + e.dataIndex + '"]')
            }
            if (e && (c.store.indexOfId(a.getId()) !== -1)) {
                d.setCurrentPosition({
                    row: a,
                    column: e,
                    view: c
                })
            }
        }
    },
    selectByPosition: function(a) {
        this.setCurrentPosition(a)
    }
}, function() {
    var a = this.prototype.Selection = function(c) {
        this.model = c
    };
    a.prototype.setPosition = function(g, d) {
        var e = this,
            c;
        if (arguments.length === 1) {
            if (g.view) {
                e.view = c = g.view
            }
            d = g.column;
            g = g.row
        }
        if (!c) {
            e.view = c = e.model.primaryView
        }
        if (typeof g === "number") {
            e.row = g;
            e.record = c.store.getAt(g)
        } else {
            if (g.isModel) {
                e.record = g;
                e.row = c.indexOf(g)
            } else {
                if (g.tagName) {
                    e.record = c.getRecord(g);
                    e.row = c.indexOf(e.record)
                }
            }
        }
        if (typeof d === "number") {
            e.column = d;
            e.columnHeader = c.getHeaderAtIndex(d)
        } else {
            e.columnHeader = d;
            e.column = d.getIndex()
        }
        return e
    }
});
Ext.define("Ext.selection.CheckboxModel", {
    alias: "selection.checkboxmodel",
    extend: "Ext.selection.RowModel",
    mode: "MULTI",
    injectCheckbox: 0,
    checkOnly: false,
    showHeaderCheckbox: true,
    headerWidth: 24,
    checkerOnCls: Ext.baseCSSPrefix + "grid-hd-checker-on",
    refreshOnRemove: true,
    beforeViewRender: function(a) {
        var c = this;
        c.callParent(arguments);
        if (!c.hasLockedHeader() || a.headerCt.lockedCt) {
            if (c.showHeaderCheckbox !== false) {
                a.headerCt.on("headerclick", c.onHeaderClick, c)
            }
            c.addCheckbox(a, true);
            c.mon(a.ownerCt, "reconfigure", c.onReconfigure, c)
        }
    },
    bindComponent: function(a) {
        var c = this;
        c.sortable = false;
        c.callParent(arguments)
    },
    hasLockedHeader: function() {
        var a = this.views,
            d = a.length,
            c;
        for (c = 0; c < d; c++) {
            if (a[c].headerCt.lockedCt) {
                return true
            }
        }
        return false
    },
    addCheckbox: function(a, c) {
        var d = this,
            e = d.injectCheckbox,
            g = a.headerCt;
        if (e !== false) {
            if (e == "first") {
                e = 0
            } else {
                if (e == "last") {
                    e = g.getColumnCount()
                }
            }
            Ext.suspendLayouts();
            g.add(e, d.getHeaderConfig());
            Ext.resumeLayouts()
        }
        if (c !== true) {
            a.refresh()
        }
    },
    onReconfigure: function(d, a, c) {
        if (c) {
            this.addCheckbox(this.views[0])
        }
    },
    toggleUiHeader: function(e) {
        var a = this.views[0],
            d = a.headerCt,
            c = d.child("gridcolumn[isCheckerHd]");
        if (c) {
            if (e) {
                c.el.addCls(this.checkerOnCls)
            } else {
                c.el.removeCls(this.checkerOnCls)
            }
        }
    },
    onHeaderClick: function(d, i, c) {
        if (i.isCheckerHd) {
            c.stopEvent();
            var a = this,
                g = i.el.hasCls(Ext.baseCSSPrefix + "grid-hd-checker-on");
            a.preventFocus = true;
            if (g) {
                a.deselectAll()
            } else {
                a.selectAll()
            }
            delete a.preventFocus
        }
    },
    getHeaderConfig: function() {
        var a = this,
            c = a.showHeaderCheckbox !== false;
        return {
            isCheckerHd: c,
            text: "&#160;",
            width: a.headerWidth,
            sortable: false,
            draggable: false,
            resizable: false,
            hideable: false,
            menuDisabled: true,
            dataIndex: "",
            cls: c ? Ext.baseCSSPrefix + "column-header-checkbox " : "",
            renderer: Ext.Function.bind(a.renderer, a),
            editRenderer: a.editRenderer || a.renderEmpty,
            locked: a.hasLockedHeader()
        }
    },
    renderEmpty: function() {
        return "&#160;"
    },
    renderer: function(j, d, c, k, g, e, a) {
        var i = Ext.baseCSSPrefix;
        d.tdCls = i + "grid-cell-special " + i + "grid-cell-row-checker";
        return '<div class="' + i + 'grid-row-checker">&#160;</div>'
    },
    onRowMouseDown: function(c, a, j, g, k) {
        c.el.focus();
        var i = this,
            d = k.getTarget("." + Ext.baseCSSPrefix + "grid-row-checker"),
            l;
        if (!i.allowRightMouseSelection(k)) {
            return
        }
        if (i.checkOnly && !d) {
            return
        }
        if (d) {
            l = i.getSelectionMode();
            if (l !== "SINGLE") {
                i.setSelectionMode("SIMPLE")
            }
            i.selectWithEvent(a, k);
            i.setSelectionMode(l)
        } else {
            i.selectWithEvent(a, k)
        }
    },
    onSelectChange: function() {
        var a = this;
        a.callParent(arguments);
        a.updateHeaderState()
    },
    onStoreLoad: function() {
        var a = this;
        a.callParent(arguments);
        a.updateHeaderState()
    },
    updateHeaderState: function() {
        var a = this.selected.getCount() === this.store.getCount();
        this.toggleUiHeader(a)
    }
});
Ext.define("Ext.tab.Tab", {
    extend: "Ext.button.Button",
    alias: "widget.tab",
    requires: ["Ext.layout.component.Tab", "Ext.util.KeyNav"],
    componentLayout: "tab",
    isTab: true,
    baseCls: Ext.baseCSSPrefix + "tab",
    activeCls: "active",
    closableCls: "closable",
    closable: true,
    closeText: "Close Tab",
    active: false,
    childEls: ["closeEl"],
    scale: false,
    position: "top",
    initComponent: function() {
        var a = this;
        a.addEvents("activate", "deactivate", "beforeclose", "close");
        a.callParent(arguments);
        if (a.card) {
            a.setCard(a.card)
        }
    },
    getTemplateArgs: function() {
        var c = this,
            a = c.callParent();
        a.closable = c.closable;
        a.closeText = c.closeText;
        return a
    },
    beforeRender: function() {
        var c = this,
            a = c.up("tabbar"),
            d = c.up("tabpanel");
        c.callParent();
        c.addClsWithUI(c.position);
        c.syncClosableUI();
        if (!c.minWidth) {
            c.minWidth = (a) ? a.minTabWidth : c.minWidth;
            if (!c.minWidth && d) {
                c.minWidth = d.minTabWidth
            }
            if (c.minWidth && c.iconCls) {
                c.minWidth += 25
            }
        }
        if (!c.maxWidth) {
            c.maxWidth = (a) ? a.maxTabWidth : c.maxWidth;
            if (!c.maxWidth && d) {
                c.maxWidth = d.maxTabWidth
            }
        }
    },
    onRender: function() {
        var a = this;
        a.callParent(arguments);
        a.keyNav = new Ext.util.KeyNav(a.el, {
            enter: a.onEnterKey,
            del: a.onDeleteKey,
            scope: a
        })
    },
    enable: function(a) {
        var c = this;
        c.callParent(arguments);
        c.removeClsWithUI(c.position + "-disabled");
        return c
    },
    disable: function(a) {
        var c = this;
        c.callParent(arguments);
        c.addClsWithUI(c.position + "-disabled");
        return c
    },
    onDestroy: function() {
        var a = this;
        Ext.destroy(a.keyNav);
        delete a.keyNav;
        a.callParent(arguments)
    },
    setClosable: function(a) {
        var c = this;
        a = (!arguments.length || !!a);
        if (c.closable != a) {
            c.closable = a;
            if (c.card) {
                c.card.closable = a
            }
            c.syncClosableUI();
            if (c.rendered) {
                c.syncClosableElements();
                c.updateLayout()
            }
        }
    },
    syncClosableElements: function() {
        var a = this,
            c = a.closeEl;
        if (a.closable) {
            if (!c) {
                a.closeEl = a.btnWrap.insertSibling({
                    tag: "a",
                    cls: a.baseCls + "-close-btn",
                    href: "#",
                    title: a.closeText
                }, "after")
            }
        } else {
            if (c) {
                c.remove();
                delete a.closeEl
            }
        }
    },
    syncClosableUI: function() {
        var c = this,
            a = [c.closableCls, c.closableCls + "-" + c.position];
        if (c.closable) {
            c.addClsWithUI(a)
        } else {
            c.removeClsWithUI(a)
        }
    },
    setCard: function(a) {
        var c = this;
        c.card = a;
        c.setText(c.title || a.title);
        c.setIconCls(c.iconCls || a.iconCls);
        c.setIcon(c.icon || a.icon)
    },
    onCloseClick: function() {
        var a = this;
        if (a.fireEvent("beforeclose", a) !== false) {
            if (a.tabBar) {
                if (a.tabBar.closeTab(a) === false) {
                    return
                }
            } else {
                a.fireClose()
            }
        }
    },
    fireClose: function() {
        this.fireEvent("close", this)
    },
    onEnterKey: function(c) {
        var a = this;
        if (a.tabBar) {
            a.tabBar.onClick(c, a.el)
        }
    },
    onDeleteKey: function(a) {
        if (this.closable) {
            this.onCloseClick()
        }
    },
    activate: function(c) {
        var a = this;
        a.active = true;
        a.addClsWithUI([a.activeCls, a.position + "-" + a.activeCls]);
        if (c !== true) {
            a.fireEvent("activate", a)
        }
    },
    deactivate: function(c) {
        var a = this;
        a.active = false;
        a.removeClsWithUI([a.activeCls, a.position + "-" + a.activeCls]);
        if (c !== true) {
            a.fireEvent("deactivate", a)
        }
    }
});
Ext.define("Ext.tab.Bar", {
    extend: "Ext.panel.Header",
    alias: "widget.tabbar",
    baseCls: Ext.baseCSSPrefix + "tab-bar",
    requires: ["Ext.tab.Tab"],
    isTabBar: true,
    defaultType: "tab",
    plain: false,
    childEls: ["body", "strip"],
    renderTpl: ['<div id="{id}-body" class="{baseCls}-body {bodyCls}<tpl if="ui"> {baseCls}-body-{ui}<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl></tpl>"<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', "{%this.renderContainer(out,values)%}", "</div>", '<div id="{id}-strip" class="{baseCls}-strip<tpl if="ui"> {baseCls}-strip-{ui}<tpl for="uiCls"> {parent.baseCls}-strip-{parent.ui}-{.}</tpl></tpl>"></div>'],
    initComponent: function() {
        var a = this;
        if (a.plain) {
            a.setUI(a.ui + "-plain")
        }
        a.addClsWithUI(a.dock);
        a.addEvents("change");
        a.callParent(arguments);
        a.layout.align = (a.orientation == "vertical") ? "left" : "top";
        a.layout.overflowHandler = new Ext.layout.container.boxOverflow.Scroller(a.layout);
        a.remove(a.titleCmp);
        delete a.titleCmp;
        Ext.apply(a.renderData, {
            bodyCls: a.bodyCls
        })
    },
    getLayout: function() {
        var a = this;
        a.layout.type = (a.dock === "top" || a.dock === "bottom") ? "hbox" : "vbox";
        return a.callParent(arguments)
    },
    onAdd: function(a) {
        a.position = this.dock;
        this.callParent(arguments)
    },
    onRemove: function(a) {
        var c = this;
        if (a === c.previousTab) {
            c.previousTab = null
        }
        c.callParent(arguments)
    },
    afterComponentLayout: function(a) {
        this.callParent(arguments);
        this.strip.setWidth(a)
    },
    onClick: function(i, g) {
        var d = this,
            k = i.getTarget("." + Ext.tab.Tab.prototype.baseCls),
            c = k && Ext.getCmp(k.id),
            j = d.tabPanel,
            a = c && c.closeEl && (g === c.closeEl.dom);
        if (a) {
            i.preventDefault()
        }
        if (c && c.isDisabled && !c.isDisabled()) {
            if (c.closable && a) {
                c.onCloseClick()
            } else {
                if (j) {
                    j.setActiveTab(c.card)
                } else {
                    d.setActiveTab(c)
                }
                c.focus()
            }
        }
    },
    closeTab: function(d) {
        var e = this,
            c = d.card,
            g = e.tabPanel,
            a;
        if (c && c.fireEvent("beforeclose", c) === false) {
            return false
        }
        a = e.findNextActivatable(d);
        Ext.suspendLayouts();
        if (g && c) {
            delete d.ownerCt;
            c.fireEvent("close", c);
            g.remove(c);
            if (!g.getComponent(c)) {
                d.fireClose();
                e.remove(d)
            } else {
                d.ownerCt = e;
                Ext.resumeLayouts(true);
                return false
            }
        }
        if (a) {
            if (g) {
                g.setActiveTab(a.card)
            } else {
                e.setActiveTab(a)
            }
            a.focus()
        }
        Ext.resumeLayouts(true)
    },
    findNextActivatable: function(a) {
        var c = this;
        if (a.active && c.items.getCount() > 1) {
            return (c.previousTab && c.previousTab !== a && !c.previousTab.disabled) ? c.previousTab : (a.next("tab[disabled=false]") || a.prev("tab[disabled=false]"))
        }
    },
    setActiveTab: function(a) {
        var c = this;
        if (!a.disabled && a !== c.activeTab) {
            if (c.activeTab) {
                if (c.activeTab.isDestroyed) {
                    c.previousTab = null
                } else {
                    c.previousTab = c.activeTab;
                    c.activeTab.deactivate()
                }
            }
            a.activate();
            c.activeTab = a;
            c.fireEvent("change", c, a, a.card);
            c.on({
                afterlayout: c.afterTabActivate,
                scope: c,
                single: true
            });
            c.updateLayout()
        }
    },
    afterTabActivate: function() {
        this.layout.overflowHandler.scrollToItem(this.activeTab)
    }
});
Ext.define("Ext.tab.Panel", {
    extend: "Ext.panel.Panel",
    alias: "widget.tabpanel",
    alternateClassName: ["Ext.TabPanel"],
    requires: ["Ext.layout.container.Card", "Ext.tab.Bar"],
    tabPosition: "top",
    removePanelHeader: true,
    plain: false,
    itemCls: Ext.baseCSSPrefix + "tabpanel-child",
    minTabWidth: undefined,
    maxTabWidth: undefined,
    deferredRender: true,
    initComponent: function() {
        var d = this,
            c = [].concat(d.dockedItems || []),
            a = d.activeTab || (d.activeTab = 0);
        d.layout = new Ext.layout.container.Card(Ext.apply({
            owner: d,
            deferredRender: d.deferredRender,
            itemCls: d.itemCls,
            activeItem: d.activeTab
        }, d.layout));
        d.tabBar = new Ext.tab.Bar(Ext.apply({
            dock: d.tabPosition,
            plain: d.plain,
            border: d.border,
            cardLayout: d.layout,
            tabPanel: d
        }, d.tabBar));
        c.push(d.tabBar);
        d.dockedItems = c;
        d.addEvents("beforetabchange", "tabchange");
        d.callParent(arguments);
        d.activeTab = d.getComponent(a);
        if (d.activeTab) {
            d.activeTab.tab.activate(true);
            d.tabBar.activeTab = d.activeTab.tab
        }
    },
    setActiveTab: function(a) {
        var d = this,
            c;
        a = d.getComponent(a);
        if (a) {
            c = d.getActiveTab();
            if (c !== a && d.fireEvent("beforetabchange", d, a, c) === false) {
                return false
            }
            if (!a.isComponent) {
                Ext.suspendLayouts();
                a = d.add(a);
                Ext.resumeLayouts()
            }
            d.activeTab = a;
            Ext.suspendLayouts();
            d.layout.setActiveItem(a);
            a = d.activeTab = d.layout.getActiveItem();
            if (a && a !== c) {
                d.tabBar.setActiveTab(a.tab);
                Ext.resumeLayouts(true);
                if (c !== a) {
                    d.fireEvent("tabchange", d, a, c)
                }
            } else {
                Ext.resumeLayouts(true)
            }
            return a
        }
    },
    getActiveTab: function() {
        var c = this,
            a = c.getComponent(c.activeTab);
        if (a && c.items.indexOf(a) != -1) {
            c.activeTab = a
        } else {
            c.activeTab = null
        }
        return c.activeTab
    },
    getTabBar: function() {
        return this.tabBar
    },
    onAdd: function(g, d) {
        var e = this,
            c = g.tabConfig || {},
            a = {
                xtype: "tab",
                card: g,
                disabled: g.disabled,
                closable: g.closable,
                hidden: g.hidden && !g.hiddenByLayout,
                tooltip: g.tooltip,
                tabBar: e.tabBar,
                closeText: g.closeText
            };
        c = Ext.applyIf(c, a);
        g.tab = e.tabBar.insert(d, c);
        g.on({
            scope: e,
            enable: e.onItemEnable,
            disable: e.onItemDisable,
            beforeshow: e.onItemBeforeShow,
            iconchange: e.onItemIconChange,
            iconclschange: e.onItemIconClsChange,
            titlechange: e.onItemTitleChange
        });
        if (g.isPanel) {
            if (e.removePanelHeader) {
                if (g.rendered) {
                    if (g.header) {
                        g.header.hide()
                    }
                } else {
                    g.header = false
                }
            }
            if (g.isPanel && e.border) {
                g.setBorder(false)
            }
        }
    },
    onItemEnable: function(a) {
        a.tab.enable()
    },
    onItemDisable: function(a) {
        a.tab.disable()
    },
    onItemBeforeShow: function(a) {
        if (a !== this.activeTab) {
            this.setActiveTab(a);
            return false
        }
    },
    onItemIconChange: function(c, a) {
        c.tab.setIcon(a)
    },
    onItemIconClsChange: function(c, a) {
        c.tab.setIconCls(a)
    },
    onItemTitleChange: function(a, c) {
        a.tab.setText(c)
    },
    doRemove: function(e, c) {
        var d = this,
            a;
        if (d.destroying || d.items.getCount() == 1) {
            d.activeTab = null
        } else {
            if ((a = d.tabBar.items.indexOf(d.tabBar.findNextActivatable(e.tab))) !== -1) {
                d.setActiveTab(a)
            }
        }
        this.callParent(arguments);
        delete e.tab.card;
        delete e.tab
    },
    onRemove: function(c, d) {
        var a = this;
        c.un({
            scope: a,
            enable: a.onItemEnable,
            disable: a.onItemDisable,
            beforeshow: a.onItemBeforeShow
        });
        if (!a.destroying && c.tab.ownerCt === a.tabBar) {
            a.tabBar.remove(c.tab)
        }
    }
});
Ext.define("Ext.util.CSS", (function() {
    var e = null,
        d = document,
        c = /(-[a-z])/gi,
        a = function(g, i) {
            return i.charAt(1).toUpperCase()
        };
    return {
        singleton: true,
        constructor: function() {
            this.rules = {};
            this.initialized = false
        },
        createStyleSheet: function(j, m) {
            var i, g = d.getElementsByTagName("head")[0],
                l = d.createElement("style");
            l.setAttribute("type", "text/css");
            if (m) {
                l.setAttribute("id", m)
            }
            if (Ext.isIE) {
                g.appendChild(l);
                i = l.styleSheet;
                i.cssText = j
            } else {
                try {
                    l.appendChild(d.createTextNode(j))
                } catch (k) {
                    l.cssText = j
                }
                g.appendChild(l);
                i = l.styleSheet ? l.styleSheet : (l.sheet || d.styleSheets[d.styleSheets.length - 1])
            }
            this.cacheStyleSheet(i);
            return i
        },
        removeStyleSheet: function(i) {
            var g = document.getElementById(i);
            if (g) {
                g.parentNode.removeChild(g)
            }
        },
        swapStyleSheet: function(k, g) {
            var j = document,
                i;
            this.removeStyleSheet(k);
            i = j.createElement("link");
            i.setAttribute("rel", "stylesheet");
            i.setAttribute("type", "text/css");
            i.setAttribute("id", k);
            i.setAttribute("href", g);
            j.getElementsByTagName("head")[0].appendChild(i)
        },
        refreshCache: function() {
            return this.getRules(true)
        },
        cacheStyleSheet: function(m) {
            if (!e) {
                e = {}
            }
            try {
                var p = m.cssRules || m.rules,
                    n, l = p.length - 1,
                    g, k;
                for (; l >= 0; --l) {
                    n = p[l].selectorText;
                    if (n) {
                        n = n.split(",");
                        k = n.length;
                        for (g = 0; g < k; g++) {
                            e[Ext.String.trim(n[g]).toLowerCase()] = p[l]
                        }
                    }
                }
            } catch (o) {}
        },
        getRules: function(j) {
            if (e === null || j) {
                e = {};
                var l = d.styleSheets,
                    k = 0,
                    g = l.length;
                for (; k < g; k++) {
                    try {
                        if (!l[k].disabled) {
                            this.cacheStyleSheet(l[k])
                        }
                    } catch (m) {}
                }
            }
            return e
        },
        getRule: function(g, k) {
            var j = this.getRules(k),
                l;
            if (!Ext.isArray(g)) {
                return j[g.toLowerCase()]
            }
            for (l = 0; l < g.length; l++) {
                if (j[g[l]]) {
                    return j[g[l].toLowerCase()]
                }
            }
            return null
        },
        updateRule: function(g, l, k) {
            var m, j;
            if (!Ext.isArray(g)) {
                m = this.getRule(g);
                if (m) {
                    m.style[l.replace(c, a)] = k;
                    return true
                }
            } else {
                for (j = 0; j < g.length; j++) {
                    if (this.updateRule(g[j], l, k)) {
                        return true
                    }
                }
            }
            return false
        }
    }
}()));
Ext.define("Ext.util.Grouper", {
    extend: "Ext.util.Sorter",
    isGrouper: true,
    getGroupString: function(a) {
        return a.get(this.property)
    }
});
Ext.define("Ext.util.Point", {
    extend: "Ext.util.Region",
    statics: {
        fromEvent: function(a) {
            a = (a.changedTouches && a.changedTouches.length > 0) ? a.changedTouches[0] : a;
            return new this(a.pageX, a.pageY)
        }
    },
    constructor: function(a, c) {
        this.callParent([c, a, c, a])
    },
    toString: function() {
        return "Point[" + this.x + "," + this.y + "]"
    },
    equals: function(a) {
        return (this.x == a.x && this.y == a.y)
    },
    isWithin: function(c, a) {
        if (!Ext.isObject(a)) {
            a = {
                x: a,
                y: a
            }
        }
        return (this.x <= c.x + a.x && this.x >= c.x - a.x && this.y <= c.y + a.y && this.y >= c.y - a.y)
    },
    roundedEquals: function(a) {
        return (Math.round(this.x) == Math.round(a.x) && Math.round(this.y) == Math.round(a.y))
    }
}, function() {
    this.prototype.translate = Ext.util.Region.prototype.translateBy
});
Ext.define("Ext.view.TableChunker", {
    singleton: true,
    requires: ["Ext.XTemplate"],
    metaTableTpl: ["{%if (this.openTableWrap)out.push(this.openTableWrap())%}", '<table class="' + Ext.baseCSSPrefix + "grid-table " + Ext.baseCSSPrefix + 'grid-table-resizer" border="0" cellspacing="0" cellpadding="0" {[this.embedFullWidth(values)]}>', "<tbody>", '<tr class="' + Ext.baseCSSPrefix + 'grid-header-row">', '<tpl for="columns">', '<th class="' + Ext.baseCSSPrefix + 'grid-col-resizer-{id}" style="width: {width}px; height: 0px;"></th>', "</tpl>", "</tr>", "{[this.openRows()]}", "{row}", '<tpl for="features">', "{[this.embedFeature(values, parent, xindex, xcount)]}", "</tpl>", "{[this.closeRows()]}", "</tbody>", "</table>", "{%if (this.closeTableWrap)out.push(this.closeTableWrap())%}"],
    constructor: function() {
        Ext.XTemplate.prototype.recurse = function(c, a) {
            return this.apply(a ? c[a] : c)
        }
    },
    embedFeature: function(c, e, a, g) {
        var d = "";
        if (!c.disabled) {
            d = c.getFeatureTpl(c, e, a, g)
        }
        return d
    },
    embedFullWidth: function(c) {
        var a = 'style="width:{fullWidth}px;';
        if (!c.rowCount) {
            a += "height:1px;"
        }
        return a + '"'
    },
    openRows: function() {
        return '<tpl for="rows">'
    },
    closeRows: function() {
        return "</tpl>"
    },
    metaRowTpl: ['<tr class="' + Ext.baseCSSPrefix + 'grid-row {[this.embedRowCls()]}" {[this.embedRowAttr()]}>', '<tpl for="columns">', '<td class="{cls} ' + Ext.baseCSSPrefix + "grid-cell " + Ext.baseCSSPrefix + 'grid-cell-{columnId} {{id}-modified} {{id}-tdCls} {[this.firstOrLastCls(xindex, xcount)]}" {{id}-tdAttr}>', '<div {unselectableAttr} class="' + Ext.baseCSSPrefix + 'grid-cell-inner {unselectableCls}" style="text-align: {align}; {{id}-style};">{{id}}</div>', "</td>", "</tpl>", "</tr>"],
    firstOrLastCls: function(a, c) {
        if (a === 1) {
            return Ext.view.Table.prototype.firstCls
        } else {
            if (a === c) {
                return Ext.view.Table.prototype.lastCls
            }
        }
    },
    embedRowCls: function() {
        return "{rowCls}"
    },
    embedRowAttr: function() {
        return "{rowAttr}"
    },
    openTableWrap: undefined,
    closeTableWrap: undefined,
    getTableTpl: function(m, c) {
        var l, k = {
                openRows: this.openRows,
                closeRows: this.closeRows,
                embedFeature: this.embedFeature,
                embedFullWidth: this.embedFullWidth,
                openTableWrap: this.openTableWrap,
                closeTableWrap: this.closeTableWrap
            },
            j = {},
            d = m.features || [],
            o = d.length,
            g = 0,
            n = {
                embedRowCls: this.embedRowCls,
                embedRowAttr: this.embedRowAttr,
                firstOrLastCls: this.firstOrLastCls,
                unselectableAttr: m.enableTextSelection ? "" : 'unselectable="on"',
                unselectableCls: m.enableTextSelection ? "" : Ext.baseCSSPrefix + "unselectable"
            },
            e = Array.prototype.slice.call(this.metaRowTpl, 0),
            a;
        for (; g < o; g++) {
            if (!d[g].disabled) {
                d[g].mutateMetaRowTpl(e);
                Ext.apply(n, d[g].getMetaRowTplFragments());
                Ext.apply(j, d[g].getFragmentTpl());
                Ext.apply(k, d[g].getTableFragments())
            }
        }
        e = new Ext.XTemplate(e.join(""), n);
        m.row = e.applyTemplate(m);
        a = new Ext.XTemplate(this.metaTableTpl.join(""), k);
        l = a.applyTemplate(m);
        if (!c) {
            l = new Ext.XTemplate(l, j)
        }
        return l
    }
});